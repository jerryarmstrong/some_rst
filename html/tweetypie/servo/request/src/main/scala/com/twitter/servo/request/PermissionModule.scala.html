<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../../" id="documentation_options" src="../../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.servo.request</p>
<p>import com.twitter.config.yaml.YamlMap
import com.twitter.util.Try</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Module for defining a set of permissions. This is similar to</p></li>
<li><p>Enumeration in the scala standard library.</p></li>
<li></li>
<li><p>To use, instantiate a subclass:</p></li>
<li></li>
<li><p>{{{</p></li>
<li><p>object MyPermissions extends PermissionModule {</p></li>
<li><p>val Eat = create(“eat”)</p></li>
<li><p>val Drink = create(“drink”)</p></li>
<li><p>}</p></li>
<li><p>}}}</p></li>
<li></li>
<li><p>Permissions only support one kind of authorization, which is that</p></li>
<li><p>you can check whether a holder of permissions has all of the</p></li>
<li><p>permissions in a particular set.</p></li>
<li></li>
<li><p>{{{</p></li>
<li><p>val snack = MyPermissions.Eat</p></li>
<li><p>val dinner = MyPermissions.Eat union MyPermissions.Drink</p></li>
<li><p>val canEat = MyPermissions.Eat</p></li>
<li><p>dinner satisfiedBy canEat // false</p></li>
<li><p>snack satisfiedBy canEat // true</p></li>
<li><p>}}}</p></li>
<li></li>
<li><p>Each instance will have its own distinct permission type, so it is</p></li>
<li><p>not possible to confuse the permissions defined in different</p></li>
<li><p>modules.</p></li>
<li></li>
<li><p>{{{</p></li>
<li><p>scala&gt; object P1 extends PermissionModule { val Read = create(“read”) }</p></li>
<li><p>scala&gt; object P2 extends PermissionModule { val Read = create(“read”) }</p></li>
<li><p>scala&gt; P1.Read satisfiedBy P2.Read</p></li>
<li><p>error: type mismatch;</p></li>
<li><p>found   : P2.Permissions</p></li>
<li><p>required: P1.Permissions</p></li>
<li><p>P1.Read satisfiedBy P2.Read</p></li>
<li><p>}}}</p></li>
<li></li>
<li><p>Once an instance has been created, it will not be possible to</p></li>
<li><p>create new permissions. The intention is that all permissions will</p></li>
<li><p>be created at object initialization time.</p></li>
<li></li>
<li><p>Each instance also supplies functionality for accessing permissions</p></li>
<li><p>by name, including parsing client permission maps from YAML.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>trait PermissionModule {</dt><dd><p>// This var is used during object initialization to collect all of
// the permissions that are created in the subclass. The lazy
// initializer for <cite>All</cite> will set this to null as a side-effect, so
// that further permission creations are not allowed.
&#64;volatile private[this] var allPerms: Set[String] = Set.empty</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Create a new Permission with the given name. Note that “*” is a</p></li>
<li><p>reversed string for <cite>All</cite> permissions, thus it can not be</p></li>
<li><p>used as the name of an individual permission.</p></li>
<li></li>
<li><p>This method must be called before <cite>All</cite> is accessed.</p></li>
<li><p>The intention is that it should be called as part of</p></li>
<li><p>object initialization.</p></li>
<li></li>
<li><p>Note that some methods of PermissionModule access <cite>All</cite>, so it is</p></li>
<li><p>best to create all of your permissions before doing anything</p></li>
<li><p>else.</p></li>
<li></li>
<li><p>&#64;throws RuntimeException: If it is called after <cite>All</cite> has been</p></li>
<li><p>initialized.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>protected def create(name: String) = {</dt><dd><dl>
<dt>synchronized {</dt><dd><dl class="simple">
<dt>if (allPerms == null) {</dt><dd><p>throw new RuntimeException(“Permission creation after initialization”)</p>
</dd>
</dl>
<p>}</p>
<p>allPerms = allPerms union Set(name)</p>
</dd>
</dl>
<p>}</p>
<p>new Permissions(Set(name))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Get a set of permissions with this single permission by name. It</p></li>
<li><p>will return None if there is no permission by that name.</p></li>
<li></li>
<li><p>No permissions may be defined after this method is called.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
</dl>
<p>def get(name: String): Option[Permissions] = All.get(name)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Get the set of permissions that contains that single permission</p></li>
<li><p>by name.</p></li>
<li></li>
<li><p>&#64;throws RuntimeException if there is no defined permission with</p></li>
<li><p>this name.</p></li>
<li></li>
<li><p>No permissions may be defined after this method is called.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>def apply(name: String): Permissions =</dt><dd><dl class="simple">
<dt>get(name) match {</dt><dd><p>case None =&gt; throw new RuntimeException(“Unknown permission: “ + name)
case Some(p) =&gt; p</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>No permissions (required or held)</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
</dl>
<p>val Empty: Permissions = new Permissions(Set.empty)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>All defined permissions.</p></li>
<li></li>
<li><p>No permissions may be defined after this value is initialized.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>lazy val All: Permissions = {</dt><dd><p>val p = new Permissions(allPerms)
allPerms = null
p</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Load permissions from a YAML map.</p></li>
<li></li>
<li><p>No permissions may be defined after this method is called.</p></li>
<li></li>
<li><p>&#64;return a map from client identifier to permission set.</p></li>
<li><p>&#64;throws RuntimeException when the permission from the Map is not defined.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>def fromYaml(m: YamlMap): Try[Map[String, Permissions]] =</dt><dd><dl>
<dt>Try {</dt><dd><dl class="simple">
<dt>m.keys.map { k =&gt;</dt><dd><p>k -&gt; fromSeq((m yamlList k).map { _.toString })</p>
</dd>
</dl>
<p>}.toMap</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Load permissions from map.</p></li>
<li></li>
<li><p>No permissions may be defined after this method is called.</p></li>
<li></li>
<li><p>&#64;param m a map from client identifier to a set of permission strings</p></li>
<li></li>
<li><p>&#64;return a map from client identifier to permission set.</p></li>
<li><p>&#64;throws RuntimeException when the permission from the Map is not defined.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>def fromMap(m: Map[String, Seq[String]]): Try[Map[String, Permissions]] =</dt><dd><dl class="simple">
<dt>Try {</dt><dd><p>m.map { case (k, v) =&gt; k -&gt; fromSeq(v) }</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Load permissions from seq.</p></li>
<li></li>
<li><p>No permissions may be defined after this method is called.</p></li>
<li></li>
<li><p>&#64;param sequence a Seq of permission strings</p></li>
<li></li>
<li><p>&#64;return a permission set.</p></li>
<li><p>&#64;throws RuntimeException when the permission is not defined.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>def fromSeq(permissionStrings: Seq[String]): Permissions =</dt><dd><dl>
<dt>permissionStrings.foldLeft(Empty) { (p, v) =&gt;</dt><dd><dl class="simple">
<dt>v match {</dt><dd><p>case “all” if get(“all”).isEmpty =&gt; All
case other =&gt; p union apply(other)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Authorizer based on a Permissions for RPC method names.</p></li>
<li><p>&#64;param requiredPermissions</p></li>
<li><p>map of RPC method names to Permissions required for that RPC</p></li>
<li><p>&#64;param clientPermissions</p></li>
<li><p>map of ClientId to Permissions a client has</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>def permissionBasedAuthorizer(</dt><dd><p>requiredPermissions: Map[String, Permissions],
clientPermissions: Map[String, Permissions]</p>
</dd>
<dt>): ClientRequestAuthorizer =</dt><dd><dl>
<dt>ClientRequestAuthorizer.filtered { (methodName, clientId) =&gt;</dt><dd><dl class="simple">
<dt>requiredPermissions.get(methodName) exists {</dt><dd><p>_ satisfiedBy clientPermissions.getOrElse(clientId, Empty)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>A set of permissions. This can represent either permissions that</p></li>
<li><p>are required to perform an action, or permissions that are held</p></li>
<li><p>by a client.</p></li>
<li></li>
<li><p>This type cannot be instantiated directly. Use the methods of</p></li>
<li><p>your subclass of PermissionModule to do so.</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
</dl>
<p>class Permissions private[PermissionModule] (private[PermissionModule] val permSet: Set[String]) {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Does the supplied set of held permissions satisfy the</p></li>
<li><p>requirements of this set of permissions?</p></li>
<li></li>
<li><p>For example, if this set of permissions is Set(“read”), and the</p></li>
<li><p>other set of permissions is Set(“read”, “write”), then the</p></li>
<li><p>other set of permissions satisfies this set.</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
</dl>
<p>def satisfiedBy(other: Permissions): Boolean = permSet subsetOf other.permSet</p>
<dl>
<dt>override def equals(other: Any): Boolean =</dt><dd><dl class="simple">
<dt>other match {</dt><dd><p>case p: Permissions =&gt; p.permSet == permSet
case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>override lazy val hashCode: Int = 5 + 37 * permSet.hashCode</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Get a single permission</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
<dt>def get(permName: String): Option[Permissions] =</dt><dd><p>if (permSet contains permName) Some(new Permissions(Set(permName))) else None</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Create a new permission set that holds the permissions of this</p></li>
<li><p>object as well as the permissions of the other object.</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
</dl>
<p>def union(other: Permissions): Permissions = new Permissions(permSet union other.permSet)</p>
<p>override def toString: String = “Permissions(%s)”.format(permSet.mkString(”, “))</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../../_sources/tweetypie/servo/request/src/main/scala/com/twitter/servo/request/PermissionModule.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>