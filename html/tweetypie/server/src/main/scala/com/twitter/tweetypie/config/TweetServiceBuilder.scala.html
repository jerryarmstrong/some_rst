<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie
package config</p>
<p>import com.twitter.coreservices.failed_task.writer.FailedTaskWriter
import com.twitter.featureswitches.v2.FeatureSwitches
import com.twitter.flockdb.client._
import com.twitter.servo.forked
import com.twitter.servo.util.FutureArrow
import com.twitter.servo.util.Scribe
import com.twitter.stitch.Stitch
import com.twitter.tweetypie.client_id.ClientIdHelper
import com.twitter.tweetypie.handler._
import com.twitter.tweetypie.repository._
import com.twitter.tweetypie.service.ReplicatingTweetService
import com.twitter.tweetypie.service._
import com.twitter.tweetypie.storage.TweetStorageClient
import com.twitter.tweetypie.storage.TweetStorageClient.GetTweet
import com.twitter.tweetypie.store._
import com.twitter.tweetypie.thriftscala._
import com.twitter.util.Activity
import com.twitter.util.Timer</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Builds a fully configured ThriftTweetService instance.</p></li>
<li></li>
<li><p>The core of the tweet service is a DispatchingTweetService, which is responsible</p></li>
<li><p>for dispatching requests to underlying handlers and stores.</p></li>
<li><p>The DispatchingTweetService instance is wrapped in:</p></li>
<li><ul>
<li><p>ObservedTweetService        (adds stats counting)</p></li>
</ul>
</li>
<li><ul>
<li><p>ClientHandlingTweetService  (authentication, exception handling, etc)</p></li>
</ul>
</li>
<li><ul>
<li><p>ReplicatingTweetService     (replicates some reads)</p></li>
</ul>
</li>
<li></li>
<li><p>TweetServiceBuilder returns an Activity[ThriftTweetService] which updates</p></li>
<li><p>on config changes. See DynamicConfig.scala for more details.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>object TweetServiceBuilder {</dt><dd><dl>
<dt>def apply(</dt><dd><p>settings: TweetServiceSettings,
statsReceiver: StatsReceiver,
timer: Timer,
deciderGates: TweetypieDeciderGates,
featureSwitchesWithExperiments: FeatureSwitches,
featureSwitchesWithoutExperiments: FeatureSwitches,
backendClients: BackendClients,
clientIdHelper: ClientIdHelper,</p>
</dd>
<dt>): Activity[ThriftTweetService] = {</dt><dd><p>// a forward reference, will be set to the DispatchingTweetService once created
val syncTweetService = new MutableTweetServiceProxy(null)</p>
<p>val tweetServiceScope = statsReceiver.scope(“tweet_service”)</p>
<dl>
<dt>val dispatchingTweetService =</dt><dd><dl class="simple">
<dt>DispatchingTweetServiceBuilder(</dt><dd><p>settings,
statsReceiver,
tweetServiceScope,
syncTweetService,
timer,
deciderGates,
featureSwitchesWithExperiments,
featureSwitchesWithoutExperiments,
backendClients,
clientIdHelper,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val failureLoggingTweetService =</dt><dd><p>// Add the failure writing inside of the authorization filter so
// that we don’t write out the failures when authorization fails.
new FailureLoggingTweetService(</p>
<blockquote>
<div><p>failedTaskWriter = FailedTaskWriter(“tweetypie_service_failures”, identity),
underlying = dispatchingTweetService</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>val observedTweetService =</dt><dd><p>new ObservedTweetService(failureLoggingTweetService, tweetServiceScope, clientIdHelper)</p>
</dd>
</dl>
<p>// Every time config is updated, create a new tweet service. Only
// ClientHandlingTweetService and ReplicatingTweetService need to
// be recreated, as the underlying TweetServices above don’t depend
// on the config.
DynamicConfig(</p>
<blockquote>
<div><p>statsReceiver.scope(“dynamic_config”),
backendClients.configBus,
settings</p>
</div></blockquote>
<dl>
<dt>).map { dynamicConfig =&gt;</dt><dd><dl>
<dt>val clientHandlingTweetService =</dt><dd><dl>
<dt>new ClientHandlingTweetService(</dt><dd><p>observedTweetService,
tweetServiceScope,
dynamicConfig.loadShedEligible,
deciderGates.shedReadTrafficVoluntarily,
ClientHandlingTweetServiceAuthorizer(</p>
<blockquote>
<div><p>settings = settings,
dynamicConfig = dynamicConfig,
statsReceiver = statsReceiver</p>
</div></blockquote>
<p>),
GetTweetsAuthorizer(</p>
<blockquote>
<div><p>config = dynamicConfig,
maxRequestSize = settings.maxGetTweetsRequestSize,
instanceCount = settings.instanceCount,
enforceRateLimitedClients = deciderGates.enforceRateLimitedClients,
maxRequestWidthEnabled = deciderGates.maxRequestWidthEnabled,
statsReceiver = tweetServiceScope.scope(“get_tweets”),</p>
</div></blockquote>
<p>),
GetTweetFieldsAuthorizer(</p>
<blockquote>
<div><p>config = dynamicConfig,
maxRequestSize = settings.maxGetTweetsRequestSize,
instanceCount = settings.instanceCount,
enforceRateLimitedClients = deciderGates.enforceRateLimitedClients,
maxRequestWidthEnabled = deciderGates.maxRequestWidthEnabled,
statsReceiver = tweetServiceScope.scope(“get_tweet_fields”),</p>
</div></blockquote>
<p>),
RequestSizeAuthorizer(settings.maxRequestSize, deciderGates.maxRequestWidthEnabled),
clientIdHelper,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>syncTweetService.underlying = clientHandlingTweetService</p>
<dl>
<dt>val replicatingService =</dt><dd><dl>
<dt>if (!settings.enableReplication)</dt><dd><p>clientHandlingTweetService</p>
</dd>
<dt>else {</dt><dd><dl>
<dt>new ReplicatingTweetService(</dt><dd><p>underlying = clientHandlingTweetService,
replicationTargets = backendClients.lowQoSReplicationClients,
executor = new forked.QueueExecutor(</p>
<blockquote>
<div><p>100,
statsReceiver.scope(“replicating_tweet_service”)</p>
</div></blockquote>
<p>),</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>replicatingService</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>object DispatchingTweetServiceBuilder {</dt><dd><p>val hasMedia: Tweet =&gt; Boolean = MediaIndexHelper(Resources.loadPartnerMediaRegexes())</p>
<dl>
<dt>def apply(</dt><dd><p>settings: TweetServiceSettings,
statsReceiver: StatsReceiver,
tweetServiceScope: StatsReceiver,
syncTweetService: ThriftTweetService,
timer: Timer,
deciderGates: TweetypieDeciderGates,
featureSwitchesWithExperiments: FeatureSwitches,
featureSwitchesWithoutExperiments: FeatureSwitches,
backendClients: BackendClients,
clientIdHelper: ClientIdHelper,</p>
</dd>
<dt>): ThriftTweetService = {</dt><dd><dl>
<dt>val (syncInvocationBuilder, asyncInvocationBuilder) = {</dt><dd><dl class="simple">
<dt>val b =</dt><dd><p>new ServiceInvocationBuilder(syncTweetService, settings.simulateDeferredrpcCallbacks)</p>
</dd>
</dl>
<p>(b.withClientId(settings.thriftClientId), b.withClientId(settings.deferredrpcClientId))</p>
</dd>
</dl>
<p>}</p>
<p>val tweetKeyFactory = TweetKeyFactory(settings.tweetKeyCacheVersion)</p>
<dl>
<dt>val caches =</dt><dd><dl>
<dt>if (!settings.withCache)</dt><dd><p>Caches.NoCache</p>
</dd>
<dt>else</dt><dd><dl class="simple">
<dt>Caches(</dt><dd><p>settings = settings,
stats = statsReceiver,
timer = timer,
clients = backendClients,
tweetKeyFactory = tweetKeyFactory,
deciderGates = deciderGates,
clientIdHelper = clientIdHelper,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
<dt>val logicalRepos =</dt><dd><dl>
<dt>LogicalRepositories(</dt><dd><p>settings = settings,
stats = statsReceiver,
timer = timer,
deciderGates = deciderGates,
external = new ExternalServiceRepositories(</p>
<blockquote>
<div><p>clients = backendClients,
statsReceiver = statsReceiver,
settings = settings,
clientIdHelper = clientIdHelper,</p>
</div></blockquote>
<p>),
caches = caches,
stratoClient = backendClients.stratoserverClient,
hasMedia = hasMedia,
clientIdHelper = clientIdHelper,
featureSwitchesWithoutExperiments = featureSwitchesWithoutExperiments,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val tweetCreationLock =</dt><dd><dl>
<dt>new CacheBasedTweetCreationLock(</dt><dd><p>cache = caches.tweetCreateLockerCache,
maxTries = 3,
stats = statsReceiver.scope(“tweet_save”).scope(“locker”),
logUniquenessId =</p>
<blockquote>
<div><p>if (settings.scribeUniquenessIds) CacheBasedTweetCreationLock.ScribeUniquenessId
else CacheBasedTweetCreationLock.LogUniquenessId</p>
</div></blockquote>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val tweetStores =</dt><dd><dl class="simple">
<dt>TweetStores(</dt><dd><p>settings = settings,
statsReceiver = statsReceiver,
timer = timer,
deciderGates = deciderGates,
tweetKeyFactory = tweetKeyFactory,
clients = backendClients,
caches = caches,
asyncBuilder = asyncInvocationBuilder,
hasMedia = hasMedia,
clientIdHelper = clientIdHelper,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val tweetDeletePathHandler =</dt><dd><dl class="simple">
<dt>new DefaultTweetDeletePathHandler(</dt><dd><p>tweetServiceScope,
logicalRepos.tweetResultRepo,
logicalRepos.optionalUserRepo,
logicalRepos.stratoSafetyLabelsRepo,
logicalRepos.lastQuoteOfQuoterRepo,
tweetStores,
getPerspectives = backendClients.timelineService.getPerspectives,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val tweetBuilders =</dt><dd><dl class="simple">
<dt>TweetBuilders(</dt><dd><p>settings = settings,
statsReceiver = statsReceiver,
deciderGates = deciderGates,
featureSwitchesWithExperiments = featureSwitchesWithExperiments,
clients = backendClients,
caches = caches,
repos = logicalRepos,
tweetStore = tweetStores,
hasMedia = hasMedia,
unretweetEdits = tweetDeletePathHandler.unretweetEdits,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val hydrateTweetForInsert =</dt><dd><dl class="simple">
<dt>WritePathHydration.hydrateTweet(</dt><dd><p>logicalRepos.tweetHydrators.hydrator,
statsReceiver.scope(“insert_tweet”)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>val defaultTweetQueryOptions = TweetQuery.Options(include = GetTweetsHandler.BaseInclude)</p>
<dl>
<dt>val parentUserIdRepo: ParentUserIdRepository.Type =</dt><dd><dl class="simple">
<dt>ParentUserIdRepository(</dt><dd><p>tweetRepo = logicalRepos.tweetRepo</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val undeleteTweetHandler =</dt><dd><dl class="simple">
<dt>UndeleteTweetHandlerBuilder(</dt><dd><p>backendClients.tweetStorageClient,
logicalRepos,
tweetStores,
parentUserIdRepo,
statsReceiver</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val eraseUserTweetsHandler =</dt><dd><dl class="simple">
<dt>EraseUserTweetsHandlerBuilder(</dt><dd><p>backendClients,
asyncInvocationBuilder,
deciderGates,
settings,
timer,
tweetDeletePathHandler,
tweetServiceScope</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val setRetweetVisibilityHandler =</dt><dd><dl>
<dt>SetRetweetVisibilityHandler(</dt><dd><dl class="simple">
<dt>tweetGetter =</dt><dd><p>TweetRepository.tweetGetter(logicalRepos.optionalTweetRepo, defaultTweetQueryOptions),</p>
</dd>
</dl>
<p>tweetStores.setRetweetVisibility</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val takedownHandler =</dt><dd><dl class="simple">
<dt>TakedownHandlerBuilder(</dt><dd><p>logicalRepos = logicalRepos,
tweetStores = tweetStores</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val updatePossiblySensitiveTweetHandler =</dt><dd><dl>
<dt>UpdatePossiblySensitiveTweetHandler(</dt><dd><dl class="simple">
<dt>HandlerError.getRequired(</dt><dd><p>TweetRepository.tweetGetter(logicalRepos.optionalTweetRepo, defaultTweetQueryOptions),
HandlerError.tweetNotFoundException</p>
</dd>
</dl>
<p>),
HandlerError.getRequired(</p>
<blockquote>
<div><dl>
<dt>FutureArrow(</dt><dd><dl>
<dt>UserRepository</dt><dd><dl class="simple">
<dt>.userGetter(</dt><dd><p>logicalRepos.optionalUserRepo,
UserQueryOptions(Set(UserField.Safety), UserVisibility.All)</p>
</dd>
</dl>
<p>)
.compose(UserKey.byId)</p>
</dd>
</dl>
</dd>
</dl>
<p>),
HandlerError.userNotFoundException</p>
</div></blockquote>
<p>),
tweetStores.updatePossiblySensitiveTweet</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val userTakedownHandler =</dt><dd><dl class="simple">
<dt>UserTakedownHandlerBuilder(</dt><dd><p>logicalRepos = logicalRepos,
tweetStores = tweetStores,
stats = tweetServiceScope</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val getDeletedTweetsHandler =</dt><dd><dl>
<dt>GetDeletedTweetsHandler(</dt><dd><p>getDeletedTweets = backendClients.tweetStorageClient.getDeletedTweets,
tweetsExist =</p>
<blockquote>
<div><p>GetDeletedTweetsHandler.tweetsExist(backendClients.tweetStorageClient.getTweet),</p>
</div></blockquote>
<p>stats = tweetServiceScope.scope(“get_deleted_tweets_handler”)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val hydrateQuotedTweet =</dt><dd><dl class="simple">
<dt>WritePathHydration.hydrateQuotedTweet(</dt><dd><p>logicalRepos.optionalTweetRepo,
logicalRepos.optionalUserRepo,
logicalRepos.quoterHasAlreadyQuotedRepo</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val deleteLocationDataHandler =</dt><dd><dl class="simple">
<dt>DeleteLocationDataHandler(</dt><dd><p>backendClients.geoScrubEventStore.getGeoScrubTimestamp,
Scribe(DeleteLocationData, “tweetypie_delete_location_data”),
backendClients.deleteLocationDataPublisher</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>val getStoredTweetsHandler = GetStoredTweetsHandler(logicalRepos.tweetResultRepo)</p>
<dl>
<dt>val getStoredTweetsByUserHandler = GetStoredTweetsByUserHandler(</dt><dd><p>getStoredTweetsHandler = getStoredTweetsHandler,
getStoredTweet = backendClients.tweetStorageClient.getStoredTweet,
selectPage = FutureArrow { select =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>backendClients.tflockReadClient</dt><dd><p>.selectPage(select, Some(settings.getStoredTweetsByUserPageSize))</p>
</dd>
</dl>
</div></blockquote>
<p>},
maxPages = settings.getStoredTweetsByUserMaxPages</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>val getTweetsHandler =</dt><dd><dl class="simple">
<dt>GetTweetsHandler(</dt><dd><p>logicalRepos.tweetResultRepo,
logicalRepos.containerAsGetTweetResultRepo,
logicalRepos.deletedTweetVisibilityRepo,
statsReceiver.scope(“read_path”),
deciderGates.shouldMaterializeContainers</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val getTweetFieldsHandler =</dt><dd><dl class="simple">
<dt>GetTweetFieldsHandler(</dt><dd><p>logicalRepos.tweetResultRepo,
logicalRepos.deletedTweetVisibilityRepo,
logicalRepos.containerAsGetTweetFieldsResultRepo,
statsReceiver.scope(“read_path”),
deciderGates.shouldMaterializeContainers</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val unretweetHandler =</dt><dd><dl class="simple">
<dt>UnretweetHandler(</dt><dd><p>tweetDeletePathHandler.deleteTweets,
backendClients.timelineService.getPerspectives,
tweetDeletePathHandler.unretweetEdits,
logicalRepos.tweetRepo,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val hydrateInsertEvent =</dt><dd><dl class="simple">
<dt>WritePathHydration.hydrateInsertTweetEvent(</dt><dd><p>hydrateTweet = hydrateTweetForInsert,
hydrateQuotedTweet = hydrateQuotedTweet</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val scrubGeoUpdateUserTimestampBuilder =</dt><dd><dl class="simple">
<dt>ScrubGeoEventBuilder.UpdateUserTimestamp(</dt><dd><p>stats = tweetServiceScope.scope(“scrub_geo_update_user_timestamp”),
userRepo = logicalRepos.optionalUserRepo</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val scrubGeoScrubTweetsBuilder =</dt><dd><dl class="simple">
<dt>ScrubGeoEventBuilder.ScrubTweets(</dt><dd><p>stats = tweetServiceScope.scope(“scrub_geo”),
userRepo = logicalRepos.optionalUserRepo</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val handlerFilter =</dt><dd><dl>
<dt>PostTweet</dt><dd><dl class="simple">
<dt>.DuplicateHandler(</dt><dd><p>tweetCreationLock = tweetCreationLock,
getTweets = getTweetsHandler,
stats = statsReceiver.scope(“duplicate”)</p>
</dd>
</dl>
<p>)
.andThen(PostTweet.RescueTweetCreateFailure)
.andThen(PostTweet.LogFailures)</p>
</dd>
</dl>
</dd>
<dt>val postTweetHandler =</dt><dd><dl>
<dt>handlerFilter[PostTweetRequest](</dt><dd><dl class="simple">
<dt>PostTweet.Handler(</dt><dd><p>tweetBuilder = tweetBuilders.tweetBuilder,
hydrateInsertEvent = hydrateInsertEvent,
tweetStore = tweetStores,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val postRetweetHandler =</dt><dd><dl>
<dt>handlerFilter[RetweetRequest](</dt><dd><dl class="simple">
<dt>PostTweet.Handler(</dt><dd><p>tweetBuilder = tweetBuilders.retweetBuilder,
hydrateInsertEvent = hydrateInsertEvent,
tweetStore = tweetStores,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val quotedTweetDeleteBuilder: QuotedTweetDeleteEventBuilder.Type =</dt><dd><p>QuotedTweetDeleteEventBuilder(logicalRepos.optionalTweetRepo)</p>
</dd>
<dt>val quotedTweetTakedownBuilder: QuotedTweetTakedownEventBuilder.Type =</dt><dd><p>QuotedTweetTakedownEventBuilder(logicalRepos.optionalTweetRepo)</p>
</dd>
<dt>val setAdditionalFieldsBuilder: SetAdditionalFieldsBuilder.Type =</dt><dd><dl class="simple">
<dt>SetAdditionalFieldsBuilder(</dt><dd><p>tweetRepo = logicalRepos.tweetRepo</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val asyncSetAdditionalFieldsBuilder: AsyncSetAdditionalFieldsBuilder.Type =</dt><dd><dl class="simple">
<dt>AsyncSetAdditionalFieldsBuilder(</dt><dd><p>userRepo = logicalRepos.userRepo</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val deleteAdditionalFieldsBuilder: DeleteAdditionalFieldsBuilder.Type =</dt><dd><dl class="simple">
<dt>DeleteAdditionalFieldsBuilder(</dt><dd><p>tweetRepo = logicalRepos.tweetRepo</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val asyncDeleteAdditionalFieldsBuilder: AsyncDeleteAdditionalFieldsBuilder.Type =</dt><dd><dl class="simple">
<dt>AsyncDeleteAdditionalFieldsBuilder(</dt><dd><p>userRepo = logicalRepos.userRepo</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>new DispatchingTweetService(</dt><dd><p>asyncDeleteAdditionalFieldsBuilder = asyncDeleteAdditionalFieldsBuilder,
asyncSetAdditionalFieldsBuilder = asyncSetAdditionalFieldsBuilder,
deleteAdditionalFieldsBuilder = deleteAdditionalFieldsBuilder,
deleteLocationDataHandler = deleteLocationDataHandler,
deletePathHandler = tweetDeletePathHandler,
eraseUserTweetsHandler = eraseUserTweetsHandler,
getDeletedTweetsHandler = getDeletedTweetsHandler,
getStoredTweetsHandler = getStoredTweetsHandler,
getStoredTweetsByUserHandler = getStoredTweetsByUserHandler,
getTweetsHandler = getTweetsHandler,
getTweetFieldsHandler = getTweetFieldsHandler,
getTweetCountsHandler = GetTweetCountsHandler(logicalRepos.tweetCountsRepo),
postTweetHandler = postTweetHandler,
postRetweetHandler = postRetweetHandler,
quotedTweetDeleteBuilder = quotedTweetDeleteBuilder,
quotedTweetTakedownBuilder = quotedTweetTakedownBuilder,
scrubGeoUpdateUserTimestampBuilder = scrubGeoUpdateUserTimestampBuilder,
scrubGeoScrubTweetsBuilder = scrubGeoScrubTweetsBuilder,
setAdditionalFieldsBuilder = setAdditionalFieldsBuilder,
setRetweetVisibilityHandler = setRetweetVisibilityHandler,
statsReceiver = statsReceiver,
takedownHandler = takedownHandler,
tweetStore = tweetStores,
undeleteTweetHandler = undeleteTweetHandler,
unretweetHandler = unretweetHandler,
updatePossiblySensitiveTweetHandler = updatePossiblySensitiveTweetHandler,
userTakedownHandler = userTakedownHandler,
clientIdHelper = clientIdHelper,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>object TakedownHandlerBuilder {</dt><dd><p>type Type = FutureArrow[TakedownRequest, Unit]</p>
<dl>
<dt>def apply(logicalRepos: LogicalRepositories, tweetStores: TotalTweetStore) =</dt><dd><dl>
<dt>TakedownHandler(</dt><dd><dl class="simple">
<dt>getTweet = HandlerError.getRequired(</dt><dd><p>tweetGetter(logicalRepos),
HandlerError.tweetNotFoundException</p>
</dd>
</dl>
<p>),
getUser = HandlerError.getRequired(</p>
<blockquote>
<div><p>userGetter(logicalRepos),
HandlerError.userNotFoundException</p>
</div></blockquote>
<p>),
writeTakedown = tweetStores.takedown</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>def tweetGetter(logicalRepos: LogicalRepositories): FutureArrow[TweetId, Option[Tweet]] =</dt><dd><dl>
<dt>FutureArrow(</dt><dd><dl>
<dt>TweetRepository.tweetGetter(</dt><dd><p>logicalRepos.optionalTweetRepo,
TweetQuery.Options(</p>
<blockquote>
<div><dl>
<dt>include = GetTweetsHandler.BaseInclude.also(</dt><dd><dl class="simple">
<dt>tweetFields = Set(</dt><dd><p>Tweet.TweetypieOnlyTakedownCountryCodesField.id,
Tweet.TweetypieOnlyTakedownReasonsField.id</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>def userGetter(logicalRepos: LogicalRepositories): FutureArrow[UserId, Option[User]] =</dt><dd><dl>
<dt>FutureArrow(</dt><dd><dl>
<dt>UserRepository</dt><dd><dl>
<dt>.userGetter(</dt><dd><p>logicalRepos.optionalUserRepo,
UserQueryOptions(</p>
<blockquote>
<div><p>Set(UserField.Roles, UserField.Safety, UserField.Takedowns),
UserVisibility.All</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)
.compose(UserKey.byId)</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>object UserTakedownHandlerBuilder {</dt><dd><dl>
<dt>def apply(</dt><dd><p>logicalRepos: LogicalRepositories,
tweetStores: TotalTweetStore,
stats: StatsReceiver</p>
</dd>
<dt>): UserTakedownHandler.Type =</dt><dd><dl class="simple">
<dt>UserTakedownHandler(</dt><dd><p>getTweet = TakedownHandlerBuilder.tweetGetter(logicalRepos),
tweetTakedown = tweetStores.takedown,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>object EraseUserTweetsHandlerBuilder {</dt><dd><dl>
<dt>def apply(</dt><dd><p>backendClients: BackendClients,
asyncInvocationBuilder: ServiceInvocationBuilder,
deciderGates: TweetypieDeciderGates,
settings: TweetServiceSettings,
timer: Timer,
tweetDeletePathHandler: DefaultTweetDeletePathHandler,
tweetServiceScope: StatsReceiver</p>
</dd>
<dt>): EraseUserTweetsHandler =</dt><dd><dl class="simple">
<dt>EraseUserTweetsHandler(</dt><dd><p>selectPage(backendClients, settings),
deleteTweet(tweetDeletePathHandler),
eraseUserTweets(backendClients, asyncInvocationBuilder),
tweetServiceScope.scope(“erase_user_tweets”),
sleep(deciderGates, settings, timer)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>def selectPage(</dt><dd><p>backendClients: BackendClients,
settings: TweetServiceSettings</p>
</dd>
<dt>): FutureArrow[Select[StatusGraph], PageResult[Long]] =</dt><dd><dl class="simple">
<dt>FutureArrow(</dt><dd><p>backendClients.tflockWriteClient.selectPage(_, Some(settings.eraseUserTweetsPageSize))</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>def deleteTweet(</dt><dd><p>tweetDeletePathHandler: DefaultTweetDeletePathHandler</p>
</dd>
<dt>): FutureEffect[(TweetId, UserId)] =</dt><dd><dl>
<dt>FutureEffect[(TweetId, UserId)] {</dt><dd><dl>
<dt>case (tweetId, expectedUserId) =&gt;</dt><dd><dl>
<dt>tweetDeletePathHandler</dt><dd><dl>
<dt>.internalDeleteTweets(</dt><dd><dl class="simple">
<dt>request = DeleteTweetsRequest(</dt><dd><p>Seq(tweetId),
isUserErasure = true,
expectedUserId = Some(expectedUserId)</p>
</dd>
</dl>
<p>),
byUserId = None,
authenticatedUserId = None,
validate = tweetDeletePathHandler.validateTweetsForUserErasureDaemon</p>
</dd>
</dl>
<p>)
.unit</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>def eraseUserTweets(</dt><dd><p>backendClients: BackendClients,
asyncInvocationBuilder: ServiceInvocationBuilder</p>
</dd>
<dt>): FutureArrow[AsyncEraseUserTweetsRequest, Unit] =</dt><dd><dl class="simple">
<dt>asyncInvocationBuilder</dt><dd><p>.asyncVia(backendClients.asyncTweetDeletionService)
.method(_.asyncEraseUserTweets)</p>
</dd>
</dl>
</dd>
<dt>def sleep(</dt><dd><p>deciderGates: TweetypieDeciderGates,
settings: TweetServiceSettings,
timer: Timer</p>
</dd>
<dt>): () =&gt; Future[Unit] =</dt><dd><dl>
<dt>() =&gt;</dt><dd><dl class="simple">
<dt>if (deciderGates.delayEraseUserTweets()) {</dt><dd><p>Future.sleep(settings.eraseUserTweetsDelay)(timer)</p>
</dd>
<dt>} else {</dt><dd><p>Future.Unit</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>object UndeleteTweetHandlerBuilder {</dt><dd><dl>
<dt>def apply(</dt><dd><p>tweetStorage: TweetStorageClient,
logicalRepos: LogicalRepositories,
tweetStores: TotalTweetStore,
parentUserIdRepo: ParentUserIdRepository.Type,
statsReceiver: StatsReceiver</p>
</dd>
<dt>): UndeleteTweetHandler.Type =</dt><dd><dl>
<dt>UndeleteTweetHandler(</dt><dd><p>undelete = tweetStorage.undelete,
tweetExists = tweetExists(tweetStorage),
getUser = FutureArrow(</p>
<blockquote>
<div><dl>
<dt>UserRepository</dt><dd><dl>
<dt>.userGetter(</dt><dd><p>logicalRepos.optionalUserRepo,
UserQueryOptions(</p>
<blockquote>
<div><p>// ExtendedProfile is needed to view a user’s birthday to
// guarantee we are not undeleting tweets from when a user was &lt; 13
TweetBuilder.userFields ++ Set(UserField.ExtendedProfile),
UserVisibility.All,
filteredAsFailure = false</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)
.compose(UserKey.byId)</p>
</dd>
</dl>
</div></blockquote>
<p>),
getDeletedTweets = tweetStorage.getDeletedTweets,
parentUserIdRepo = parentUserIdRepo,
save = save(</p>
<blockquote>
<div><p>logicalRepos,
tweetStores,
statsReceiver</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>private def tweetExists(tweetStorage: TweetStorageClient): FutureArrow[TweetId, Boolean] =</dt><dd><dl>
<dt>FutureArrow { id =&gt;</dt><dd><dl>
<dt>Stitch</dt><dd><p>.run(tweetStorage.getTweet(id))
.map {</p>
<blockquote>
<div><p>case _: GetTweet.Response.Found =&gt; true
case _ =&gt; false</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>//  1. hydrates the undeleted tweet
//  2. hands a UndeleteTweetEvent to relevant stores.
//  3. return the hydrated tweet
def save(</p>
<blockquote>
<div><p>logicalRepos: LogicalRepositories,
tweetStores: TotalTweetStore,
statsReceiver: StatsReceiver</p>
</div></blockquote>
<p>): FutureArrow[UndeleteTweet.Event, Tweet] = {</p>
<blockquote>
<div><dl>
<dt>val hydrateTweet =</dt><dd><dl class="simple">
<dt>WritePathHydration.hydrateTweet(</dt><dd><p>logicalRepos.tweetHydrators.hydrator,
statsReceiver.scope(“undelete_tweet”)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val hydrateQuotedTweet =</dt><dd><dl class="simple">
<dt>WritePathHydration.hydrateQuotedTweet(</dt><dd><p>logicalRepos.optionalTweetRepo,
logicalRepos.optionalUserRepo,
logicalRepos.quoterHasAlreadyQuotedRepo</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val hydrateUndeleteEvent =</dt><dd><dl class="simple">
<dt>WritePathHydration.hydrateUndeleteTweetEvent(</dt><dd><p>hydrateTweet = hydrateTweet,
hydrateQuotedTweet = hydrateQuotedTweet</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>FutureArrow[UndeleteTweet.Event, Tweet] { event =&gt;</dt><dd><dl class="simple">
<dt>for {</dt><dd><p>hydratedEvent &lt;- hydrateUndeleteEvent(event)
_ &lt;- tweetStores.undeleteTweet(hydratedEvent)</p>
</dd>
</dl>
<p>} yield hydratedEvent.tweet</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/tweetypie/server/src/main/scala/com/twitter/tweetypie/config/TweetServiceBuilder.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>