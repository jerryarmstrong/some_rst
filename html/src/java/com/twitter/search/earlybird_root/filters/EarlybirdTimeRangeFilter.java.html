<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../" id="documentation_options" src="../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.earlybird_root.filters;</p>
<p>import java.util.Collections;
import java.util.Map;
import java.util.Optional;</p>
<p>import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Maps;</p>
<p>import org.slf4j.Logger;
import org.slf4j.LoggerFactory;</p>
<p>import com.twitter.finagle.Service;
import com.twitter.finagle.SimpleFilter;
import com.twitter.search.common.decider.SearchDecider;
import com.twitter.search.common.metrics.SearchCounter;
import com.twitter.search.common.util.earlybird.EarlybirdResponseUtil;
import com.twitter.search.earlybird.config.ServingRange;
import com.twitter.search.earlybird.thrift.EarlybirdResponse;
import com.twitter.search.earlybird.thrift.EarlybirdResponseCode;
import com.twitter.search.earlybird.thrift.ThriftSearchResults;
import com.twitter.search.earlybird_root.common.EarlybirdRequestContext;
import com.twitter.search.earlybird_root.common.EarlybirdRequestType;
import com.twitter.search.queryparser.query.Query;
import com.twitter.search.queryparser.query.QueryParserException;
import com.twitter.search.queryparser.util.IdTimeRanges;
import com.twitter.util.Future;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A Finagle filter used to filter requests to tiers.</p></li>
<li><p>Parses serialized query on Earlybird request, and extracts since / until / since_id / max_id</p></li>
<li><p>operators. This filter then tests whether the request overlaps with the given tier. If there</p></li>
<li><p>is no overlap, an empty response is returned without actually forwarding the requests to the</p></li>
<li><p>underlying service.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public class EarlybirdTimeRangeFilter extends</dt><dd><blockquote>
<div><p>SimpleFilter&lt;EarlybirdRequestContext, EarlybirdResponse&gt; {</p>
</div></blockquote>
<p>private static final Logger LOG = LoggerFactory.getLogger(EarlybirdTimeRangeFilter.class);</p>
<dl class="simple">
<dt>private static final EarlybirdResponse ERROR_RESPONSE =</dt><dd><dl class="simple">
<dt>new EarlybirdResponse(EarlybirdResponseCode.PERSISTENT_ERROR, 0)</dt><dd><p>.setSearchResults(new ThriftSearchResults());</p>
</dd>
</dl>
</dd>
</dl>
<p>private final ServingRangeProvider servingRangeProvider;
private final Optional&lt;EarlybirdTimeFilterQueryRewriter&gt; queryRewriter;</p>
<p>private static final Map&lt;EarlybirdRequestType, SearchCounter&gt; FAILED_REQUESTS;
static {</p>
<blockquote>
<div><dl class="simple">
<dt>final Map&lt;EarlybirdRequestType, SearchCounter&gt; tempMap =</dt><dd><p>Maps.newEnumMap(EarlybirdRequestType.class);</p>
</dd>
<dt>for (EarlybirdRequestType requestType<span class="classifier">EarlybirdRequestType.values()) {</span></dt><dd><dl class="simple">
<dt>tempMap.put(requestType, SearchCounter.export(</dt><dd><p>“<a href="#id7"><span class="problematic" id="id8">time_range_filter_</span></a>” + requestType.getNormalizedName() + “_failed_requests”));</p>
</dd>
</dl>
</dd>
</dl>
<p>}
FAILED_REQUESTS = Collections.unmodifiableMap(tempMap);</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>public static EarlybirdTimeRangeFilter newTimeRangeFilterWithQueryRewriter(</dt><dd><blockquote>
<div><p>ServingRangeProvider servingRangeProvider,
SearchDecider decider) {</p>
</div></blockquote>
<dl class="simple">
<dt>return new EarlybirdTimeRangeFilter(servingRangeProvider,</dt><dd><p>Optional.of(new EarlybirdTimeFilterQueryRewriter(servingRangeProvider, decider)));</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>public static EarlybirdTimeRangeFilter newTimeRangeFilterWithoutQueryRewriter(</dt><dd><blockquote>
<div><p>ServingRangeProvider servingRangeProvider) {</p>
</div></blockquote>
<p>return new EarlybirdTimeRangeFilter(servingRangeProvider, Optional.empty());</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Construct a filter that avoids forwarding requests to unrelated tiers</p></li>
<li><p>based on requests’ since / until / since_id / max_id.</p></li>
<li><p>&#64;param provider Holds the boundary information.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>EarlybirdTimeRangeFilter(</dt><dd><blockquote>
<div><p>ServingRangeProvider provider,
Optional&lt;EarlybirdTimeFilterQueryRewriter&gt; rewriter) {</p>
</div></blockquote>
<p>this.servingRangeProvider = provider;
this.queryRewriter = rewriter;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public ServingRangeProvider getServingRangeProvider() {</dt><dd><p>return servingRangeProvider;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public Future&lt;EarlybirdResponse&gt; apply(</p>
<blockquote>
<div><blockquote>
<div><p>EarlybirdRequestContext requestContext,
Service&lt;EarlybirdRequestContext, EarlybirdResponse&gt; service) {</p>
</div></blockquote>
<p>Query parsedQuery = requestContext.getParsedQuery();
if (parsedQuery != null) {</p>
<blockquote>
<div><p>// Only perform filtering if serialized query is set.
try {</p>
<blockquote>
<div><p>IdTimeRanges queryRanges = IdTimeRanges.fromQuery(parsedQuery);
if (queryRanges == null) {</p>
<blockquote>
<div><p>// No time ranges in query.
return issueServiceRequest(service, requestContext);</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>ServingRange servingRange =</dt><dd><dl class="simple">
<dt>servingRangeProvider.getServingRange(</dt><dd><p>requestContext, requestContext.useOverrideTierConfig());</p>
</dd>
</dl>
</dd>
<dt>if (queryDoesNotOverlapWithServingRange(queryRanges, servingRange)) {</dt><dd><dl class="simple">
<dt>return Future.value(tierSkippedResponse(requestContext.getEarlybirdRequestType(),</dt><dd><p>servingRange));</p>
</dd>
</dl>
</dd>
<dt>} else {</dt><dd><p>return issueServiceRequest(service, requestContext);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} catch (QueryParserException e) {</dt><dd><p>LOG.warn(“Unable to get IdTimeRanges from query: “ + parsedQuery.serialize());
// The failure here is not due to a miss-formed query from the client, since we already
// were able to successfully get a parsed Query from the request.
// If we can’t determine the time ranges, pass the query along to the tier, and just
// restrict it to the timeranges of the tier.
return issueServiceRequest(service, requestContext);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>// There’s no serialized query. Just pass through like an identity filter.
return issueServiceRequest(service, requestContext);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private boolean queryDoesNotOverlapWithServingRange(IdTimeRanges queryRanges,</dt><dd><blockquote>
<div><p>ServingRange servingRange) {</p>
</div></blockquote>
<p>// As long as a query overlaps with the tier serving range on either side,
// the request is not filtered. I.e. we want to be conservative when doing this filtering,
// because it is just an optimization. We ignore the inclusiveness / exclusiveness of the
// boundaries. If the tier boundary and the query boundry happen to be the same, we do not
// filter the request.
return queryRanges.getSinceIDExclusive().or(0L)</p>
<blockquote>
<div><blockquote>
<div><p>&gt; servingRange.getServingRangeMaxId()</p>
</div></blockquote>
<dl class="simple">
<dt>|| queryRanges.getMaxIDInclusive().or(Long.MAX_VALUE)</dt><dd><p>&lt; servingRange.getServingRangeSinceId()</p>
</dd>
<dt>|| queryRanges.getSinceTimeInclusive().or(0)</dt><dd><p>&gt; servingRange.getServingRangeUntilTimeSecondsFromEpoch()</p>
</dd>
<dt>|| queryRanges.getUntilTimeExclusive().or(Integer.MAX_VALUE)</dt><dd><p>&lt; servingRange.getServingRangeSinceTimeSecondsFromEpoch();</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private Future&lt;EarlybirdResponse&gt; issueServiceRequest(</dt><dd><blockquote>
<div><p>Service&lt;EarlybirdRequestContext, EarlybirdResponse&gt; service,
EarlybirdRequestContext requestContext) {</p>
</div></blockquote>
<dl>
<dt>try {</dt><dd><p>EarlybirdRequestContext request = requestContext;
if (queryRewriter.isPresent()) {</p>
<blockquote>
<div><p>request = queryRewriter.get().rewriteRequest(requestContext);</p>
</div></blockquote>
<p>}
return service.apply(request);</p>
</dd>
<dt>} catch (QueryParserException e) {</dt><dd><p>FAILED_REQUESTS.get(requestContext.getEarlybirdRequestType()).increment();
String msg = “Failed to add time filter operators”;
LOG.error(msg, e);</p>
<p>// Note that in this case it is not clear whether the error is the client’s fault or our
// fault, so we don’t necessarily return a CLIENT_ERROR here.
// Currently this actually returns a PERSISTENT_ERROR.
if (requestContext.getRequest().getDebugMode() &gt; 0) {</p>
<blockquote>
<div><dl class="simple">
<dt>return Future.value(</dt><dd><p>ERROR_RESPONSE.deepCopy().setDebugString(msg + “: “ + e.getMessage()));</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>return Future.value(ERROR_RESPONSE);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Creates a tier skipped response, based on the given request type.</p></li>
<li></li>
<li><p>For recency, relevance, facets and top tweets requests, this method returns a SUCCESS response</p></li>
<li><p>with no search results and the minSearchedStatusID and maxSearchedStatusID appropriately set.</p></li>
<li><p>For term stats response, it returns a TIER_SKIPPED response, but we need to revisit this.</p></li>
<li></li>
<li><p>&#64;param requestType The type of the request.</p></li>
<li><p>&#64;param servingRange The serving range of the tier that we’re skipping.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
</dl>
<p>&#64;VisibleForTesting
public static EarlybirdResponse tierSkippedResponse(</p>
<blockquote>
<div><blockquote>
<div><p>EarlybirdRequestType requestType,
ServingRange servingRange) {</p>
</div></blockquote>
<dl>
<dt>String debugMessage =</dt><dd><p>“Tier skipped because it does not intersect with query time boundaries.”;</p>
</dd>
<dt>if (requestType == EarlybirdRequestType.TERM_STATS) {</dt><dd><p>// If it’s a term stats request, return a TIER_SKIPPED response for now.
// But we need to figure out the right thing to do here.
return new EarlybirdResponse(EarlybirdResponseCode.TIER_SKIPPED, 0)</p>
<blockquote>
<div><p>.setDebugString(debugMessage);</p>
</div></blockquote>
</dd>
<dt>} else {</dt><dd><p>// minIds in ServingRange instances are set to tierLowerBoundary - 1, because the
// since_id operator is exclusive. The max_id operator on the other hand is inclusive,
// so maxIds in ServingRange instances are also set to tierUpperBoundary - 1.
// Here we want both of them to be inclusive, so we need to increment the minId by 1.
return EarlybirdResponseUtil.tierSkippedRootResponse(</p>
<blockquote>
<div><p>servingRange.getServingRangeSinceId() + 1,
servingRange.getServingRangeMaxId(),
debugMessage);</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../_sources/src/java/com/twitter/search/earlybird_root/filters/EarlybirdTimeRangeFilter.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>