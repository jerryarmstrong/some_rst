<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.core.earlybird.index.inverted;</p>
<p>import java.io.IOException;</p>
<p>import javax.annotation.Nullable;</p>
<p>import org.apache.lucene.index.PostingsEnum;
import org.apache.lucene.search.DocIdSetIterator;</p>
<p>import com.twitter.search.common.metrics.SearchCounter;
import com.twitter.search.common.util.io.flushable.DataDeserializer;
import com.twitter.search.common.util.io.flushable.DataSerializer;
import com.twitter.search.common.util.io.flushable.FlushInfo;
import com.twitter.search.common.util.io.flushable.Flushable;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>An optimized posting lists implementation storing doc deltas, doc freqs, and positions as packed</p></li>
<li><p>ints in a 64 ints slice backed by <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> IntBlockPool}.</p></li>
<li></li>
<li><p>There are three inner data structures used to store values used by a posting lists instance:</p></li>
<li></li>
<li><ul>
<li><p>Skip lists, used for fast <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> PostingsEnum#advance(int)}, are stored in <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #skipLists}</p></li>
</ul>
</li>
<li><p>int block pool.</p></li>
<li><ul>
<li><p>Doc deltas and freqs are stored in <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #deltaFreqLists} int block pool.</p></li>
</ul>
</li>
<li><ul>
<li><p>Positions are stored in <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #positionLists} int block pool.</p></li>
</ul>
</li>
<li></li>
<li><p>For detail layout and configuration, please refer to the Javadoc of <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #skipLists},</p></li>
<li><p><a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #deltaFreqLists} and <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #positionLists}.</p></li>
<li></li>
<li><p>&lt;b&gt;This implementation designed for posting lists with a LARGE number of postings.&lt;/b&gt;</p></li>
<li></li>
<li><p>&lt;i&gt;Acknowledgement&lt;/i&gt;: the concepts of slice based packed ints encoding/decoding is borrowed</p></li>
<li><p>from <a class="reference external" href="mailto:{&#37;&#52;&#48;code">{<span>&#64;</span>code</a> HighDFCompressedPostinglists}, which will be deprecated due</p></li>
<li><p>to not supporting positions that are greater than 255.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public class HighDFPackedIntsPostingLists extends OptimizedPostingLists {</dt><dd><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A counter used to track when positions enum is required and a posting lists instance is set</p></li>
<li><p>to omit positions.</p></li>
<li></li>
<li><p>&#64;see #postings(int, int, int)</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>private static final SearchCounter GETTING_POSITIONS_WITH_OMIT_POSITIONS =</dt><dd><dl class="simple">
<dt>SearchCounter.export(</dt><dd><p>“high_df_packed_ints_posting_list_getting_positions_with_omit_positions”);</p>
</dd>
</dl>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Information related to size of a slice.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
</dl>
<p>static final int SLICE_SIZE_BIT = 6;
static final int SLICE_SIZE = 1 &lt;&lt; SLICE_SIZE_BIT;                 //   64 ints per block
static final int NUM_BITS_PER_SLICE = SLICE_SIZE * Integer.SIZE;   // 2048 bits per block</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A skip list has ONE skip list header that contains 5 ints (4 ints if positions are omitted):</p></li>
<li><ul>
<li><p>1st int: number of skip entries in this skip list.</p></li>
</ul>
</li>
<li><ul>
<li><p>2nd int: largest doc ID in this posting list.</p></li>
</ul>
</li>
<li><ul>
<li><p>3rd int: number of docs in this posting list.</p></li>
</ul>
</li>
<li><ul>
<li><p>4th int: pointer to the start of the delta-freq list of this posting list.</p></li>
</ul>
</li>
<li><ul>
<li><p>5th int: (OPTIONAL) pointer to the start of the position list of this posting list.</p></li>
</ul>
</li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
</dl>
<p>static final int SKIPLIST_HEADER_SIZE = 5;
static final int SKIPLIST_HEADER_SIZE_WITHOUT_POSITIONS = SKIPLIST_HEADER_SIZE - 1;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A skip list has MANY skip entries. Each skip entry is for one slice in delta-freq list.</p></li>
<li><p>There are 3 ints in every skip entry (2 ints if positions are omitted):</p></li>
<li><ul>
<li><p>1st int: last doc ID in previous slice (0 for the first slice), this is mainly used during</p></li>
</ul>
</li>
<li><p>skipping because deltas, not absolute doc IDs, are stored in a slice.</p></li>
<li><ul>
<li><p>2nd int: encoded metadata of the corresponding delta-freq slice. There are 4 piece of</p></li>
</ul>
</li>
<li><p>information from the LOWEST bits to HIGHEST bits of this int:</p></li>
<li><p>11 bits: number of docs (delta-freq pairs) in this slice.</p></li>
<li><p>5 bits: number of bits used to encode each freq.</p></li>
<li><p>5 bits: number of bits used to encode each delta.</p></li>
<li><p>11 bits: POSITION SLICE OFFSET: an index of number of positions; this is where the</p></li>
<li><p>first position of the first doc (in this delta-freq slice) is in the</p></li>
<li><p>position slice. The position slice is identified by the 3rd int below.</p></li>
<li><p>These two piece information uniquely identified the location of the start</p></li>
<li><p>position of this delta-freq slice. This value is always 0 if position is</p></li>
<li><p>omitted.</p></li>
<li><ul>
<li><p>3rd int: (OPTIONAL) POSITION SLICE INDEX: an index of of number of slices; this value</p></li>
</ul>
</li>
<li><p>identifies the slice in which the first position of the first doc (in this</p></li>
<li><p>delta-freq slice) exists. The exact location inside the position slice is identified</p></li>
<li><p>by POSITION SLICE OFFSET that is stored in the 2nd int above.</p></li>
<li><p>Notice: this is not the absolute address in the block pool, but instead a relative</p></li>
<li><p>offset (in number of slices) on top of this term’s first position slice.</p></li>
<li><p>This value DOES NOT EXIST if position is omitted.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
</dl>
<p>static final int SKIPLIST_ENTRY_SIZE = 3;
static final int SKIPLIST_ENTRY_SIZE_WITHOUT_POSITIONS = SKIPLIST_ENTRY_SIZE - 1;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Shifts and masks used to encode/decode metadata from the 2nd int of a skip list entry.</p></li>
<li><p>&#64;see #SKIPLIST_ENTRY_SIZE</p></li>
<li><p>&#64;see #encodeSkipListEntryMetadata(int, int, int, int)</p></li>
<li><p>&#64;see #getNumBitsForDelta(int)</p></li>
<li><p>&#64;see #getNumBitsForFreq(int)</p></li>
<li><p>&#64;see #getNumDocsInSlice(int)</p></li>
<li><p>&#64;see #getPositionOffsetInSlice(int)</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
</dl>
<p>static final int SKIPLIST_ENTRY_POSITION_OFFSET_SHIFT = 21;
static final int SKIPLIST_ENTRY_NUM_BITS_DELTA_SHIFT = 16;
static final int SKIPLIST_ENTRY_NUM_BITS_FREQ_SHIFT = 11;
static final int SKIPLIST_ENTRY_POSITION_OFFSET_MASK = (1 &lt;&lt; 11) - 1;
static final int SKIPLIST_ENTRY_NUM_BITS_DELTA_MASK = (1 &lt;&lt; 5) - 1;
static final int SKIPLIST_ENTRY_NUM_BITS_FREQ_MASK = (1 &lt;&lt; 5) - 1;
static final int SKIPLIST_ENTRY_NUM_DOCS_MASK = (1 &lt;&lt; 11) - 1;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Each position slice has a header that is the 1st int in this position slice. From LOWEST bits</p></li>
<li><p>to HIGHEST bits, there are 2 pieces of information encoded in this single int:</p></li>
<li><p>11 bits: number of positions in this slice.</p></li>
<li><p>5 bits: number of bits used to encode each position.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
</dl>
<p>static final int POSITION_SLICE_HEADER_SIZE = 1;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Information related to size of a position slice. The actual size is the same as</p></li>
<li><p><a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #SLICE_SIZE}, but there is 1 int used for position slice header.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
</dl>
<p>static final int POSITION_SLICE_SIZE_WITHOUT_HEADER = SLICE_SIZE - POSITION_SLICE_HEADER_SIZE;
static final int POSITION_SLICE_NUM_BITS_WITHOUT_HEADER =</p>
<blockquote>
<div><p>POSITION_SLICE_SIZE_WITHOUT_HEADER * Integer.SIZE;</p>
</div></blockquote>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Shifts and masks used to encode/decode metadata from the position slice header.</p></li>
<li><p>&#64;see #POSITION_SLICE_HEADER_SIZE</p></li>
<li><p>&#64;see #encodePositionEntryHeader(int, int)</p></li>
<li><p>&#64;see #getNumPositionsInSlice(int)</p></li>
<li><p>&#64;see #getNumBitsForPosition(int)</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
</dl>
<p>static final int POSITION_SLICE_HEADER_BITS_POSITION_SHIFT = 11;
static final int POSITION_SLICE_HEADER_BITS_POSITION_MASK = (1 &lt;&lt; 5) - 1;
static final int POSITION_SLICE_HEADER_NUM_POSITIONS_MASK = (1 &lt;&lt; 11) - 1;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Stores skip list for each posting list.</p></li>
<li></li>
<li><p>A skip list consists of ONE skip list header and MANY skip list entries, and each skip entry</p></li>
<li><p>corresponds to one delta-freq slice. Also, unlike <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #deltaFreqLists} and</p></li>
<li><p><a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #positionLists}, values in skip lists int pool are NOT stored in unit of slices.</p></li>
<li></li>
<li><p>Example:</p></li>
<li><p>H: skip list header int</p></li>
<li><p>E: skip list entry int</p></li>
<li><p>‘: int boundary</p></li>
<li><p><a href="#id19"><span class="problematic" id="id20">|</span></a>: header/entry boundary (also a boundary of int)</p></li>
<li></li>
<li><p>&lt;—– skip list A —–&gt; &lt;- skip list B -&gt;</p></li>
<li><p><a href="#id93"><span class="problematic" id="id94">|H'H'H'H'H|E'E|E'E|E'E|E'E|H'H'H'H'H|E'E|E'E|</span></a></p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
</dl>
<p>private final IntBlockPool skipLists;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Stores delta-freq list for each posting list.</p></li>
<li></li>
<li><p>A delta-freq list consists of MANY 64-int slices, and delta-freq pairs are stored compactly</p></li>
<li><p>with a fixed number of bits within a single slice. Each slice has a corresponding skip list</p></li>
<li><p>entry in <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #skipLists} storing metadata about this slice.</p></li>
<li></li>
<li><p>Example:</p></li>
<li><p><a href="#id23"><span class="problematic" id="id24">|</span></a>: slice boundary</p></li>
<li></li>
<li><p>&lt;—————– delta-freq list A —————–&gt; &lt;— delta-freq list B —&gt;</p></li>
<li><p><a href="#id95"><span class="problematic" id="id96">|64 ints slice|64 ints slice|64 ints slice|64 ints slice|64 ints slice|64 ints slice|</span></a></p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
</dl>
<p>private final IntBlockPool deltaFreqLists;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Stores position list for each posting list.</p></li>
<li></li>
<li><p>A position list consists of MANY 64 ints slices, and positions are stored compactly with a</p></li>
<li><p>fixed number of bits within a single slice. The first int in each slice is used as a header to</p></li>
<li><p>store the metadata about this position slice.</p></li>
<li></li>
<li><p>Example:</p></li>
<li><p>H: position header int</p></li>
<li><p>‘: int boundary</p></li>
<li><p><a href="#id27"><span class="problematic" id="id28">|</span></a>: slice boundary</p></li>
<li></li>
<li><p>&lt;————— position list A —————&gt; &lt;———- position list B ———-&gt;</p></li>
<li><p><a href="#id97"><span class="problematic" id="id98">|H'63 ints|H'63 ints|H'63 ints|H'63 ints|H'63 ints|H'63 ints|H'63 ints|H'63 ints|H'63 ints|</span></a></p></li>
</ul>
<p><a href="#id29"><span class="problematic" id="id30">*</span></a>/</p>
</dd>
</dl>
<p>private final IntBlockPool positionLists;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Whether positions are omitted in this optimized posting lists.</p></li>
</ul>
<p><a href="#id31"><span class="problematic" id="id32">*</span></a>/</p>
</dd>
</dl>
<p>private final boolean omitPositions;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Skip list header and entry size for this posting lists, could be different depends on whether</p></li>
<li><p>position is omitted or not.</p></li>
<li></li>
<li><p>&#64;see #SKIPLIST_HEADER_SIZE</p></li>
<li><p>&#64;see #SKIPLIST_HEADER_SIZE_WITHOUT_POSITIONS</p></li>
<li><p>&#64;see #SKIPLIST_ENTRY_SIZE</p></li>
<li><p>&#64;see #SKIPLIST_ENTRY_SIZE_WITHOUT_POSITIONS</p></li>
</ul>
<p><a href="#id33"><span class="problematic" id="id34">*</span></a>/</p>
</dd>
</dl>
<p>private final int skipListHeaderSize;
private final int skiplistEntrySize;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Buffer used in <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #copyPostingList(PostingsEnum, int)}</p></li>
<li><p>to queue up values needed for a slice.</p></li>
<li><p>Loaded posting lists have them set as null.</p></li>
</ul>
<p><a href="#id35"><span class="problematic" id="id36">*</span></a>/</p>
</dd>
</dl>
<p>private final PostingsBufferQueue docFreqQueue;
private final PostingsBufferQueue positionQueue;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Packed ints writer used to write into delta-freq int pool and position int pool.</p></li>
<li><p>Loaded posting lists have them set as null.</p></li>
</ul>
<p><a href="#id37"><span class="problematic" id="id38">*</span></a>/</p>
</dd>
</dl>
<p>private final IntBlockPoolPackedLongsWriter deltaFreqListsWriter;
private final IntBlockPoolPackedLongsWriter positionListsWriter;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Default constructor.</p></li>
<li></li>
<li><p>&#64;param omitPositions whether positions will be omitted in these posting lists.</p></li>
</ul>
<p><a href="#id39"><span class="problematic" id="id40">*</span></a>/</p>
</dd>
<dt>public HighDFPackedIntsPostingLists(boolean omitPositions) {</dt><dd><dl class="simple">
<dt>this(</dt><dd><p>new IntBlockPool(“high_df_packed_ints_skip_lists”),
new IntBlockPool(“high_df_packed_ints_delta_freq_lists”),
new IntBlockPool(“high_df_packed_ints_position_lists”),
omitPositions,
new PostingsBufferQueue(NUM_BITS_PER_SLICE),
new PostingsBufferQueue(POSITION_SLICE_NUM_BITS_WITHOUT_HEADER));</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Constructors used by loader.</p></li>
<li></li>
<li><p>&#64;param skipLists loaded int block pool represents skip lists</p></li>
<li><p>&#64;param deltaFreqLists loaded int block pool represents delta-freq lists</p></li>
<li><p>&#64;param positionLists loaded int block pool represents position lists</p></li>
<li><p>&#64;param omitPositions whether positions will be omitted in these posting lists</p></li>
<li><p>&#64;param docFreqQueue buffer used to queue up values used for a doc freq slice, null if loaded</p></li>
<li><p>&#64;param positionQueue buffer used to queue up values used for a position slice, null if loaded</p></li>
<li><p>&#64;see FlushHandler#doLoad(FlushInfo, DataDeserializer)</p></li>
</ul>
<p><a href="#id41"><span class="problematic" id="id42">*</span></a>/</p>
</dd>
<dt>private HighDFPackedIntsPostingLists(</dt><dd><blockquote>
<div><p>IntBlockPool skipLists,
IntBlockPool deltaFreqLists,
IntBlockPool positionLists,
boolean omitPositions,
&#64;Nullable PostingsBufferQueue docFreqQueue,
&#64;Nullable PostingsBufferQueue positionQueue) {</p>
</div></blockquote>
<p>this.skipLists = skipLists;
this.deltaFreqLists = deltaFreqLists;
this.positionLists = positionLists;
this.omitPositions = omitPositions;</p>
<p>this.docFreqQueue = docFreqQueue;
this.positionQueue = positionQueue;</p>
<p>// docFreqQueue is null if this postingLists is loaded,
// we don’t need to create writer at that case.
if (docFreqQueue == null) {</p>
<blockquote>
<div><p>assert positionQueue == null;
this.deltaFreqListsWriter = null;
this.positionListsWriter = null;</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>this.deltaFreqListsWriter = new IntBlockPoolPackedLongsWriter(deltaFreqLists);
this.positionListsWriter = new IntBlockPoolPackedLongsWriter(positionLists);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (omitPositions) {</dt><dd><p>skipListHeaderSize = SKIPLIST_HEADER_SIZE_WITHOUT_POSITIONS;
skiplistEntrySize = SKIPLIST_ENTRY_SIZE_WITHOUT_POSITIONS;</p>
</dd>
<dt>} else {</dt><dd><p>skipListHeaderSize = SKIPLIST_HEADER_SIZE;
skiplistEntrySize = SKIPLIST_ENTRY_SIZE;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A simple wrapper around assorted states used when coping positions in a posting enum.</p></li>
<li><p>&#64;see #copyPostingList(PostingsEnum, int)</p></li>
</ul>
<p><a href="#id43"><span class="problematic" id="id44">*</span></a>/</p>
</dd>
<dt>private static class PositionsState {</dt><dd><p>/** Max position has been seen for the current position slice. <a href="#id45"><span class="problematic" id="id46">*</span></a>/
private int maxPosition = 0;</p>
<p>/** Bits needed to encode/decode positions in the current position slice. <a href="#id47"><span class="problematic" id="id48">*</span></a>/
private int bitsNeededForPosition = 0;</p>
<p>/** Total number of position slices created for current posting list. <a href="#id49"><span class="problematic" id="id50">*</span></a>/
private int numPositionsSlices = 0;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Whenever a slice of doc/freq pairs is written, this will point to the first position</p></li>
<li><p>associated with the first doc in the doc/freq slice.</p></li>
</ul>
<p><a href="#id51"><span class="problematic" id="id52">*</span></a>/</p>
</dd>
</dl>
<p>private int currentPositionsSliceIndex = 0;
private int currentPositionsSliceOffset = 0;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Whenever a new document is processed, this points to the first position for this doc.</p></li>
<li><p>This is used if this doc ends up being chosen as the first doc in a doc/freq slice.</p></li>
</ul>
<p><a href="#id53"><span class="problematic" id="id54">*</span></a>/</p>
</dd>
</dl>
<p>private int nextPositionsSliceIndex = 0;
private int nextPositionsSliceOffset = 0;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Copies postings in the given postings enum into this posting lists instance.</p></li>
<li></li>
<li><p>&#64;param postingsEnum enumerator of the posting list that needs to be copied</p></li>
<li><p>&#64;param numPostings number of postings in the posting list that needs to be copied</p></li>
<li><p>&#64;return pointer to the copied posting list in this posting lists instance</p></li>
</ul>
<p><a href="#id55"><span class="problematic" id="id56">*</span></a>/</p>
</dd>
</dl>
<p>&#64;Override
public int copyPostingList(PostingsEnum postingsEnum, int numPostings) throws IOException {</p>
<blockquote>
<div><p>assert docFreqQueue.isEmpty() : “each new posting list should start with an empty queue”;
assert positionQueue.isEmpty() : “each new posting list should start with an empty queue”;</p>
<p>final int skipListPointer = skipLists.length();
final int deltaFreqListPointer = deltaFreqLists.length();
final int positionListPointer = positionLists.length();
assert isSliceStart(deltaFreqListPointer) : “each new posting list should start at a new slice”;
assert isSliceStart(positionListPointer) : “each new posting list should start at a new slice”;</p>
<p>// Make room for skip list HEADER.
for (int i = 0; i &lt; skipListHeaderSize; i++) {</p>
<blockquote>
<div><p>skipLists.add(-1);</p>
</div></blockquote>
<p>}</p>
<p>int doc;
int prevDoc = 0;
int prevWrittenDoc = 0;</p>
<p>int maxDelta = 0;
int maxFreq = 0;</p>
<p>int bitsNeededForDelta = 0;
int bitsNeededForFreq = 0;</p>
<p>// Keep tracking positions related info for this posting list.
PositionsState positionsState = new PositionsState();</p>
<p>int numDocs = 0;
int numDeltaFreqSlices = 0;
while ((doc = postingsEnum.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {</p>
<blockquote>
<div><p>numDocs++;</p>
<p>int delta = doc - prevDoc;
assert delta &lt;= MAX_DOC_ID;</p>
<p>int newBitsForDelta = bitsNeededForDelta;
if (delta &gt; maxDelta) {</p>
<blockquote>
<div><p>maxDelta = delta;
newBitsForDelta = log(maxDelta, 2);
assert newBitsForDelta &lt;= MAX_DOC_ID_BIT;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Optimization: store freq - 1 since a freq must be positive. Save bits and improve decoding</p></li>
<li><p>speed. At read side, the read frequency will plus 1.</p></li>
<li><p>&#64;see HighDFPackedIntsDocsEnum#loadNextPosting()</p></li>
</ul>
<p><a href="#id57"><span class="problematic" id="id58">*</span></a>/</p>
</dd>
</dl>
<p>int freq = postingsEnum.freq() - 1;
assert freq &gt;= 0;</p>
<p>int newBitsForFreq = bitsNeededForFreq;
if (freq &gt; maxFreq) {</p>
<blockquote>
<div><p>maxFreq = freq;
newBitsForFreq = log(maxFreq, 2);
assert newBitsForFreq &lt;= MAX_FREQ_BIT;</p>
</div></blockquote>
<p>}</p>
<p>// Write positions for this doc if not omit positions.
if (!omitPositions) {</p>
<blockquote>
<div><p>writePositionsForDoc(postingsEnum, positionsState);</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>if ((newBitsForDelta + newBitsForFreq) * (docFreqQueue.size() + 1) &gt; NUM_BITS_PER_SLICE) {</dt><dd><p>//The latest doc does not fit into this slice.
assert (bitsNeededForDelta + bitsNeededForFreq) * docFreqQueue.size()</p>
<blockquote>
<div><p>&lt;= NUM_BITS_PER_SLICE;</p>
</div></blockquote>
<dl class="simple">
<dt>prevWrittenDoc = writeDeltaFreqSlice(</dt><dd><p>bitsNeededForDelta,
bitsNeededForFreq,
positionsState,
prevWrittenDoc);</p>
</dd>
</dl>
<p>numDeltaFreqSlices++;</p>
<p>maxDelta = delta;
maxFreq = freq;
bitsNeededForDelta = log(maxDelta, 2);
bitsNeededForFreq = log(maxFreq, 2);</p>
</dd>
<dt>} else {</dt><dd><p>bitsNeededForDelta = newBitsForDelta;
bitsNeededForFreq = newBitsForFreq;</p>
</dd>
</dl>
<p>}</p>
<p>docFreqQueue.offer(doc, freq);</p>
<p>prevDoc = doc;</p>
</div></blockquote>
<p>}</p>
<p>// Some positions may be left in the buffer queue.
if (!positionQueue.isEmpty()) {</p>
<blockquote>
<div><p>writePositionSlice(positionsState.bitsNeededForPosition);</p>
</div></blockquote>
<p>}</p>
<p>// Some docs may be left in the buffer queue.
if (!docFreqQueue.isEmpty()) {</p>
<blockquote>
<div><dl class="simple">
<dt>writeDeltaFreqSlice(</dt><dd><p>bitsNeededForDelta,
bitsNeededForFreq,
positionsState,
prevWrittenDoc);</p>
</dd>
</dl>
<p>numDeltaFreqSlices++;</p>
</div></blockquote>
<p>}</p>
<p>// Write skip list header.
int skipListHeaderPointer = skipListPointer;
final int numSkipListEntries =</p>
<blockquote>
<div><p>(skipLists.length() - (skipListPointer + skipListHeaderSize)) / skiplistEntrySize;</p>
</div></blockquote>
<dl class="simple">
<dt>assert numSkipListEntries == numDeltaFreqSlices</dt><dd><p>: “number of delta freq slices should be the same as number of skip list entries”;</p>
</dd>
</dl>
<p>skipLists.set(skipListHeaderPointer++, numSkipListEntries);
skipLists.set(skipListHeaderPointer++, prevDoc);
skipLists.set(skipListHeaderPointer++, numDocs);
skipLists.set(skipListHeaderPointer++, deltaFreqListPointer);
if (!omitPositions) {</p>
<blockquote>
<div><p>skipLists.set(skipListHeaderPointer, positionListPointer);</p>
</div></blockquote>
<p>}</p>
<p>return skipListPointer;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Write positions for current doc into <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #positionLists}.</p></li>
<li></li>
<li><p>&#64;param postingsEnum postings enumerator containing the positions need to be written</p></li>
<li><p>&#64;param positionsState some states about <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #positionLists} and <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #positionQueue}</p></li>
<li><p>&#64;see #copyPostingList(PostingsEnum, int)</p></li>
</ul>
<p><a href="#id59"><span class="problematic" id="id60">*</span></a>/</p>
</dd>
<dt>private void writePositionsForDoc(</dt><dd><blockquote>
<div><p>PostingsEnum postingsEnum,
PositionsState positionsState) throws IOException {</p>
</div></blockquote>
<p>assert !omitPositions : “this method should not be called if positions are omitted”;</p>
<dl>
<dt>for (int i = 0; i &lt; postingsEnum.freq(); i++) {</dt><dd><p>int pos = postingsEnum.nextPosition();</p>
<p>int newBitsForPosition = positionsState.bitsNeededForPosition;
if (pos &gt; positionsState.maxPosition) {</p>
<blockquote>
<div><p>positionsState.maxPosition = pos;
newBitsForPosition = log(positionsState.maxPosition, 2);
assert newBitsForPosition &lt;= MAX_POSITION_BIT;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>if (newBitsForPosition * (positionQueue.size() + 1)</dt><dd><blockquote>
<div><p>&gt; POSITION_SLICE_NUM_BITS_WITHOUT_HEADER
|| positionQueue.isFull()) {</p>
</div></blockquote>
<dl class="simple">
<dt>assert positionsState.bitsNeededForPosition * positionQueue.size()</dt><dd><p>&lt;= POSITION_SLICE_NUM_BITS_WITHOUT_HEADER;</p>
</dd>
</dl>
<p>writePositionSlice(positionsState.bitsNeededForPosition);
positionsState.numPositionsSlices++;</p>
<p>positionsState.maxPosition = pos;
positionsState.bitsNeededForPosition = log(positionsState.maxPosition, 2);</p>
</dd>
<dt>} else {</dt><dd><p>positionsState.bitsNeededForPosition = newBitsForPosition;</p>
</dd>
</dl>
<p>}</p>
<p>// Update first position pointer if this position is the first position of a doc
if (i == 0) {</p>
<blockquote>
<div><p>positionsState.nextPositionsSliceIndex = positionsState.numPositionsSlices;
positionsState.nextPositionsSliceOffset = positionQueue.size();</p>
</div></blockquote>
<p>}</p>
<p>// Stores a dummy doc -1 since doc is unused in position list.
positionQueue.offer(-1, pos);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Write out all the buffered positions in <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #positionQueue} into a position slice.</p></li>
<li></li>
<li><p>&#64;param bitsNeededForPosition number of bits used for each position in this position slice</p></li>
</ul>
<p><a href="#id61"><span class="problematic" id="id62">*</span></a>/</p>
</dd>
<dt>private void writePositionSlice(final int bitsNeededForPosition) {</dt><dd><p>assert !omitPositions;
assert 0 &lt;= bitsNeededForPosition &amp;&amp; bitsNeededForPosition &lt;= MAX_POSITION_BIT;</p>
<p>final int lengthBefore = positionLists.length();
assert isSliceStart(lengthBefore);</p>
<p>// First int in this slice stores number of bits needed for position
// and number of positions in this slice..
positionLists.add(encodePositionEntryHeader(bitsNeededForPosition, positionQueue.size()));</p>
<p>positionListsWriter.jumpToInt(positionLists.length(), bitsNeededForPosition);
while (!positionQueue.isEmpty()) {</p>
<blockquote>
<div><p>int pos = PostingsBufferQueue.getSecondValue(positionQueue.poll());
assert log(pos, 2) &lt;= bitsNeededForPosition;</p>
<p>positionListsWriter.writePackedInt(pos);</p>
</div></blockquote>
<p>}</p>
<p>// Fill up this slice in case it is only partially filled.
while (positionLists.length() &lt; lengthBefore + SLICE_SIZE) {</p>
<blockquote>
<div><p>positionLists.add(0);</p>
</div></blockquote>
<p>}</p>
<p>assert positionLists.length() - lengthBefore == SLICE_SIZE;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Write out all the buffered docs and frequencies in <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #docFreqQueue} into a delta-freq</p></li>
<li><p>slice and update the skip list entry of this slice.</p></li>
<li></li>
<li><p>&#64;param bitsNeededForDelta number of bits used for each delta in this delta-freq slice</p></li>
<li><p>&#64;param bitsNeededForFreq number of bits used for each freq in this delta-freq slice</p></li>
<li><p>&#64;param positionsState some states about <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #positionLists} and <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #positionQueue}</p></li>
<li><p>&#64;param prevWrittenDoc last doc written in previous slice</p></li>
<li><p>&#64;return last doc written in this slice</p></li>
</ul>
<p><a href="#id63"><span class="problematic" id="id64">*</span></a>/</p>
</dd>
<dt>private int writeDeltaFreqSlice(</dt><dd><blockquote>
<div><p>final int bitsNeededForDelta,
final int bitsNeededForFreq,
final PositionsState positionsState,
final int prevWrittenDoc) {</p>
</div></blockquote>
<p>assert 0 &lt;= bitsNeededForDelta &amp;&amp; bitsNeededForDelta &lt;= MAX_DOC_ID_BIT;
assert 0 &lt;= bitsNeededForFreq &amp;&amp; bitsNeededForFreq &lt;= MAX_FREQ_BIT;</p>
<p>final int lengthBefore = deltaFreqLists.length();
assert isSliceStart(lengthBefore);</p>
<p>writeSkipListEntry(prevWrittenDoc, bitsNeededForDelta, bitsNeededForFreq, positionsState);</p>
<p>// Keep track of previous docID so that we compute the docID deltas.
int prevDoc = prevWrittenDoc;</p>
<p>// A &lt;delta|freq&gt; pair is stored as a packed value.
final int bitsPerPackedValue = bitsNeededForDelta + bitsNeededForFreq;
deltaFreqListsWriter.jumpToInt(deltaFreqLists.length(), bitsPerPackedValue);
while (!docFreqQueue.isEmpty()) {</p>
<blockquote>
<div><p>long value = docFreqQueue.poll();
int doc = PostingsBufferQueue.getDocID(value);
int delta = doc - prevDoc;
assert log(delta, 2) &lt;= bitsNeededForDelta;</p>
<p>int freq = PostingsBufferQueue.getSecondValue(value);
assert log(freq, 2) &lt;= bitsNeededForFreq;</p>
<p>// Cast the delta to long before left shift to avoid overflow.
final long deltaFreqPair = (((long) delta) &lt;&lt; bitsNeededForFreq) + freq;
deltaFreqListsWriter.writePackedLong(deltaFreqPair);
prevDoc = doc;</p>
</div></blockquote>
<p>}</p>
<p>// Fill up this slice in case it is only partially filled.
while (deltaFreqLists.length() &lt;  lengthBefore + SLICE_SIZE) {</p>
<blockquote>
<div><p>deltaFreqLists.add(0);</p>
</div></blockquote>
<p>}</p>
<p>positionsState.currentPositionsSliceIndex = positionsState.nextPositionsSliceIndex;
positionsState.currentPositionsSliceOffset = positionsState.nextPositionsSliceOffset;</p>
<p>assert deltaFreqLists.length() - lengthBefore == SLICE_SIZE;
return prevDoc;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Write the skip list entry for a delta-freq slice.</p></li>
<li></li>
<li><p>&#64;param prevWrittenDoc last doc written in previous slice</p></li>
<li><p>&#64;param bitsNeededForDelta number of bits used for each delta in this delta-freq slice</p></li>
<li><p>&#64;param bitsNeededForFreq number of bits used for each freq in this delta-freq slice</p></li>
<li><p>&#64;param positionsState some states about <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #positionLists} and <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #positionQueue}</p></li>
<li><p>&#64;see #writeDeltaFreqSlice(int, int, PositionsState, int)</p></li>
<li><p>&#64;see #SKIPLIST_ENTRY_SIZE</p></li>
</ul>
<p><a href="#id65"><span class="problematic" id="id66">*</span></a>/</p>
</dd>
<dt>private void writeSkipListEntry(</dt><dd><blockquote>
<div><p>int prevWrittenDoc,
int bitsNeededForDelta,
int bitsNeededForFreq,
PositionsState positionsState) {</p>
</div></blockquote>
<p>// 1st int: last written doc ID in previous slice
skipLists.add(prevWrittenDoc);</p>
<p>// 2nd int: encoded metadata
skipLists.add(</p>
<blockquote>
<div><dl class="simple">
<dt>encodeSkipListEntryMetadata(</dt><dd><p>positionsState.currentPositionsSliceOffset,
bitsNeededForDelta,
bitsNeededForFreq,
docFreqQueue.size()));</p>
</dd>
</dl>
</div></blockquote>
<p>// 3rd int: optional, position slice index
if (!omitPositions) {</p>
<blockquote>
<div><p>skipLists.add(positionsState.currentPositionsSliceIndex);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Create and return a docs enumerator or docs-positions enumerator based on input flag.</p></li>
<li></li>
<li><p>&#64;see org.apache.lucene.index.PostingsEnum</p></li>
</ul>
<p><a href="#id67"><span class="problematic" id="id68">*</span></a>/</p>
</dd>
</dl>
<p>&#64;Override
public EarlybirdPostingsEnum postings(</p>
<blockquote>
<div><blockquote>
<div><p>int postingListPointer, int numPostings, int flags) throws IOException {</p>
</div></blockquote>
<p>// Positions are omitted but position enumerator are requried.
if (omitPositions &amp;&amp; PostingsEnum.featureRequested(flags, PostingsEnum.POSITIONS)) {</p>
<blockquote>
<div><p>GETTING_POSITIONS_WITH_OMIT_POSITIONS.increment();</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if (!omitPositions &amp;&amp; PostingsEnum.featureRequested(flags, PostingsEnum.POSITIONS)) {</dt><dd><dl class="simple">
<dt>return new HighDFPackedIntsDocsAndPositionsEnum(</dt><dd><p>skipLists,
deltaFreqLists,
positionLists,
postingListPointer,
numPostings,
false);</p>
</dd>
</dl>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>return new HighDFPackedIntsDocsEnum(</dt><dd><p>skipLists,
deltaFreqLists,
postingListPointer,
numPostings,
omitPositions);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/<strong>**************************************************</strong></dt><dd><ul class="simple">
<li><p>Skip list entry encoded data encoding and decoding *</p></li>
</ul>
<p><strong>**************************************************</strong>/</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Encode a skip list entry metadata, which is stored in the 2nd int of the skip list entry.</p></li>
<li></li>
<li><p>&#64;see #SKIPLIST_ENTRY_SIZE</p></li>
</ul>
<p><a href="#id69"><span class="problematic" id="id70">*</span></a>/</p>
</dd>
<dt>private static int encodeSkipListEntryMetadata(</dt><dd><blockquote>
<div><p>int positionOffsetInSlice, int numBitsForDelta, int numBitsForFreq, int numDocsInSlice) {</p>
</div></blockquote>
<dl class="simple">
<dt>assert 0 &lt;= positionOffsetInSlice</dt><dd><p>&amp;&amp; positionOffsetInSlice &lt; POSITION_SLICE_NUM_BITS_WITHOUT_HEADER;</p>
</dd>
</dl>
<p>assert 0 &lt;= numBitsForDelta &amp;&amp; numBitsForDelta &lt;= MAX_DOC_ID_BIT;
assert 0 &lt;= numBitsForFreq &amp;&amp; numBitsForFreq &lt;= MAX_FREQ_BIT;
assert 0 &lt; numDocsInSlice &amp;&amp; numDocsInSlice &lt;= NUM_BITS_PER_SLICE;
return (positionOffsetInSlice &lt;&lt; SKIPLIST_ENTRY_POSITION_OFFSET_SHIFT)</p>
<blockquote>
<div><ul class="simple">
<li><p>(numBitsForDelta &lt;&lt; SKIPLIST_ENTRY_NUM_BITS_DELTA_SHIFT)</p></li>
<li><p>(numBitsForFreq &lt;&lt; SKIPLIST_ENTRY_NUM_BITS_FREQ_SHIFT)</p></li>
</ul>
<p>// stores numDocsInSlice - 1 to avoid over flow since numDocsInSlice ranges in [1, 2048]
// and 11 bits are used to store number docs in slice
+ (numDocsInSlice - 1);</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Decode POSITION_SLICE_OFFSET of the delta-freq slice having the given skip entry encoded data.</p></li>
<li></li>
<li><p>&#64;see #SKIPLIST_ENTRY_SIZE</p></li>
</ul>
<p><a href="#id71"><span class="problematic" id="id72">*</span></a>/</p>
</dd>
<dt>static int getPositionOffsetInSlice(int skipListEntryEncodedMetadata) {</dt><dd><dl class="simple">
<dt>return (skipListEntryEncodedMetadata &gt;&gt;&gt; SKIPLIST_ENTRY_POSITION_OFFSET_SHIFT)</dt><dd><p>&amp; SKIPLIST_ENTRY_POSITION_OFFSET_MASK;</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Decode number of bits used for delta in the slice having the given skip entry encoded data.</p></li>
<li></li>
<li><p>&#64;see #SKIPLIST_ENTRY_SIZE</p></li>
</ul>
<p><a href="#id73"><span class="problematic" id="id74">*</span></a>/</p>
</dd>
<dt>static int getNumBitsForDelta(int skipListEntryEncodedMetadata) {</dt><dd><dl class="simple">
<dt>return (skipListEntryEncodedMetadata &gt;&gt;&gt; SKIPLIST_ENTRY_NUM_BITS_DELTA_SHIFT)</dt><dd><p>&amp; SKIPLIST_ENTRY_NUM_BITS_DELTA_MASK;</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Decode number of bits used for freqs in the slice having the given skip entry encoded data.</p></li>
<li></li>
<li><p>&#64;see #SKIPLIST_ENTRY_SIZE</p></li>
</ul>
<p><a href="#id75"><span class="problematic" id="id76">*</span></a>/</p>
</dd>
<dt>static int getNumBitsForFreq(int skipListEntryEncodedMetadata) {</dt><dd><dl class="simple">
<dt>return (skipListEntryEncodedMetadata &gt;&gt;&gt; SKIPLIST_ENTRY_NUM_BITS_FREQ_SHIFT)</dt><dd><p>&amp; SKIPLIST_ENTRY_NUM_BITS_FREQ_MASK;</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Decode number of delta-freq pairs stored in the slice having the given skip entry encoded data.</p></li>
<li></li>
<li><p>&#64;see #SKIPLIST_ENTRY_SIZE</p></li>
</ul>
<p><a href="#id77"><span class="problematic" id="id78">*</span></a>/</p>
</dd>
<dt>static int getNumDocsInSlice(int skipListEntryEncodedMetadata) {</dt><dd><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Add 1 to the decode value since the stored value is subtracted by 1.</p></li>
<li><p>&#64;see #encodeSkipListEntryMetadata(int, int, int, int)</p></li>
</ul>
<p><a href="#id79"><span class="problematic" id="id80">*</span></a>/</p>
</dd>
</dl>
<p>return (skipListEntryEncodedMetadata &amp; SKIPLIST_ENTRY_NUM_DOCS_MASK) + 1;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/<strong>*************************************************</strong></dt><dd><ul class="simple">
<li><p>Position slice entry header encoding and decoding *</p></li>
</ul>
<p><strong>*************************************************</strong>/</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Encode a position slice entry header.</p></li>
<li></li>
<li><p>&#64;param numBitsForPosition number of bits used to encode positions in this slice.</p></li>
<li><p>&#64;param numPositionsInSlice number of positions in this slice.</p></li>
<li><p>&#64;return an int as the encoded header.</p></li>
<li><p>&#64;see #POSITION_SLICE_HEADER_SIZE</p></li>
</ul>
<p><a href="#id81"><span class="problematic" id="id82">*</span></a>/</p>
</dd>
<dt>private static int encodePositionEntryHeader(int numBitsForPosition, int numPositionsInSlice) {</dt><dd><p>assert 0 &lt;= numBitsForPosition &amp;&amp; numBitsForPosition &lt;= MAX_POSITION_BIT;
assert 0 &lt; numPositionsInSlice &amp;&amp; numPositionsInSlice &lt;= POSITION_SLICE_NUM_BITS_WITHOUT_HEADER;
return (numBitsForPosition &lt;&lt; POSITION_SLICE_HEADER_BITS_POSITION_SHIFT) + numPositionsInSlice;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Decode number of bits used for position in the slice having the given header.</p></li>
<li></li>
<li><p>&#64;param positionEntryHeader entry header will be decoded.</p></li>
<li><p>&#64;see #POSITION_SLICE_HEADER_SIZE</p></li>
</ul>
<p><a href="#id83"><span class="problematic" id="id84">*</span></a>/</p>
</dd>
<dt>static int getNumBitsForPosition(int positionEntryHeader) {</dt><dd><dl class="simple">
<dt>return (positionEntryHeader &gt;&gt;&gt; POSITION_SLICE_HEADER_BITS_POSITION_SHIFT)</dt><dd><p>&amp; POSITION_SLICE_HEADER_BITS_POSITION_MASK;</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Decode number of positions stored in the slice having the given header.</p></li>
<li></li>
<li><p>&#64;param positionEntryHeader entry header will be decoded.</p></li>
<li><p>&#64;see #POSITION_SLICE_HEADER_SIZE</p></li>
</ul>
<p><a href="#id85"><span class="problematic" id="id86">*</span></a>/</p>
</dd>
<dt>static int getNumPositionsInSlice(int positionEntryHeader) {</dt><dd><p>return positionEntryHeader &amp; POSITION_SLICE_HEADER_NUM_POSITIONS_MASK;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/<strong>**************</strong></dt><dd><ul class="simple">
<li><p>Helper methods *</p></li>
</ul>
<p><strong>**************</strong>/</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Check if given pointer is pointing to the slice start.</p></li>
<li></li>
<li><p>&#64;param pointer the index will be checked.</p></li>
</ul>
<p><a href="#id87"><span class="problematic" id="id88">*</span></a>/</p>
</dd>
<dt>static boolean isSliceStart(int pointer) {</dt><dd><p>return pointer % HighDFPackedIntsPostingLists.SLICE_SIZE == 0;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Ceil of log of x in the given base.</p></li>
<li></li>
<li><p>&#64;return x == 0 ? 0 : Math.ceil(Math.log(x) / Math.log(base))</p></li>
</ul>
<p><a href="#id89"><span class="problematic" id="id90">*</span></a>/</p>
</dd>
<dt>private static int log(int x, int base) {</dt><dd><p>assert base &gt;= 2;
if (x == 0) {</p>
<blockquote>
<div><p>return 0;</p>
</div></blockquote>
<p>}
int ret = 1;
long n = base; // needs to be a long to avoid overflow
while (x &gt;= n) {</p>
<blockquote>
<div><p>n <a href="#id91"><span class="problematic" id="id92">*</span></a>= base;
ret++;</p>
</div></blockquote>
<p>}
return ret;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/<strong>******************</strong></dt><dd><ul class="simple">
<li><p>For flush and load *</p></li>
</ul>
<p><strong>******************</strong>/</p>
</dd>
</dl>
<p>&#64;SuppressWarnings(“unchecked”)
&#64;Override
public FlushHandler getFlushHandler() {</p>
<blockquote>
<div><p>return new FlushHandler(this);</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>public static class FlushHandler extends Flushable.Handler&lt;HighDFPackedIntsPostingLists&gt; {</dt><dd><p>private static final String OMIT_POSITIONS_PROP_NAME = “omitPositions”;
private static final String SKIP_LISTS_PROP_NAME = “skipLists”;
private static final String DELTA_FREQ_LISTS_PROP_NAME = “deltaFreqLists”;
private static final String POSITION_LISTS_PROP_NAME = “positionLists”;</p>
<dl class="simple">
<dt>public FlushHandler() {</dt><dd><p>super();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public FlushHandler(HighDFPackedIntsPostingLists objectToFlush) {</dt><dd><p>super(objectToFlush);</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
protected void doFlush(FlushInfo flushInfo, DataSerializer out)</p>
<blockquote>
<div><blockquote>
<div><p>throws IOException {</p>
</div></blockquote>
<p>HighDFPackedIntsPostingLists objectToFlush = getObjectToFlush();
flushInfo.addBooleanProperty(OMIT_POSITIONS_PROP_NAME, objectToFlush.omitPositions);
objectToFlush.skipLists.getFlushHandler()</p>
<blockquote>
<div><p>.flush(flushInfo.newSubProperties(SKIP_LISTS_PROP_NAME), out);</p>
</div></blockquote>
<dl class="simple">
<dt>objectToFlush.deltaFreqLists.getFlushHandler()</dt><dd><p>.flush(flushInfo.newSubProperties(DELTA_FREQ_LISTS_PROP_NAME), out);</p>
</dd>
<dt>objectToFlush.positionLists.getFlushHandler()</dt><dd><p>.flush(flushInfo.newSubProperties(POSITION_LISTS_PROP_NAME), out);</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>&#64;Override
protected HighDFPackedIntsPostingLists doLoad(</p>
<blockquote>
<div><blockquote>
<div><p>FlushInfo flushInfo, DataDeserializer in) throws IOException {</p>
</div></blockquote>
<dl class="simple">
<dt>IntBlockPool skipLists = (new IntBlockPool.FlushHandler())</dt><dd><p>.load(flushInfo.getSubProperties(SKIP_LISTS_PROP_NAME), in);</p>
</dd>
<dt>IntBlockPool deltaFreqLists = (new IntBlockPool.FlushHandler())</dt><dd><p>.load(flushInfo.getSubProperties(DELTA_FREQ_LISTS_PROP_NAME), in);</p>
</dd>
<dt>IntBlockPool positionLists = (new IntBlockPool.FlushHandler())</dt><dd><p>.load(flushInfo.getSubProperties(POSITION_LISTS_PROP_NAME), in);</p>
</dd>
<dt>return new HighDFPackedIntsPostingLists(</dt><dd><p>skipLists,
deltaFreqLists,
positionLists,
flushInfo.getBooleanProperty(OMIT_POSITIONS_PROP_NAME),
null,
null);</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/src/java/com/twitter/search/core/earlybird/index/inverted/HighDFPackedIntsPostingLists.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>