<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../" id="documentation_options" src="../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.simclusters_v2.scalding.offline_job.adhoc</p>
<p>import com.twitter.bijection.{Bufferable, Injection}
import com.twitter.scalding._
import com.twitter.scalding.commons.source.VersionedKeyValSource
import com.twitter.simclusters_v2.common.{ClusterId, CosineSimilarityUtil, TweetId}
import com.twitter.simclusters_v2.scalding.common.matrix.SparseRowMatrix
import com.twitter.simclusters_v2.scalding.offline_job.SimClustersOfflineJobUtil
import com.twitter.wtf.scalding.jobs.common.AdhocExecutionApp
import java.util.TimeZone</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li></li>
<li><p>A job to sample some tweets for evaluation.</p></li>
<li></li>
<li><p>we bucket tweets by the log(# of fav + 1) and randomly pick 1000 for each bucket for evaluation.</p></li>
<li></li>
<li><p>to run the job:</p></li>
<li><dl class="simple">
<dt>scalding remote run </dt><dd><p>–target src/scala/com/twitter/simclusters_v2/scalding/offline_job/adhoc:tweet_embedding_evaluation_samples-adhoc –user recos-platform –reducers 1000 –main-class com.twitter.simclusters_v2.scalding.offline_job.adhoc.TweetSimilarityEvaluationSamplingAdhocApp – –date 2021-01-27 2021-01-28 –output /user/recos-platform/adhoc/tweet_embedding_01_27_28_sample_tweets</p>
</dd>
</dl>
</li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
</dl>
<p>object TweetSimilarityEvaluationSamplingAdhocApp extends AdhocExecutionApp {</p>
<blockquote>
<div><dl class="simple">
<dt>override def runOnDateRange(</dt><dd><p>args: Args</p>
</dd>
<dt>)(</dt><dd><p>implicit dateRange: DateRange,
timeZone: TimeZone,
uniqueID: UniqueID</p>
</dd>
</dl>
<p>): Execution[Unit] = {</p>
<blockquote>
<div><p>val random = new java.util.Random(args.long(“seed”, 20200322L))</p>
<p>// # of tweets in each bucket
val topK = args.int(“bucket_size”, 1000)</p>
<p>val output = args(“output”)</p>
<dl>
<dt>SimClustersOfflineJobUtil</dt><dd><p>.readTimelineFavoriteData(dateRange)
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (_, tweetId, _) =&gt;</dt><dd><p>tweetId -&gt; 1L</p>
</dd>
</dl>
</div></blockquote>
<p>}
.sumByKey
.filter(_._2 &gt;= 10L) // only consider tweets with more than 10 favs
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (tweetId, tweetFavs) =&gt;</dt><dd><p>val bucket = math.log10(tweetFavs + 1.0).toInt
bucket -&gt; (tweetId, random.nextDouble())</p>
</dd>
</dl>
</div></blockquote>
<p>}
.group
.sortedReverseTake(topK)(Ordering.by(_._2))
.flatMap {</p>
<blockquote>
<div><dl>
<dt>case (bucket, tweets) =&gt;</dt><dd><p>val bucketSize = tweets.length
tweets.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (tweetId, _) =&gt;</dt><dd><p>(tweetId, bucket, bucketSize)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>}
.writeExecution(</p>
<blockquote>
<div><p>TypedTsv[(Long, Int, Int)](output)</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li></li>
<li><p>A job for evaluating the performance of an approximate nearest neighbor search method with a brute</p></li>
<li><p>force method.</p></li>
<li></li>
<li><p>Evaluation method:</p></li>
<li></li>
<li><p>After getting the embeddings for these tweets, we bucketize tweets based on the number of favs they have</p></li>
<li><p>(i.e., math.log10(numFavors).toInt), and then randomly select 1000 tweets from each bucket.</p></li>
<li><p>We do not include tweets with fewer than 10 favs. We compute the nearest neighbors (in terms of cosine similarity)</p></li>
<li><p>for these tweets using the brute force method and use up to top 100 neighbors with the cosine</p></li>
<li><p>similarity score &gt;0.8 for each tweet as ground-truth set G.</p></li>
<li></li>
<li><p>We then compute the nearest neighbors for these tweets based on the approximate nearest neighbor search: for each tweet, we find the top clusters, and then find top tweets in each cluster as potential candidates. We rank these potential candidates by the cosine similarity scores and take top 100 as prediction set P. We evaluate the precision and recall using</p></li>
<li></li>
<li><p>Precision = <a href="#id5"><span class="problematic" id="id6">|P \intersect G|</span></a> / <a href="#id7"><span class="problematic" id="id8">|P|</span></a></p></li>
<li><p>Recall = <a href="#id9"><span class="problematic" id="id10">|P \intersect G|</span></a> / <a href="#id11"><span class="problematic" id="id12">|G|</span></a></p></li>
<li></li>
<li><p>Note that <a href="#id13"><span class="problematic" id="id14">|P|</span></a> and <a href="#id15"><span class="problematic" id="id16">|G|</span></a> can be different, when there are not many neighbors returned.</p></li>
<li><p>scalding remote run –target src/scala/com/twitter/simclusters_v2/scalding/offline_job/adhoc:tweet_embedding_evaluation-adhoc –user recos-platform –reducers 1000 –main-class com.twitter.simclusters_v2.scalding.offline_job.adhoc.TweetSimilarityEvaluationAdhocApp – –date 2021-01-27 –tweet_top_k /user/recos-platform/adhoc/tweet_embedding_01_27_28_unnormalized_t9/tweet_top_k_clusters –cluster_top_k /user/recos-platform/adhoc/tweet_embedding_01_27_28_unnormalized_t9/cluster_top_k_tweets –tweets /user/recos-platform/adhoc/tweet_embedding_01_27_28_sample_tweets –output  /user/recos-platform/adhoc/tweet_embedding_evaluation_01_27_28_t05_k50_1</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
</dl>
<p>object TweetSimilarityEvaluationAdhocApp extends AdhocExecutionApp {</p>
<blockquote>
<div><dl class="simple">
<dt>implicit val inj1: Injection[List[(Int, Double)], Array[Byte]] =</dt><dd><p>Bufferable.injectionOf[List[(Int, Double)]]</p>
</dd>
<dt>implicit val inj2: Injection[List[(Long, Double)], Array[Byte]] =</dt><dd><p>Bufferable.injectionOf[List[(Long, Double)]]</p>
</dd>
</dl>
<p>// Take top 20 candidates, the score * 100
private def formatList(candidates: Seq[(TweetId, Double)]): Seq[(TweetId, Int)] = {</p>
<blockquote>
<div><dl class="simple">
<dt>candidates.take(10).map {</dt><dd><dl class="simple">
<dt>case (clusterId, score) =&gt;</dt><dd><p>(clusterId, (score * 100).toInt)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>override def runOnDateRange(</dt><dd><p>args: Args</p>
</dd>
<dt>)(</dt><dd><p>implicit dateRange: DateRange,
timeZone: TimeZone,
uniqueID: UniqueID</p>
</dd>
</dl>
<p>): Execution[Unit] = {</p>
<blockquote>
<div><p>// path to read the tweet -&gt; top cluster data set. should be the same from the SimClustersTweetEmbeddingAdhocApp job
val tweetTopKClustersPath = args(“tweet_top_k”)</p>
<p>// path to read the cluster -&gt; top tweets data set. should be the same from the SimClustersTweetEmbeddingAdhocApp job
val clusterTopKTweetsPath = args(“cluster_top_k”)</p>
<p>// path to read the sampled tweets, should be the same from TweetSimilarityEvaluationSamplingAdhocApp
val tweetsPath = args(“tweets”)</p>
<p>// see the comment of this class. this is to determine which tweet should be ground truth
val threshold = args.double(“threshold”, 0.8)</p>
<p>// see the comment of this class. this is to determine which tweet should be ground truth
val topK = args.int(“topK”, 100)</p>
<p>// output path for evaluation results
val output = args(“output”)</p>
<p>// read tweet -&gt; top clusters data set
val tweetTopKClusters: SparseRowMatrix[TweetId, ClusterId, Double] =</p>
<blockquote>
<div><dl>
<dt>SparseRowMatrix(</dt><dd><dl>
<dt>TypedPipe</dt><dd><dl class="simple">
<dt>.from(</dt><dd><p>VersionedKeyValSource[TweetId, List[(ClusterId, Double)]](tweetTopKClustersPath)</p>
</dd>
</dl>
<p>)
.mapValues(_.filter(_._2 &gt; 0.001).toMap),</p>
</dd>
</dl>
<p>isSkinnyMatrix = true</p>
</dd>
</dl>
<p>).rowL2Normalize</p>
</div></blockquote>
<p>// read cluster -&gt; top tweets data set
val clusterTopTweets: SparseRowMatrix[ClusterId, TweetId, Double] =</p>
<blockquote>
<div><dl>
<dt>SparseRowMatrix(</dt><dd><dl>
<dt>TypedPipe</dt><dd><dl class="simple">
<dt>.from(</dt><dd><p>VersionedKeyValSource[ClusterId, List[(TweetId, Double)]](clusterTopKTweetsPath)</p>
</dd>
</dl>
<p>)
.mapValues(_.filter(_._2 &gt; 0.02).toMap),</p>
</dd>
</dl>
<p>isSkinnyMatrix = false</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>// read the sampled tweets from TweetSimilarityEvaluationSamplingAdhocApp
val tweetSubset = TypedPipe.from(TypedTsv[(Long, Int, Int)](tweetsPath))</p>
<p>// the tweet -&gt; top clusters for the sampled tweets
val tweetEmbeddingSubset =</p>
<blockquote>
<div><p>tweetTopKClusters.filterRows(tweetSubset.map(_._1))</p>
</div></blockquote>
<p>// compute ground-truth top similar tweets for each sampled tweets.
// for each sampled tweets, we compute their similarity with every tweets in the tweet -&gt; top clusters data set.
// we filter out those with similarity score smaller than the threshold and keep top k as the ground truth similar tweets
val groundTruthData = tweetTopKClusters.toSparseMatrix</p>
<blockquote>
<div><dl class="simple">
<dt>.multiplySkinnySparseRowMatrix(</dt><dd><p>tweetEmbeddingSubset.toSparseMatrix.transpose.toSparseRowMatrix(true),
numReducersOpt = Some(5000)</p>
</dd>
</dl>
<p>)
.toSparseMatrix
.transpose
.filter((_, _, v) =&gt; v &gt; threshold)
.sortWithTakePerRow(topK)(Ordering.by(-_._2))</p>
</div></blockquote>
<p>// compute approximate similar tweets for each sampled tweets.
// this is achieved by multiplying “sampled_tweets -&gt; top clusters” matrix with “cluster -&gt; top tweets” matrix.
// note that in the implementation, we first compute the transponse of this matrix in order to ultlize the optimization done on skinny matrices
val predictionData = clusterTopTweets.toSparseMatrix.transpose</p>
<blockquote>
<div><dl class="simple">
<dt>.multiplySkinnySparseRowMatrix(</dt><dd><p>tweetEmbeddingSubset.toSparseMatrix.transpose.toSparseRowMatrix(true),
numReducersOpt = Some(5000)</p>
</dd>
</dl>
<p>)
.toSparseMatrix
.transpose
.toTypedPipe
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (queryTweet, candidateTweet, _) =&gt;</dt><dd><p>(queryTweet, candidateTweet)</p>
</dd>
</dl>
</div></blockquote>
<p>}
.join(tweetEmbeddingSubset.toTypedPipe)
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (queryId, (candidateId, queryEmbedding)) =&gt;</dt><dd><p>candidateId -&gt; (queryId, queryEmbedding)</p>
</dd>
</dl>
</div></blockquote>
<p>}
.join(tweetTopKClusters.toTypedPipe)
.map {</p>
<blockquote>
<div><dl>
<dt>case (candidateId, ((queryId, queryEmbedding), candidateEmbedding)) =&gt;</dt><dd><dl>
<dt>queryId -&gt; (candidateId, CosineSimilarityUtil</dt><dd><dl class="simple">
<dt>.dotProduct(</dt><dd><p>queryEmbedding,
candidateEmbedding</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>}
.filter(_._2._2 &gt; threshold)
.group
.sortedReverseTake(topK)(Ordering.by(_._2))</p>
</div></blockquote>
<p>// Exist in Ground Truth but not exist in Predication
val potentialData =</p>
<blockquote>
<div><dl>
<dt>groundTruthData</dt><dd><p>.leftJoin(predictionData)
.map {</p>
<blockquote>
<div><dl>
<dt>case (tweetId, (groundTruthCandidates, predictedCandidates)) =&gt;</dt><dd><p>val predictedCandidateSet = predictedCandidates.toSeq.flatten.map(_._1).toSet
val potentialTweets = groundTruthCandidates.filterNot {</p>
<blockquote>
<div><dl class="simple">
<dt>case (candidateId, _) =&gt;</dt><dd><p>predictedCandidateSet.contains(candidateId)</p>
</dd>
</dl>
</div></blockquote>
<p>}
(tweetId, potentialTweets)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>val debuggingData =</dt><dd><dl>
<dt>groundTruthData</dt><dd><p>.leftJoin(predictionData)
.map {</p>
<blockquote>
<div><dl>
<dt>case (tweetId, (groundTruthTweets, maybepredictedTweets)) =&gt;</dt><dd><p>val predictedTweets = maybepredictedTweets.toSeq.flatten
val predictedTweetSet = predictedTweets.map(_._1).toSet
val potentialTweets = groundTruthTweets.filterNot {</p>
<blockquote>
<div><dl class="simple">
<dt>case (candidateId, _) =&gt;</dt><dd><p>predictedTweetSet.contains(candidateId)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl>
<dt>(</dt><dd><p>tweetId,
Seq(</p>
<blockquote>
<div><p>formatList(potentialTweets),
formatList(groundTruthTweets),
formatList(predictedTweets)))</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>// for each tweet, compare the approximate topk and ground-truth topk.
// compute precision and recall, then averaging them per bucket.
val eval = tweetSubset</p>
<blockquote>
<div><dl class="simple">
<dt>.map {</dt><dd><dl class="simple">
<dt>case (tweetId, bucket, bucketSize) =&gt;</dt><dd><p>tweetId -&gt; (bucket, bucketSize)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.leftJoin(groundTruthData)
.leftJoin(predictionData)
.map {</p>
<blockquote>
<div><dl>
<dt>case (_, (((bucket, bucketSize), groundTruthOpt), predictionOpt)) =&gt;</dt><dd><p>val groundTruth = groundTruthOpt.getOrElse(Nil).map(_._1)
val prediction = predictionOpt.getOrElse(Nil).map(_._1)</p>
<p>assert(groundTruth.distinct.size == groundTruth.size)
assert(prediction.distinct.size == prediction.size)</p>
<p>val intersection = groundTruth.toSet.intersect(prediction.toSet)</p>
<dl>
<dt>val precision =</dt><dd><dl class="simple">
<dt>if (prediction.nonEmpty)</dt><dd><p>intersection.size.toDouble / prediction.size.toDouble</p>
</dd>
</dl>
<p>else 0.0</p>
</dd>
<dt>val recall =</dt><dd><dl class="simple">
<dt>if (groundTruth.nonEmpty)</dt><dd><p>intersection.size.toDouble / groundTruth.size.toDouble</p>
</dd>
</dl>
<p>else 0.0</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>bucket,
bucketSize) -&gt; (groundTruth.size, prediction.size, intersection.size, precision, recall, 1.0)</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>}
.sumByKey
.map {</p>
<blockquote>
<div><dl>
<dt>case (</dt><dd><blockquote>
<div><p>(bucket, bucketSize),
(groundTruthSum, predictionSum, interSectionSum, precisionSum, recallSum, count)) =&gt;</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>bucket,
bucketSize,
groundTruthSum / count,
predictionSum / count,
interSectionSum / count,
precisionSum / count,
recallSum / count,
count)</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>// output the eval results and some sample results for eyeballing
Execution</p>
<blockquote>
<div><dl>
<dt>.zip(</dt><dd><dl>
<dt>eval</dt><dd><p>.writeExecution(TypedTsv(output)),</p>
</dd>
<dt>groundTruthData</dt><dd><dl>
<dt>.map {</dt><dd><dl>
<dt>case (tweetId, neighbors) =&gt;</dt><dd><dl>
<dt>tweetId -&gt; neighbors</dt><dd><dl class="simple">
<dt>.map {</dt><dd><p>case (id, score) =&gt; s”$id:$score”</p>
</dd>
</dl>
<p>}
.mkString(“,”)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}
.writeExecution(</p>
<blockquote>
<div><p>TypedTsv(args(“output”) + “_ground_truth”)</p>
</div></blockquote>
<p>),</p>
</dd>
<dt>predictionData</dt><dd><dl>
<dt>.map {</dt><dd><dl>
<dt>case (tweetId, neighbors) =&gt;</dt><dd><dl>
<dt>tweetId -&gt; neighbors</dt><dd><dl class="simple">
<dt>.map {</dt><dd><p>case (id, score) =&gt; s”$id:$score”</p>
</dd>
</dl>
<p>}
.mkString(“,”)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}
.writeExecution(</p>
<blockquote>
<div><p>TypedTsv(args(“output”) + “_prediction”)</p>
</div></blockquote>
<p>),</p>
</dd>
<dt>potentialData</dt><dd><dl>
<dt>.map {</dt><dd><dl>
<dt>case (tweetId, neighbors) =&gt;</dt><dd><dl>
<dt>tweetId -&gt; neighbors</dt><dd><dl class="simple">
<dt>.map {</dt><dd><p>case (id, score) =&gt; s”$id:$score”</p>
</dd>
</dl>
<p>}
.mkString(“,”)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>}.writeExecution(</dt><dd><p>TypedTsv(args(“output”) + “_potential”)</p>
</dd>
</dl>
<p>),</p>
</dd>
<dt>debuggingData</dt><dd><dl>
<dt>.map {</dt><dd><dl>
<dt>case (tweetId, candidateList) =&gt;</dt><dd><dl>
<dt>val value = candidateList</dt><dd><dl>
<dt>.map { candidates =&gt;</dt><dd><dl>
<dt>candidates</dt><dd><dl class="simple">
<dt>.map {</dt><dd><dl class="simple">
<dt>case (id, score) =&gt;</dt><dd><p>s”${id}D$score”</p>
</dd>
</dl>
</dd>
</dl>
<p>}.mkString(“C”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}.mkString(“B”)</p>
</dd>
</dl>
<p>s”${tweetId}A$value”</p>
</dd>
</dl>
</dd>
<dt>}.writeExecution(</dt><dd><p>TypedTsv(args(“output”) + “_debugging”)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>)
.unit</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../_sources/src/scala/com/twitter/simclusters_v2/scalding/offline_job/adhoc/TweetSimilarityEvaluationAdhocApp.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>