<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../" id="documentation_options" src="../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.simclusters_v2.candidate_source</p>
<p>import com.twitter.conversions.DurationOps._
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.frigate.common.base.CandidateSource
import com.twitter.frigate.common.base.Stats
import com.twitter.simclusters_v2.candidate_source.HeavyRanker.UniformScoreStoreRanker
import com.twitter.simclusters_v2.candidate_source.SimClustersANNCandidateSource.SimClustersANNConfig
import com.twitter.simclusters_v2.candidate_source.SimClustersANNCandidateSource.SimClustersTweetCandidate
import com.twitter.simclusters_v2.common.ModelVersions._
import com.twitter.simclusters_v2.common.ClusterId
import com.twitter.simclusters_v2.common.SimClustersEmbedding
import com.twitter.simclusters_v2.common.TweetId
import com.twitter.simclusters_v2.summingbird.stores.ClusterKey
import com.twitter.simclusters_v2.thriftscala.EmbeddingType
import com.twitter.simclusters_v2.thriftscala.InternalId
import com.twitter.simclusters_v2.thriftscala.ScoreInternalId
import com.twitter.simclusters_v2.thriftscala.ScoringAlgorithm
import com.twitter.simclusters_v2.thriftscala.SimClustersEmbeddingId
import com.twitter.simclusters_v2.thriftscala.SimClustersEmbeddingPairScoreId
import com.twitter.simclusters_v2.thriftscala.{Score =&gt; ThriftScore}
import com.twitter.simclusters_v2.thriftscala.{ScoreId =&gt; ThriftScoreId}
import com.twitter.snowflake.id.SnowflakeId
import com.twitter.storehaus.ReadableStore
import com.twitter.util.Duration
import com.twitter.util.Future
import com.twitter.util.Time
import scala.collection.mutable</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>This store looks for tweets whose similarity is close to a Source SimClustersEmbeddingId.</p></li>
<li></li>
<li><p>Approximate cosine similarity is the core algorithm to drive this store.</p></li>
<li></li>
<li><p>Step 1 - 4 are in “fetchCandidates” method.</p></li>
<li><ol class="arabic simple">
<li><p>Retrieve the SimClusters Embedding by the SimClustersEmbeddingId</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>Fetch top N clusters’ top tweets from the clusterTweetCandidatesStore (TopTweetsPerCluster index).</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="3">
<li><p>Calculate all the tweet candidates’ dot-product or approximate cosine similarity to source tweets.</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="4">
<li><p>Take top M tweet candidates by the step 3’s score</p></li>
</ol>
</li>
<li><p>Step 5-6 are in “reranking” method.</p></li>
<li><ol class="arabic simple" start="5">
<li><p>Calculate the similarity score between source and candidates.</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="6">
<li><p>Return top N candidates by the step 5’s score.</p></li>
</ol>
</li>
<li></li>
<li><p>Warning: Only turn off the step 5 for User InterestedIn candidate generation. It’s the only use</p></li>
<li><p>case in Recos that we use dot-product to rank the tweet candidates.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>case class SimClustersANNCandidateSource(</dt><dd><p>clusterTweetCandidatesStore: ReadableStore[ClusterKey, Seq[(TweetId, Double)]],
simClustersEmbeddingStore: ReadableStore[SimClustersEmbeddingId, SimClustersEmbedding],
heavyRanker: HeavyRanker.HeavyRanker,
configs: Map[EmbeddingType, SimClustersANNConfig],
statsReceiver: StatsReceiver)</p>
<blockquote>
<div><p>extends CandidateSource[SimClustersANNCandidateSource.Query, SimClustersTweetCandidate] {</p>
</div></blockquote>
<p>import SimClustersANNCandidateSource._</p>
<p>override val name: String = this.getClass.getName
private val stats = statsReceiver.scope(this.getClass.getName)</p>
<p>private val fetchSourceEmbeddingStat = stats.scope(“fetchSourceEmbedding”)
protected val fetchCandidateEmbeddingsStat = stats.scope(“fetchCandidateEmbeddings”)
private val fetchCandidatesStat = stats.scope(“fetchCandidates”)
private val rerankingStat = stats.scope(“reranking”)</p>
<dl>
<dt>override def get(</dt><dd><p>query: SimClustersANNCandidateSource.Query</p>
</dd>
<dt>): Future[Option[Seq[SimClustersTweetCandidate]]] = {</dt><dd><p>val sourceEmbeddingId = query.sourceEmbeddingId
loadConfig(query) match {</p>
<blockquote>
<div><dl>
<dt>case Some(config) =&gt;</dt><dd><dl>
<dt>for {</dt><dd><dl class="simple">
<dt>maybeSimClustersEmbedding &lt;- Stats.track(fetchSourceEmbeddingStat) {</dt><dd><p>simClustersEmbeddingStore.get(query.sourceEmbeddingId)</p>
</dd>
</dl>
<p>}
maybeFilteredCandidates &lt;- maybeSimClustersEmbedding match {</p>
<blockquote>
<div><dl>
<dt>case Some(sourceEmbedding) =&gt;</dt><dd><dl>
<dt>for {</dt><dd><dl class="simple">
<dt>rawCandidates &lt;- Stats.trackSeq(fetchCandidatesStat) {</dt><dd><p>fetchCandidates(sourceEmbeddingId, config, sourceEmbedding)</p>
</dd>
</dl>
<p>}
rankedCandidates &lt;- Stats.trackSeq(rerankingStat) {</p>
<blockquote>
<div><p>reranking(sourceEmbeddingId, config, rawCandidates)</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>} yield {</dt><dd><dl class="simple">
<dt>fetchCandidatesStat</dt><dd><dl class="simple">
<dt>.stat(</dt><dd><p>sourceEmbeddingId.embeddingType.name,
sourceEmbeddingId.modelVersion.name).add(rankedCandidates.size)</p>
</dd>
</dl>
</dd>
</dl>
<p>Some(rankedCandidates)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>case None =&gt;</dt><dd><dl class="simple">
<dt>fetchCandidatesStat</dt><dd><dl class="simple">
<dt>.stat(</dt><dd><p>sourceEmbeddingId.embeddingType.name,
sourceEmbeddingId.modelVersion.name).add(0)</p>
</dd>
</dl>
</dd>
</dl>
<p>Future.None</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
<dt>} yield {</dt><dd><p>maybeFilteredCandidates</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>// Skip over queries whose config is not defined
Future.None</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def fetchCandidates(</dt><dd><p>sourceEmbeddingId: SimClustersEmbeddingId,
config: SimClustersANNConfig,
sourceEmbedding: SimClustersEmbedding</p>
</dd>
<dt>): Future[Seq[SimClustersTweetCandidate]] = {</dt><dd><p>val now = Time.now
val earliestTweetId = SnowflakeId.firstIdFor(now - config.maxTweetCandidateAge)
val latestTweetId = SnowflakeId.firstIdFor(now - config.minTweetCandidateAge)
val clusterIds =</p>
<blockquote>
<div><dl>
<dt>sourceEmbedding</dt><dd><p>.truncate(config.maxScanClusters).clusterIds
.map { clusterId: ClusterId =&gt;</p>
<blockquote>
<div><p>ClusterKey(clusterId, sourceEmbeddingId.modelVersion, config.candidateEmbeddingType)</p>
</div></blockquote>
<p>}.toSet</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>Future</dt><dd><dl>
<dt>.collect {</dt><dd><p>clusterTweetCandidatesStore.multiGet(clusterIds)</p>
</dd>
<dt>}.map { clusterTweetsMap =&gt;</dt><dd><p>// Use Mutable map to optimize performance. The method is thread-safe.
// Set initial map size to around p75 of map size distribution to avoid too many copying
// from extending the size of the mutable hashmap
val candidateScoresMap =</p>
<blockquote>
<div><p>new SimClustersANNCandidateSource.HashMap[TweetId, Double](InitialCandidateMapSize)</p>
</div></blockquote>
<dl>
<dt>val candidateNormalizationMap =</dt><dd><p>new SimClustersANNCandidateSource.HashMap[TweetId, Double](InitialCandidateMapSize)</p>
</dd>
<dt>clusterTweetsMap.foreach {</dt><dd><dl>
<dt>case (ClusterKey(clusterId, _, _, _), Some(tweetScores))</dt><dd><blockquote>
<div><p>if sourceEmbedding.contains(clusterId) =&gt;</p>
</div></blockquote>
<p>val sourceClusterScore = sourceEmbedding.getOrElse(clusterId)</p>
<dl>
<dt>for (i &lt;- 0 until Math.min(tweetScores.size, config.maxTopTweetsPerCluster)) {</dt><dd><p>val (tweetId, score) = tweetScores(i)</p>
<dl>
<dt>if (!parseTweetId(sourceEmbeddingId).contains(tweetId) &amp;&amp;</dt><dd><p>tweetId &gt;= earliestTweetId &amp;&amp; tweetId &lt;= latestTweetId) {
candidateScoresMap.put(</p>
<blockquote>
<div><p>tweetId,
candidateScoresMap.getOrElse(tweetId, 0.0) + score * sourceClusterScore)</p>
</div></blockquote>
<dl class="simple">
<dt>if (config.enablePartialNormalization) {</dt><dd><dl class="simple">
<dt>candidateNormalizationMap</dt><dd><p>.put(tweetId, candidateNormalizationMap.getOrElse(tweetId, 0.0) + score * score)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>case _ =&gt; ()</p>
</dd>
</dl>
<p>}</p>
<p>stats.stat(“candidateScoresMap”).add(candidateScoresMap.size)
stats.stat(“candidateNormalizationMap”).add(candidateNormalizationMap.size)</p>
<p>// Re-Rank the candidate by configuration
val processedCandidateScores = candidateScoresMap.map {</p>
<blockquote>
<div><dl>
<dt>case (candidateId, score) =&gt;</dt><dd><p>// Enable Partial Normalization
val processedScore =</p>
<blockquote>
<div><dl>
<dt>if (config.enablePartialNormalization) {</dt><dd><p>// We applied the “log” version of partial normalization when we rank candidates
// by log cosine similarity
if (config.rankingAlgorithm == ScoringAlgorithm.PairEmbeddingLogCosineSimilarity) {</p>
<blockquote>
<div><dl class="simple">
<dt>score / sourceEmbedding.l2norm / math.log(</dt><dd><p>1 + candidateNormalizationMap(candidateId))</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>score / sourceEmbedding.l2norm / math.sqrt(candidateNormalizationMap(candidateId))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>} else score</p>
</div></blockquote>
<p>SimClustersTweetCandidate(candidateId, processedScore, sourceEmbeddingId)</p>
</dd>
</dl>
</div></blockquote>
<p>}.toSeq</p>
<dl class="simple">
<dt>processedCandidateScores</dt><dd><p>.sortBy(-_.score)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def reranking(</dt><dd><p>sourceEmbeddingId: SimClustersEmbeddingId,
config: SimClustersANNConfig,
candidates: Seq[SimClustersTweetCandidate]</p>
</dd>
<dt>): Future[Seq[SimClustersTweetCandidate]] = {</dt><dd><dl>
<dt>val rankedCandidates = if (config.enableHeavyRanking) {</dt><dd><dl>
<dt>heavyRanker</dt><dd><dl class="simple">
<dt>.rank(</dt><dd><p>scoringAlgorithm = config.rankingAlgorithm,
sourceEmbeddingId = sourceEmbeddingId,
candidateEmbeddingType = config.candidateEmbeddingType,
minScore = config.minScore,
candidates = candidates.take(config.maxReRankingCandidates)</p>
</dd>
</dl>
<p>).map(_.sortBy(-_.score))</p>
</dd>
</dl>
</dd>
<dt>} else {</dt><dd><p>Future.value(candidates)</p>
</dd>
</dl>
<p>}
rankedCandidates.map(_.take(config.maxNumResults))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private[candidate_source] def loadConfig(query: Query): Option[SimClustersANNConfig] = {</dt><dd><dl>
<dt>configs.get(query.sourceEmbeddingId.embeddingType).map { baseConfig =&gt;</dt><dd><p>// apply overrides if any
query.overrideConfig match {</p>
<blockquote>
<div><dl>
<dt>case Some(overrides) =&gt;</dt><dd><dl>
<dt>baseConfig.copy(</dt><dd><p>maxNumResults = overrides.maxNumResults.getOrElse(baseConfig.maxNumResults),
maxTweetCandidateAge =</p>
<blockquote>
<div><p>overrides.maxTweetCandidateAge.getOrElse(baseConfig.maxTweetCandidateAge),</p>
</div></blockquote>
<p>minScore = overrides.minScore.getOrElse(baseConfig.minScore),
candidateEmbeddingType =</p>
<blockquote>
<div><p>overrides.candidateEmbeddingType.getOrElse(baseConfig.candidateEmbeddingType),</p>
</div></blockquote>
<dl class="simple">
<dt>enablePartialNormalization =</dt><dd><p>overrides.enablePartialNormalization.getOrElse(baseConfig.enablePartialNormalization),</p>
</dd>
<dt>enableHeavyRanking =</dt><dd><p>overrides.enableHeavyRanking.getOrElse(baseConfig.enableHeavyRanking),</p>
</dd>
</dl>
<p>rankingAlgorithm = overrides.rankingAlgorithm.getOrElse(baseConfig.rankingAlgorithm),
maxReRankingCandidates =</p>
<blockquote>
<div><p>overrides.maxReRankingCandidates.getOrElse(baseConfig.maxReRankingCandidates),</p>
</div></blockquote>
<dl class="simple">
<dt>maxTopTweetsPerCluster =</dt><dd><p>overrides.maxTopTweetsPerCluster.getOrElse(baseConfig.maxTopTweetsPerCluster),</p>
</dd>
</dl>
<p>maxScanClusters = overrides.maxScanClusters.getOrElse(baseConfig.maxScanClusters),
minTweetCandidateAge =</p>
<blockquote>
<div><p>overrides.minTweetCandidateAge.getOrElse(baseConfig.minTweetCandidateAge)</p>
</div></blockquote>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>case _ =&gt; baseConfig</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>object SimClustersANNCandidateSource {</p>
<blockquote>
<div><p>final val ProductionMaxNumResults = 200
final val InitialCandidateMapSize = 16384</p>
<dl class="simple">
<dt>def apply(</dt><dd><p>clusterTweetCandidatesStore: ReadableStore[ClusterKey, Seq[(TweetId, Double)]],
simClustersEmbeddingStore: ReadableStore[SimClustersEmbeddingId, SimClustersEmbedding],
uniformScoringStore: ReadableStore[ThriftScoreId, ThriftScore],
configs: Map[EmbeddingType, SimClustersANNConfig],
statsReceiver: StatsReceiver</p>
</dd>
<dt>) = new SimClustersANNCandidateSource(</dt><dd><p>clusterTweetCandidatesStore = clusterTweetCandidatesStore,
simClustersEmbeddingStore = simClustersEmbeddingStore,
heavyRanker = new UniformScoreStoreRanker(uniformScoringStore, statsReceiver),
configs = configs,
statsReceiver = statsReceiver</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>private def parseTweetId(embeddingId: SimClustersEmbeddingId): Option[TweetId] = {</dt><dd><dl class="simple">
<dt>embeddingId.internalId match {</dt><dd><dl class="simple">
<dt>case InternalId.TweetId(tweetId) =&gt;</dt><dd><p>Some(tweetId)</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>None</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>case class Query(</dt><dd><p>sourceEmbeddingId: SimClustersEmbeddingId,
// Only override the config in DDG and Debuggers.
// Use Post-filter for the holdbacks for better cache hit rate.
overrideConfig: Option[SimClustersANNConfigOverride] = None)</p>
</dd>
<dt>case class SimClustersTweetCandidate(</dt><dd><p>tweetId: TweetId,
score: Double,
sourceEmbeddingId: SimClustersEmbeddingId)</p>
</dd>
<dt>class HashMap[A, B](initSize: Int) extends mutable.HashMap[A, B] {</dt><dd><p>override def initialSize: Int = initSize // 16 - by default</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>The Configuration of Each SimClusters ANN Candidate Source.</p></li>
<li><p>Expect One SimClusters Embedding Type mapping to a SimClusters ANN Configuration in Production.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>case class SimClustersANNConfig(</dt><dd><p>// The max number of candidates for a ANN Query
// Please don’t override this value in Production.
maxNumResults: Int = ProductionMaxNumResults,
// The max tweet candidate duration from now.
maxTweetCandidateAge: Duration,
// The min score of the candidates
minScore: Double,
// The Candidate Embedding Type of Tweet.
candidateEmbeddingType: EmbeddingType,
// Enables normalization of approximate SimClusters vectors to remove popularity bias
enablePartialNormalization: Boolean,
// Whether to enable Embedding Similarity ranking
enableHeavyRanking: Boolean,
// The ranking algorithm for Source Candidate Similarity
rankingAlgorithm: ScoringAlgorithm,
// The max number of candidates in ReRanking Step
maxReRankingCandidates: Int,
// The max number of Top Tweets from every cluster tweet index
maxTopTweetsPerCluster: Int,
// The max number of Clusters in the source Embeddings.
maxScanClusters: Int,
// The min tweet candidate duration from now.
minTweetCandidateAge: Duration)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Contains same fields as [[SimClustersANNConfig]], to specify which fields are to be overriden</p></li>
<li><p>for experimental purposes.</p></li>
<li></li>
<li><p>All fields in this class must be optional.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>case class SimClustersANNConfigOverride(</dt><dd><p>maxNumResults: Option[Int] = None,
maxTweetCandidateAge: Option[Duration] = None,
minScore: Option[Double] = None,
candidateEmbeddingType: Option[EmbeddingType] = None,
enablePartialNormalization: Option[Boolean] = None,
enableHeavyRanking: Option[Boolean] = None,
rankingAlgorithm: Option[ScoringAlgorithm] = None,
maxReRankingCandidates: Option[Int] = None,
maxTopTweetsPerCluster: Option[Int] = None,
maxScanClusters: Option[Int] = None,
minTweetCandidateAge: Option[Duration] = None,
enableLookbackSource: Option[Boolean] = None)</p>
</dd>
</dl>
<p>final val DefaultMaxTopTweetsPerCluster = 200
final val DefaultEnableHeavyRanking = false
object SimClustersANNConfig {</p>
<blockquote>
<div><dl>
<dt>val DefaultSimClustersANNConfig: SimClustersANNConfig =</dt><dd><dl class="simple">
<dt>SimClustersANNConfig(</dt><dd><p>maxTweetCandidateAge = 1.days,
minScore = 0.7,
candidateEmbeddingType = EmbeddingType.LogFavBasedTweet,
enablePartialNormalization = true,
enableHeavyRanking = false,
rankingAlgorithm = ScoringAlgorithm.PairEmbeddingCosineSimilarity,
maxReRankingCandidates = 250,
maxTopTweetsPerCluster = 200,
maxScanClusters = 50,
minTweetCandidateAge = 0.seconds</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>val LookbackMediaMinDays: Int = 0
val LookbackMediaMaxDays: Int = 2
val LookbackMediaMaxTweetsPerDay: Int = 2000
val maxTopTweetsPerCluster: Int =</p>
<blockquote>
<div><p>(LookbackMediaMaxDays - LookbackMediaMinDays + 1) * LookbackMediaMaxTweetsPerDay</p>
</div></blockquote>
<dl>
<dt>val LookbackMediaTweetConfig: Map[EmbeddingType, SimClustersANNConfig] = {</dt><dd><p>val candidateEmbeddingType = EmbeddingType.LogFavLongestL2EmbeddingTweet
val minTweetAge = LookbackMediaMinDays.days
val maxTweetAge =</p>
<blockquote>
<div><p>LookbackMediaMaxDays.days - 1.hour // To compensate for the cache TTL that might push the tweet age beyond max age</p>
</div></blockquote>
<p>val rankingAlgorithm = ScoringAlgorithm.PairEmbeddingCosineSimilarity</p>
<p>val maxScanClusters = 50
val minScore = 0.5
Map(</p>
<blockquote>
<div><dl>
<dt>EmbeddingType.FavBasedProducer -&gt; SimClustersANNConfig(</dt><dd><p>minTweetCandidateAge = minTweetAge,
maxTweetCandidateAge = maxTweetAge,
minScore =</p>
<blockquote>
<div><p>minScore, // for twistly candidates. To specify a higher threshold, use a post-filter</p>
</div></blockquote>
<p>candidateEmbeddingType = candidateEmbeddingType,
enablePartialNormalization = true,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm = rankingAlgorithm,
maxReRankingCandidates = 250,
maxTopTweetsPerCluster = maxTopTweetsPerCluster,
maxScanClusters = maxScanClusters,</p>
</dd>
</dl>
<p>),
EmbeddingType.LogFavLongestL2EmbeddingTweet -&gt; SimClustersANNConfig(</p>
<blockquote>
<div><p>minTweetCandidateAge = minTweetAge,
maxTweetCandidateAge = maxTweetAge,
minScore =</p>
<blockquote>
<div><p>minScore, // for twistly candidates. To specify a higher threshold, use a post-filter</p>
</div></blockquote>
<p>candidateEmbeddingType = candidateEmbeddingType,
enablePartialNormalization = true,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm = rankingAlgorithm,
maxReRankingCandidates = 250,
maxTopTweetsPerCluster = maxTopTweetsPerCluster,
maxScanClusters = maxScanClusters,</p>
</div></blockquote>
<p>),
EmbeddingType.FavTfgTopic -&gt; SimClustersANNConfig(</p>
<blockquote>
<div><p>minTweetCandidateAge = minTweetAge,
maxTweetCandidateAge = maxTweetAge,
minScore = minScore,
candidateEmbeddingType = candidateEmbeddingType,
enablePartialNormalization = true,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm = rankingAlgorithm,
maxReRankingCandidates = 400,
maxTopTweetsPerCluster = 200,
maxScanClusters = maxScanClusters,</p>
</div></blockquote>
<p>),
EmbeddingType.LogFavBasedKgoApeTopic -&gt; SimClustersANNConfig(</p>
<blockquote>
<div><p>minTweetCandidateAge = minTweetAge,
maxTweetCandidateAge = maxTweetAge,
minScore = minScore,
candidateEmbeddingType = candidateEmbeddingType,
enablePartialNormalization = true,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm = rankingAlgorithm,
maxReRankingCandidates = 400,
maxTopTweetsPerCluster = 200,
maxScanClusters = maxScanClusters,</p>
</div></blockquote>
<p>),</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val DefaultConfigMappings: Map[EmbeddingType, SimClustersANNConfig] = Map(</dt><dd><dl class="simple">
<dt>EmbeddingType.FavBasedProducer -&gt; SimClustersANNConfig(</dt><dd><p>maxTweetCandidateAge = 1.days,
minScore = 0.0, // for twistly candidates. To specify a higher threshold, use a post-filter
candidateEmbeddingType = EmbeddingType.LogFavBasedTweet,
enablePartialNormalization = true,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm = ScoringAlgorithm.PairEmbeddingCosineSimilarity,
maxReRankingCandidates = 250,
maxTopTweetsPerCluster = DefaultMaxTopTweetsPerCluster,
maxScanClusters = 50,
minTweetCandidateAge = 0.seconds</p>
</dd>
</dl>
<p>),
EmbeddingType.LogFavBasedUserInterestedMaxpoolingAddressBookFromIIAPE -&gt; SimClustersANNConfig(</p>
<blockquote>
<div><p>maxTweetCandidateAge = 1.days,
minScore = 0.0, // for twistly candidates. To specify a higher threshold, use a post-filter
candidateEmbeddingType = EmbeddingType.LogFavBasedTweet,
enablePartialNormalization = true,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm = ScoringAlgorithm.PairEmbeddingCosineSimilarity,
maxReRankingCandidates = 250,
maxTopTweetsPerCluster = DefaultMaxTopTweetsPerCluster,
maxScanClusters = 50,
minTweetCandidateAge = 0.seconds</p>
</div></blockquote>
<p>),
EmbeddingType.LogFavBasedUserInterestedAverageAddressBookFromIIAPE -&gt; SimClustersANNConfig(</p>
<blockquote>
<div><p>maxTweetCandidateAge = 1.days,
minScore = 0.0, // for twistly candidates. To specify a higher threshold, use a post-filter
candidateEmbeddingType = EmbeddingType.LogFavBasedTweet,
enablePartialNormalization = true,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm = ScoringAlgorithm.PairEmbeddingCosineSimilarity,
maxReRankingCandidates = 250,
maxTopTweetsPerCluster = DefaultMaxTopTweetsPerCluster,
maxScanClusters = 50,
minTweetCandidateAge = 0.seconds</p>
</div></blockquote>
<p>),
EmbeddingType.LogFavBasedUserInterestedBooktypeMaxpoolingAddressBookFromIIAPE -&gt; SimClustersANNConfig(</p>
<blockquote>
<div><p>maxTweetCandidateAge = 1.days,
minScore = 0.0, // for twistly candidates. To specify a higher threshold, use a post-filter
candidateEmbeddingType = EmbeddingType.LogFavBasedTweet,
enablePartialNormalization = true,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm = ScoringAlgorithm.PairEmbeddingCosineSimilarity,
maxReRankingCandidates = 250,
maxTopTweetsPerCluster = DefaultMaxTopTweetsPerCluster,
maxScanClusters = 50,
minTweetCandidateAge = 0.seconds</p>
</div></blockquote>
<p>),
EmbeddingType.LogFavBasedUserInterestedLargestDimMaxpoolingAddressBookFromIIAPE -&gt; SimClustersANNConfig(</p>
<blockquote>
<div><p>maxTweetCandidateAge = 1.days,
minScore = 0.0, // for twistly candidates. To specify a higher threshold, use a post-filter
candidateEmbeddingType = EmbeddingType.LogFavBasedTweet,
enablePartialNormalization = true,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm = ScoringAlgorithm.PairEmbeddingCosineSimilarity,
maxReRankingCandidates = 250,
maxTopTweetsPerCluster = DefaultMaxTopTweetsPerCluster,
maxScanClusters = 50,
minTweetCandidateAge = 0.seconds</p>
</div></blockquote>
<p>),
EmbeddingType.LogFavBasedUserInterestedLouvainMaxpoolingAddressBookFromIIAPE -&gt; SimClustersANNConfig(</p>
<blockquote>
<div><p>maxTweetCandidateAge = 1.days,
minScore = 0.0, // for twistly candidates. To specify a higher threshold, use a post-filter
candidateEmbeddingType = EmbeddingType.LogFavBasedTweet,
enablePartialNormalization = true,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm = ScoringAlgorithm.PairEmbeddingCosineSimilarity,
maxReRankingCandidates = 250,
maxTopTweetsPerCluster = DefaultMaxTopTweetsPerCluster,
maxScanClusters = 50,
minTweetCandidateAge = 0.seconds</p>
</div></blockquote>
<p>),
EmbeddingType.LogFavBasedUserInterestedConnectedMaxpoolingAddressBookFromIIAPE -&gt; SimClustersANNConfig(</p>
<blockquote>
<div><p>maxTweetCandidateAge = 1.days,
minScore = 0.0, // for twistly candidates. To specify a higher threshold, use a post-filter
candidateEmbeddingType = EmbeddingType.LogFavBasedTweet,
enablePartialNormalization = true,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm = ScoringAlgorithm.PairEmbeddingCosineSimilarity,
maxReRankingCandidates = 250,
maxTopTweetsPerCluster = DefaultMaxTopTweetsPerCluster,
maxScanClusters = 50,
minTweetCandidateAge = 0.seconds</p>
</div></blockquote>
<p>),
EmbeddingType.RelaxedAggregatableLogFavBasedProducer -&gt; SimClustersANNConfig(</p>
<blockquote>
<div><p>maxTweetCandidateAge = 1.days,
minScore = 0.25, // for twistly candidates. To specify a higher threshold, use a post-filter
candidateEmbeddingType = EmbeddingType.LogFavBasedTweet,
enablePartialNormalization = true,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm = ScoringAlgorithm.PairEmbeddingCosineSimilarity,
maxReRankingCandidates = 250,
maxTopTweetsPerCluster = DefaultMaxTopTweetsPerCluster,
maxScanClusters = 50,
minTweetCandidateAge = 0.seconds</p>
</div></blockquote>
<p>),
EmbeddingType.LogFavLongestL2EmbeddingTweet -&gt; SimClustersANNConfig(</p>
<blockquote>
<div><p>maxTweetCandidateAge = 1.days,
minScore = 0.3, // for twistly candidates. To specify a higher threshold, use a post-filter
candidateEmbeddingType = EmbeddingType.LogFavBasedTweet,
enablePartialNormalization = true,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm = ScoringAlgorithm.PairEmbeddingCosineSimilarity,
maxReRankingCandidates = 400,
maxTopTweetsPerCluster = DefaultMaxTopTweetsPerCluster,
maxScanClusters = 50,
minTweetCandidateAge = 0.seconds</p>
</div></blockquote>
<p>),
EmbeddingType.FilteredUserInterestedInFromPE -&gt; SimClustersANNConfig(</p>
<blockquote>
<div><p>maxTweetCandidateAge = 1.days,
minScore = 0.7, // unused, heavy ranking disabled
candidateEmbeddingType = EmbeddingType.LogFavBasedTweet,
enablePartialNormalization = false,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm =</p>
<blockquote>
<div><p>ScoringAlgorithm.PairEmbeddingCosineSimilarity, // Unused, heavy ranking disabled</p>
</div></blockquote>
<p>maxReRankingCandidates = 150, // unused, heavy ranking disabled
maxTopTweetsPerCluster = DefaultMaxTopTweetsPerCluster,
maxScanClusters = 50,
minTweetCandidateAge = 0.seconds</p>
</div></blockquote>
<p>),
EmbeddingType.FilteredUserInterestedIn -&gt; SimClustersANNConfig(</p>
<blockquote>
<div><p>maxTweetCandidateAge = 1.days,
minScore = 0.7, // unused, heavy ranking disabled
candidateEmbeddingType = EmbeddingType.LogFavBasedTweet,
enablePartialNormalization = false,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm =</p>
<blockquote>
<div><p>ScoringAlgorithm.PairEmbeddingCosineSimilarity, // Unused, heavy ranking disabled</p>
</div></blockquote>
<p>maxReRankingCandidates = 150, // unused, heavy ranking disabled
maxTopTweetsPerCluster = DefaultMaxTopTweetsPerCluster,
maxScanClusters = 50,
minTweetCandidateAge = 0.seconds</p>
</div></blockquote>
<p>),
EmbeddingType.UnfilteredUserInterestedIn -&gt; SimClustersANNConfig(</p>
<blockquote>
<div><p>maxTweetCandidateAge = 1.days,
minScore = 0.0,
candidateEmbeddingType = EmbeddingType.LogFavBasedTweet,
enablePartialNormalization = true,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm = ScoringAlgorithm.PairEmbeddingLogCosineSimilarity,
maxReRankingCandidates = 400,
maxTopTweetsPerCluster = DefaultMaxTopTweetsPerCluster,
maxScanClusters = 50,
minTweetCandidateAge = 0.seconds</p>
</div></blockquote>
<p>),
EmbeddingType.FollowBasedUserInterestedInFromAPE -&gt; SimClustersANNConfig(</p>
<blockquote>
<div><p>maxTweetCandidateAge = 1.days,
minScore = 0.0,
candidateEmbeddingType = EmbeddingType.LogFavBasedTweet,
enablePartialNormalization = true,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm = ScoringAlgorithm.PairEmbeddingCosineSimilarity,
maxReRankingCandidates = 200,
maxTopTweetsPerCluster = DefaultMaxTopTweetsPerCluster,
maxScanClusters = 50,
minTweetCandidateAge = 0.seconds</p>
</div></blockquote>
<p>),
EmbeddingType.LogFavBasedUserInterestedInFromAPE -&gt; SimClustersANNConfig(</p>
<blockquote>
<div><p>maxTweetCandidateAge = 1.days,
minScore = 0.0,
candidateEmbeddingType = EmbeddingType.LogFavBasedTweet,
enablePartialNormalization = true,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm = ScoringAlgorithm.PairEmbeddingCosineSimilarity,
maxReRankingCandidates = 200,
maxTopTweetsPerCluster = DefaultMaxTopTweetsPerCluster,
maxScanClusters = 50,
minTweetCandidateAge = 0.seconds</p>
</div></blockquote>
<p>),
EmbeddingType.FavTfgTopic -&gt; SimClustersANNConfig(</p>
<blockquote>
<div><p>maxTweetCandidateAge = 1.days,
minScore = 0.5,
candidateEmbeddingType = EmbeddingType.LogFavBasedTweet,
enablePartialNormalization = true,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm = ScoringAlgorithm.PairEmbeddingCosineSimilarity,
maxReRankingCandidates = 400,
maxTopTweetsPerCluster = DefaultMaxTopTweetsPerCluster,
maxScanClusters = 50,
minTweetCandidateAge = 0.seconds</p>
</div></blockquote>
<p>),
EmbeddingType.LogFavBasedKgoApeTopic -&gt; SimClustersANNConfig(</p>
<blockquote>
<div><p>maxTweetCandidateAge = 1.days,
minScore = 0.5,
candidateEmbeddingType = EmbeddingType.LogFavBasedTweet,
enablePartialNormalization = true,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm = ScoringAlgorithm.PairEmbeddingCosineSimilarity,
maxReRankingCandidates = 400,
maxTopTweetsPerCluster = DefaultMaxTopTweetsPerCluster,
maxScanClusters = 50,
minTweetCandidateAge = 0.seconds</p>
</div></blockquote>
<p>),
EmbeddingType.UserNextInterestedIn -&gt; SimClustersANNConfig(</p>
<blockquote>
<div><p>maxTweetCandidateAge = 1.days,
minScore = 0.0,
candidateEmbeddingType = EmbeddingType.LogFavBasedTweet,
enablePartialNormalization = true,
enableHeavyRanking = DefaultEnableHeavyRanking,
rankingAlgorithm = ScoringAlgorithm.PairEmbeddingCosineSimilarity,
maxReRankingCandidates = 200,
maxTopTweetsPerCluster = DefaultMaxTopTweetsPerCluster,
maxScanClusters = 50,
minTweetCandidateAge = 0.seconds</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Only cache the candidates if it’s not Consumer-source. For example, TweetSource, ProducerSource,</p></li>
<li><p>TopicSource. We don’t cache consumer-sources (e.g. UserInterestedIn) since a cached consumer</p></li>
<li><p>object is going rarely hit, since it can’t be shared by multiple users.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>val CacheableShortTTLEmbeddingTypes: Set[EmbeddingType] =</dt><dd><dl class="simple">
<dt>Set(</dt><dd><p>EmbeddingType.FavBasedProducer,
EmbeddingType.LogFavLongestL2EmbeddingTweet,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val CacheableLongTTLEmbeddingTypes: Set[EmbeddingType] =</dt><dd><dl class="simple">
<dt>Set(</dt><dd><p>EmbeddingType.FavTfgTopic,
EmbeddingType.LogFavBasedKgoApeTopic</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../_sources/src/scala/com/twitter/simclusters_v2/candidate_source/SimClustersANNCandidateSource.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>