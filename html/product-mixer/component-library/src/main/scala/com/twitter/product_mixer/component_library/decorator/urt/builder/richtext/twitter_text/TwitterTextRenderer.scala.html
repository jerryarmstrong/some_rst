<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../../../../../../" id="documentation_options" src="../../../../../../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.product_mixer.component_library.decorator.urt.builder.richtext.twitter_text</p>
<p>import com.twitter.product_mixer.core.model.marshalling.response.urt.richtext.ReferenceObject
import com.twitter.product_mixer.core.model.marshalling.response.urt.richtext.RichText
import com.twitter.product_mixer.core.model.marshalling.response.urt.richtext.RichTextAlignment
import com.twitter.product_mixer.core.model.marshalling.response.urt.richtext.RichTextEntity
import com.twitter.product_mixer.core.model.marshalling.response.urt.richtext.RichTextFormat
import scala.annotation.tailrec
import scala.collection.mutable</p>
<p>object TwitterTextRenderer {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Creates a new [[TwitterTextRenderer]] instance.</p></li>
<li><p>&#64;param text      The initial text representation</p></li>
<li><p>&#64;param rtl       Defines whether this text is in an RTL language</p></li>
<li><p>&#64;param alignment Assigns the [[RichTextAlignment]] of the given text for display</p></li>
<li><p>&#64;return          A new [[TwitterTextRenderer]] instance</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>def apply(</dt><dd><p>text: String,
rtl: Option[Boolean] = None,
alignment: Option[RichTextAlignment] = None</p>
</dd>
<dt>): TwitterTextRenderer = {</dt><dd><p>TwitterTextRenderer(rtl, alignment).append(text)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Creates a new [[TwitterTextRenderer]] instance from a product-mixer [[RichText]] object.</p></li>
<li><p>Converts Unicode entity indexes into JVM String indexes.</p></li>
<li><p>&#64;param richText  The product-mixer [[RichText]] representation</p></li>
<li><p>&#64;return          A new [[TwitterTextRenderer]] instance</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>def fromRichText(richText: RichText): TwitterTextRenderer = {</dt><dd><p>val builder = TwitterTextRenderer(richText.text, richText.rtl, richText.alignment)
richText.entities.foreach { e =&gt;</p>
<blockquote>
<div><p>val startIndex = richText.text.offsetByCodePoints(0, e.fromIndex)
val endIndex = richText.text.offsetByCodePoints(0, e.toIndex)
e.format.foreach { f =&gt;</p>
<blockquote>
<div><p>builder.setFormat(startIndex, endIndex, f)</p>
</div></blockquote>
<p>}
e.ref.foreach { r =&gt;</p>
<blockquote>
<div><p>builder.setRefObject(startIndex, endIndex, r)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
builder</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def buildRichTextEntity(</dt><dd><p>text: String,
entity: TwitterTextRendererEntity[_]</p>
</dd>
<dt>): RichTextEntity = {</dt><dd><p>val fromIndex = text.codePointCount(0, entity.startIndex)
val toIndex = text.codePointCount(0, entity.endIndex)</p>
<dl class="simple">
<dt>entity.value match {</dt><dd><dl class="simple">
<dt>case format: RichTextFormat =&gt;</dt><dd><p>RichTextEntity(fromIndex, toIndex, ref = None, format = Some(format))</p>
</dd>
<dt>case ref: ReferenceObject =&gt;</dt><dd><p>RichTextEntity(fromIndex, toIndex, ref = Some(ref), format = None)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>case class TwitterTextRenderer(</dt><dd><p>rtl: Option[Boolean],
alignment: Option[RichTextAlignment],</p>
</dd>
<dt>) {</dt><dd><p>private[this] val textBuilder = new mutable.StringBuilder()</p>
<dl>
<dt>private[richtext] val formatBuffer =</dt><dd><p>mutable.ArrayBuffer[TwitterTextRendererEntity[RichTextFormat]]()</p>
</dd>
<dt>private[richtext] val refObjectBuffer =</dt><dd><p>mutable.ArrayBuffer[TwitterTextRendererEntity[ReferenceObject]]()</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Appends a string with attached [[RichTextFormat]] and [[ReferenceObject]] information.</p></li>
<li><p>&#64;param string    The text to append to the end of the existing text</p></li>
<li><p>&#64;param format    The [[RichTextFormat]] assigned to the new text</p></li>
<li><p>&#64;param refObject The [[ReferenceObject]] assigned to the new text</p></li>
<li><p>&#64;return          this</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>def append(</dt><dd><p>string: String,
format: Option[RichTextFormat] = None,
refObject: Option[ReferenceObject] = None</p>
</dd>
<dt>): TwitterTextRenderer = {</dt><dd><dl>
<dt>if (string.nonEmpty) {</dt><dd><p>val start = textBuilder.length
val end = start + string.length
format.foreach { f =&gt;</p>
<blockquote>
<div><p>formatBuffer.append(TwitterTextRendererEntity(start, end, f))</p>
</div></blockquote>
<p>}
refObject.foreach { r =&gt;</p>
<blockquote>
<div><p>refObjectBuffer.append(TwitterTextRendererEntity(start, end, r))</p>
</div></blockquote>
<p>}
textBuilder.append(string)</p>
</dd>
</dl>
<p>}
this</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Builds a new [[RichText]] thrift instance with Unicode entity ranges.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>def build: RichText = {</dt><dd><p>val richTextString = this.text
val richTextEntities = this.entities</p>
<blockquote>
<div><dl class="simple">
<dt>.map { e =&gt;</dt><dd><p>TwitterTextRenderer.buildRichTextEntity(richTextString, e)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>RichText(</dt><dd><p>text = richTextString,
rtl = rtl,
alignment = alignment,
entities = richTextEntities.toList</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Modifies the TwitterTextRenderer with the provided [[TwitterTextRendererProcessor]]</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>def transform(twitterTextProcessor: TwitterTextRendererProcessor): TwitterTextRenderer = {</dt><dd><p>twitterTextProcessor.process(this)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Builds and returns a sorted list of [[TwitterTextRendererEntity]] with JVM String index entity ranges.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>def entities: Seq[TwitterTextRendererEntity[_]] = {</dt><dd><p>buildEntities(formatBuffer.toList, refObjectBuffer.toList)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Assigns a [[RichTextFormat]] to the given range while keeping existing formatting information.</p></li>
<li><p>New formatting will only be assigned to unformatted text ranges.</p></li>
<li><p>&#64;param start  Start index to apply formatting (inclusive)</p></li>
<li><p>&#64;param end    End index to apply formatting (exclusive)</p></li>
<li><p>&#64;param format The format to assign</p></li>
<li><p>&#64;return       this</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>def mergeFormat(start: Int, end: Int, format: RichTextFormat): TwitterTextRenderer = {</dt><dd><p>validateRange(start, end)
var injectionIndex: Option[Int] = None
var entity = TwitterTextRendererEntity(start, end, format)</p>
<p>val buffer = mutable.ArrayBuffer[TwitterTextRendererEntity[RichTextFormat]]()
val iterator = formatBuffer.zipWithIndex.reverseIterator</p>
<dl>
<dt>while (iterator.hasNext &amp;&amp; injectionIndex.isEmpty) {</dt><dd><dl>
<dt>iterator.next match {</dt><dd><dl class="simple">
<dt>case (e, i) if e.startIndex &gt;= end =&gt;</dt><dd><p>buffer.append(e)</p>
</dd>
<dt>case (e, i) if e.enclosedIn(entity.startIndex, entity.endIndex) =&gt;</dt><dd><p>val endEntity = entity.copy(startIndex = e.endIndex)
if (endEntity.nonEmpty) { buffer.append(endEntity) }
buffer.append(e)
entity = entity.copy(endIndex = e.startIndex)</p>
</dd>
<dt>case (e, i) if e.encloses(entity.startIndex, entity.endIndex) =&gt;</dt><dd><p>buffer.append(e.copy(startIndex = entity.endIndex))
buffer.append(e.copy(endIndex = entity.startIndex))
injectionIndex = Some(i + 1)</p>
</dd>
<dt>case (e, i) if e.startsBetween(entity.startIndex, entity.endIndex) =&gt;</dt><dd><p>buffer.append(e)
entity = entity.copy(endIndex = e.startIndex)</p>
</dd>
<dt>case (e, i) if e.endsBetween(entity.startIndex, entity.endIndex) =&gt;</dt><dd><p>buffer.append(e)
entity = entity.copy(startIndex = e.endIndex)
injectionIndex = Some(i + 1)</p>
</dd>
<dt>case (e, i) if e.endIndex &lt;= entity.startIndex =&gt;</dt><dd><p>buffer.append(e)
injectionIndex = Some(i + 1)</p>
</dd>
</dl>
<p>case _ =&gt; // do nothing</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>val index = injectionIndex.map(_ - 1).getOrElse(0)
formatBuffer.remove(index, formatBuffer.length - index)
formatBuffer.appendAll(buffer.reverse)</p>
<dl class="simple">
<dt>if (entity.nonEmpty) {</dt><dd><p>formatBuffer.insert(injectionIndex.getOrElse(0), entity)</p>
</dd>
</dl>
<p>}</p>
<p>this</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Removes text, formatting, and refObject information from the given range.</p></li>
<li><p>&#64;param start  Start index to apply formatting (inclusive)</p></li>
<li><p>&#64;param end    End index to apply formatting (exclusive)</p></li>
<li><p>&#64;return       this</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
</dl>
<p>def remove(start: Int, end: Int): TwitterTextRenderer = replace(start, end, “”)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Replaces text, formatting, and refObject information in the given range.</p></li>
<li><p>&#64;param start     Start index to apply formatting (inclusive)</p></li>
<li><p>&#64;param end       End index to apply formatting (exclusive)</p></li>
<li><p>&#64;param string    The new text to insert</p></li>
<li><p>&#64;param format    The [[RichTextFormat]] assigned to the new text</p></li>
<li><p>&#64;param refObject The [[ReferenceObject]] assigned to the new text</p></li>
<li><p>&#64;return          this</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>def replace(</dt><dd><p>start: Int,
end: Int,
string: String,
format: Option[RichTextFormat] = None,
refObject: Option[ReferenceObject] = None</p>
</dd>
<dt>): TwitterTextRenderer = {</dt><dd><p>validateRange(start, end)</p>
<p>val newEnd = start + string.length
val formatInjectIndex = removeAndOffsetFormats(start, end, string.length)
val refObjectInjectIndex = removeAndOffsetRefObjects(start, end, string.length)
format.foreach { f =&gt;</p>
<blockquote>
<div><p>formatBuffer.insert(formatInjectIndex, TwitterTextRendererEntity(start, newEnd, f))</p>
</div></blockquote>
<p>}
refObject.foreach { r =&gt;</p>
<blockquote>
<div><p>refObjectBuffer.insert(refObjectInjectIndex, TwitterTextRendererEntity(start, newEnd, r))</p>
</div></blockquote>
<p>}
textBuilder.replace(start, end, string)</p>
<p>this</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Assigns a [[RichTextFormat]] to the given range. Trims existing format ranges that overlap the</p></li>
<li><p>new format range. Removes format ranges that fall within the new range.</p></li>
<li><p>&#64;param start  Start index to apply formatting (inclusive)</p></li>
<li><p>&#64;param end    End index to apply formatting (exclusive)</p></li>
<li><p>&#64;param format The format to assign</p></li>
<li><p>&#64;return       this</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>def setFormat(start: Int, end: Int, format: RichTextFormat): TwitterTextRenderer = {</dt><dd><p>validateRange(start, end)
val bufferIndex = removeAndOffsetFormats(start, end, end - start)
formatBuffer.insert(bufferIndex, TwitterTextRendererEntity(start, end, format))</p>
<p>this</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private[this] def removeAndOffsetFormats(start: Int, end: Int, newSize: Int): Int = {</dt><dd><p>val newEnd = start + newSize
val offset = newEnd - end
var injectionIndex: Option[Int] = None</p>
<p>val buffer = mutable.ArrayBuffer[TwitterTextRendererEntity[RichTextFormat]]()
val iterator = formatBuffer.zipWithIndex.reverseIterator</p>
<dl>
<dt>while (iterator.hasNext &amp;&amp; injectionIndex.isEmpty) {</dt><dd><dl>
<dt>iterator.next match {</dt><dd><dl class="simple">
<dt>case (e, i) if e.startIndex &gt;= end =&gt;</dt><dd><p>buffer.append(e.offset(offset))</p>
</dd>
<dt>case (e, i) if e.encloses(start, end) =&gt;</dt><dd><p>buffer.append(e.copy(startIndex = newEnd, endIndex = e.endIndex + offset))
buffer.append(e.copy(endIndex = e.endIndex + offset))
injectionIndex = Some(i + 1)</p>
</dd>
<dt>case (e, i) if e.endsBetween(start, end) =&gt;</dt><dd><p>buffer.append(e.copy(endIndex = start))
injectionIndex = Some(i + 1)</p>
</dd>
<dt>case (e, i) if e.startsBetween(start, end) =&gt;</dt><dd><p>buffer.append(e.copy(startIndex = newEnd, endIndex = e.endIndex + offset))</p>
</dd>
<dt>case (e, i) if e.endIndex &lt;= start =&gt;</dt><dd><p>buffer.append(e)
injectionIndex = Some(i + 1)</p>
</dd>
</dl>
<p>case _ =&gt; // do nothing</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
val index = injectionIndex.map(_ - 1).getOrElse(0)
formatBuffer.remove(index, formatBuffer.length - index)
formatBuffer.appendAll(buffer.reverse)</p>
<p>injectionIndex.getOrElse(0)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private[this] def validateRange(start: Int, end: Int): Unit = {</dt><dd><dl class="simple">
<dt>require(</dt><dd><p>start &gt;= 0 &amp;&amp; start &lt; textBuilder.length &amp;&amp; end &gt; start &amp;&amp; end &lt;= textBuilder.length,
s”The start ($start) and end ($end) indexes must be within the text range (0..${textBuilder.length})”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Assigns a [[ReferenceObject]] to the given range. Since it makes little sense to trim object</p></li>
<li><p>ranges, existing intersecting or overlapping ranges are removed entirely.</p></li>
<li><p>&#64;param start  Start index to apply formatting (inclusive)</p></li>
<li><p>&#64;param end       End index to apply formatting (exclusive)</p></li>
<li><p>&#64;param refObject The [[ReferenceObject]] to assign</p></li>
<li><p>&#64;return          this</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
<dt>def setRefObject(start: Int, end: Int, refObject: ReferenceObject): TwitterTextRenderer = {</dt><dd><p>validateRange(start, end)
val bufferIndex = removeAndOffsetRefObjects(start, end, end - start)
refObjectBuffer.insert(bufferIndex, TwitterTextRendererEntity(start, end, refObject))</p>
<p>this</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private[this] def removeAndOffsetRefObjects(start: Int, end: Int, newSize: Int): Int = {</dt><dd><p>val newEnd = start + newSize
val offset = newEnd - end
var injectionIndex: Option[Int] = None</p>
<p>val buffer = mutable.ArrayBuffer[TwitterTextRendererEntity[ReferenceObject]]()
val iterator = refObjectBuffer.zipWithIndex.reverseIterator</p>
<dl>
<dt>while (iterator.hasNext &amp;&amp; injectionIndex.isEmpty) {</dt><dd><dl class="simple">
<dt>iterator.next match {</dt><dd><p>case (e, i) if e.startIndex &gt;= end =&gt; buffer.append(e.offset(offset))
case (e, i) if e.endIndex &lt;= start =&gt; injectionIndex = Some(i + 1)
case _ =&gt; // do nothing</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
val index = injectionIndex.getOrElse(0)
refObjectBuffer.remove(index, refObjectBuffer.length - index)
refObjectBuffer.appendAll(buffer.reverse)</p>
<p>index</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Builds and returns the full TwitterTextRenderer text with any changes applied to the builder instance.</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>def text: String = {</dt><dd><p>textBuilder.mkString</p>
</dd>
</dl>
<p>}</p>
<p>&#64;tailrec
private def buildEntities(</p>
<blockquote>
<div><p>formats: List[TwitterTextRendererEntity[RichTextFormat]],
refs: List[TwitterTextRendererEntity[ReferenceObject]],
acc: List[TwitterTextRendererEntity[_]] = List()</p>
</div></blockquote>
<dl>
<dt>): Seq[TwitterTextRendererEntity[_]] = {</dt><dd><dl>
<dt>(formats, refs) match {</dt><dd><p>case (Nil, Nil) =&gt; acc
case (remainingFormats, Nil) =&gt; acc ++ remainingFormats
case (Nil, remainingRefs) =&gt; acc ++ remainingRefs</p>
<dl>
<dt>case (format +: remainingFormats, ref +: remainingRefs)</dt><dd><blockquote>
<div><p>if format.startIndex &lt; ref.startIndex || (format.startIndex == ref.startIndex &amp;&amp; format.endIndex &lt; ref.endIndex) =&gt;</p>
</div></blockquote>
<p>buildEntities(remainingFormats, refs, acc :+ format)</p>
</dd>
<dt>case (format +: remainingFormats, ref +: remainingRefs)</dt><dd><blockquote>
<div><p>if format.startIndex == ref.startIndex &amp;&amp; format.endIndex == ref.endIndex =&gt;</p>
</div></blockquote>
<p>buildEntities(remainingFormats, remainingRefs, acc :+ format :+ ref)</p>
</dd>
<dt>case (_, ref +: remainingRefs) =&gt;</dt><dd><p>buildEntities(formats, remainingRefs, acc :+ ref)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class TwitterTextRendererEntity[+T] private[richtext] (</dt><dd><p>startIndex: Int,
endIndex: Int,
value: T) {
require(startIndex &lt;= endIndex, “startIndex must be &lt;= than endIndex”)</p>
<p>def nonEmpty: Boolean = !isEmpty</p>
<p>def isEmpty: Boolean = startIndex == endIndex</p>
<dl class="simple">
<dt>private[richtext] def enclosedIn(start: Int, end: Int): Boolean = {</dt><dd><p>start &lt;= startIndex &amp;&amp; endIndex &lt;= end</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private[richtext] def encloses(start: Int, end: Int): Boolean = {</dt><dd><p>startIndex &lt; start &amp;&amp; end &lt; endIndex</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private[richtext] def endsBetween(start: Int, end: Int): Boolean = {</dt><dd><p>start &lt; endIndex &amp;&amp; endIndex &lt;= end &amp;&amp; startIndex &lt; start</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private[richtext] def offset(num: Int): TwitterTextRendererEntity[T] = {</dt><dd><p>copy(startIndex = startIndex + num, endIndex = endIndex + num)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private[richtext] def startsBetween(start: Int, end: Int): Boolean = {</dt><dd><p>startIndex &gt;= start &amp;&amp; startIndex &lt; end &amp;&amp; endIndex &gt; end</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../../../../../../_sources/product-mixer/component-library/src/main/scala/com/twitter/product_mixer/component_library/decorator/urt/builder/richtext/twitter_text/TwitterTextRenderer.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>