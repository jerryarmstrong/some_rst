<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../../../" id="documentation_options" src="../../../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.product_mixer.core.service.candidate_feature_hydrator_executor</p>
<p>import com.twitter.finagle.stats.StatsReceiver
import com.twitter.product_mixer.core.feature.Feature
import com.twitter.product_mixer.core.feature.featuremap.FeatureMap
import com.twitter.product_mixer.core.functional_component.feature_hydrator.BaseBulkCandidateFeatureHydrator
import com.twitter.product_mixer.core.functional_component.feature_hydrator.BaseCandidateFeatureHydrator
import com.twitter.product_mixer.core.functional_component.feature_hydrator.CandidateFeatureHydrator
import com.twitter.product_mixer.core.functional_component.feature_hydrator.HydratorCandidateResult
import com.twitter.product_mixer.core.functional_component.feature_hydrator.featurestorev1.FeatureStoreV1CandidateFeatureHydrator
import com.twitter.product_mixer.core.model.common.CandidateWithFeatures
import com.twitter.product_mixer.core.model.common.Conditionally
import com.twitter.product_mixer.core.model.common.UniversalNoun
import com.twitter.product_mixer.core.pipeline.PipelineQuery
import com.twitter.product_mixer.core.pipeline.pipeline_failure.MisconfiguredFeatureMapFailure
import com.twitter.product_mixer.core.pipeline.pipeline_failure.PipelineFailure
import com.twitter.product_mixer.core.service.Executor
import com.twitter.product_mixer.core.service.Executor._
import com.twitter.product_mixer.core.service.candidate_feature_hydrator_executor.CandidateFeatureHydratorExecutor.Inputs
import com.twitter.product_mixer.core.service.feature_hydrator_observer.FeatureHydratorObserver
import com.twitter.stitch.Arrow
import com.twitter.util.Try
import javax.inject.Inject
import javax.inject.Singleton</p>
<p>&#64;Singleton
class CandidateFeatureHydratorExecutor &#64;Inject() (override val statsReceiver: StatsReceiver)</p>
<blockquote>
<div><blockquote>
<div><p>extends Executor {</p>
</div></blockquote>
<dl>
<dt>def arrow[Query &lt;: PipelineQuery, Result &lt;: UniversalNoun[Any]](</dt><dd><p>hydrators: Seq[BaseCandidateFeatureHydrator[Query, Result, _]],
context: Executor.Context</p>
</dd>
<dt>): Arrow[</dt><dd><p>Inputs[Query, Result],
CandidateFeatureHydratorExecutorResult[</p>
<blockquote>
<div><p>Result</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>] = {</p>
<blockquote>
<div><p>val observer = new FeatureHydratorObserver(statsReceiver, hydrators, context)</p>
<dl class="simple">
<dt>val candidateFeatureHydratorExecutorResults: Seq[Arrow[</dt><dd><p>Inputs[Query, Result],
CandidateFeatureHydratorExecutorResult[Result]</p>
</dd>
</dl>
<p>]] = hydrators.map(getCandidateHydratorArrow(_, context, observer))</p>
<dl>
<dt>val runHydrators = Arrow.collect(candidateFeatureHydratorExecutorResults).map {</dt><dd><dl>
<dt>candidateFeatureHydratorExecutorResult: Seq[CandidateFeatureHydratorExecutorResult[Result]] =&gt;</dt><dd><dl>
<dt>candidateFeatureHydratorExecutorResult.foldLeft(</dt><dd><dl class="simple">
<dt>CandidateFeatureHydratorExecutorResult[Result](</dt><dd><p>Seq.empty,
Map.empty</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>) { (accumulator, additionalResult) =&gt;</dt><dd><p>// accumulator.results and additionalResults.results are either the same length or one may be empty
// checks in each Hydrator’s Arrow implementation ensure the ordering and length are correct
val mergedFeatureMaps =</p>
<blockquote>
<div><dl>
<dt>if (accumulator.results.length == additionalResult.results.length) {</dt><dd><p>// merge if there are results for both and they are the same size
// also handles both being empty
accumulator.results.zip(additionalResult.results).map {</p>
<blockquote>
<div><dl>
<dt>case (accumulatedScoredCandidate, resultScoredCandidate) =&gt;</dt><dd><dl class="simple">
<dt>val updatedFeatureMap =</dt><dd><p>accumulatedScoredCandidate.features ++ resultScoredCandidate.features</p>
</dd>
</dl>
<p>HydratorCandidateResult(resultScoredCandidate.candidate, updatedFeatureMap)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
<dt>} else if (accumulator.results.isEmpty) {</dt><dd><p>// accumulator is empty (the initial case) so use additional results
additionalResult.results</p>
</dd>
<dt>} else {</dt><dd><p>// empty results but non-empty accumulator due to Hydrator being turned off so use accumulator results
accumulator.results</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>CandidateFeatureHydratorExecutorResult(</dt><dd><p>mergedFeatureMaps,
accumulator.individualFeatureHydratorResults ++ additionalResult.individualFeatureHydratorResults</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>Arrow.ifelse[Inputs[Query, Result], CandidateFeatureHydratorExecutorResult[Result]](</dt><dd><p>_.candidates.nonEmpty,
runHydrators,
Arrow.value(CandidateFeatureHydratorExecutorResult(Seq.empty, Map.empty)))</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>/** &#64;note the returned [[Arrow]] must have a result for every candidate passed into it in the same order OR a completely empty result <a href="#id1"><span class="problematic" id="id2">*</span></a>/
private def getCandidateHydratorArrow[Query &lt;: PipelineQuery, Result &lt;: UniversalNoun[Any]](</p>
<blockquote>
<div><p>hydrator: BaseCandidateFeatureHydrator[Query, Result, _],
context: Executor.Context,
candidateFeatureHydratorObserver: FeatureHydratorObserver</p>
</div></blockquote>
<dl>
<dt>): Arrow[</dt><dd><p>Inputs[Query, Result],
CandidateFeatureHydratorExecutorResult[Result]</p>
</dd>
<dt>] = {</dt><dd><p>val componentExecutorContext = context.pushToComponentStack(hydrator.identifier)</p>
<dl>
<dt>val validateFeatureMapFn: FeatureMap =&gt; FeatureMap =</dt><dd><dl>
<dt>hydrator match {</dt><dd><p>// Feature store candidate hydrators store the resulting PredictionRecords and
// not the features, so we cannot validate the same way
case _: FeatureStoreV1CandidateFeatureHydrator[Query, Result] =&gt;</p>
<blockquote>
<div><p>identity</p>
</div></blockquote>
<dl class="simple">
<dt>case _ =&gt;</dt><dd><dl class="simple">
<dt>validateFeatureMap(</dt><dd><p>hydrator.features.asInstanceOf[Set[Feature[_, _]]],
_,
componentExecutorContext)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>val hydratorBaseArrow = hydrator match {</dt><dd><dl class="simple">
<dt>case hydrator: CandidateFeatureHydrator[Query, Result] =&gt;</dt><dd><dl class="simple">
<dt>singleCandidateHydratorArrow(</dt><dd><p>hydrator,
validateFeatureMapFn,
componentExecutorContext,
parentContext = context)</p>
</dd>
</dl>
</dd>
<dt>case hydrator: BaseBulkCandidateFeatureHydrator[Query, Result, _] =&gt;</dt><dd><dl class="simple">
<dt>bulkCandidateHydratorArrow(</dt><dd><p>hydrator,
validateFeatureMapFn,
componentExecutorContext,
parentContext = context)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val candidateFeatureHydratorArrow =</dt><dd><dl>
<dt>Arrow</dt><dd><p>.zipWithArg(hydratorBaseArrow)
.map {</p>
<blockquote>
<div><dl>
<dt>case (</dt><dd><blockquote>
<div><p>arg: CandidateFeatureHydratorExecutor.Inputs[Query, Result],
featureMapSeq: Seq[FeatureMap]) =&gt;</p>
</div></blockquote>
<p>val candidates = arg.candidates.map(_.candidate)</p>
<dl class="simple">
<dt>candidateFeatureHydratorObserver.observeFeatureSuccessAndFailures(</dt><dd><p>hydrator,
featureMapSeq)</p>
</dd>
</dl>
<p>// Build a map from candidate to FeatureMap
val candidateAndFeatureMaps = if (candidates.size == featureMapSeq.size) {</p>
<blockquote>
<div><dl class="simple">
<dt>candidates.zip(featureMapSeq).map {</dt><dd><p>case (candidate, featureMap) =&gt; HydratorCandidateResult(candidate, featureMap)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><dl class="simple">
<dt>throw PipelineFailure(</dt><dd><p>MisconfiguredFeatureMapFailure,
s”Unexpected response length from ${hydrator.identifier}, ensure hydrator returns feature map for all candidates”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
val individualFeatureHydratorFeatureMaps =</p>
<blockquote>
<div><p>Map(hydrator.identifier -&gt; IndividualFeatureHydratorResult(candidateAndFeatureMaps))</p>
</div></blockquote>
<dl class="simple">
<dt>CandidateFeatureHydratorExecutorResult(</dt><dd><p>candidateAndFeatureMaps,
individualFeatureHydratorFeatureMaps)</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
<dt>val conditionallyRunArrow = hydrator match {</dt><dd><dl>
<dt>case hydrator: BaseCandidateFeatureHydrator[Query, Result, _] with Conditionally[</dt><dd><blockquote>
<div><blockquote>
<div><p>Query &#64;unchecked</p>
</div></blockquote>
<p>] =&gt;</p>
</div></blockquote>
<dl>
<dt>Arrow.ifelse[Inputs[Query, Result], CandidateFeatureHydratorExecutorResult[Result]](</dt><dd><p>{ case Inputs(query: Query &#64;unchecked, _) =&gt; hydrator.onlyIf(query) },
candidateFeatureHydratorArrow,
Arrow.value(</p>
<blockquote>
<div><dl class="simple">
<dt>CandidateFeatureHydratorExecutorResult(</dt><dd><p>Seq.empty,
Map(hydrator.identifier -&gt; FeatureHydratorDisabled[Result]())</p>
</dd>
</dl>
<p>))</p>
</div></blockquote>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>case _ =&gt; candidateFeatureHydratorArrow</p>
</dd>
</dl>
<p>}</p>
<p>wrapWithErrorHandling(context, hydrator.identifier)(conditionallyRunArrow)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def singleCandidateHydratorArrow[Query &lt;: PipelineQuery, Result &lt;: UniversalNoun[Any]](</dt><dd><p>hydrator: CandidateFeatureHydrator[Query, Result],
validateFeatureMap: FeatureMap =&gt; FeatureMap,
componentContext: Context,
parentContext: Context</p>
</dd>
<dt>): Arrow[Inputs[Query, Result], Seq[FeatureMap]] = {</dt><dd><dl>
<dt>val inputTransformer = Arrow</dt><dd><dl>
<dt>.map { inputs: Inputs[Query, Result] =&gt;</dt><dd><dl class="simple">
<dt>inputs.candidates.map { candidate =&gt;</dt><dd><p>(inputs.query, candidate.candidate, candidate.features)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>val hydratorArrow = Arrow</dt><dd><dl class="simple">
<dt>.flatMap[(Query, Result, FeatureMap), FeatureMap] {</dt><dd><dl class="simple">
<dt>case (query, candidate, featureMap) =&gt;</dt><dd><p>hydrator.apply(query, candidate, featureMap)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>// validate before observing so validation failures are caught in the metrics
val hydratorArrowWithValidation = hydratorArrow.map(validateFeatureMap)</p>
<p>// no tracing here since per-Component spans is overkill
val observedArrow =</p>
<blockquote>
<div><dl class="simple">
<dt>wrapPerCandidateComponentWithExecutorBookkeepingWithoutTracing(</dt><dd><p>parentContext,
hydrator.identifier</p>
</dd>
</dl>
<p>)(hydratorArrowWithValidation)</p>
</div></blockquote>
<p>// only handle non-validation failures
val liftNonValidationFailuresToFailedFeatures = Arrow.handle[FeatureMap, FeatureMap] {</p>
<blockquote>
<div><dl class="simple">
<dt>case NotAMisconfiguredFeatureMapFailure(e) =&gt;</dt><dd><p>featureMapWithFailuresForFeatures(hydrator.features, e, componentContext)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl>
<dt>wrapComponentsWithTracingOnly(parentContext, hydrator.identifier)(</dt><dd><dl class="simple">
<dt>inputTransformer.andThen(</dt><dd><p>Arrow.sequence(observedArrow.andThen(liftNonValidationFailuresToFailedFeatures))</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def bulkCandidateHydratorArrow[Query &lt;: PipelineQuery, Result &lt;: UniversalNoun[Any]](</dt><dd><p>hydrator: BaseBulkCandidateFeatureHydrator[Query, Result, _],
validateFeatureMap: FeatureMap =&gt; FeatureMap,
componentContext: Context,
parentContext: Context</p>
</dd>
<dt>): Arrow[Inputs[Query, Result], Seq[FeatureMap]] = {</dt><dd><dl>
<dt>val hydratorArrow: Arrow[Inputs[Query, Result], Seq[FeatureMap]] =</dt><dd><dl class="simple">
<dt>Arrow.flatMap { inputs =&gt;</dt><dd><p>hydrator.apply(inputs.query, inputs.candidates)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>val validationArrow: Arrow[(Inputs[Query, Result], Seq[FeatureMap]), Seq[FeatureMap]] = Arrow</dt><dd><dl>
<dt>.map[(Inputs[Query, Result], Seq[FeatureMap]), Seq[FeatureMap]] {</dt><dd><dl>
<dt>case (inputs, results) =&gt;</dt><dd><p>// For bulk APIs, this ensures no candidates are omitted and also ensures the order is preserved.
if (inputs.candidates.length != results.length) {</p>
<blockquote>
<div><dl class="simple">
<dt>throw PipelineFailure(</dt><dd><p>MisconfiguredFeatureMapFailure,
s”Unexpected response from ${hydrator.identifier}, ensure hydrator returns features for all candidates. Missing results for ${inputs.candidates.length - results.length} candidates”</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>}</p>
<p>results.map(validateFeatureMap)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>// validate before observing so validation failures are caught in the metrics
val hydratorArrowWithValidation: Arrow[Inputs[Query, Result], Seq[FeatureMap]] =</p>
<blockquote>
<div><p>Arrow.zipWithArg(hydratorArrow).andThen(validationArrow)</p>
</div></blockquote>
<dl class="simple">
<dt>val observedArrow =</dt><dd><dl class="simple">
<dt>wrapComponentWithExecutorBookkeeping(parentContext, hydrator.identifier)(</dt><dd><p>hydratorArrowWithValidation)</p>
</dd>
</dl>
</dd>
</dl>
<p>// only handle non-validation failures
val liftNonValidationFailuresToFailedFeatures =</p>
<blockquote>
<div><dl>
<dt>Arrow.map[(Inputs[Query, Result], Try[Seq[FeatureMap]]), Try[Seq[FeatureMap]]] {</dt><dd><dl>
<dt>case (inputs, resultTry) =&gt;</dt><dd><dl>
<dt>resultTry.handle {</dt><dd><dl>
<dt>case NotAMisconfiguredFeatureMapFailure(e) =&gt;</dt><dd><dl class="simple">
<dt>val errorFeatureMap =</dt><dd><dl class="simple">
<dt>featureMapWithFailuresForFeatures(</dt><dd><p>hydrator.features.asInstanceOf[Set[Feature[_, _]]],
e,
componentContext)</p>
</dd>
</dl>
</dd>
</dl>
<p>inputs.candidates.map(_ =&gt; errorFeatureMap)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>Arrow</dt><dd><p>.zipWithArg(observedArrow.liftToTry)
.andThen(liftNonValidationFailuresToFailedFeatures)
.lowerFromTry</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>object CandidateFeatureHydratorExecutor {</dt><dd><dl class="simple">
<dt>case class Inputs[+Query &lt;: PipelineQuery, Candidate &lt;: UniversalNoun[Any]](</dt><dd><p>query: Query,
candidates: Seq[CandidateWithFeatures[Candidate]])</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../../../_sources/product-mixer/core/src/main/scala/com/twitter/product_mixer/core/service/candidate_feature_hydrator_executor/CandidateFeatureHydratorExecutor.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>