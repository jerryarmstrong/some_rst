<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.visibility.interfaces.tweets</p>
<p>import com.twitter.decider.Decider
import com.twitter.featureswitches.v2.FeatureSwitches
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.mediaservices.media_util.GenericMediaKey
import com.twitter.servo.util.Gate
import com.twitter.stitch.Stitch
import com.twitter.strato.client.{Client =&gt; StratoClient}
import com.twitter.util.Stopwatch
import com.twitter.visibility.VisibilityLibrary
import com.twitter.visibility.builder.VerdictLogger
import com.twitter.visibility.builder.VisibilityResult
import com.twitter.visibility.builder.common.MutedKeywordFeatures
import com.twitter.visibility.builder.media._
import com.twitter.visibility.builder.tweets.TweetVisibilityNudgeSourceWrapper
import com.twitter.visibility.builder.tweets._
import com.twitter.visibility.builder.users.AuthorFeatures
import com.twitter.visibility.builder.users.RelationshipFeatures
import com.twitter.visibility.builder.users.ViewerFeatures
import com.twitter.visibility.builder.users.ViewerSearchSafetyFeatures
import com.twitter.visibility.builder.users.ViewerSensitiveMediaSettingsFeatures
import com.twitter.visibility.common._
import com.twitter.visibility.common.actions.LimitedAction
import com.twitter.visibility.common.actions.LimitedActionType
import com.twitter.visibility.common.actions.LimitedActionsPolicy
import com.twitter.visibility.rules.ComposableActions._
import com.twitter.visibility.configapi.configs.VisibilityDeciderGates
import com.twitter.visibility.features.TweetIsInnerQuotedTweet
import com.twitter.visibility.features.TweetIsRetweet
import com.twitter.visibility.features.TweetIsSourceTweet
import com.twitter.visibility.generators.LocalizedInterstitialGenerator
import com.twitter.visibility.generators.TombstoneGenerator
import com.twitter.visibility.interfaces.tweets.enrichments.ComplianceTweetNoticeEnrichment
import com.twitter.visibility.interfaces.tweets.enrichments.LimitedActionsPolicyEnrichment
import com.twitter.visibility.interfaces.tweets.enrichments.TweetVisibilityNudgeEnrichment
import com.twitter.visibility.logging.thriftscala.VFLibType
import com.twitter.visibility.models.ContentId.TweetId
import com.twitter.visibility.models.SafetyLevel
import com.twitter.visibility.models.SafetyLevel.toThrift
import com.twitter.visibility.rules._</p>
<dl>
<dt>object TweetVisibilityLibrary {</dt><dd><p>type Type = TweetVisibilityRequest =&gt; Stitch[VisibilityResult]</p>
<dl>
<dt>def apply(</dt><dd><p>visibilityLibrary: VisibilityLibrary,
userSource: UserSource,
userRelationshipSource: UserRelationshipSource,
keywordMatcher: KeywordMatcher.Matcher,
invitedToConversationRepo: InvitedToConversationRepo,
decider: Decider,
stratoClient: StratoClient,
localizationSource: LocalizationSource,
tweetPerspectiveSource: TweetPerspectiveSource,
tweetMediaMetadataSource: TweetMediaMetadataSource,
tombstoneGenerator: TombstoneGenerator,
interstitialGenerator: LocalizedInterstitialGenerator,
limitedActionsFeatureSwitches: FeatureSwitches,
enableParityTest: Gate[Unit] = Gate.False</p>
</dd>
<dt>): Type = {</dt><dd><p>val libraryStatsReceiver = visibilityLibrary.statsReceiver
val stratoClientStatsReceiver = visibilityLibrary.statsReceiver.scope(“strato”)
val vfEngineCounter = libraryStatsReceiver.counter(“vf_engine_requests”)
val vfLatencyOverallStat = libraryStatsReceiver.stat(“vf_latency_overall”)
val vfLatencyStitchBuildStat = libraryStatsReceiver.stat(“vf_latency_stitch_build”)
val vfLatencyStitchRunStat = libraryStatsReceiver.stat(“vf_latency_stitch_run”)
val visibilityDeciderGates = VisibilityDeciderGates(decider)
val verdictLogger =</p>
<blockquote>
<div><dl class="simple">
<dt>createVerdictLogger(</dt><dd><p>visibilityDeciderGates.enableVerdictLoggerTVL,
decider,
libraryStatsReceiver)</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>val tweetLabelMaps = new StratoTweetLabelMaps(</dt><dd><p>SafetyLabelMapSource.fromStrato(stratoClient, stratoClientStatsReceiver))</p>
</dd>
<dt>val mediaLabelMaps = new StratoMediaLabelMaps(</dt><dd><p>MediaSafetyLabelMapSource.fromStrato(stratoClient, stratoClientStatsReceiver))</p>
</dd>
</dl>
<p>val tweetFeatures = new TweetFeatures(tweetLabelMaps, libraryStatsReceiver)
val tweetPerspectiveFeatures =</p>
<blockquote>
<div><p>new TweetPerspectiveFeatures(tweetPerspectiveSource, libraryStatsReceiver)</p>
</div></blockquote>
<p>val mediaFeatures = new MediaFeatures(mediaLabelMaps, libraryStatsReceiver)
val tweetMediaMetadataFeatures =</p>
<blockquote>
<div><p>new TweetMediaMetadataFeatures(tweetMediaMetadataSource, libraryStatsReceiver)</p>
</div></blockquote>
<p>val authorFeatures = new AuthorFeatures(userSource, libraryStatsReceiver)
val viewerFeatures = new ViewerFeatures(userSource, libraryStatsReceiver)
val mutedKeywordFeatures =</p>
<blockquote>
<div><dl class="simple">
<dt>new MutedKeywordFeatures(</dt><dd><p>userSource,
userRelationshipSource,
keywordMatcher,
libraryStatsReceiver,
visibilityDeciderGates.enableFollowCheckInMutedKeyword</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>val relationshipFeatures =</dt><dd><p>new RelationshipFeatures(userRelationshipSource, libraryStatsReceiver)</p>
</dd>
<dt>val fonsrRelationshipFeatures =</dt><dd><dl class="simple">
<dt>new FosnrRelationshipFeatures(</dt><dd><p>tweetLabels = tweetLabelMaps,
userRelationshipSource = userRelationshipSource,
statsReceiver = libraryStatsReceiver)</p>
</dd>
</dl>
</dd>
<dt>val conversationControlFeatures =</dt><dd><dl class="simple">
<dt>new ConversationControlFeatures(</dt><dd><p>relationshipFeatures,
invitedToConversationRepo,
libraryStatsReceiver</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val exclusiveTweetFeatures =</dt><dd><p>new ExclusiveTweetFeatures(userRelationshipSource, libraryStatsReceiver)</p>
</dd>
<dt>val viewerSearchSafetyFeatures = new ViewerSearchSafetyFeatures(</dt><dd><p>UserSearchSafetySource.fromStrato(stratoClient, stratoClientStatsReceiver),
libraryStatsReceiver)</p>
</dd>
<dt>val viewerSensitiveMediaSettingsFeatures = new ViewerSensitiveMediaSettingsFeatures(</dt><dd><p>UserSensitiveMediaSettingsSource.fromStrato(stratoClient, stratoClientStatsReceiver),
libraryStatsReceiver)</p>
</dd>
</dl>
<p>val toxicReplyFilterFeature = new ToxicReplyFilterFeature(statsReceiver = libraryStatsReceiver)</p>
<dl>
<dt>val misinfoPolicySource =</dt><dd><p>MisinformationPolicySource.fromStrato(stratoClient, stratoClientStatsReceiver)</p>
</dd>
<dt>val misinfoPolicyFeatures =</dt><dd><p>new MisinformationPolicyFeatures(misinfoPolicySource, stratoClientStatsReceiver)</p>
</dd>
<dt>val communityTweetFeatures = new CommunityTweetFeaturesV2(</dt><dd><dl class="simple">
<dt>communitiesSource = CommunitiesSource.fromStrato(</dt><dd><p>stratoClient,
stratoClientStatsReceiver</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>val trustedFriendsTweetFeatures = new TrustedFriendsFeatures(</dt><dd><dl class="simple">
<dt>trustedFriendsSource =</dt><dd><p>TrustedFriendsSource.fromStrato(stratoClient, stratoClientStatsReceiver))</p>
</dd>
</dl>
</dd>
</dl>
<p>val editTweetFeatures = new EditTweetFeatures(libraryStatsReceiver)</p>
<p>val parityTest = new TweetVisibilityLibraryParityTest(libraryStatsReceiver, stratoClient)</p>
<dl>
<dt>val localizedNudgeSource =</dt><dd><p>LocalizedNudgeSource.fromLocalizationSource(localizationSource)</p>
</dd>
<dt>val tweetVisibilityNudgeFeatures =</dt><dd><p>new TweetVisibilityNudgeSourceWrapper(localizedNudgeSource)</p>
</dd>
<dt>val localizedLimitedActionsSource =</dt><dd><p>LocalizedLimitedActionsSource.fromLocalizationSource(localizationSource)</p>
</dd>
<dt>{ r: TweetVisibilityRequest =&gt;</dt><dd><p>val elapsed = Stopwatch.start()
var runStitchStartMs = 0L
vfEngineCounter.incr()</p>
<p>val contentId = TweetId(r.tweet.id)
val viewerId = r.viewerContext.userId
val authorId = coreData.userId
val tweetGenericMediaKeys = r.tweet.mediaRefs</p>
<blockquote>
<div><p>.getOrElse(Seq.empty)
.flatMap { mediaRef =&gt;</p>
<blockquote>
<div><p>GenericMediaKey.fromStringKey(mediaRef.genericMediaKey)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<dl>
<dt>val tpf =</dt><dd><dl class="simple">
<dt>tweetPerspectiveFeatures.forTweet(</dt><dd><p>r.tweet,
viewerId,
visibilityDeciderGates.enableFetchTweetReportedPerspective())</p>
</dd>
</dl>
</dd>
<dt>val featureMap =</dt><dd><dl>
<dt>visibilityLibrary.featureMapBuilder(</dt><dd><dl>
<dt>Seq(</dt><dd><p>mutedKeywordFeatures.forTweet(r.tweet, viewerId, authorId),
viewerFeatures.forViewerContext(r.viewerContext),
viewerSearchSafetyFeatures.forViewerId(viewerId),
viewerSensitiveMediaSettingsFeatures.forViewerId(viewerId),
relationshipFeatures.forAuthorId(authorId, viewerId),
fonsrRelationshipFeatures</p>
<blockquote>
<div><p>.forTweetAndAuthorId(tweet = r.tweet, authorId = authorId, viewerId = viewerId),</p>
</div></blockquote>
<p>tweetFeatures.forTweet(r.tweet),
tpf,
mediaFeatures.forMediaKeys(tweetGenericMediaKeys),
authorFeatures.forAuthorId(authorId),
conversationControlFeatures.forTweet(r.tweet, viewerId),
_.withConstantFeature(TweetIsInnerQuotedTweet, r.isInnerQuotedTweet),
_.withConstantFeature(TweetIsRetweet, r.isRetweet),
_.withConstantFeature(TweetIsSourceTweet, r.isSourceTweet),
misinfoPolicyFeatures.forTweet(r.tweet, r.viewerContext),
exclusiveTweetFeatures.forTweet(r.tweet, r.viewerContext),
communityTweetFeatures.forTweet(r.tweet, r.viewerContext),
tweetMediaMetadataFeatures</p>
<blockquote>
<div><dl class="simple">
<dt>.forTweet(</dt><dd><p>r.tweet,
tweetGenericMediaKeys,
visibilityDeciderGates.enableFetchTweetMediaMetadata()),</p>
</dd>
</dl>
</div></blockquote>
<p>trustedFriendsTweetFeatures.forTweet(r.tweet, viewerId),
editTweetFeatures.forTweet(r.tweet),
toxicReplyFilterFeature.forTweet(r.tweet, viewerId),</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>val languageCode = r.viewerContext.requestLanguageCode.getOrElse(“en”)
val countryCode = r.viewerContext.requestCountryCode</p>
<dl>
<dt>val response = visibilityLibrary</dt><dd><dl class="simple">
<dt>.runRuleEngine(</dt><dd><p>contentId,
featureMap,
r.viewerContext,
r.safetyLevel</p>
</dd>
</dl>
<p>)
.map(</p>
<blockquote>
<div><dl class="simple">
<dt>TweetVisibilityNudgeEnrichment(</dt><dd><p>_,
tweetVisibilityNudgeFeatures,
languageCode,
countryCode))</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>.map(verdict =&gt; {</dt><dd><dl class="simple">
<dt>if (visibilityDeciderGates.enableBackendLimitedActions()) {</dt><dd><dl class="simple">
<dt>LimitedActionsPolicyEnrichment(</dt><dd><p>verdict,
localizedLimitedActionsSource,
languageCode,
countryCode,
limitedActionsFeatureSwitches,
libraryStatsReceiver)</p>
</dd>
</dl>
</dd>
<dt>} else {</dt><dd><p>verdict</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>})
.map(</p>
<blockquote>
<div><dl class="simple">
<dt>handleComposableVisibilityResult(</dt><dd><p>_,
visibilityDeciderGates.enableMediaInterstitialComposition(),
visibilityDeciderGates.enableBackendLimitedActions()))</p>
</dd>
</dl>
</div></blockquote>
<p>.map(handleInnerQuotedTweetVisibilityResult(_, r.isInnerQuotedTweet))
.map(tombstoneGenerator(_, languageCode))
.map(interstitialGenerator(_, languageCode))
.map(ComplianceTweetNoticeEnrichment(_, libraryStatsReceiver))
.onSuccess(_ =&gt; {</p>
<blockquote>
<div><p>val overallStatMs = elapsed().inMilliseconds
vfLatencyOverallStat.add(overallStatMs)
val runStitchEndMs = elapsed().inMilliseconds
vfLatencyStitchRunStat.add(runStitchEndMs - runStitchStartMs)</p>
</div></blockquote>
<p>})
.onSuccess(</p>
<blockquote>
<div><dl class="simple">
<dt>scribeVisibilityVerdict(</dt><dd><p>_,
visibilityDeciderGates.enableVerdictScribingTVL,
verdictLogger,
r.viewerContext.userId,
r.safetyLevel))</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>runStitchStartMs = elapsed().inMilliseconds
val buildStitchStatMs = elapsed().inMilliseconds
vfLatencyStitchBuildStat.add(buildStitchStatMs)</p>
<dl>
<dt>if (enableParityTest()) {</dt><dd><dl class="simple">
<dt>response.applyEffect { resp =&gt;</dt><dd><p>Stitch.async(parityTest.runParityTest(r, resp))</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>response</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def handleComposableVisibilityResult(</dt><dd><p>result: VisibilityResult,
enableMediaInterstitialComposition: Boolean,
enableBackendLimitedActions: Boolean</p>
</dd>
<dt>): VisibilityResult = {</dt><dd><dl class="simple">
<dt>if (result.secondaryVerdicts.nonEmpty || enableBackendLimitedActions) {</dt><dd><dl class="simple">
<dt>result.copy(verdict = composeActions(</dt><dd><p>result.verdict,
result.secondaryVerdicts,
enableMediaInterstitialComposition,
enableBackendLimitedActions))</p>
</dd>
</dl>
</dd>
<dt>} else {</dt><dd><p>result</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def handleInnerQuotedTweetVisibilityResult(</dt><dd><p>result: VisibilityResult,
isInnerQuotedTweet: Boolean</p>
</dd>
<dt>): VisibilityResult = {</dt><dd><dl>
<dt>val newVerdict: Action =</dt><dd><dl>
<dt>result.verdict match {</dt><dd><dl>
<dt>case Interstitial(Reason.Nsfw | Reason.NsfwMedia, _, _) if isInnerQuotedTweet =&gt;</dt><dd><p>Drop(Reason.Nsfw)</p>
</dd>
<dt>case ComposableActionsWithInterstitial(tweetInterstitial)</dt><dd><blockquote>
<div><p>if isInnerQuotedTweet &amp;&amp; (tweetInterstitial.reason == Reason.Nsfw || tweetInterstitial.reason == Reason.NsfwMedia) =&gt;</p>
</div></blockquote>
<p>Drop(Reason.Nsfw)</p>
</dd>
</dl>
<p>case verdict =&gt; verdict</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>result.copy(verdict = newVerdict)</p>
</dd>
</dl>
<p>}</p>
<p>def hasTweetRules(safetyLevel: SafetyLevel): Boolean = RuleBase.hasTweetRules(safetyLevel)</p>
<dl>
<dt>def composeActions(</dt><dd><p>primary: Action,
secondary: Seq[Action],
enableMediaInterstitialComposition: Boolean,
enableBackendLimitedActions: Boolean</p>
</dd>
<dt>): Action = {</dt><dd><dl>
<dt>if (primary.isComposable &amp;&amp; (secondary.nonEmpty || enableBackendLimitedActions)) {</dt><dd><p>val actions = Seq[Action] { primary } ++ secondary
val interstitialOpt = Action.getFirstInterstitial(actions: _*)
val softInterventionOpt = Action.getFirstSoftIntervention(actions: _*)
val downrankOpt = Action.getFirstDownrankHomeTimeline(actions: _*)
val avoidOpt = Action.getFirstAvoid(actions: _*)
val tweetVisibilityNudgeOpt = Action.getFirstTweetVisibilityNudge(actions: _*)</p>
<dl>
<dt>val mediaInterstitialOpt = {</dt><dd><p>val firstMediaInterstitialOpt = Action.getFirstMediaInterstitial(actions: _*)
if (enableMediaInterstitialComposition &amp;&amp; interstitialOpt != firstMediaInterstitialOpt) {</p>
<blockquote>
<div><p>firstMediaInterstitialOpt</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val limitedEngagementsOpt = enableBackendLimitedActions match {</dt><dd><p>case true =&gt; buildCompositeLimitedEngagements(Action.getAllLimitedEngagements(actions: _*))
case false =&gt; Action.getFirstLimitedEngagements(actions: _*)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val abusiveQualityOpt = {</dt><dd><dl class="simple">
<dt>if (actions.contains(ConversationSectionAbusiveQuality)) {</dt><dd><p>Some(ConversationSectionAbusiveQuality)</p>
</dd>
<dt>} else {</dt><dd><p>None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val numActions =</dt><dd><dl class="simple">
<dt>Seq[Option[_]](</dt><dd><p>interstitialOpt,
softInterventionOpt,
limitedEngagementsOpt,
downrankOpt,
avoidOpt,
mediaInterstitialOpt,
tweetVisibilityNudgeOpt,
abusiveQualityOpt)
.count(_.isDefined)</p>
</dd>
</dl>
</dd>
<dt>if (numActions &gt; 1) {</dt><dd><dl class="simple">
<dt>TweetInterstitial(</dt><dd><p>interstitialOpt,
softInterventionOpt,
limitedEngagementsOpt,
downrankOpt,
avoidOpt,
mediaInterstitialOpt,
tweetVisibilityNudgeOpt,
abusiveQualityOpt</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>if (enableBackendLimitedActions) {</dt><dd><p>limitedEngagementsOpt.getOrElse(primary)</p>
</dd>
<dt>} else {</dt><dd><p>primary</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>primary</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def scribeVisibilityVerdict(</dt><dd><p>result: VisibilityResult,
enableVerdictScribing: Gate[Unit],
verdictLogger: VerdictLogger,
viewerId: Option[Long],
safetyLevel: SafetyLevel</p>
</dd>
<dt>): Unit = if (enableVerdictScribing()) {</dt><dd><dl class="simple">
<dt>verdictLogger.scribeVerdict(</dt><dd><p>visibilityResult = result,
viewerId = viewerId,
safetyLevel = toThrift(safetyLevel),
vfLibType = VFLibType.TweetVisibilityLibrary)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def buildCompositeLimitedEngagements(</dt><dd><p>limitedEngagements: Seq[IsLimitedEngagements]</p>
</dd>
<dt>): Option[LimitedEngagements] = {</dt><dd><dl>
<dt>limitedEngagements.headOption.flatMap { limitedEngagement =&gt;</dt><dd><dl>
<dt>val distinctLimitedActions = limitedEngagements</dt><dd><p>.collect({ case IsLimitedEngagements(Some(policy), _) =&gt; policy.limitedActions })
.flatten
.foldRight(Map.empty[LimitedActionType, LimitedAction])({ (limitedAction, acc) =&gt;</p>
<blockquote>
<div><p>acc + ((limitedAction.limitedActionType, limitedAction))</p>
</div></blockquote>
<p>})
.values
.toSeq</p>
</dd>
<dt>if (distinctLimitedActions.nonEmpty) {</dt><dd><p>val limitedActionsPolicy = Some(LimitedActionsPolicy(distinctLimitedActions))
Some(LimitedEngagements(limitedEngagement.getLimitedEngagementReason, limitedActionsPolicy))</p>
</dd>
<dt>} else {</dt><dd><p>None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def createVerdictLogger(</dt><dd><p>enableVerdictLogger: Gate[Unit],
decider: Decider,
statsReceiver: StatsReceiver</p>
</dd>
<dt>): VerdictLogger = {</dt><dd><dl class="simple">
<dt>if (enableVerdictLogger()) {</dt><dd><p>VerdictLogger(statsReceiver, decider)</p>
</dd>
<dt>} else {</dt><dd><p>VerdictLogger.Empty</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/visibilitylib/src/main/scala/com/twitter/visibility/interfaces/tweets/TweetVisibilityLibrary.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>