<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tsp.stores</p>
<p>import com.twitter.conversions.DurationOps._
import com.twitter.tsp.thriftscala.TspTweetInfo
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.frigate.thriftscala.TweetHealthScores
import com.twitter.frigate.thriftscala.UserAgathaScores
import com.twitter.logging.Logger
import com.twitter.mediaservices.commons.thriftscala.MediaCategory
import com.twitter.mediaservices.commons.tweetmedia.thriftscala.MediaInfo
import com.twitter.mediaservices.commons.tweetmedia.thriftscala.MediaSizeType
import com.twitter.simclusters_v2.common.TweetId
import com.twitter.simclusters_v2.common.UserId
import com.twitter.spam.rtf.thriftscala.SafetyLevel
import com.twitter.stitch.Stitch
import com.twitter.stitch.storehaus.ReadableStoreOfStitch
import com.twitter.stitch.tweetypie.TweetyPie
import com.twitter.stitch.tweetypie.TweetyPie.TweetyPieException
import com.twitter.storehaus.ReadableStore
import com.twitter.topiclisting.AnnotationRuleProvider
import com.twitter.tsp.utils.HealthSignalsUtils
import com.twitter.tweetypie.thriftscala.TweetInclude
import com.twitter.tweetypie.thriftscala.{Tweet =&gt; TTweet}
import com.twitter.tweetypie.thriftscala._
import com.twitter.util.Duration
import com.twitter.util.Future
import com.twitter.util.TimeoutException
import com.twitter.util.Timer</p>
<p>object TweetyPieFieldsStore {</p>
<blockquote>
<div><p>// Tweet fields options. Only fields specified here will be hydrated in the tweet
private val CoreTweetFields: Set[TweetInclude] = Set[TweetInclude](</p>
<blockquote>
<div><p>TweetInclude.TweetFieldId(TTweet.IdField.id),
TweetInclude.TweetFieldId(TTweet.CoreDataField.id), // needed for the authorId
TweetInclude.TweetFieldId(TTweet.LanguageField.id),
TweetInclude.CountsFieldId(StatusCounts.FavoriteCountField.id),
TweetInclude.CountsFieldId(StatusCounts.RetweetCountField.id),
TweetInclude.TweetFieldId(TTweet.QuotedTweetField.id),
TweetInclude.TweetFieldId(TTweet.MediaKeysField.id),
TweetInclude.TweetFieldId(TTweet.EscherbirdEntityAnnotationsField.id),
TweetInclude.TweetFieldId(TTweet.MediaField.id),
TweetInclude.TweetFieldId(TTweet.UrlsField.id)</p>
</div></blockquote>
<p>)</p>
<dl class="simple">
<dt>private val gtfo: GetTweetFieldsOptions = GetTweetFieldsOptions(</dt><dd><p>tweetIncludes = CoreTweetFields,
safetyLevel = Some(SafetyLevel.Recommendations)</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>def getStoreFromTweetyPie(</dt><dd><p>tweetyPie: TweetyPie,
convertExceptionsToNotFound: Boolean = true</p>
</dd>
<dt>): ReadableStore[Long, GetTweetFieldsResult] = {</dt><dd><p>val log = Logger(“TweetyPieFieldsStore”)</p>
<dl>
<dt>ReadableStoreOfStitch { tweetId: Long =&gt;</dt><dd><dl>
<dt>tweetyPie</dt><dd><p>.getTweetFields(tweetId, options = gtfo)
.rescue {</p>
<blockquote>
<div><dl class="simple">
<dt>case ex: TweetyPieException if convertExceptionsToNotFound =&gt;</dt><dd><p>log.error(ex, s”Error while hitting tweetypie ${ex.result}”)
Stitch.NotFound</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>object TweetInfoStore {</p>
<blockquote>
<div><p>case class IsPassTweetHealthFilters(tweetStrictest: Option[Boolean])</p>
<p>case class IsPassAgathaHealthFilters(agathaStrictest: Option[Boolean])</p>
<p>private val HealthStoreTimeout: Duration = 40.milliseconds
private val isPassTweetHealthFilters: IsPassTweetHealthFilters = IsPassTweetHealthFilters(None)
private val isPassAgathaHealthFilters: IsPassAgathaHealthFilters = IsPassAgathaHealthFilters(None)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>case class TweetInfoStore(</dt><dd><p>tweetFieldsStore: ReadableStore[TweetId, GetTweetFieldsResult],
tweetHealthModelStore: ReadableStore[TweetId, TweetHealthScores],
userHealthModelStore: ReadableStore[UserId, UserAgathaScores],
timer: Timer</p>
</dd>
<dt>)(</dt><dd><dl class="simple">
<dt>statsReceiver: StatsReceiver)</dt><dd><p>extends ReadableStore[TweetId, TspTweetInfo] {</p>
</dd>
</dl>
<p>import TweetInfoStore._</p>
<dl>
<dt>private[this] def toTweetInfo(</dt><dd><p>tweetFieldsResult: GetTweetFieldsResult</p>
</dd>
<dt>): Future[Option[TspTweetInfo]] = {</dt><dd><dl>
<dt>tweetFieldsResult.tweetResult match {</dt><dd><dl>
<dt>case result: TweetFieldsResultState.Found if result.found.suppressReason.isEmpty =&gt;</dt><dd><p>val tweet = result.found.tweet</p>
<p>val authorIdOpt = tweet.coreData.map(_.userId)
val favCountOpt = tweet.counts.flatMap(_.favoriteCount)</p>
<p>val languageOpt = tweet.language.map(_.language)
val hasImageOpt =</p>
<blockquote>
<div><p>tweet.mediaKeys.map(_.map(_.mediaCategory).exists(_ == MediaCategory.TweetImage))</p>
</div></blockquote>
<dl class="simple">
<dt>val hasGifOpt =</dt><dd><p>tweet.mediaKeys.map(_.map(_.mediaCategory).exists(_ == MediaCategory.TweetGif))</p>
</dd>
<dt>val isNsfwAuthorOpt = Some(</dt><dd><p>tweet.coreData.exists(_.nsfwUser) || tweet.coreData.exists(_.nsfwAdmin))</p>
</dd>
</dl>
<p>val isTweetReplyOpt = tweet.coreData.map(_.reply.isDefined)
val hasMultipleMediaOpt =</p>
<blockquote>
<div><p>tweet.mediaKeys.map(_.map(_.mediaCategory).size &gt; 1)</p>
</div></blockquote>
<dl class="simple">
<dt>val isKGODenylist = Some(</dt><dd><dl class="simple">
<dt>tweet.escherbirdEntityAnnotations</dt><dd><p>.exists(_.entityAnnotations.exists(AnnotationRuleProvider.isSuppressedTopicsDenylist)))</p>
</dd>
</dl>
</dd>
</dl>
<p>val isNullcastOpt = tweet.coreData.map(_.nullcast) // These are Ads. go/nullcast</p>
<dl>
<dt>val videoDurationOpt = tweet.media.flatMap(_.flatMap {</dt><dd><dl>
<dt>_.mediaInfo match {</dt><dd><dl class="simple">
<dt>case Some(MediaInfo.VideoInfo(info)) =&gt;</dt><dd><p>Some((info.durationMillis + 999) / 1000) // video playtime always round up</p>
</dd>
</dl>
<p>case _ =&gt; None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}.headOption)</p>
<p>// There many different types of videos. To be robust to new types being added, we just use
// the videoDurationOpt to keep track of whether the item has a video or not.
val hasVideo = videoDurationOpt.isDefined</p>
<dl class="simple">
<dt>val mediaDimensionsOpt =</dt><dd><dl class="simple">
<dt>tweet.media.flatMap(_.headOption.flatMap(</dt><dd><p>_.sizes.find(_.sizeType == MediaSizeType.Orig).map(size =&gt; (size.width, size.height))))</p>
</dd>
</dl>
</dd>
</dl>
<p>val mediaWidth = mediaDimensionsOpt.map(_._1).getOrElse(1)
val mediaHeight = mediaDimensionsOpt.map(_._2).getOrElse(1)
// high resolution media’s width is always greater than 480px and height is always greater than 480px
val isHighMediaResolution = mediaHeight &gt; 480 &amp;&amp; mediaWidth &gt; 480
val isVerticalAspectRatio = mediaHeight &gt;= mediaWidth &amp;&amp; mediaWidth &gt; 1
val hasUrlOpt = tweet.urls.map(_.nonEmpty)</p>
<dl>
<dt>(authorIdOpt, favCountOpt) match {</dt><dd><dl>
<dt>case (Some(authorId), Some(favCount)) =&gt;</dt><dd><dl>
<dt>hydrateHealthScores(tweet.id, authorId).map {</dt><dd><dl>
<dt>case (isPassAgathaHealthFilters, isPassTweetHealthFilters) =&gt;</dt><dd><dl>
<dt>Some(</dt><dd><dl class="simple">
<dt>TspTweetInfo(</dt><dd><p>authorId = authorId,
favCount = favCount,
language = languageOpt,
hasImage = hasImageOpt,
hasVideo = Some(hasVideo),
hasGif = hasGifOpt,
isNsfwAuthor = isNsfwAuthorOpt,
isKGODenylist = isKGODenylist,
isNullcast = isNullcastOpt,
videoDurationSeconds = videoDurationOpt,
isHighMediaResolution = Some(isHighMediaResolution),
isVerticalAspectRatio = Some(isVerticalAspectRatio),
isPassAgathaHealthFilterStrictest = isPassAgathaHealthFilters.agathaStrictest,
isPassTweetHealthFilterStrictest = isPassTweetHealthFilters.tweetStrictest,
isReply = isTweetReplyOpt,
hasMultipleMedia = hasMultipleMediaOpt,
hasUrl = hasUrlOpt</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>statsReceiver.counter(“missingFields”).incr()
Future.None // These values should always exist.</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>case _: TweetFieldsResultState.NotFound =&gt;</dt><dd><p>statsReceiver.counter(“notFound”).incr()
Future.None</p>
</dd>
<dt>case _: TweetFieldsResultState.Failed =&gt;</dt><dd><p>statsReceiver.counter(“failed”).incr()
Future.None</p>
</dd>
<dt>case _: TweetFieldsResultState.Filtered =&gt;</dt><dd><p>statsReceiver.counter(“filtered”).incr()
Future.None</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>statsReceiver.counter(“unknown”).incr()
Future.None</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private[this] def hydrateHealthScores(</dt><dd><p>tweetId: TweetId,
authorId: Long</p>
</dd>
<dt>): Future[(IsPassAgathaHealthFilters, IsPassTweetHealthFilters)] = {</dt><dd><dl>
<dt>Future</dt><dd><dl>
<dt>.join(</dt><dd><dl class="simple">
<dt>tweetHealthModelStore</dt><dd><p>.multiGet(Set(tweetId))(tweetId),</p>
</dd>
<dt>userHealthModelStore</dt><dd><p>.multiGet(Set(authorId))(authorId)</p>
</dd>
</dl>
</dd>
<dt>).map {</dt><dd><dl>
<dt>case (tweetHealthScoresOpt, userAgathaScoresOpt) =&gt;</dt><dd><p>// This stats help us understand empty rate for AgathaCalibratedNsfw / NsfwTextUserScore
statsReceiver.counter(“totalCountAgathaScore”).incr()
if (userAgathaScoresOpt.getOrElse(UserAgathaScores()).agathaCalibratedNsfw.isEmpty)</p>
<blockquote>
<div><p>statsReceiver.counter(“emptyCountAgathaCalibratedNsfw”).incr()</p>
</div></blockquote>
<dl class="simple">
<dt>if (userAgathaScoresOpt.getOrElse(UserAgathaScores()).nsfwTextUserScore.isEmpty)</dt><dd><p>statsReceiver.counter(“emptyCountNsfwTextUserScore”).incr()</p>
</dd>
<dt>val isPassAgathaHealthFilters = IsPassAgathaHealthFilters(</dt><dd><dl class="simple">
<dt>agathaStrictest =</dt><dd><p>Some(HealthSignalsUtils.isTweetAgathaModelQualified(userAgathaScoresOpt)),</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>val isPassTweetHealthFilters = IsPassTweetHealthFilters(</dt><dd><dl class="simple">
<dt>tweetStrictest =</dt><dd><p>Some(HealthSignalsUtils.isTweetHealthModelQualified(tweetHealthScoresOpt))</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
<p>(isPassAgathaHealthFilters, isPassTweetHealthFilters)</p>
</dd>
</dl>
</dd>
<dt>}.raiseWithin(HealthStoreTimeout)(timer).rescue {</dt><dd><dl class="simple">
<dt>case _: TimeoutException =&gt;</dt><dd><p>statsReceiver.counter(“hydrateHealthScoreTimeout”).incr()
Future.value((isPassAgathaHealthFilters, isPassTweetHealthFilters))</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>statsReceiver.counter(“hydrateHealthScoreFailure”).incr()
Future.value((isPassAgathaHealthFilters, isPassTweetHealthFilters))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def multiGet[K1 &lt;: TweetId](ks: Set[K1]): Map[K1, Future[Option[TspTweetInfo]]] = {</dt><dd><p>statsReceiver.counter(“tweetFieldsStore”).incr(ks.size)
tweetFieldsStore</p>
<blockquote>
<div><p>.multiGet(ks).mapValues(_.flatMap { _.map { v =&gt; toTweetInfo(v) }.getOrElse(Future.None) })</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/topic-social-proof/server/src/main/scala/com/twitter/tsp/stores/TweetInfoStore.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>