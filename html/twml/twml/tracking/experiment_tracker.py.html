<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>“””
This module contains the experiment tracker for tracking training in ML Metastore
“””
from contextlib import contextmanager
from datetime import datetime
import getpass
import hashlib
import os
import re
import sys
import time</p>
<p>from absl import logging
import tensorflow.compat.v1 as tf
from twml.hooks import MetricsUpdateHook</p>
<dl>
<dt>try:</dt><dd><p>from urllib import quote as encode_url</p>
</dd>
<dt>except ImportError:</dt><dd><p>from urllib.parse import quote as encode_url</p>
</dd>
<dt>try:</dt><dd><p># ML Metastore packages might not be available on GCP.
# If they are not found, tracking is disabled
import requests
from com.twitter.mlmetastore.modelrepo.client import ModelRepoClient
from com.twitter.mlmetastore.modelrepo.core.path import (</p>
<blockquote>
<div><p>check_valid_id, get_components_from_id, generate_id)</p>
</div></blockquote>
<dl class="simple">
<dt>from com.twitter.mlmetastore.modelrepo.core import (</dt><dd><p>DeepbirdRun, Experiment, FeatureConfig, FeatureConfigFeature, Model, ProgressReport, Project, StatusUpdate)</p>
</dd>
</dl>
</dd>
<dt>except ImportError:</dt><dd><p>ModelRepoClient = None</p>
</dd>
<dt>class ExperimentTracker(object):</dt><dd><p>“””
A tracker that records twml runs in ML Metastore.
“””</p>
<dl>
<dt>def __init__(self, params, run_config, save_dir):</dt><dd><p>“””</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>params (python dict):</dt><dd><p>The trainer params. ExperimentTracker uses <cite>params.experiment_tracking_path</cite> (String) and
<cite>params.disable_experiment_tracking</cite>.
If <cite>experiment_tracking_path</cite> is set to None, the tracker tries to guess a path with
save_dir.
If <cite>disable_experiment_tracking</cite> is True, the tracker is disabled.</p>
</dd>
<dt>run_config (tf.estimator.RunConfig):</dt><dd><p>The run config used by the estimator.</p>
</dd>
<dt>save_dir (str):</dt><dd><p>save_dir of the trainer</p>
</dd>
</dl>
</dd>
</dl>
<p>“””
if isinstance(params, dict):</p>
<blockquote>
<div><p>self._params = params</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p># preserving backward compatibility for people still using HParams
logging.warning(“Please stop using HParams and use python dicts. HParams are removed in TF 2”)
self._params = dict((k, v) for k, v in params.values().items() if v != ‘null’)</p>
</dd>
</dl>
<p>self._run_config = run_config
self._graceful_shutdown_port = self._params.get(‘health_port’)</p>
<p>self.tracking_path = self._params.get(‘experiment_tracking_path’)
is_tracking_path_too_long = self.tracking_path is not None and len(self.tracking_path) &gt; 256</p>
<dl class="simple">
<dt>if is_tracking_path_too_long:</dt><dd><p>raise ValueError(“Experiment Tracking Path longer than 256 characters”)</p>
</dd>
<dt>self.disabled = (</dt><dd><p>self._params.get(‘disable_experiment_tracking’, False) or
not self._is_env_eligible_for_tracking() or
ModelRepoClient is None</p>
</dd>
</dl>
<p>)</p>
<p>self._is_hogwild = bool(os.environ.get(‘TWML_HOGWILD_PORTS’))</p>
<p>self._is_distributed = bool(os.environ.get(‘TF_CONFIG’))</p>
<p>self._client = None if self.disabled else ModelRepoClient()</p>
<p>run_name_from_environ = self.run_name_from_environ()
run_name_can_be_inferred = (</p>
<blockquote>
<div><p>self.tracking_path is not None or run_name_from_environ is not None)</p>
</div></blockquote>
<p># Turn the flags off as needed in hogwild / distributed
if self._is_hogwild or self._is_distributed:</p>
<blockquote>
<div><dl>
<dt>self._env_eligible_for_recording_experiment = (</dt><dd><p>self._run_config.task_type == “evaluator”)</p>
</dd>
<dt>if run_name_can_be_inferred:</dt><dd><dl class="simple">
<dt>self._env_eligible_for_recording_export_metadata = (</dt><dd><p>self._run_config.task_type == “chief”)</p>
</dd>
</dl>
</dd>
<dt>else:</dt><dd><dl class="simple">
<dt>logging.info(</dt><dd><p>‘experiment_tracking_path is not set and can not be inferred. ‘
‘Recording export metadata is disabled because the chief node and eval node ‘
‘are setting different experiment tracking paths.’)</p>
</dd>
</dl>
<p>self._env_eligible_for_recording_export_metadata = False</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>else:</dt><dd><p># Defaults to True
self._env_eligible_for_recording_experiment = True
self._env_eligible_for_recording_export_metadata = True</p>
</dd>
<dt>if not self.disabled:</dt><dd><p># Sanitize passed in experiment tracking paths. e.g. own:proJ:exp:Run.Name
# -&gt; own:proj:exp:Run_Name
if self.tracking_path:</p>
<blockquote>
<div><dl>
<dt>try:</dt><dd><p>check_valid_id(self.tracking_path)</p>
</dd>
<dt>except ValueError as err:</dt><dd><p>logging.error(f’Invalid experiment tracking path provided. Sanitizing: {self.tracking_path}nError: {err}’)
self.tracking_path = generate_id(</p>
<blockquote>
<div><p>owner=self.path[‘owner’],
project_name=self.path[‘project_name’],
experiment_name=self.path[‘experiment_name’],
run_name=self.path[‘run_name’]</p>
</div></blockquote>
<p>)
logging.error(f’Generated sanitized experiment tracking path: {self.tracking_path}’)</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>else:</dt><dd><dl class="simple">
<dt>logging.info(</dt><dd><p>‘No experiment_tracking_path set. Experiment Tracker will try to guess a path’)</p>
</dd>
</dl>
<p>self.tracking_path = self.guess_path(save_dir, run_name_from_environ)
logging.info(‘Guessed path: %s’, self.tracking_path)</p>
</dd>
</dl>
<p># additional check to see if generated path is valid
try:</p>
<blockquote>
<div><p>check_valid_id(self.tracking_path)</p>
</div></blockquote>
<dl>
<dt>except ValueError as err:</dt><dd><dl class="simple">
<dt>logging.error(</dt><dd><p>‘Could not generate valid experiment tracking path. Disabling tracking. ‘ +
‘Error:n{}’.format(err)</p>
</dd>
</dl>
<p>)
self.disabled = True</p>
</dd>
</dl>
</dd>
<dt>self.project_id = None if self.disabled else ‘{}:{}’.format(</dt><dd><p>self.path[‘owner’], self.path[‘project_name’])</p>
</dd>
</dl>
<p>self.base_run_id = None if self.disabled else self.tracking_path
self._current_run_name_suffix = None</p>
<p>self._current_tracker_hook = None</p>
<dl class="simple">
<dt>if self.disabled:</dt><dd><p>logging.info(‘Experiment Tracker is disabled’)</p>
</dd>
<dt>else:</dt><dd><p>logging.info(‘Experiment Tracker initialized with base run id: %s’, self.base_run_id)</p>
</dd>
</dl>
</dd>
</dl>
<p>&#64;contextmanager
def track_experiment(self, eval_hooks, get_estimator_spec_fn, name=None):</p>
<blockquote>
<div><p>“””
A context manager for tracking experiment. It should wrap the training loop.
An experiment tracker eval hook is appended to eval_hooks to collect metrics.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>eval_hooks (list):</dt><dd><p>The list of eval_hooks to be used. When it’s not None, and does not contain any ,
MetricsUpdateHook an experiment tracker eval hook is appended to it. When it contains
any MetricsUpdateHook, this tracker is disabled to avoid conflict with legacy Model Repo
tracker (<cite>TrackRun</cite>).</p>
</dd>
<dt>get_estimator_spec_fn (func):</dt><dd><p>A function to get the current EstimatorSpec of the trainer, used by the eval hook.</p>
</dd>
<dt>name (str);</dt><dd><p>Name of this training or evaluation. Used as a suffix of the run_id.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>The tracker’s eval hook which is appended to eval_hooks.</p>
</dd>
</dl>
<p>“””</p>
<p># disable this tracker if legacy TrackRun hook is present
# TODO: remove this once we completely deprecate the old TrackRun interface
if eval_hooks is not None:</p>
<blockquote>
<div><p>self.disabled = self.disabled or any(isinstance(x, MetricsUpdateHook) for x in eval_hooks)</p>
</div></blockquote>
<dl>
<dt>logging.info(‘Is environment eligible for recording experiment: %s’,</dt><dd><p>self._env_eligible_for_recording_experiment)</p>
</dd>
<dt>if self._env_eligible_for_recording_experiment and self._graceful_shutdown_port:</dt><dd><dl class="simple">
<dt>requests.post(’<a class="reference external" href="http://localhost">http://localhost</a>:{}/track_training_start’.format(</dt><dd><p>self._graceful_shutdown_port</p>
</dd>
</dl>
<p>))</p>
</dd>
<dt>if self.disabled or eval_hooks is None:</dt><dd><p>yield None</p>
</dd>
<dt>else:</dt><dd><p>assert self._current_tracker_hook is None, ‘experiment tracking has been started already’</p>
<dl class="simple">
<dt>if name is not None:</dt><dd><p>self._current_run_name_suffix = ‘_’ + name</p>
</dd>
</dl>
<p>logging.info(‘Starting experiment tracking. Path: %s’, self._current_run_id)
logging.info(‘Is environment eligible for recording export metadata: %s’,</p>
<blockquote>
<div><p>self._env_eligible_for_recording_export_metadata)</p>
</div></blockquote>
<dl>
<dt>logging.info(‘This run will be available at: <a class="reference external" href="http://go/mldash/experiments/%s">http://go/mldash/experiments/%s</a>’,</dt><dd><p>encode_url(self.experiment_id))</p>
</dd>
<dt>try:</dt><dd><p>self._record_run()
self._add_run_status(StatusUpdate(self._current_run_id, status=’RUNNING’))
self._register_for_graceful_shutdown()</p>
<p>self._current_tracker_hook = self.create_eval_hook(get_estimator_spec_fn)</p>
</dd>
<dt>except Exception as err:</dt><dd><dl class="simple">
<dt>logging.error(</dt><dd><p>‘Failed to record run. This experiment will not be tracked. Error: %s’, str(err))</p>
</dd>
</dl>
<p>self._current_tracker_hook = None</p>
</dd>
<dt>if self._current_tracker_hook is None:</dt><dd><p>yield None</p>
</dd>
<dt>else:</dt><dd><dl>
<dt>try:</dt><dd><p>eval_hooks.append(self._current_tracker_hook)
yield self._current_tracker_hook</p>
</dd>
<dt>except Exception as err:</dt><dd><dl class="simple">
<dt>self._add_run_status(</dt><dd><p>StatusUpdate(self._current_run_id, status=’FAILED’, description=str(err)))</p>
</dd>
</dl>
<p>self._deregister_for_graceful_shutdown()
self._current_tracker_hook = None
self._current_run_name_suffix = None
logging.error(‘Experiment tracking done. Experiment failed.’)
raise</p>
</dd>
<dt>try:</dt><dd><dl class="simple">
<dt>if self._current_tracker_hook.metric_values:</dt><dd><p>self._record_update(self._current_tracker_hook.metric_values)</p>
</dd>
</dl>
<p>self._add_run_status(StatusUpdate(self._current_run_id, status=’SUCCESS’))
logging.info(‘Experiment tracking done. Experiment succeeded.’)</p>
</dd>
<dt>except Exception as err:</dt><dd><dl class="simple">
<dt>logging.error(</dt><dd><p>‘Failed to update mark run as successful. Error: %s’, str(err))</p>
</dd>
</dl>
</dd>
<dt>finally:</dt><dd><p>self._deregister_for_graceful_shutdown()
self._current_tracker_hook = None
self._current_run_name_suffix = None</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>def create_eval_hook(self, get_estimator_spec_fn):</dt><dd><p>“””
Create an eval_hook to track eval metrics</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>get_estimator_spec_fn (func):</dt><dd><p>A function that returns the current EstimatorSpec of the trainer.</p>
</dd>
</dl>
</dd>
</dl>
<p>“””
return MetricsUpdateHook(</p>
<blockquote>
<div><p>get_estimator_spec_fn=get_estimator_spec_fn,
add_metrics_fn=self._record_update)</p>
</div></blockquote>
</dd>
<dt>def register_model(self, export_path):</dt><dd><p>“””
Record the exported model.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>export_path (str):</dt><dd><p>The path to the exported model.</p>
</dd>
</dl>
</dd>
</dl>
<p>“””
if self.disabled:</p>
<blockquote>
<div><p>return None</p>
</div></blockquote>
<dl class="simple">
<dt>try:</dt><dd><p>logging.info(‘Model is exported to %s. Computing hash of the model.’, export_path)
model_hash = self.compute_model_hash(export_path)
logging.info(‘Model hash: %s. Registering it in ML Metastore.’, model_hash)
self._client.register_model(Model(model_hash, self.path[‘owner’], self.base_run_id))</p>
</dd>
<dt>except Exception as err:</dt><dd><p>logging.error(‘Failed to register model. Error: %s’, str(err))</p>
</dd>
</dl>
</dd>
<dt>def export_feature_spec(self, feature_spec_dict):</dt><dd><p>“””
Export feature spec to ML Metastore (go/ml-metastore).</p>
<p>Please note that the feature list in FeatureConfig only keeps the list of feature hash ids due
to the 1mb upper limit for values in manhattan, and more specific information (feature type,
feature name) for each feature config feature is stored separately in FeatureConfigFeature dataset.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>feature_spec_dict (dict): A dictionary obtained from FeatureConfig.get_feature_spec()</p>
</dd>
</dl>
<p>“””
if self.disabled or not self._env_eligible_for_recording_export_metadata:</p>
<blockquote>
<div><p>return None</p>
</div></blockquote>
<dl>
<dt>try:</dt><dd><p>logging.info(‘Exporting feature spec to ML Metastore.’)
feature_list = feature_spec_dict[‘features’]
label_list = feature_spec_dict[‘labels’]
weight_list = feature_spec_dict[‘weight’]
self._client.add_feature_config(FeatureConfig(self._current_run_id, list(feature_list.keys()),</p>
<blockquote>
<div><p>list(label_list.keys()), list(weight_list.keys())))</p>
</div></blockquote>
<dl>
<dt>feature_config_features = [</dt><dd><dl class="simple">
<dt>FeatureConfigFeature(</dt><dd><p>hash_id=_feature_hash_id,
feature_name=_feature[‘featureName’],
feature_type=_feature[‘featureType’]</p>
</dd>
</dl>
<p>)
for _feature_hash_id, _feature in zip(feature_list.keys(), feature_list.values())</p>
</dd>
</dl>
<p>]
self._client.add_feature_config_features(list(feature_list.keys()), feature_config_features)</p>
<dl>
<dt>feature_config_labels = [</dt><dd><dl class="simple">
<dt>FeatureConfigFeature(</dt><dd><p>hash_id=_label_hash_id,
feature_name=_label[‘featureName’]</p>
</dd>
</dl>
<p>)
for _label_hash_id, _label in zip(label_list.keys(), label_list.values())</p>
</dd>
</dl>
<p>]
self._client.add_feature_config_features(list(label_list.keys()), feature_config_labels)</p>
<dl>
<dt>feature_config_weights = [</dt><dd><dl class="simple">
<dt>FeatureConfigFeature(</dt><dd><p>hash_id=_weight_hash_id,
feature_name=_weight[‘featureName’],
feature_type=_weight[‘featureType’]</p>
</dd>
</dl>
<p>)
for _weight_hash_id, _weight in zip(weight_list.keys(), weight_list.values())</p>
</dd>
</dl>
<p>]
self._client.add_feature_config_features(list(weight_list.keys()), feature_config_weights)</p>
</dd>
<dt>except Exception as err:</dt><dd><p>logging.error(‘Failed to export feature spec. Error: %s’, str(err))</p>
</dd>
</dl>
</dd>
</dl>
<p>&#64;property
def path(self):</p>
<blockquote>
<div><dl class="simple">
<dt>if self.disabled:</dt><dd><p>return None</p>
</dd>
</dl>
<p>return get_components_from_id(self.tracking_path, ensure_valid_id=False)</p>
</div></blockquote>
<p>&#64;property
def experiment_id(self):</p>
<blockquote>
<div><dl class="simple">
<dt>if self.disabled:</dt><dd><p>return None</p>
</dd>
<dt>return ‘%s:%s:%s’ % (self.path[‘owner’], self.path[‘project_name’],</dt><dd><p>self.path[‘experiment_name’])</p>
</dd>
</dl>
</div></blockquote>
<p>&#64;property
def _current_run_name(self):</p>
<blockquote>
<div><p>“””
Return the current run name.
“””
if self._current_run_name_suffix is not None:</p>
<blockquote>
<div><p>return self.path[‘run_name’] + self._current_run_name_suffix</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>return self.path[‘run_name’]</p>
</dd>
</dl>
</div></blockquote>
<p>&#64;property
def _current_run_id(self):</p>
<blockquote>
<div><p>“””
Return the current run id.
“””
if self._current_run_name_suffix is not None:</p>
<blockquote>
<div><p>return self.base_run_id + self._current_run_name_suffix</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>return self.base_run_id</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>def get_run_status(self) -&gt; str:</dt><dd><dl class="simple">
<dt>if not self.disabled:</dt><dd><p>return self._client.get_latest_dbv2_status(self._current_run_id)</p>
</dd>
</dl>
</dd>
<dt>def _add_run_status(self, status):</dt><dd><p>“””
Add run status with underlying client.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>status (StatusUpdate):</dt><dd><p>The status update to add.</p>
</dd>
</dl>
</dd>
</dl>
<p>“””
if not self.disabled and self._env_eligible_for_recording_experiment:</p>
<blockquote>
<div><p>self._client.add_run_status(status)</p>
</div></blockquote>
</dd>
<dt>def _record_run(self):</dt><dd><p>“””
Record the run in ML Metastore.
“””
if self.disabled or not self._env_eligible_for_recording_experiment:</p>
<blockquote>
<div><p>return None</p>
</div></blockquote>
<dl>
<dt>if not self._client.project_exists(self.project_id):</dt><dd><p>self._client.add_project(Project(self.path[‘project_name’], self.path[‘owner’]))
time.sleep(1)</p>
</dd>
<dt>if not self._client.experiment_exists(self.experiment_id):</dt><dd><dl class="simple">
<dt>self._client.add_experiment(Experiment(</dt><dd><p>self.path[‘experiment_name’], self.path[‘owner’], self.project_id, ‘’))</p>
</dd>
</dl>
<p>time.sleep(1)</p>
</dd>
<dt>run = DeepbirdRun(self.experiment_id, self._current_run_name, ‘’,</dt><dd><p>{‘raw_command’: ‘ ‘.join(sys.argv)}, self._params)</p>
</dd>
</dl>
<p>self._client.add_deepbird_run(run, force=True)
time.sleep(1)</p>
</dd>
<dt>def _record_update(self, metrics):</dt><dd><p>“””
Record metrics update in ML Metastore.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>metrics (dict):</dt><dd><p>The dict of the metrics and their values.</p>
</dd>
</dl>
</dd>
</dl>
<p>“””</p>
<dl class="simple">
<dt>if self.disabled or not self._env_eligible_for_recording_experiment:</dt><dd><p>return None</p>
</dd>
</dl>
<p>reported_metrics = {}
for k, v in metrics.items():</p>
<blockquote>
<div><dl class="simple">
<dt>if hasattr(v, ‘item’):</dt><dd><p>reported_metrics[k] = v.item() if v.size == 1 else str(v.tolist())</p>
</dd>
<dt>else:</dt><dd><p>logging.warning(“Ignoring %s because the value (%s) is not valid” % (k, str(v)))</p>
</dd>
</dl>
</div></blockquote>
<p>report = ProgressReport(self._current_run_id, reported_metrics)</p>
<dl class="simple">
<dt>try:</dt><dd><p>self._client.add_progress_report(report)</p>
</dd>
<dt>except Exception as err:</dt><dd><p>logging.error(‘Failed to record metrics in ML Metastore. Error: {}’.format(err))
logging.error(‘Run ID: {}’.format(self._current_run_id))
logging.error(‘Progress Report: {}’.format(report.to_json_string()))</p>
</dd>
</dl>
</dd>
<dt>def _register_for_graceful_shutdown(self):</dt><dd><p>“””
Register the tracker with the health server, enabling graceful shutdown.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>(Response) health server response</p>
</dd>
</dl>
<p>“””
if self._graceful_shutdown_port and not self.disabled and self._env_eligible_for_recording_experiment:</p>
<blockquote>
<div><dl class="simple">
<dt>return requests.post(’<a class="reference external" href="http://localhost">http://localhost</a>:{}/register_id/{}’.format(</dt><dd><p>self._graceful_shutdown_port,
self._current_run_id</p>
</dd>
</dl>
<p>))</p>
</div></blockquote>
</dd>
<dt>def _deregister_for_graceful_shutdown(self):</dt><dd><p>“””
Deregister the tracker with the health server, disabling graceful shutdown.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>(Response) health server response</p>
</dd>
</dl>
<p>“””
if self._graceful_shutdown_port and not self.disabled and self._env_eligible_for_recording_experiment:</p>
<blockquote>
<div><dl class="simple">
<dt>return requests.post(’<a class="reference external" href="http://localhost">http://localhost</a>:{}/deregister_id/{}’.format(</dt><dd><p>self._graceful_shutdown_port,
self._current_run_id</p>
</dd>
</dl>
<p>))</p>
</div></blockquote>
</dd>
<dt>def _is_env_eligible_for_tracking(self):</dt><dd><p>“””
Determine if experiment tracking should run in the env.
“””
is_unit_test = (</p>
<blockquote>
<div><p>os.environ.get(‘PYTEST_CURRENT_TEST’) is not None and
os.environ.get(‘TEST_EXP_TRACKER’) is None</p>
</div></blockquote>
<p>)</p>
<dl class="simple">
<dt>is_running_on_ci = (</dt><dd><p>getpass.getuser() == ‘scoot-service’ and
os.environ.get(‘TEST_EXP_TRACKER’) is None</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>return (</dt><dd><p>not is_unit_test and
not is_running_on_ci</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>&#64;classmethod
def run_name_from_environ(cls):</p>
<blockquote>
<div><p>“””
Create run id from environment if possible.
“””
job_name = os.environ.get(“TWML_JOB_NAME”)
job_launch_time = os.environ.get(“TWML_JOB_LAUNCH_TIME”)</p>
<dl>
<dt>if not job_name or not job_launch_time:</dt><dd><p>return None</p>
</dd>
<dt>try:</dt><dd><p># job_launch_time should be in isoformat
# python2 doesnt support datetime.fromisoformat, so use hardcoded format string.
job_launch_time_formatted = datetime.strptime(job_launch_time,</p>
<blockquote>
<div><p>“%Y-%m-%dT%H:%M:%S.%f”)</p>
</div></blockquote>
</dd>
<dt>except ValueError:</dt><dd><p># Fallback in case aurora config is generating datetime in a different format.
job_launch_time_formatted = (job_launch_time</p>
<blockquote>
<div><p>.replace(“-”, “_”).replace(“T”, “_”)
.replace(“:”, “_”).replace(“.”, “_”))</p>
</div></blockquote>
</dd>
<dt>return ‘{}_{}’.format(</dt><dd><p>job_name, job_launch_time_formatted.strftime(‘%m_%d_%Y_%I_%M_%p’))</p>
</dd>
</dl>
</div></blockquote>
<p>&#64;classmethod
def guess_path(cls, save_dir, run_name=None):</p>
<blockquote>
<div><p>“””
Guess an experiment tracking path based on save_dir.</p>
<dl class="simple">
<dt>Returns:</dt><dd><p>(str) guessed path</p>
</dd>
</dl>
<p>“””
if not run_name:</p>
<blockquote>
<div><p>run_name = ‘Unnamed_{}’.format(datetime.now().strftime(‘%m_%d_%Y_%I_%M_%p’))</p>
</div></blockquote>
<dl>
<dt>if save_dir.startswith(‘hdfs://’):</dt><dd><p>path_match = re.search(r’/user/([a-z0-9-_]+)/([a-z0-9-_]+)’, save_dir)</p>
<dl>
<dt>if path_match:</dt><dd><p>groups = path_match.groups()
user = groups[0]
project_name = groups[1]</p>
<p>return generate_id(user, ‘default’, project_name, run_name)</p>
</dd>
</dl>
</dd>
</dl>
<p>user = getpass.getuser()
project_name = re.sub(r’^[a-z0-9-_]’, os.path.basename(save_dir), ‘’)
if not project_name:</p>
<blockquote>
<div><p>project_name = ‘unnamed’</p>
</div></blockquote>
<p>return generate_id(user, ‘default’, project_name, run_name)</p>
</div></blockquote>
<p>&#64;classmethod
def compute_model_hash(cls, export_path):</p>
<blockquote>
<div><p>“””
Computes the hash of an exported model. This is a gfile version of
twitter.mlmetastore.common.versioning.compute_hash. The two functions should generate
the same hash when given the same model.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>export_path (str):</dt><dd><p>The path to the exported model.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>(str) hash of the exported model</p>
</dd>
</dl>
<p>“””
paths = []
for path, subdirs, files in tf.io.gfile.walk(export_path):</p>
<blockquote>
<div><dl class="simple">
<dt>for name in sorted(files):</dt><dd><p>paths.append(os.path.join(path, name))</p>
</dd>
</dl>
</div></blockquote>
<p>paths.sort()
hash_object = hashlib.new(‘sha1’)</p>
<dl class="simple">
<dt>for path in paths:</dt><dd><dl class="simple">
<dt>with tf.io.gfile.GFile(path, “rb”) as file:</dt><dd><p>hash_object.update(file.read())</p>
</dd>
</dl>
</dd>
</dl>
<p>return hash_object.hexdigest()</p>
</div></blockquote>
</dd>
</dl>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../_sources/twml/twml/tracking/experiment_tracker.py.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>