<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>“””
This module implements custom tf.data.datasets for twml.
“””
import numbers</p>
<p>from absl import logging
from kazoo.client import KazooClient
from libtwml import OPLIB
import tensorflow.compat.v1 as tf
from twml.constants import DEFAULT_ZOOKEEPER_BASE_ZNODE, DEFAULT_ZOOKEEPER_HOST</p>
<dl>
<dt>class BlockFormatDataset(tf.data.Dataset):</dt><dd><p>“””A <code class="docutils literal notranslate"><span class="pre">tf.data.Dataset</span></code> comprising records from one or more TFRecord files.”””</p>
<dl>
<dt>def __init__(self, filenames, compression_type=”auto”, buffer_size=1 &lt;&lt; 20):</dt><dd><p>“””
Creates a <code class="docutils literal notranslate"><span class="pre">BlockFormatDataset</span></code>.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>filenames:</dt><dd><p>A <cite>tf.string</cite> tensor containing one or more filenames.</p>
</dd>
<dt>compression_type:</dt><dd><p>A string specifying the compression type.
Can be one of ‘gz’ (or ‘gzip’), ‘none’, ‘auto’ (default).
When compression_type == ‘auto’, it is inferred from file extension.</p>
</dd>
<dt>buffer_size:</dt><dd><p>Buffer size to be used during decompression. default: 1&lt;&lt;20.</p>
</dd>
</dl>
</dd>
</dl>
<p>“””
self._filenames = tf.convert_to_tensor(filenames, dtype=tf.string, name=”filenames”)
self._compression_type = tf.convert_to_tensor(compression_type.lower(), name=”compression_type”)
self._buffer_size = tf.convert_to_tensor(buffer_size, dtype=tf.int64, name=”buffer_size”)
# Parent class calss self._as_variant_tensor in init. So call this at the end.
super(BlockFormatDataset, self).__init__()</p>
</dd>
<dt>def _as_variant_tensor(self):</dt><dd><p>“””
Create the resource handle for the dataset.
“””
try:</p>
<blockquote>
<div><p>block_format_dataset = __import__(“libtwml_internal”).OPLIB.block_format_dataset
return block_format_dataset(self._filenames)</p>
</div></blockquote>
<dl class="simple">
<dt>except ImportError:</dt><dd><p>block_format_dataset = OPLIB.block_format_dataset_v2
return block_format_dataset(self._filenames, self._compression_type, self._buffer_size)</p>
</dd>
</dl>
</dd>
<dt>def _inputs(self):</dt><dd><p>return []</p>
</dd>
</dl>
<p>&#64;property
def output_shapes(self):</p>
<blockquote>
<div><p>“””Return output shapes”””
return tf.TensorShape([])</p>
</div></blockquote>
<p>&#64;property
def output_types(self):</p>
<blockquote>
<div><p>“””Return output types”””
return tf.string</p>
</div></blockquote>
<p>&#64;property
def output_classes(self):</p>
<blockquote>
<div><p>“””Return output classes”””
return tf.Tensor</p>
</div></blockquote>
</dd>
<dt>def downsample_dataset(dataset, sample_rate, rate_name):</dt><dd><p>“””
Downsample a tf.data.Dataset at sample_rate
“””
if sample_rate is None or sample_rate == 1.0:</p>
<blockquote>
<div><p>return dataset</p>
</div></blockquote>
<dl class="simple">
<dt>elif not isinstance(sample_rate, numbers.Real):</dt><dd><p>raise TypeError(“dataset %s must be a real number” % rate_name)</p>
</dd>
<dt>elif sample_rate &lt;= 0 or sample_rate &gt; 1:</dt><dd><p>raise ValueError(“dataset %s must be in range (0, 1])” % rate_name)</p>
</dd>
</dl>
<p>return dataset.filter(lambda _: tf.squeeze(tf.random_uniform([1])) &lt; sample_rate)</p>
</dd>
<dt>def _filenames_dataset(files, shards=None, shard_index=None):</dt><dd><p>“””
Get a tf.data.Dataset with file names from a list of files
Optionally shard the file list (see stream_block_format_dataset)
“””
files = tf.data.Dataset.from_tensor_slices(files)</p>
<dl class="simple">
<dt>if [shards, shard_index] != [None, None]:</dt><dd><p>logging.info(“Sharding files dataset (index: %d, shards: %d)” % (shard_index, shards))
files = files.shard(num_shards=shards, index=shard_index)</p>
</dd>
</dl>
<p>return files</p>
</dd>
<dt>def stream_block_format_dataset(</dt><dd><blockquote>
<div><p>files, parse_fn, batch_size, num_threads,
shuffle=True, repeat=False,
block_length=None, part_file_parallelism=None, file_shuffle_size=None,
record_shuffle_size=None, dataset_fn=None,
keep_rate=None, parts_downsampling_rate=None, prefetch_size=2,
shards=None, shard_index=None, shuffle_files=True, interleave=True):</p>
</div></blockquote>
<p>“””
Helper function to stream a list of part files.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>files:</dt><dd><p>List of input files which will create a dataset.</p>
</dd>
<dt>parse_fn:</dt><dd><p>A function that takes a byte tensor containing a datarecord and decodes it.</p>
</dd>
<dt>batch_size:</dt><dd><p>The batch size for each step.</p>
</dd>
<dt>num_threads:</dt><dd><p>Number of threads working on the data in parallel.</p>
</dd>
<dt>shuffle:</dt><dd><p>Shuffle records within each file using <code class="docutils literal notranslate"><span class="pre">record_shuffle_size</span></code>. Defaults to True.</p>
</dd>
<dt>repeat:</dt><dd><p>Repeat the dataset indefinitely. Defaults to False.
Useful when you want to use an <code class="docutils literal notranslate"><span class="pre">[train,eval]_steps</span></code> greater than the size of the dataset
(otherwise <code class="docutils literal notranslate"><span class="pre">Estimator.[train,evaluate]</span></code> stop when the end of the dataset is reached).</p>
</dd>
<dt>block_length (optional):</dt><dd><p>Number of consecutive records to pull from a single part file.
Defaults to batch_size.</p>
</dd>
<dt>part_file_parallelism (optional):</dt><dd><p>Number of part files to read from in parallel. Once a part file is completely read, it will
be replaced by the next part file in the part file list.</p>
<p><code class="docutils literal notranslate"><span class="pre">num_threads</span></code> specifies a reader thread pool size, while <code class="docutils literal notranslate"><span class="pre">part_file_parallelism</span></code> specifies
the number of files to read from in parallel. If <code class="docutils literal notranslate"><span class="pre">part_file_parallelism</span></code> is greater than or
equal to <code class="docutils literal notranslate"><span class="pre">num_threads</span></code>, the reads will be distributed over <code class="docutils literal notranslate"><span class="pre">num_threads</span></code>. On the other hand,
if <code class="docutils literal notranslate"><span class="pre">part_file_parallelism</span></code> is smaller than``num_threads``, it is very likely that the reader
thread pool will be underutilized, since it can never be the case that every reader thread has
a part file to read from.</p>
</dd>
<dt>file_shuffle_size (optional):</dt><dd><p>the buffer_size used for shuffling of the list of files.
Defaults to 1000. For example, if you have 2000 files, the first
1000 files are shuffled together, iterated through, then the next 1000 files are shuffled
and iterated through.</p>
</dd>
<dt>record_shuffle_size (optional):</dt><dd><p>the <code class="docutils literal notranslate"><span class="pre">buffer_size</span></code> used for shuffling records in each thread.
Defaults to <code class="docutils literal notranslate"><span class="pre">batch_size</span> <span class="pre">*</span> <span class="pre">8</span></code> records.</p>
</dd>
<dt>dataset_fn (optional):</dt><dd><p>A function of that modifies the dataset after it reads different interleaved parts files.
Defaults to:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dataset_fn</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">parse_fn</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
  <span class="k">return</span> <span class="n">dataset</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">parse_fn</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt>keep_rate (optional):</dt><dd><p>A float value in (0.0, 1.0] that indicates to drop records according to the Bernoulli
distribution with p = 1 - keep_rate.
Defaults to None (no records dropped).</p>
</dd>
<dt>parts_downsampling_rate (optional):</dt><dd><p>A float value in <code class="docutils literal notranslate"><span class="pre">(0.0,</span> <span class="pre">1.0]</span></code> that indicates the factor by which to downsample part files.
For example, a value of 0.2 means only 20 percent of part files become part of the dataset.</p>
<p>Note that this argument is only useful in conjunction with a [train,eval]_steps of -1
(that is, when the entire dataset is used). Furthermore, note that even in this case, each
epoch will see a different set of part files. This is because new part files are re-sampled
every epoch. In other words, this argument is only provided for backwards compatibility with
DeepBird v1. We recommend you use a smaller [train,eval]_steps (or specify a keep_rate)
instead.</p>
</dd>
<dt>shards (optional):</dt><dd><p>Number of partitions to shard the dataset into. This is useful for codistillation and other
techniques that require each worker to train on disjoint partitions of the dataset.
The dataset is not sharded by default.</p>
</dd>
<dt>shard_index (optional):</dt><dd><p>Which partition of the dataset to use if <code class="docutils literal notranslate"><span class="pre">shards</span></code> is set.</p>
</dd>
<dt>shuffle_files (optional):</dt><dd><p>Shuffle the list of files. Defaults to True.
When False, files are iterated in the order they are passed in.</p>
</dd>
<dt>interleave (optional):</dt><dd><p>Interleave records from multiple files in parallel. Defaults to True.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>tf.data.DataSet of batches of HashedDataRecord resource handles decoded and streamed online.</p>
</dd>
</dl>
<p>“””
# Creating a dataset from an input directory</p>
<p>files = _filenames_dataset(files, shards=shards, shard_index=shard_index)</p>
<p>file_shuffle_size = file_shuffle_size if file_shuffle_size is not None else 100000
record_shuffle_size = record_shuffle_size if record_shuffle_size is not None else (batch_size * 8)
block_length = block_length if block_length is not None else batch_size</p>
<p>logging.info(“NUM_THREADS: %d”, num_threads)</p>
<dl class="simple">
<dt>if repeat:</dt><dd><p>files = files.repeat()</p>
</dd>
<dt>if shuffle_files:</dt><dd><p># Randomly shuffle the files list.
files = files.shuffle(buffer_size=file_shuffle_size)</p>
</dd>
</dl>
<p># Downsample parts files
files = downsample_dataset(files, parts_downsampling_rate, “parts_downsampling_rate”)</p>
<p># Interleave the result from BlockFormatDataset
# block_length == batch_size results in batch_size records being read from a single file.
def map_fn(filenames):</p>
<blockquote>
<div><p>‘’’function that maps each filename to a BlockFormatDataset’’’
# reach each file using BlockFormatDataset
dataset = BlockFormatDataset(filenames)</p>
<p># early prefetching can sometimes improve performance (like on GCS)
dataset = dataset.prefetch(tf.data.experimental.AUTOTUNE)</p>
<p># Shuffling before repeating ensures strong ordering.
if shuffle:</p>
<blockquote>
<div><p>dataset = dataset.shuffle(buffer_size=record_shuffle_size)</p>
</div></blockquote>
<p>return dataset</p>
</div></blockquote>
<dl>
<dt>if interleave:</dt><dd><p>part_file_parallelism = num_threads if part_file_parallelism is None else part_file_parallelism
dataset = files.interleave(</p>
<blockquote>
<div><p>map_fn, cycle_length=part_file_parallelism, block_length=block_length, num_parallel_calls=num_threads)</p>
</div></blockquote>
</dd>
<dt>else:</dt><dd><p>dataset = files.flat_map(map_fn)</p>
</dd>
</dl>
<p># Downsample DataRecords
dataset = downsample_dataset(dataset, keep_rate, “keep_rate”)</p>
<dl class="simple">
<dt>if dataset_fn is None:</dt><dd><p># Create a batch of datarecords and decode them
return dataset.batch(batch_size).map(parse_fn, num_parallel_calls=tf.data.experimental.AUTOTUNE).prefetch(prefetch_size)</p>
</dd>
</dl>
<p>return dataset_fn(dataset, parse_fn, batch_size)</p>
</dd>
<dt>def cx_zk_path(path):</dt><dd><dl class="simple">
<dt>if path is None:</dt><dd><p>raise ValueError(“Path for zookeeper dataset pointer is None. You must specify a path.”)</p>
</dd>
</dl>
<p>return_path = “/”.join([DEFAULT_ZOOKEEPER_BASE_ZNODE, path])
logging.info(“Zookeeper path is: {}”.format(return_path))
return return_path</p>
</dd>
<dt>def zookeeper_ordered_dataset(</dt><dd><blockquote>
<div><p>files, parse_fn, batch_size, zk_counter_path, repeat=False,
num_threads=2, block_length=None, part_file_parallelism=None,
batch_shuffle_size=None, file_keep_rate=None, record_keep_rate=None,
prefetch_size=2, interleave=False, dataset_fn=None, verbose=False):</p>
</div></blockquote>
<p>“””
Make a tf.Dataset given an ordered list of filenames, using Zookeeper to keep track of
which file to read, and to coordinate multiple workers.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>files:</dt><dd><p>ordered list of (typically HDFS) filenames. This must remain consistent
between different workers, and between worker restarts (e.g. in the case
of instance failure or preemption).
To ensure this remains consistent, consider using the –train.files_list
option from DataRecordTrainer.</p>
</dd>
<dt>parse_fn:</dt><dd><p>A function that takes a byte tensor containing a datarecord and decodes it.</p>
</dd>
<dt>batch_size:</dt><dd><p>The batch size for each step.</p>
</dd>
<dt>zk_counter_path:</dt><dd><p>Path under the root node for the underlying zookeeper shared counter that
is used to coordinate distributed iteration over the list of files.
Full path will be <cite>‘/’.join([DEFAULT_ZOOKEEPER_BASE_ZNODE, zk_counter_path])</cite>.</p>
</dd>
<dt>repeat:</dt><dd><p>Default False. Set True to repeat over the files forever.</p>
</dd>
<dt>num_threads:</dt><dd><p>Default 2. Number of threads working on the data in parallel.
Only used if interleave=True.</p>
</dd>
<dt>block_length:</dt><dd><p>Default None. Number of consecutive records to pull from a single part file.
If None, then block_length=batch_size will be used.
Only used if interleave=True.</p>
</dd>
<dt>part_file_parallelism:</dt><dd><p>Default None. Number of part files to read from in parallel. Once a part file is completely
read, it will be replaced by the next part file indicated by the zookeeper counter.
Only used if interleave=True.</p>
<p><code class="docutils literal notranslate"><span class="pre">num_threads</span></code> specifies a reader thread pool size, while <code class="docutils literal notranslate"><span class="pre">part_file_parallelism</span></code> specifies
the number of files to read from in parallel. If <code class="docutils literal notranslate"><span class="pre">part_file_parallelism</span></code> is greater than or
equal to <code class="docutils literal notranslate"><span class="pre">num_threads</span></code>, the reads will be distributed over <code class="docutils literal notranslate"><span class="pre">num_threads</span></code>. On the other hand,
if <code class="docutils literal notranslate"><span class="pre">part_file_parallelism</span></code> is smaller than``num_threads``, it is very likely that the reader
thread pool will be underutilized, since it can never be the case that every reader thread has
a part file to read from.</p>
</dd>
<dt>batch_shuffle_size:</dt><dd><p>Default None. Size of shuffle buffer, for shuffling that will be applied after batching.
if None, then batches will not be shuffled. Ignored if dataset_fn is provided.</p>
</dd>
<dt>file_keep_rate:</dt><dd><p>Default None. Fraction of files to keep, or None to keep all files.</p>
</dd>
<dt>record_keep_rate:</dt><dd><p>Default None. Fraction of records to keep, or None to keep all records.</p>
</dd>
<dt>prefetch_size:</dt><dd><p>Default 2. Number of parsed batches to prefetch. Ignored if dataset_fn is provided.</p>
</dd>
<dt>interleave:</dt><dd><p>Default False. Set True to use tf.data.Dataset.interleave rather than flat_map.</p>
</dd>
<dt>dataset_fn:</dt><dd><p>A function that is applied to the dataset of individual records, after
these have been read from the parts files.
If <code class="docutils literal notranslate"><span class="pre">None</span></code> (the default), the behavior will be as though dataset_fn were set to:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">dataset_fn</span><span class="p">(</span><span class="n">dataset</span><span class="p">,</span> <span class="n">parse_fn</span><span class="p">,</span> <span class="n">batch_size</span><span class="p">):</span>
  <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">batch</span><span class="p">(</span><span class="n">batch_size</span><span class="p">)</span>
  <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="n">parse_fn</span><span class="p">,</span> <span class="n">tf</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">experimental</span><span class="o">.</span><span class="n">AUTOTUNE</span><span class="p">)</span>
  <span class="k">if</span> <span class="n">batch_shuffle_size</span><span class="p">:</span>
    <span class="n">dataset</span> <span class="o">=</span> <span class="n">dataset</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">batch_shuffle_size</span><span class="p">)</span>
  <span class="k">return</span> <span class="n">dataset</span><span class="o">.</span><span class="n">prefetch</span><span class="p">(</span><span class="n">prefetch_size</span><span class="p">)</span>
</pre></div>
</div>
</dd>
<dt>verbose:</dt><dd><p>Default False. Set True to log the names of files loaded by TF.</p>
</dd>
</dl>
</dd>
</dl>
<p>“””
block_length = batch_size if block_length is None else block_length
part_file_parallelism = num_threads if part_file_parallelism is None else part_file_parallelism</p>
<dl>
<dt>def zk_index_generator(my_files=files):</dt><dd><p>zk = KazooClient(hosts=DEFAULT_ZOOKEEPER_HOST)
zk.start()
my_counter = zk.Counter(cx_zk_path(zk_counter_path), default=0)
while True:</p>
<blockquote>
<div><p>my_counter += 1
counter_pre_value = my_counter.pre_value
if repeat:</p>
<blockquote>
<div><p>counter_pre_value = counter_pre_value % len(my_files)</p>
</div></blockquote>
<dl>
<dt>if counter_pre_value &gt;= len(my_files):</dt><dd><p>break</p>
</dd>
<dt>else:</dt><dd><p>chosen_file = my_files[counter_pre_value]
if verbose:</p>
<blockquote>
<div><p>logging.info(“{}. yielding {}”.format(counter_pre_value, chosen_file))</p>
</div></blockquote>
<p>yield chosen_file</p>
</dd>
</dl>
</div></blockquote>
<p>zk.stop()</p>
</dd>
</dl>
<p>files = tf.data.Dataset.from_generator(zk_index_generator, tf.string)</p>
<p># Downsample parts files
files = downsample_dataset(files, file_keep_rate, “file_keep_rate”)</p>
<dl class="simple">
<dt>def map_fn(filenames):</dt><dd><p>return BlockFormatDataset(filenames).prefetch(20)</p>
</dd>
</dl>
<p># Dont interleave for sequential training
if interleave:</p>
<blockquote>
<div><dl class="simple">
<dt>dataset = files.interleave(</dt><dd><p>map_fn,
cycle_length=part_file_parallelism,
block_length=block_length,
num_parallel_calls=num_threads)</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>dataset = files.flat_map(map_fn)</p>
</dd>
</dl>
<p># Downsample DataRecords
dataset = downsample_dataset(dataset, record_keep_rate, “record_keep_rate”)</p>
<dl>
<dt>if dataset_fn is None:</dt><dd><p># Create a batch of datarecords and decode them
dataset = dataset.batch(batch_size)
dataset = dataset.map(parse_fn, num_parallel_calls=tf.data.experimental.AUTOTUNE)
# shuffle after batching and parsing for performance reasons
# faster b/c 1 random selection is made per batch rather than per record
if batch_shuffle_size:</p>
<blockquote>
<div><p>dataset = dataset.shuffle(buffer_size=batch_shuffle_size)</p>
</div></blockquote>
<p>dataset = dataset.prefetch(prefetch_size)</p>
</dd>
<dt>else:</dt><dd><p>dataset = dataset_fn(dataset, parse_fn, batch_size)</p>
</dd>
</dl>
<p>return dataset</p>
</dd>
</dl>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../_sources/twml/twml/dataset.py.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>