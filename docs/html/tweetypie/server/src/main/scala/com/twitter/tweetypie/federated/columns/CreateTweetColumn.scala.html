<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../../" id="documentation_options" src="../../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie
package federated.columns</p>
<p>import com.twitter.accounts.util.SafetyMetadataUtils
import com.twitter.ads.callback.thriftscala.EngagementRequest
import com.twitter.bouncer.thriftscala.{Bounce =&gt; BouncerBounce}
import com.twitter.escherbird.thriftscala.TweetEntityAnnotation
import com.twitter.geo.model.LatitudeLongitude
import com.twitter.stitch.Stitch
import com.twitter.strato.catalog.OpMetadata
import com.twitter.strato.config.AllOf
import com.twitter.strato.config.BouncerAccess
import com.twitter.strato.config.ContactInfo
import com.twitter.strato.config.Policy
import com.twitter.strato.data.Conv
import com.twitter.strato.data.Description.PlainText
import com.twitter.strato.data.Lifecycle.Production
import com.twitter.strato.fed.StratoFed
import com.twitter.strato.opcontext.OpContext
import com.twitter.strato.response.Err
import com.twitter.strato.thrift.ScroogeConv
import com.twitter.tweetypie.decider.overrides.TweetyPieDeciderOverrides
import com.twitter.tweetypie.federated.columns.ApiErrors._
import com.twitter.tweetypie.federated.columns.CreateTweetColumn.toCreateTweetErr
import com.twitter.tweetypie.federated.context.GetRequestContext
import com.twitter.tweetypie.federated.prefetcheddata.PrefetchedDataRequest
import com.twitter.tweetypie.federated.prefetcheddata.PrefetchedDataResponse
import com.twitter.tweetypie.federated.promotedcontent.TweetPromotedContentLogger
import com.twitter.tweetypie.federated.promotedcontent.TweetPromotedContentLogger._
import com.twitter.tweetypie.repository.UnmentionInfoRepository
import com.twitter.tweetypie.repository.VibeRepository
import com.twitter.tweetypie.thriftscala.TransientCreateContext
import com.twitter.tweetypie.thriftscala.TweetCreateContextKey
import com.twitter.tweetypie.thriftscala.TweetCreateState._
import com.twitter.tweetypie.thriftscala.{graphql =&gt; gql}
import com.twitter.tweetypie.util.CommunityAnnotation
import com.twitter.tweetypie.util.ConversationControls
import com.twitter.tweetypie.util.TransientContextUtil
import com.twitter.tweetypie.{thriftscala =&gt; thrift}
import com.twitter.util.Throwables
import com.twitter.weaverbird.common.{GetRequestContext =&gt; WGetRequestContext}</p>
<dl>
<dt>class CreateTweetColumn(</dt><dd><p>postTweet: thrift.PostTweetRequest =&gt; Future[thrift.PostTweetResult],
getRequestContext: GetRequestContext,
prefetchedDataRepository: PrefetchedDataRequest =&gt; Stitch[PrefetchedDataResponse],
unmentionInfoRepository: UnmentionInfoRepository.Type,
vibeRepository: VibeRepository.Type,
logTweetPromotedContent: TweetPromotedContentLogger.Type,
statsReceiver: StatsReceiver,
enableCommunityTweetCreatesDecider: Gate[Unit],</p>
</dd>
<dt>) extends StratoFed.Column(CreateTweetColumn.Path)</dt><dd><blockquote>
<div><p>with StratoFed.Execute.StitchWithContext
with StratoFed.HandleDarkRequests {</p>
</div></blockquote>
<dl class="simple">
<dt>override val policy: Policy = AllOf(</dt><dd><p>Seq(AccessPolicy.TweetMutationCommonAccessPolicies, BouncerAccess()))</p>
</dd>
</dl>
<p>// The underlying call to thriftTweetService.postRetweet is not idempotent
override val isIdempotent: Boolean = false</p>
<p>override type Arg = gql.CreateTweetRequest
override type Result = gql.CreateTweetResponseWithSubqueryPrefetchItems</p>
<p>override val argConv: Conv[Arg] = ScroogeConv.fromStruct
override val resultConv: Conv[Result] = ScroogeConv.fromStruct</p>
<p>override val contactInfo: ContactInfo = TweetypieContactInfo
override val metadata: OpMetadata =</p>
<blockquote>
<div><dl>
<dt>OpMetadata(</dt><dd><p>Some(Production),
Some(</p>
<blockquote>
<div><dl class="simple">
<dt>PlainText(</dt><dd><p>“””</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>Creates a tweet using the calling authenticated Twitter user as author.
NOTE, not all Tweet space fields are GraphQL queryable in the CreateTweet mutation response.
See <a class="reference external" href="http://go/missing-create-tweet-fields">http://go/missing-create-tweet-fields</a>.
“””))
)</p>
</div></blockquote>
<p>private val getWeaverbirdCtx = new WGetRequestContext()</p>
<p>override def execute(request: Arg, opContext: OpContext): Stitch[Result] = {</p>
<blockquote>
<div><p>val ctx = getRequestContext(opContext)</p>
<p>// First, do any request parameter validation that can result in an error
// prior to calling into thriftTweetService.postTweet.
val safetyLevel = ctx.safetyLevel.getOrElse(throw SafetyLevelMissingErr)</p>
<dl class="simple">
<dt>val trackingId = request.engagementRequest match {</dt><dd><dl class="simple">
<dt>case Some(engagementRequest: EngagementRequest) if ctx.hasPrivilegePromotedTweetsInTimeline =&gt;</dt><dd><p>TrackingId.parse(engagementRequest.impressionId, statsReceiver)</p>
</dd>
<dt>case Some(e: EngagementRequest) =&gt;</dt><dd><p>throw ClientNotPrivilegedErr</p>
</dd>
<dt>case None =&gt;</dt><dd><p>None</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>val deviceSource = ctx.deviceSource.getOrElse(throw GenericAccessDeniedErr)</p>
<dl class="simple">
<dt>if (request.nullcast &amp;&amp; !ctx.hasPrivilegeNullcastingAccess) {</dt><dd><p>throw GenericAccessDeniedErr</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val safetyMetadata = SafetyMetadataUtils.makeSafetyMetaData(</dt><dd><p>sessionHash = ctx.sessionHash,
knownDeviceToken = ctx.knownDeviceToken,
contributorId = ctx.contributorId</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>val cardReference: Option[thrift.CardReference] =</dt><dd><p>request.cardUri.filter(_.nonEmpty).map(thrift.CardReference(_))</p>
</dd>
<dt>val escherbirdEntityAnnotations: Option[thrift.EscherbirdEntityAnnotations] =</dt><dd><dl class="simple">
<dt>request.semanticAnnotationIds</dt><dd><p>.filter(_.nonEmpty)
.map((seq: Seq[gql.TweetAnnotation]) =&gt; seq.map(parseTweetEntityAnnotation))
.map(thrift.EscherbirdEntityAnnotations(_))</p>
</dd>
</dl>
</dd>
</dl>
<p>val mediaEntities = request.media.map(_.mediaEntities)
val mediaUploadIds = mediaEntities.map(_.map(_.mediaId)).filter(_.nonEmpty)</p>
<dl>
<dt>val mediaTags: Option[thrift.TweetMediaTags] = {</dt><dd><p>val mediaTagsAuthorized = !ctx.isContributorRequest</p>
<dl>
<dt>val tagMap: Map[MediaId, Seq[thrift.MediaTag]] =</dt><dd><dl>
<dt>mediaEntities</dt><dd><p>.getOrElse(Nil)
.filter(_ =&gt; mediaTagsAuthorized)
.filter(_.taggedUsers.nonEmpty)
.map(mediaEntity =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>mediaEntity.mediaId -&gt;</dt><dd><dl class="simple">
<dt>mediaEntity.taggedUsers</dt><dd><p>.map(user_id =&gt; thrift.MediaTag(thrift.MediaTagType.User, Some(user_id))))</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>.toMap</p>
</dd>
</dl>
</dd>
<dt>Option(tagMap)</dt><dd><p>.filter(_.nonEmpty)
.map(thrift.TweetMediaTags(_))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>// Can not have both conversation controls and communities defined for a tweet
// as they have conflicting permissions on who can reply to the tweet.
val communities = parseCommunityIds(escherbirdEntityAnnotations)
if (request.conversationControl.isDefined &amp;&amp; communities.nonEmpty) {</p>
<blockquote>
<div><p>throw CannotConvoControlAndCommunitiesErr</p>
</div></blockquote>
<p>}</p>
<p>// Currently we do not support posting to multiple communities.
if (communities.length &gt; 1) {</p>
<blockquote>
<div><p>throw TooManyCommunitiesErr</p>
</div></blockquote>
<p>}</p>
<p>// Kill switch for community tweets in case we need to disable them for app security.
if (communities.nonEmpty &amp;&amp; !enableCommunityTweetCreatesDecider()) {</p>
<blockquote>
<div><p>throw CommunityUserNotAuthorizedErr</p>
</div></blockquote>
<p>}</p>
<p>// additionalFields is used to marshal multiple input params and
// should only be defined if one or more of those params are defined.
val additionalFields: Option[Tweet] =</p>
<blockquote>
<div><dl>
<dt>cardReference</dt><dd><p>.orElse(escherbirdEntityAnnotations)
.orElse(mediaTags)
.map(_ =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>thrift.Tweet(</dt><dd><p>0L,
cardReference = cardReference,
escherbirdEntityAnnotations = escherbirdEntityAnnotations,
mediaTags = mediaTags</p>
</dd>
</dl>
<p>))</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>val transientContext: Option[TransientCreateContext] =</dt><dd><dl class="simple">
<dt>parseTransientContext(</dt><dd><p>request.batchCompose,
request.periscope,
ctx.twitterUserId,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>// PostTweetRequest.additionalContext is marked as deprecated in favor of .transientContext,
// but the REST API still supports it and it is still passed along through Tweetypie, and
// FanoutService and Notifications still depend on it.
val additionalContext: Option[Map[TweetCreateContextKey, String]] =</p>
<blockquote>
<div><p>transientContext.map(TransientContextUtil.toAdditionalContext)</p>
</div></blockquote>
<dl>
<dt>val thriftPostTweetRequest = thrift.PostTweetRequest(</dt><dd><p>userId = ctx.twitterUserId,
text = request.tweetText,
createdVia = deviceSource,
inReplyToTweetId = request.reply.map(_.inReplyToTweetId),
geo = request.geo.flatMap(parseTweetCreateGeo),
autoPopulateReplyMetadata = request.reply.isDefined,
excludeReplyUserIds = request.reply.map(_.excludeReplyUserIds).filter(_.nonEmpty),
nullcast = request.nullcast,
// Send a dark request to Tweetypie if the dark_request directive is set or
// if the Tweet is undo-able.
dark = ctx.isDarkRequest || request.undoOptions.exists(_.isUndo),
hydrationOptions = Some(HydrationOptions.writePathHydrationOptions(ctx.cardsPlatformKey)),
remoteHost = ctx.remoteHost,
safetyMetaData = Some(safetyMetadata),
attachmentUrl = request.attachmentUrl,
mediaUploadIds = mediaUploadIds,
mediaMetadata = None,
transientContext = transientContext,
additionalContext = additionalContext,
conversationControl = request.conversationControl.map(parseTweetCreateConversationControl),
exclusiveTweetControlOptions = request.exclusiveTweetControlOptions.map { _ =&gt;</p>
<blockquote>
<div><p>thrift.ExclusiveTweetControlOptions()</p>
</div></blockquote>
<p>},
trustedFriendsControlOptions =</p>
<blockquote>
<div><p>request.trustedFriendsControlOptions.map(parseTrustedFriendsControlOptions),</p>
</div></blockquote>
<p>editOptions = request.editOptions.flatMap(_.previousTweetId.map(thrift.EditOptions(_))),
collabControlOptions = request.collabControlOptions.map(parseCollabControlOptions),
additionalFields = additionalFields,
trackingId = trackingId,
noteTweetOptions = request.noteTweetOptions.map(options =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>thrift.NoteTweetOptions(</dt><dd><p>options.noteTweetId,
options.mentionedScreenNames,
options.mentionedUserIds,
options.isExpandable))</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>)</p>
<dl>
<dt>val stitchPostTweet =</dt><dd><dl>
<dt>Stitch.callFuture {</dt><dd><dl class="simple">
<dt>TweetyPieDeciderOverrides.ConversationControlUseFeatureSwitchResults.On {</dt><dd><p>postTweet(thriftPostTweetRequest)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>for {</dt><dd><p>engagement &lt;- request.engagementRequest
if !request.reply.exists(_.inReplyToTweetId == 0) // no op per go/rb/845242
engagementType = if (request.reply.isDefined) ReplyEngagement else TweetEngagement</p>
</dd>
</dl>
<p>} logTweetPromotedContent(engagement, engagementType, ctx.isDarkRequest)</p>
<dl>
<dt>stitchPostTweet.flatMap { result: thrift.PostTweetResult =&gt;</dt><dd><p>result.state match {</p>
<blockquote>
<div><dl>
<dt>case thrift.TweetCreateState.Ok =&gt;</dt><dd><p>val unmentionSuccessCounter = statsReceiver.counter(“unmention_info_success”)
val unmentionFailuresCounter = statsReceiver.counter(“unmention_info_failures”)
val unmentionFailuresScope = statsReceiver.scope(“unmention_info_failures”)</p>
<dl>
<dt>val unmentionInfoStitch = result.tweet match {</dt><dd><dl>
<dt>case Some(tweet) =&gt;</dt><dd><dl>
<dt>unmentionInfoRepository(tweet)</dt><dd><dl class="simple">
<dt>.onFailure { t =&gt;</dt><dd><p>unmentionFailuresCounter.incr()
unmentionFailuresScope.counter(Throwables.mkString(t): _*).incr()</p>
</dd>
</dl>
<p>}
.onSuccess { _ =&gt;</p>
<blockquote>
<div><p>unmentionSuccessCounter.incr()</p>
</div></blockquote>
<p>}
.rescue {</p>
<blockquote>
<div><dl class="simple">
<dt>case _ =&gt;</dt><dd><p>Stitch.None</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
<dt>case _ =&gt;</dt><dd><p>Stitch.None</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>val vibeSuccessCounter = statsReceiver.counter(“vibe_success”)
val vibeFailuresCounter = statsReceiver.counter(“vibe_failures”)
val vibeFailuresScope = statsReceiver.scope(“vibe_failures”)</p>
<dl>
<dt>val vibeStitch = result.tweet match {</dt><dd><dl>
<dt>case Some(tweet) =&gt;</dt><dd><dl>
<dt>vibeRepository(tweet)</dt><dd><dl class="simple">
<dt>.onSuccess { _ =&gt;</dt><dd><p>vibeSuccessCounter.incr()</p>
</dd>
</dl>
<p>}
.onFailure { t =&gt;</p>
<blockquote>
<div><p>vibeFailuresCounter.incr()
vibeFailuresScope.counter(Throwables.mkString(t): _*).incr()</p>
</div></blockquote>
<p>}
.rescue {</p>
<blockquote>
<div><dl class="simple">
<dt>case _ =&gt;</dt><dd><p>Stitch.None</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
<dt>case _ =&gt;</dt><dd><p>Stitch.None</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>Stitch</dt><dd><p>.join(unmentionInfoStitch, vibeStitch)
.liftToOption()
.flatMap { prefetchFields =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>val r = PrefetchedDataRequest(</dt><dd><p>tweet = result.tweet.get,
sourceTweet = result.sourceTweet,
quotedTweet = result.quotedTweet,
safetyLevel = safetyLevel,
unmentionInfo = prefetchFields.flatMap(params =&gt; params._1),
vibe = prefetchFields.flatMap(params =&gt; params._2),
requestContext = getWeaverbirdCtx()</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>prefetchedDataRepository(r)</dt><dd><p>.liftToOption()
.map((prefetchedData: Option[PrefetchedDataResponse]) =&gt; {</p>
<blockquote>
<div><dl class="simple">
<dt>gql.CreateTweetResponseWithSubqueryPrefetchItems(</dt><dd><p>data = Some(gql.CreateTweetResponse(result.tweet.map(_.id))),
subqueryPrefetchItems = prefetchedData.map(_.value)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>})</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
<dt>case errState =&gt;</dt><dd><p>throw toCreateTweetErr(errState, result.bounce, result.failureReason)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private[this] def parseTweetCreateGeo(gqlGeo: gql.TweetGeo): Option[thrift.TweetCreateGeo] = {</dt><dd><dl>
<dt>val coordinates: Option[thrift.GeoCoordinates] =</dt><dd><dl>
<dt>gqlGeo.coordinates.map { coords =&gt;</dt><dd><dl>
<dt>LatitudeLongitude.of(coords.latitude, coords.longitude) match {</dt><dd><dl>
<dt>case Return(latlon: LatitudeLongitude) =&gt;</dt><dd><dl class="simple">
<dt>thrift.GeoCoordinates(</dt><dd><p>latitude = latlon.latitudeDegrees,
longitude = latlon.longitudeDegrees,
geoPrecision = latlon.precision,
display = coords.displayCoordinates</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>case Throw(_) =&gt;</dt><dd><p>throw InvalidCoordinatesErr</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>val geoSearchRequestId = gqlGeo.geoSearchRequestId.map { id =&gt;</dt><dd><dl class="simple">
<dt>if (id.isEmpty) {</dt><dd><p>throw InvalidGeoSearchRequestIdErr</p>
</dd>
</dl>
<p>}
thrift.TweetGeoSearchRequestID(id)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>if (coordinates.isEmpty &amp;&amp; gqlGeo.placeId.isEmpty) {</dt><dd><p>None</p>
</dd>
<dt>} else {</dt><dd><dl>
<dt>Some(</dt><dd><dl class="simple">
<dt>thrift.TweetCreateGeo(</dt><dd><p>coordinates = coordinates,
placeId = gqlGeo.placeId,
geoSearchRequestId = geoSearchRequestId</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private[this] def parseTweetCreateConversationControl(</dt><dd><p>gqlCC: gql.TweetConversationControl</p>
</dd>
<dt>): thrift.TweetCreateConversationControl =</dt><dd><dl class="simple">
<dt>gqlCC.mode match {</dt><dd><dl class="simple">
<dt>case gql.ConversationControlMode.ByInvitation =&gt;</dt><dd><p>ConversationControls.Create.byInvitation()</p>
</dd>
<dt>case gql.ConversationControlMode.Community =&gt;</dt><dd><p>ConversationControls.Create.community()</p>
</dd>
<dt>case gql.ConversationControlMode.EnumUnknownConversationControlMode(_) =&gt;</dt><dd><p>throw ConversationControlNotSupportedErr</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>private[this] def parseTweetEntityAnnotation(</dt><dd><p>gqlTweetAnnotation: gql.TweetAnnotation</p>
</dd>
<dt>): TweetEntityAnnotation =</dt><dd><dl class="simple">
<dt>TweetEntityAnnotation(</dt><dd><p>gqlTweetAnnotation.groupId,
gqlTweetAnnotation.domainId,
gqlTweetAnnotation.entityId</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>private[this] def parseCommunityIds(</dt><dd><p>escherbirdAnnotations: Option[thrift.EscherbirdEntityAnnotations]</p>
</dd>
<dt>): Seq[Long] =</dt><dd><dl>
<dt>escherbirdAnnotations</dt><dd><p>.map(_.entityAnnotations).getOrElse(Nil)
.flatMap {</p>
<blockquote>
<div><p>case CommunityAnnotation(id) =&gt; Seq(id)
case _ =&gt; Nil</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
<dt>private[this] def parseBatchMode(</dt><dd><p>gqlBatchComposeMode: gql.BatchComposeMode</p>
</dd>
</dl>
<p>): thrift.BatchComposeMode = {</p>
<blockquote>
<div><dl class="simple">
<dt>gqlBatchComposeMode match {</dt><dd><dl class="simple">
<dt>case gql.BatchComposeMode.BatchFirst =&gt;</dt><dd><p>thrift.BatchComposeMode.BatchFirst</p>
</dd>
<dt>case gql.BatchComposeMode.BatchSubsequent =&gt;</dt><dd><p>thrift.BatchComposeMode.BatchSubsequent</p>
</dd>
<dt>case gql.BatchComposeMode.EnumUnknownBatchComposeMode(_) =&gt;</dt><dd><p>throw InvalidBatchModeParameterErr</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private[this] def parseTransientContext(</dt><dd><p>gqlBatchComposeMode: Option[gql.BatchComposeMode],
gqlPeriscope: Option[gql.TweetPeriscopeContext],
twitterUserId: UserId,</p>
</dd>
<dt>): Option[TransientCreateContext] = {</dt><dd><p>val batchComposeMode = gqlBatchComposeMode.map(parseBatchMode)</p>
<p>// Per c.t.fanoutservice.model.Tweet#deviceFollowType, isLive=None and Some(false) are
// equivalent and the creatorId is discarded in both cases.
val periscopeIsLive = gqlPeriscope.map(_.isLive).filter(_ == true)
val periscopeCreatorId = if (periscopeIsLive.isDefined) Some(twitterUserId) else None</p>
<dl>
<dt>if (batchComposeMode.isDefined || periscopeIsLive.isDefined) {</dt><dd><dl>
<dt>Some(</dt><dd><dl class="simple">
<dt>thrift.TransientCreateContext(</dt><dd><p>batchCompose = batchComposeMode,
periscopeIsLive = periscopeIsLive,
periscopeCreatorId = periscopeCreatorId</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>} else {</dt><dd><p>None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private[this] def parseTrustedFriendsControlOptions(</dt><dd><p>gqlTrustedFriendsControlOptions: gql.TrustedFriendsControlOptions</p>
</dd>
<dt>): thrift.TrustedFriendsControlOptions = {</dt><dd><dl class="simple">
<dt>thrift.TrustedFriendsControlOptions(</dt><dd><p>trustedFriendsListId = gqlTrustedFriendsControlOptions.trustedFriendsListId</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private[this] def parseCollabControlOptions(</dt><dd><p>gqlCollabControlOptions: gql.CollabControlOptions</p>
</dd>
<dt>): thrift.CollabControlOptions = {</dt><dd><dl>
<dt>gqlCollabControlOptions.collabControlType match {</dt><dd><dl>
<dt>case gql.CollabControlType.CollabInvitation =&gt;</dt><dd><dl>
<dt>thrift.CollabControlOptions.CollabInvitation(</dt><dd><dl class="simple">
<dt>thrift.CollabInvitationOptions(</dt><dd><p>collaboratorUserIds = gqlCollabControlOptions.collaboratorUserIds</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>case gql.CollabControlType.EnumUnknownCollabControlType(_) =&gt;</dt><dd><p>throw CollabTweetInvalidParamsErr</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>object CreateTweetColumn {</dt><dd><p>val Path = “tweetypie/createTweet.Tweet”</p>
<dl>
<dt>def toCreateTweetErr(</dt><dd><p>errState: thrift.TweetCreateState,
bounce: Option[BouncerBounce],
failureReason: Option[String]</p>
</dd>
<dt>): Err = errState match {</dt><dd><dl class="simple">
<dt>case TextCannotBeBlank =&gt;</dt><dd><p>TweetCannotBeBlankErr</p>
</dd>
<dt>case TextTooLong =&gt;</dt><dd><p>TweetTextTooLongErr</p>
</dd>
<dt>case Duplicate =&gt;</dt><dd><p>DuplicateStatusErr</p>
</dd>
<dt>case MalwareUrl =&gt;</dt><dd><p>MalwareTweetErr</p>
</dd>
<dt>case UserDeactivated | UserSuspended =&gt;</dt><dd><p>// should not occur since this condition is caught by access policy filters
CurrentUserSuspendedErr</p>
</dd>
<dt>case RateLimitExceeded =&gt;</dt><dd><p>RateLimitExceededErr</p>
</dd>
<dt>case UrlSpam =&gt;</dt><dd><p>TweetUrlSpamErr</p>
</dd>
<dt>case Spam | UserReadonly =&gt;</dt><dd><p>TweetSpammerErr</p>
</dd>
<dt>case SpamCaptcha =&gt;</dt><dd><p>CaptchaChallengeErr</p>
</dd>
<dt>case SafetyRateLimitExceeded =&gt;</dt><dd><p>SafetyRateLimitExceededErr</p>
</dd>
<dt>case Bounce if bounce.isDefined =&gt;</dt><dd><p>accessDeniedByBouncerErr(bounce.get)</p>
</dd>
<dt>case MentionLimitExceeded =&gt;</dt><dd><p>MentionLimitExceededErr</p>
</dd>
<dt>case UrlLimitExceeded =&gt;</dt><dd><p>UrlLimitExceededErr</p>
</dd>
<dt>case HashtagLimitExceeded =&gt;</dt><dd><p>HashtagLimitExceededErr</p>
</dd>
<dt>case CashtagLimitExceeded =&gt;</dt><dd><p>CashtagLimitExceededErr</p>
</dd>
<dt>case HashtagLengthLimitExceeded =&gt;</dt><dd><p>HashtagLengthLimitExceededErr</p>
</dd>
<dt>case TooManyAttachmentTypes =&gt;</dt><dd><p>TooManyAttachmentTypesErr</p>
</dd>
<dt>case InvalidUrl =&gt;</dt><dd><p>InvalidUrlErr</p>
</dd>
<dt>case DisabledByIpiPolicy =&gt;</dt><dd><dl class="simple">
<dt>failureReason</dt><dd><p>.map(tweetEngagementLimitedErr)
.getOrElse(GenericTweetCreateErr)</p>
</dd>
</dl>
</dd>
<dt>case InvalidAdditionalField =&gt;</dt><dd><dl class="simple">
<dt>failureReason</dt><dd><p>.map(invalidAdditionalFieldWithReasonErr)
.getOrElse(InvalidAdditionalFieldErr)</p>
</dd>
</dl>
</dd>
</dl>
<p>// InvalidImage has been deprecated by tweetypie. Use InvalidMedia instead.
case InvalidMedia | InvalidImage | MediaNotFound =&gt;</p>
<blockquote>
<div><p>invalidMediaErr(failureReason)</p>
</div></blockquote>
<dl class="simple">
<dt>case InReplyToTweetNotFound =&gt;</dt><dd><p>InReplyToTweetNotFoundErr</p>
</dd>
<dt>case InvalidAttachmentUrl =&gt;</dt><dd><p>InvalidAttachmentUrlErr</p>
</dd>
<dt>case ConversationControlNotAllowed =&gt;</dt><dd><p>ConversationControlNotAuthorizedErr</p>
</dd>
<dt>case InvalidConversationControl =&gt;</dt><dd><p>ConversationControlInvalidErr</p>
</dd>
<dt>case ReplyTweetNotAllowed =&gt;</dt><dd><p>ConversationControlReplyRestricted</p>
</dd>
<dt>case ExclusiveTweetEngagementNotAllowed =&gt;</dt><dd><p>ExclusiveTweetEngagementNotAllowedErr</p>
</dd>
<dt>case CommunityReplyTweetNotAllowed =&gt;</dt><dd><p>CommunityReplyTweetNotAllowedErr</p>
</dd>
<dt>case CommunityUserNotAuthorized =&gt;</dt><dd><p>CommunityUserNotAuthorizedErr</p>
</dd>
<dt>case CommunityNotFound =&gt;</dt><dd><p>CommunityNotFoundErr</p>
</dd>
<dt>case SuperFollowsInvalidParams =&gt;</dt><dd><p>SuperFollowInvalidParamsErr</p>
</dd>
<dt>case SuperFollowsCreateNotAuthorized =&gt;</dt><dd><p>SuperFollowCreateNotAuthorizedErr</p>
</dd>
<dt>case CommunityProtectedUserCannotTweet =&gt;</dt><dd><p>CommunityProtectedUserCannotTweetErr</p>
</dd>
<dt>case TrustedFriendsInvalidParams =&gt;</dt><dd><p>TrustedFriendsInvalidParamsErr</p>
</dd>
<dt>case TrustedFriendsEngagementNotAllowed =&gt;</dt><dd><p>TrustedFriendsEngagementNotAllowedErr</p>
</dd>
<dt>case TrustedFriendsCreateNotAllowed =&gt;</dt><dd><p>TrustedFriendsCreateNotAllowedErr</p>
</dd>
<dt>case TrustedFriendsQuoteTweetNotAllowed =&gt;</dt><dd><p>TrustedFriendsQuoteTweetNotAllowedErr</p>
</dd>
<dt>case CollabTweetInvalidParams =&gt;</dt><dd><p>CollabTweetInvalidParamsErr</p>
</dd>
<dt>case StaleTweetEngagementNotAllowed =&gt;</dt><dd><p>StaleTweetEngagementNotAllowedErr</p>
</dd>
<dt>case StaleTweetQuoteTweetNotAllowed =&gt;</dt><dd><p>StaleTweetQuoteTweetNotAllowedErr</p>
</dd>
<dt>case FieldEditNotAllowed =&gt;</dt><dd><p>FieldEditNotAllowedErr</p>
</dd>
<dt>case NotEligibleForEdit =&gt;</dt><dd><p>NotEligibleForEditErr</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>GenericTweetCreateErr</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../../_sources/tweetypie/server/src/main/scala/com/twitter/tweetypie/federated/columns/CreateTweetColumn.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>