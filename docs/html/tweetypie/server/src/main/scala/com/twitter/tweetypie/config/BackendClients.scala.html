<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie
package config</p>
<p>import com.twitter.ads.internal.pcl.service.CallbackPromotedContentLogger
import com.twitter.ads.loggingclient.AdsLoggingClient
import com.twitter.adserver.thriftscala.AdCallbackEvent
import com.twitter.conversions.DurationOps._
import com.twitter.conversions.PercentOps._
import com.twitter.container.{thriftscala =&gt; ccs}
import com.twitter.deferredrpc.client.DeferredThriftService
import com.twitter.deferredrpc.thrift.Datacenter
import com.twitter.deferredrpc.thrift.DeferredRPC
import com.twitter.deferredrpc.thrift.Target
import com.twitter.escherbird.thriftscala.TweetEntityAnnotationService$FinagleClient
import com.twitter.escherbird.thriftscala.{</p>
<blockquote>
<div><p>TweetEntityAnnotationService =&gt; TweetEntityAnnotationScroogeIface</p>
</div></blockquote>
<p>}
import com.twitter.eventbus.client.EventBusPublisher
import com.twitter.eventbus.client.EventBusPublisherBuilder
import com.twitter.expandodo.thriftscala.CardsService$FinagleClient
import com.twitter.expandodo.thriftscala.{CardsService =&gt; CardsScroogeIface}
import com.twitter.finagle._
import com.twitter.finagle.builder.ClientBuilder
import com.twitter.finagle.client.Transporter
import com.twitter.finagle.factory.TimeoutFactory
import com.twitter.finagle.liveness.FailureAccrualFactory
import com.twitter.finagle.loadbalancer.Balancers
import com.twitter.finagle.mtls.authentication.EmptyServiceIdentifier
import com.twitter.finagle.mtls.client.MtlsClientBuilder._
import com.twitter.finagle.mtls.client.MtlsStackClient._
import com.twitter.finagle.partitioning.param
import com.twitter.finagle.service.TimeoutFilter.PropagateDeadlines
import com.twitter.finagle.service._
import com.twitter.finagle.ssl.OpportunisticTls
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.finagle.thrift.ThriftClientRequest
import com.twitter.finagle.thriftmux.MethodBuilder
import com.twitter.finagle.tracing.DefaultTracer
import com.twitter.flockdb.client.thriftscala.FlockDB
import com.twitter.flockdb.client.FlockResponse
import com.twitter.flockdb.client.TFlockClient
import com.twitter.flockdb.client.UserTimelineGraph
import com.twitter.geoduck.backend.hydration.thriftscala.{Hydration =&gt; GeoduckHydration}
import com.twitter.geoduck.backend.relevance.thriftscala.Relevance
import com.twitter.geoduck.backend.relevance.thriftscala.Relevance$FinagleClient
import com.twitter.geoduck.backend.relevance.thriftscala.RelevanceContext
import com.twitter.geoduck.service.common.clientmodules.GeoduckGeohashLocate
import com.twitter.geoduck.thriftscala.ReverseGeocoder
import com.twitter.geoduck.util.service.GeoduckLocate
import com.twitter.gizmoduck.thriftscala.UserService
import com.twitter.hashing.KeyHasher
import com.twitter.limiter.client.LimiterClientFactory
import com.twitter.mediainfo.server.thriftscala.MediaInfoService$FinagleClient
import com.twitter.mediainfo.server.thriftscala.{MediaInfoService =&gt; MediaInfoScroogeIface}
import com.twitter.merlin.thriftscala.UserRolesService
import com.twitter.passbird.thriftscala.PassbirdService
import com.twitter.passbird.thriftscala.PassbirdService$FinagleClient
import com.twitter.service.gen.scarecrow.thriftscala.ScarecrowService$FinagleClient
import com.twitter.service.gen.scarecrow.thriftscala.{ScarecrowService =&gt; ScarecrowScroogeIface}
import com.twitter.service.talon.thriftscala.Talon$FinagleClient
import com.twitter.service.talon.thriftscala.{Talon =&gt; TalonScroogeIface}
import com.twitter.snowflake.client.SnowflakeClient
import com.twitter.snowflake.thriftscala.Snowflake
import com.twitter.socialgraph.thriftscala.SocialGraphService$FinagleClient
import com.twitter.socialgraph.thriftscala.{SocialGraphService =&gt; SocialGraphScroogeIface}
import com.twitter.storage.client.manhattan.kv.Experiments
import com.twitter.storage.client.manhattan.kv.ManhattanKVClient
import com.twitter.storage.client.manhattan.kv.ManhattanKVClientMtlsParams
import com.twitter.storage.client.manhattan.kv.NoMtlsParams
import com.twitter.strato.client.Strato
import com.twitter.strato.client.{Client =&gt; StratoClient}
import com.twitter.timelineservice.fanout.thriftscala.FanoutService
import com.twitter.timelineservice.fanout.thriftscala.FanoutService$FinagleClient
import com.twitter.timelineservice.{thriftscala =&gt; tls}
import com.twitter.tweetypie.backends._
import com.twitter.tweetypie.client_id.ClientIdHelper
import com.twitter.tweetypie.media.MediaClient
import com.twitter.tweetypie.service.ReplicatingTweetService.GatedReplicationClient
import com.twitter.tweetypie.storage.ManhattanTweetStorageClient
import com.twitter.tweetypie.storage.TweetStorageClient
import com.twitter.tweetypie.store._
import com.twitter.tweetypie.thriftscala.DeleteLocationData
import com.twitter.tweetypie.thriftscala.RetweetArchivalEvent
import com.twitter.tweetypie.thriftscala.TweetEvent
import com.twitter.tweetypie.thriftscala.TweetServiceInternal$FinagleClient
import com.twitter.user_image_service.thriftscala.UserImageService$FinagleClient
import com.twitter.user_image_service.thriftscala.{UserImageService =&gt; UserImageScroogeIface}
import com.twitter.util.Throw
import com.twitter.util.Timer
import com.twitter.util.{TimeoutException =&gt; UtilTimeoutException}
import scala.util.Random</p>
<p>trait BackendClients {</p>
<blockquote>
<div><p>/** returns all the finagle.Names created while building clients <a href="#id1"><span class="problematic" id="id2">*</span></a>/
def referencedNames: Seq[Name]</p>
<p>val asyncRetryTweetService: ThriftTweetService
val asyncTweetDeletionService: ThriftTweetService
val asyncTweetService: ThriftTweetService
val configBus: ConfigBus
val creativesContainerService: CreativesContainerService
val darkTrafficClient: Service[Array[Byte], Array[Byte]]
val deleteLocationDataPublisher: EventBusPublisher[DeleteLocationData]
val escherbird: Escherbird
val expandodo: Expandodo
val fanoutServiceClient: FanoutService.MethodPerEndpoint
val geoHydrationLocate: GeoduckLocate
val geoRelevance: Relevance.MethodPerEndpoint
val geoScrubEventStore: GeoScrubEventStore
val geoduckGeohashLocate: GeoduckGeohashLocate
val gizmoduck: Gizmoduck
val gnipEnricherator: GnipEnricherator
val guano: Guano
val limiterService: LimiterService
val lowQoSReplicationClients: Seq[GatedReplicationClient]
val mediaClient: MediaClient
val mediaInfoService: MediaInfoService
val memcacheClient: memcached.Client
val merlin: UserRolesService.MethodPerEndpoint
val passbirdClient: PassbirdService.MethodPerEndpoint
val replicationClient: ThriftTweetService
val retweetArchivalEventPublisher: EventBusPublisher[RetweetArchivalEvent]
val scarecrow: Scarecrow
val snowflakeClient: SnowflakeClient.SnowflakeClient
val socialGraphService: SocialGraphService
val stratoserverClient: StratoClient
val talon: Talon
val tflockReadClient: TFlockClient
val tflockWriteClient: TFlockClient
val timelineService: TimelineService
val tweetEventsPublisher: EventBusPublisher[TweetEvent]
val tweetStorageClient: TweetStorageClient
val userImageService: UserImageService
val callbackPromotedContentLogger: CallbackPromotedContentLogger</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>default implementation of BackendClients that connects to real, remote</p></li>
<li><p>backend services.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>object BackendClients {</dt><dd><p>// for most services, tweetypie typically maintains only a single connection to
// each host in the cluster, and that is enough for normal steady-state work.
// to prevent ddos’ing backends during unusual traffic influxes, we set the host
// connection limit to be 2-3x the steady-state daily peak, giving plenty of head
// room but without allowing an excessive number of connections.
private val defaultHostConnectionLimit = 3</p>
<p>// 100ms is greater than most gc pauses; smaller values cause more timeouts
private val defaultConnectTimeout = 100.milliseconds
// tcpConnect timeout is less than half of defaultConnectTimeout, to allow at least
// two tries (except when there is a GC pause)
private val defaultTcpConnectTimeout = 20.milliseconds</p>
<dl class="simple">
<dt>private val WriteExceptionsOnly: PartialFunction[Try[Nothing], Boolean] =</dt><dd><p>RetryPolicy.WriteExceptionsOnly</p>
</dd>
<dt>private val ClosedExceptionsOnly: PartialFunction[Try[Nothing], Boolean] = {</dt><dd><p>case Throw(_: ChannelClosedException) =&gt; true</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private val TimeoutExceptionsOnly: PartialFunction[Try[Nothing], Boolean] = {</dt><dd><p>case Throw(_: TimeoutException) =&gt; true
case Throw(_: UtilTimeoutException) =&gt; true</p>
</dd>
</dl>
<p>}</p>
<p>private val NoBackoff = Backoff.const(0.second)</p>
<dl>
<dt>private def retry(writeExceptions: Int = 100, closedExceptions: Int = 2, timeouts: Int = 0) =</dt><dd><dl class="simple">
<dt>RetryPolicy.combine(</dt><dd><p>RetryPolicy.backoff(NoBackoff.take(writeExceptions))(WriteExceptionsOnly),
RetryPolicy.backoff(NoBackoff.take(closedExceptions))(ClosedExceptionsOnly),
RetryPolicy.backoff(NoBackoff.take(timeouts))(TimeoutExceptionsOnly)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>implicit val warmup: Warmup[BackendClients] = {</dt><dd><p>// Use a random string so that the keys are likely to hash to
// different memcache instances. Request multiple keys at a time so
// that we don’t consider the backend warm just because we can get a
// bunch of successful responses to one cache.
val cacheGet = (_: memcached.Client).get(Seq.fill(20)(Random.nextLong.toString))</p>
<dl class="simple">
<dt>Warmup</dt><dd><p>.empty[BackendClients]
.warmField(_.expandodo)
.warmField(_.gizmoduck)
.warmField(_.memcacheClient)(Warmup(“memcache”)(cacheGet))
.warmField(_.talon)
.warmField(_.tweetStorageClient)(Warmup(“tweetstorage”)(_.ping()))
.warmField(_.tflockReadClient)(Warmup(“tflock”)(_.contains(UserTimelineGraph, 0, 0)))
.warmField(_.scarecrow)
.warmField(_.socialGraphService)
.warmField(_.timelineService)
.warmField(_.geoRelevance)(Warmup(“geo_relevance”)(_.placeSearch(RelevanceContext())))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def apply(</dt><dd><p>settings: TweetServiceSettings,
deciderGates: TweetypieDeciderGates,
statsReceiver: StatsReceiver,
hostStatsReceiver: StatsReceiver,
timer: Timer,
clientIdHelper: ClientIdHelper,</p>
</dd>
<dt>): BackendClients = {</dt><dd><p>val thriftClientId = settings.thriftClientId
val tracer = DefaultTracer</p>
<p>val env = settings.env.toString
val zone = settings.zone
val log = Logger(getClass)
val backendsScope = statsReceiver.scope(“backends”)</p>
<p>/** a Seq builder of finagle.Names loaded via getName <a href="#id5"><span class="problematic" id="id6">*</span></a>/
val referencedNamesBuilder = Seq.newBuilder[Name]</p>
<p>/** the default set of exceptions we believe are safe for Tweetypie to retry <a href="#id7"><span class="problematic" id="id8">*</span></a>/
val defaultResponseClassifier: ResponseClassifier =</p>
<blockquote>
<div><p>ResponseClassifier.RetryOnChannelClosed.orElse(ResponseClassifier.RetryOnTimeout)</p>
</div></blockquote>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Resolve a string into a Finagle Name and record it</p></li>
<li><p>in referencedNames.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>def eval(address: String): Name = {</dt><dd><p>val name = Resolver.eval(address)
referencedNamesBuilder += name
name</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def backendContext(name: String) =</dt><dd><p>Backend.Context(timer, backendsScope.scope(name))</p>
</dd>
</dl>
<p>// by default, retries on most exceptions (see defaultRetryExceptions).  if an rpc is not
// idempotent, it should use a different retry policy.
def clientBuilder(name: String) = {</p>
<blockquote>
<div><dl class="simple">
<dt>ClientBuilder()</dt><dd><p>.name(name)
.reportTo(statsReceiver)
.reportHostStats(hostStatsReceiver)
.tracer(tracer)
.daemon(true)
.tcpConnectTimeout(defaultTcpConnectTimeout)
.connectTimeout(defaultConnectTimeout)
.retryPolicy(retry())</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl>
<dt>def thriftMuxClientBuilder(name: String, address: String, clazz: Class[_]) = {</dt><dd><dl>
<dt>clientBuilder(name)</dt><dd><dl class="simple">
<dt>.stack(</dt><dd><dl class="simple">
<dt>ThriftMux.client</dt><dd><p>.withClientId(thriftClientId)
.withOpportunisticTls(OpportunisticTls.Required)
.withServiceClass(clazz))</p>
</dd>
</dl>
</dd>
</dl>
<p>.loadBalancer(balancer())
.dest(eval(address))
.mutualTls(settings.serviceIdentifier)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>// Our base ThriftMux.Client
// Prefer using thriftMuxMethodBuilder below but
// can be used to build custom clients (re: darkTrafficClient)
def thriftMuxClient(name: String, propagateDeadlines: Boolean = true): ThriftMux.Client = {</p>
<blockquote>
<div><dl class="simple">
<dt>ThriftMux.client</dt><dd><p>.withClientId(thriftClientId)
.withLabel(name)
.withStatsReceiver(statsReceiver)
.withTracer(tracer)
.withTransport.connectTimeout(defaultTcpConnectTimeout)
.withSession.acquisitionTimeout(defaultConnectTimeout)
.withMutualTls(settings.serviceIdentifier)
.withOpportunisticTls(OpportunisticTls.Required)
.configured(PropagateDeadlines(enabled = propagateDeadlines))</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>// If an endpoint is non-idempotent you should add .nonidempotent and
// leave off any ResponseClassifiers (it will remove any placed before but not after)
// If it is unequivocally idempotent you should add .idempotent and
// leave off any ResponseClassifiers (it will retry on all Throws).  This will also
// enable backup requests
def thriftMuxMethodBuilder(</p>
<blockquote>
<div><p>name: String,
dest: String,</p>
</div></blockquote>
<dl class="simple">
<dt>): MethodBuilder = {</dt><dd><dl class="simple">
<dt>thriftMuxClient(name)</dt><dd><p>.withLoadBalancer(balancer(minAperture = 2))
.methodBuilder(dest)
.withRetryForClassifier(defaultResponseClassifier)
.withTimeoutTotal(2.seconds) // total timeout including 1st attempt and up to 2 retries</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>def balancer(minAperture: Int = 2) = Balancers.aperture(minAperture = minAperture)</p>
<dl>
<dt>val eventBusPublisherBuilder =</dt><dd><dl class="simple">
<dt>EventBusPublisherBuilder()</dt><dd><p>.dest(eval(“/s/eventbus/provisioning”))
.clientId(settings.thriftClientId)
// eventbus stats are further scoped by stream, so put all
// publishers under the same stats namespace
.statsReceiver(backendsScope.scope(“event_bus”))
// This makes the underlying kps-client to be resolved over WilyNs vs DNS
.serviceIdentifier(settings.serviceIdentifier)</p>
</dd>
</dl>
</dd>
<dt>new BackendClients {</dt><dd><p>def referencedNames: Seq[Name] = referencedNamesBuilder.result()</p>
<dl>
<dt>val memcacheClient: memcached.Client =</dt><dd><dl>
<dt>Memcached.client</dt><dd><p>.withMutualTls(settings.serviceIdentifier)
.connectionsPerEndpoint(2)
.configured(param.KeyHasher(KeyHasher.FNV1_32))
.configured(Transporter.ConnectTimeout(100.milliseconds))
.configured(TimeoutFilter.Param(200.milliseconds))
.configured(TimeoutFactory.Param(200.milliseconds))
.configured(param.EjectFailedHost(false))
.configured(FailureAccrualFactory.Param(numFailures = 20, markDeadFor = 30.second))
.configured(</p>
<blockquote>
<div><p>PendingRequestFilter.Param(limit = Some(settings.cacheClientPendingRequestLimit))</p>
</div></blockquote>
<p>)
.filtered(new MemcacheExceptionLoggingFilter)
.newRichClient(dest = eval(settings.twemcacheDest), label = “memcache”)</p>
</dd>
</dl>
</dd>
</dl>
<p>/* clients <a href="#id11"><span class="problematic" id="id12">*</span></a>/
val tweetStorageClient: TweetStorageClient =</p>
<blockquote>
<div><dl>
<dt>Manhattan.fromClient(</dt><dd><dl class="simple">
<dt>new ManhattanTweetStorageClient(</dt><dd><p>settings.tweetStorageConfig,
statsReceiver = backendsScope.scope(“tweet_storage”),
clientIdHelper = clientIdHelper,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>val socialGraphService: SocialGraphService = {</dt><dd><dl>
<dt>val finagleClient =</dt><dd><dl class="simple">
<dt>new SocialGraphService$FinagleClient(</dt><dd><dl class="simple">
<dt>thriftMuxClientBuilder(</dt><dd><p>“socialgraph”,
“/s/socialgraph/socialgraph”,
classOf[SocialGraphScroogeIface.MethodPerEndpoint]</p>
</dd>
<dt>).loadBalancer(Balancers.aperturePeakEwma(minAperture = 16))</dt><dd><p>.build()</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
<dt>settings.socialGraphSeviceConfig(</dt><dd><p>SocialGraphService.fromClient(finagleClient),
backendContext(“socialgraph”)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val tflockClient =</dt><dd><dl>
<dt>new FlockDB.FinagledClient(</dt><dd><dl class="simple">
<dt>thriftMuxClientBuilder(“tflock”, “/s/tflock/tflock”, classOf[FlockDB.MethodPerEndpoint])</dt><dd><p>.loadBalancer(balancer(minAperture = 5))
.responseClassifier(FlockResponse.classifier)
.build(),</p>
</dd>
</dl>
<p>serviceName = “tflock”,
stats = statsReceiver</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val tflockReadClient: TFlockClient =</dt><dd><p>settings.tflockReadConfig(tflockClient, backendContext(“tflock”))</p>
</dd>
<dt>val tflockWriteClient: TFlockClient =</dt><dd><p>settings.tflockWriteConfig(tflockClient, backendContext(“tflock”))</p>
</dd>
<dt>val gizmoduck: Gizmoduck = {</dt><dd><dl class="simple">
<dt>val clientBuilder =</dt><dd><dl class="simple">
<dt>thriftMuxClientBuilder(</dt><dd><p>“gizmoduck”,
“/s/gizmoduck/gizmoduck”,
classOf[UserService.MethodPerEndpoint])
.loadBalancer(balancer(minAperture = 63))</p>
</dd>
</dl>
</dd>
<dt>val mb = MethodBuilder</dt><dd><p>.from(clientBuilder)
.idempotent(maxExtraLoad = 1.percent)
.servicePerEndpoint[UserService.ServicePerEndpoint]</p>
</dd>
</dl>
<p>val gizmoduckClient = ThriftMux.Client.methodPerEndpoint(mb)
settings.gizmoduckConfig(Gizmoduck.fromClient(gizmoduckClient), backendContext(“gizmoduck”))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val merlin: UserRolesService.MethodPerEndpoint = {</dt><dd><dl class="simple">
<dt>val thriftClient = thriftMuxMethodBuilder(“merlin”, “/s/merlin/merlin”)</dt><dd><p>.withTimeoutPerRequest(100.milliseconds)
.withTimeoutTotal(400.milliseconds)
.idempotent(0.01)
.servicePerEndpoint[UserRolesService.ServicePerEndpoint]</p>
</dd>
</dl>
<p>ThriftMux.Client.methodPerEndpoint(thriftClient)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val talon: Talon = {</dt><dd><dl>
<dt>val talonClient =</dt><dd><dl class="simple">
<dt>new Talon$FinagleClient(</dt><dd><dl class="simple">
<dt>thriftMuxClientBuilder(</dt><dd><p>“talon”,
“/s/talon/backend”,
classOf[TalonScroogeIface.MethodPerEndpoint])
.build()</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>settings.talonConfig(Talon.fromClient(talonClient), backendContext(“talon”))</p>
</dd>
</dl>
<p>}</p>
<p>val guano = Guano()</p>
<dl>
<dt>val mediaInfoService: MediaInfoService = {</dt><dd><dl>
<dt>val finagleClient =</dt><dd><dl class="simple">
<dt>new MediaInfoService$FinagleClient(</dt><dd><dl class="simple">
<dt>thriftMuxClientBuilder(</dt><dd><p>“mediainfo”,
“/s/photurkey/mediainfo”,
classOf[MediaInfoScroogeIface.MethodPerEndpoint])
.loadBalancer(balancer(minAperture = 75))
.build()</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
<dt>settings.mediaInfoServiceConfig(</dt><dd><p>MediaInfoService.fromClient(finagleClient),
backendContext(“mediainfo”)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val userImageService: UserImageService = {</dt><dd><dl>
<dt>val finagleClient =</dt><dd><dl class="simple">
<dt>new UserImageService$FinagleClient(</dt><dd><dl class="simple">
<dt>thriftMuxClientBuilder(</dt><dd><p>“userImage”,
“/s/user-image-service/uis”,
classOf[UserImageScroogeIface.MethodPerEndpoint])
.build()</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
<dt>settings.userImageServiceConfig(</dt><dd><p>UserImageService.fromClient(finagleClient),
backendContext(“userImage”)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val mediaClient: MediaClient =</dt><dd><dl class="simple">
<dt>MediaClient.fromBackends(</dt><dd><p>userImageService = userImageService,
mediaInfoService = mediaInfoService</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val timelineService: TimelineService = {</dt><dd><dl>
<dt>val timelineServiceClient =</dt><dd><dl class="simple">
<dt>new tls.TimelineService$FinagleClient(</dt><dd><dl class="simple">
<dt>thriftMuxClientBuilder(</dt><dd><p>“timelineService”,
“/s/timelineservice/timelineservice”,
classOf[tls.TimelineService.MethodPerEndpoint])
.loadBalancer(balancer(minAperture = 13))
.build()</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
<dt>settings.timelineServiceConfig(</dt><dd><p>TimelineService.fromClient(timelineServiceClient),
backendContext(“timelineService”)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val expandodo: Expandodo = {</dt><dd><dl>
<dt>val cardsServiceClient =</dt><dd><dl class="simple">
<dt>new CardsService$FinagleClient(</dt><dd><dl class="simple">
<dt>thriftMuxClientBuilder(</dt><dd><p>“expandodo”,
“/s/expandodo/server”,
classOf[CardsScroogeIface.MethodPerEndpoint])
.loadBalancer(balancer(minAperture = 6))
.build()</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
<dt>settings.expandodoConfig(</dt><dd><p>Expandodo.fromClient(cardsServiceClient),
backendContext(“expandodo”)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val creativesContainerService: CreativesContainerService = {</dt><dd><dl class="simple">
<dt>val mb = thriftMuxMethodBuilder(</dt><dd><p>“creativesContainerService”,
“/s/creatives-container/creatives-container”,</p>
</dd>
<dt>).withTimeoutTotal(300.milliseconds)</dt><dd><p>.idempotent(maxExtraLoad = 1.percent)
.servicePerEndpoint[ccs.CreativesContainerService.ServicePerEndpoint]</p>
</dd>
<dt>settings.creativesContainerServiceConfig(</dt><dd><p>CreativesContainerService.fromClient(ccs.CreativesContainerService.MethodPerEndpoint(mb)),
backendContext(“creativesContainerService”)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val scarecrow: Scarecrow = {</dt><dd><dl>
<dt>val scarecrowClient = new ScarecrowService$FinagleClient(</dt><dd><dl class="simple">
<dt>thriftMuxClientBuilder(</dt><dd><p>“scarecrow”,
“/s/abuse/scarecrow”,
classOf[ScarecrowScroogeIface.MethodPerEndpoint])
.loadBalancer(balancer(minAperture = 6))
.build(),</p>
</dd>
</dl>
<p>serviceName = “scarecrow”,
stats = statsReceiver</p>
</dd>
</dl>
<p>)</p>
<p>settings.scarecrowConfig(Scarecrow.fromClient(scarecrowClient), backendContext(“scarecrow”))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val snowflakeClient: Snowflake.MethodPerEndpoint = {</dt><dd><p>eval(“/s/snowflake/snowflake”) // eagerly resolve the serverset
val mb = thriftMuxMethodBuilder(</p>
<blockquote>
<div><p>“snowflake”,
“/s/snowflake/snowflake”</p>
</div></blockquote>
<dl class="simple">
<dt>).withTimeoutTotal(300.milliseconds)</dt><dd><p>.withTimeoutPerRequest(100.milliseconds)
.idempotent(maxExtraLoad = 1.percent)</p>
</dd>
</dl>
<p>SnowflakeClient.snowflakeClient(mb)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val deferredRpcClient =</dt><dd><dl>
<dt>new DeferredRPC.FinagledClient(</dt><dd><dl class="simple">
<dt>thriftMuxClientBuilder(</dt><dd><p>“deferredrpc”,
“/s/kafka-shared/krpc-server-main”,
classOf[DeferredRPC.MethodPerEndpoint])
.requestTimeout(200.milliseconds)
.retryPolicy(retry(timeouts = 3))
.build(),</p>
</dd>
</dl>
<p>serviceName = “deferredrpc”,
stats = statsReceiver</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>def deferredTweetypie(target: Target): ThriftTweetService = {</dt><dd><p>// When deferring back to the local datacenter, preserve the finagle
// context and dtabs. This will ensure that developer dtabs are honored
// and that context is preserved in eventbus. (eventbus enqueues only
// happen in async requests within the same datacenter.)
//
// Effectively, this means we consider deferredrpc requests within the
// same datacenter to be part of the same request, but replicated
// requests are not.
val isLocal: Boolean = target.datacenter == Datacenter.Local</p>
<dl>
<dt>val deferredThriftService: Service[ThriftClientRequest, Array[Byte]] =</dt><dd><dl class="simple">
<dt>new DeferredThriftService(</dt><dd><p>deferredRpcClient,
target,
serializeFinagleContexts = isLocal,
serializeFinagleDtabs = isLocal</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>new TweetServiceInternal$FinagleClient(deferredThriftService)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val replicationClient: ThriftTweetService =</dt><dd><p>deferredTweetypie(Target(Datacenter.AllOthers, “tweetypie-replication”))</p>
</dd>
</dl>
<p>// used for read endpoints replication
val lowQoSReplicationClients: Seq[GatedReplicationClient] = {</p>
<blockquote>
<div><p>val rampUpGate = Gate.linearRampUp(Time.now, settings.forkingRampUp)</p>
<p>// Gates to avoid sending replicated reads from a cluster to itself
val inATLA = if (settings.zone == “atla”) Gate.True else Gate.False
val inPDXA = if (settings.zone == “pdxa”) Gate.True else Gate.False</p>
<dl>
<dt>Seq(</dt><dd><dl class="simple">
<dt>GatedReplicationClient(</dt><dd><p>client = deferredTweetypie(Target(Datacenter.Atla, “tweetypie-lowqos”)),
gate = rampUpGate &amp; deciderGates.replicateReadsToATLA &amp; !inATLA</p>
</dd>
</dl>
<p>),
GatedReplicationClient(</p>
<blockquote>
<div><p>client = deferredTweetypie(Target(Datacenter.Pdxa, “tweetypie-lowqos”)),
gate = rampUpGate &amp; deciderGates.replicateReadsToPDXA &amp; !inPDXA</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>}</p>
<p>// used for async operations in the write path
val asyncTweetService: ThriftTweetService =</p>
<blockquote>
<div><p>deferredTweetypie(Target(Datacenter.Local, “tweetypie”))</p>
</div></blockquote>
<p>// used to trigger asyncEraseUserTweetsRequest
val asyncTweetDeletionService: ThriftTweetService =</p>
<blockquote>
<div><p>deferredTweetypie(Target(Datacenter.Local, “tweetypie-retweet-deletion”))</p>
</div></blockquote>
<p>// used for async retries
val asyncRetryTweetService: ThriftTweetService =</p>
<blockquote>
<div><p>deferredTweetypie(Target(Datacenter.Local, “tweetypie-async-retry”))</p>
</div></blockquote>
<dl>
<dt>val darkTrafficClient: Service[Array[Byte], Array[Byte]] = {</dt><dd><dl>
<dt>val thriftService =</dt><dd><dl class="simple">
<dt>thriftMuxClient(</dt><dd><p>“tweetypie.dark”,
propagateDeadlines = false</p>
</dd>
<dt>).withRequestTimeout(100.milliseconds)</dt><dd><p>.newService(“/s/tweetypie/proxy”)</p>
</dd>
</dl>
</dd>
<dt>val transformer =</dt><dd><dl class="simple">
<dt>new Filter[Array[Byte], Array[Byte], ThriftClientRequest, Array[Byte]] {</dt><dd><dl class="simple">
<dt>override def apply(</dt><dd><p>request: Array[Byte],
service: Service[ThriftClientRequest, Array[Byte]]</p>
</dd>
<dt>): Future[Array[Byte]] =</dt><dd><p>service(new ThriftClientRequest(request, false))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>transformer andThen thriftService</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val geoHydrationClient: GeoduckHydration.MethodPerEndpoint = {</dt><dd><dl class="simple">
<dt>val mb = thriftMuxMethodBuilder(“geoduck_hydration”, “/s/geo/hydration”)</dt><dd><p>.withTimeoutPerRequest(100.millis)
.idempotent(maxExtraLoad = 1.percent)</p>
</dd>
<dt>ThriftMux.Client.methodPerEndpoint(</dt><dd><p>mb.servicePerEndpoint[GeoduckHydration.ServicePerEndpoint])</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>val geoHydrationLocate: GeoduckLocate = geoHydrationClient.locate</p>
<dl class="simple">
<dt>val geoReverseGeocoderClient: ReverseGeocoder.MethodPerEndpoint = {</dt><dd><dl class="simple">
<dt>val mb = thriftMuxMethodBuilder(“geoduck_reversegeocoder”, “/s/geo/geoduck_reversegeocoder”)</dt><dd><p>.withTimeoutPerRequest(100.millis)
.idempotent(maxExtraLoad = 1.percent)</p>
</dd>
<dt>ThriftMux.Client.methodPerEndpoint(</dt><dd><p>mb.servicePerEndpoint[ReverseGeocoder.ServicePerEndpoint])</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val geoduckGeohashLocate: GeoduckGeohashLocate = {</dt><dd><dl class="simple">
<dt>new GeoduckGeohashLocate(</dt><dd><p>reverseGeocoderClient = geoReverseGeocoderClient,
hydrationClient = geoHydrationClient,
classScopedStatsReceiver = statsReceiver.scope(“geo_geohash_locate”))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val geoRelevance =</dt><dd><dl>
<dt>new Relevance$FinagleClient(</dt><dd><dl class="simple">
<dt>thriftMuxClientBuilder(</dt><dd><p>“geoduck_relevance”,
“/s/geo/relevance”,
classOf[Relevance.MethodPerEndpoint])
.requestTimeout(100.milliseconds)
.retryPolicy(retry(timeouts = 1))
.build(),</p>
</dd>
</dl>
<p>stats = statsReceiver</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val fanoutServiceClient =</dt><dd><dl class="simple">
<dt>new FanoutService$FinagleClient(</dt><dd><p>new DeferredThriftService(deferredRpcClient, Target(Datacenter.Local, “fanoutservice”)),
serviceName = “fanoutservice”,
stats = statsReceiver</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val limiterService: LimiterService = {</dt><dd><dl>
<dt>val limiterClient =</dt><dd><dl class="simple">
<dt>new LimiterClientFactory(</dt><dd><p>name = “limiter”,
clientId = thriftClientId,
tracer = tracer,
statsReceiver = statsReceiver,
serviceIdentifier = settings.serviceIdentifier,
opportunisticTlsLevel = OpportunisticTls.Required,
daemonize = true</p>
</dd>
</dl>
<p>)(eval(“/s/limiter/limiter”))</p>
</dd>
<dt>val limiterBackend = settings.limiterBackendConfig(</dt><dd><p>LimiterBackend.fromClient(limiterClient),
backendContext(“limiter”)</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>LimiterService.fromBackend(</dt><dd><p>limiterBackend.incrementFeature,
limiterBackend.getFeatureUsage,
getAppId,
backendsScope.scope(“limiter”)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val passbirdClient =</dt><dd><dl>
<dt>new PassbirdService$FinagleClient(</dt><dd><dl class="simple">
<dt>thriftMuxClientBuilder(</dt><dd><p>“passbird”,
“/s/passbird/passbird”,
classOf[PassbirdService.MethodPerEndpoint])
.requestTimeout(100.milliseconds)
.retryPolicy(retry(timeouts = 1))
.build(),</p>
</dd>
</dl>
<p>serviceName = “passbird”,
stats = statsReceiver</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val escherbird: Escherbird = {</dt><dd><dl>
<dt>val escherbirdClient =</dt><dd><dl class="simple">
<dt>new TweetEntityAnnotationService$FinagleClient(</dt><dd><dl class="simple">
<dt>thriftMuxClientBuilder(</dt><dd><p>“escherbird”,
“/s/escherbird/annotationservice”,
classOf[TweetEntityAnnotationScroogeIface.MethodPerEndpoint])
.build()</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
<dt>settings.escherbirdConfig(</dt><dd><p>Escherbird.fromClient(escherbirdClient),
backendContext(“escherbird”)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val geoScrubEventStore: GeoScrubEventStore = {</dt><dd><dl>
<dt>val mhMtlsParams =</dt><dd><p>if (settings.serviceIdentifier == EmptyServiceIdentifier) NoMtlsParams
else</p>
<blockquote>
<div><dl class="simple">
<dt>ManhattanKVClientMtlsParams(</dt><dd><p>serviceIdentifier = settings.serviceIdentifier,
opportunisticTls = OpportunisticTls.Required)</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>val mhClient =</dt><dd><dl class="simple">
<dt>new ManhattanKVClient(</dt><dd><p>appId = “geoduck_scrub_datastore”,
dest = “/s/manhattan/omega.native-thrift”,
mtlsParams = mhMtlsParams,
label = “mh_omega”,
Seq(Experiments.ApertureLoadBalancer)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>GeoScrubEventStore(</dt><dd><p>mhClient,
settings.geoScrubEventStoreConfig,
backendContext(“geoScrubEventStore”)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val tweetEventsPublisher: EventBusPublisher[TweetEvent] =</dt><dd><dl class="simple">
<dt>eventBusPublisherBuilder</dt><dd><p>.streamName(“tweet_events”)
.thriftStruct(TweetEvent)
.publishTimeout(500.milliseconds)
.serializeFinagleDtabs(true)
.build()</p>
</dd>
</dl>
</dd>
<dt>val deleteLocationDataPublisher: EventBusPublisher[DeleteLocationData] =</dt><dd><dl class="simple">
<dt>eventBusPublisherBuilder</dt><dd><p>.streamName(“tweetypie_delete_location_data_prod”)
.thriftStruct(DeleteLocationData)
// deleteLocationData is relatively rare, and publishing to
// eventbus is all that the endpoint does. This means that it
// is much more likely that we will have to make a connection,
// which has much greater latency, and also makes us more
// tolerant of slow requests, so we choose a long timeout.
.publishTimeout(2.seconds)
.build()</p>
</dd>
</dl>
</dd>
<dt>val retweetArchivalEventPublisher: EventBusPublisher[RetweetArchivalEvent] =</dt><dd><dl class="simple">
<dt>eventBusPublisherBuilder</dt><dd><p>.streamName(“retweet_archival_events”)
.thriftStruct(RetweetArchivalEvent)
.publishTimeout(500.milliseconds)
.build()</p>
</dd>
</dl>
</dd>
<dt>val gnipEnricherator: GnipEnricherator = {</dt><dd><dl>
<dt>val gnipEnricherator =</dt><dd><dl class="simple">
<dt>thriftMuxMethodBuilder(</dt><dd><p>“enricherator”,
“/s/datadelivery-enrichments/enricherator”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>GnipEnricherator.fromMethod(gnipEnricherator)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val stratoserverClient: StratoClient = Strato.client</dt><dd><dl class="simple">
<dt>.withMutualTls(</dt><dd><p>serviceIdentifier = settings.serviceIdentifier,
opportunisticLevel = OpportunisticTls.Required)</p>
</dd>
</dl>
<p>.withLabel(“stratoserver”)
.withRequestTimeout(100.milliseconds)
.build()</p>
</dd>
<dt>val configBus: ConfigBus =</dt><dd><p>ConfigBus(backendsScope.scope(“config_bus”), settings.instanceId, settings.instanceCount)</p>
</dd>
<dt>val callbackPromotedContentLogger: CallbackPromotedContentLogger = {</dt><dd><dl class="simple">
<dt>val publisher =</dt><dd><dl class="simple">
<dt>eventBusPublisherBuilder</dt><dd><p>.streamName(settings.adsLoggingClientTopicName)
.thriftStruct(AdCallbackEvent)
.publishTimeout(500.milliseconds)
.serializeFinagleDtabs(true)
.maxQueuedEvents(1000)
.kafkaDest(“/s/kafka/ads-callback:kafka-tls”)
.build()</p>
</dd>
</dl>
</dd>
</dl>
<p>val stats = backendsScope.scope(“promoted_content”)
val adsLoggingClient = AdsLoggingClient(publisher, stats, “Tweetypie”)
new CallbackPromotedContentLogger(adsLoggingClient, stats)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/tweetypie/server/src/main/scala/com/twitter/tweetypie/config/BackendClients.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>