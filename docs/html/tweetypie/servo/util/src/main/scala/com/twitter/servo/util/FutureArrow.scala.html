<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../../" id="documentation_options" src="../../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.servo.util</p>
<p>import com.twitter.finagle.service.RetryPolicy
import com.twitter.finagle.stats.Stat
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.finagle.tracing.Trace
import com.twitter.finagle.FailedFastException
import com.twitter.finagle.Filter
import com.twitter.finagle.Service
import com.twitter.util._
import scala.util.control.NonFatal</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A collection of FutureArrow factory functions.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
</dl>
<p>object FutureArrow {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produce a FutureArrow from a function <cite>A =&gt; Future[B]</cite>.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>def apply[A, B](f: A =&gt; Future[B]): FutureArrow[A, B] =</dt><dd><dl>
<dt>new FutureArrow[A, B] {</dt><dd><dl>
<dt>override def apply(a: A): Future[B] =</dt><dd><p>try f(a)
catch {</p>
<blockquote>
<div><p>case NonFatal(e) =&gt; Future.exception(e)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produce a FutureArrow that supports recursive calls.  Recursing from a <cite>Future</cite></p></li>
<li><p>continuation is stack-safe, but direct recursion will use the stack, like a</p></li>
<li><p>normal method invocation.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>def rec[A, B](f: FutureArrow[A, B] =&gt; A =&gt; Future[B]): FutureArrow[A, B] =</dt><dd><dl>
<dt>new FutureArrow[A, B] { self =&gt;</dt><dd><p>private val g: A =&gt; Future[B] = f(this)
override def apply(a: A): Future[B] =</p>
<blockquote>
<div><p>try g(a)
catch {</p>
<blockquote>
<div><p>case NonFatal(e) =&gt; Future.exception(e)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produce a FutureArrow from an FunctionArrow.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>def fromFunctionArrow[A, B](f: FunctionArrow[A, B]): FutureArrow[A, B] =</dt><dd><p>FutureArrow[A, B](a =&gt; Future(f(a)))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produce a FutureArrow from a function.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
</dl>
<p>def fromFunction[A, B](f: A =&gt; B): FutureArrow[A, B] = fromFunctionArrow(FunctionArrow(f))</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produce a FutureArrow from a function <cite>A =&gt; Try[B]</cite>.</p></li>
<li></li>
<li><p>The Try is evaluated within a Future. Thus, Throw results are translated</p></li>
<li><p>to <a href="#id11"><span class="problematic" id="id12">`</span></a>Future.exception`s.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>def fromTry[A, B](f: A =&gt; Try[B]): FutureArrow[A, B] =</dt><dd><p>FutureArrow[A, B](a =&gt; Future.const(f(a)))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>A FutureArrow that simply returns a Future of its argument.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>def identity[A]: FutureArrow[A, A] =</dt><dd><p>FutureArrow[A, A](a =&gt; Future.value(a))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>A FutureArrow with a constant result, regardless of input.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>def const[A, B](value: Future[B]): FutureArrow[A, B] =</dt><dd><p>FutureArrow[A, B](_ =&gt; value)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Appends two FutureArrows together.</p></li>
<li></li>
<li><p>This forms a category with ‘identity’.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
</dl>
<p>def append[A, B, C](a: FutureArrow[A, B], b: FutureArrow[B, C]) = a.andThen(b)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produce a FutureArrow that applies an FutureEffect, returning the argument</p></li>
<li><p>value as-is on success. If the effect returns an Future exception, then the</p></li>
<li><p>result of the filter will also be that exception.</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
<dt>def effect[A](effect: FutureEffect[A]): FutureArrow[A, A] =</dt><dd><p>apply(a =&gt; effect(a).map(_ =&gt; a))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a FutureArrow that proxies to one of two others, depending on a</p></li>
<li><p>predicate.</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>def choose[A, B](predicate: A =&gt; Boolean, ifTrue: FutureArrow[A, B], ifFalse: FutureArrow[A, B]) =</dt><dd><p>FutureArrow[A, B](a =&gt; if (predicate(a)) ifTrue(a) else ifFalse(a))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a FutureArrow whose application is guarded by a predicate. <cite>f</cite> is</p></li>
<li><p>applied if the predicate returns true, otherwise the argument is simply</p></li>
<li><p>returned.</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
<dt>def onlyIf[A](predicate: A =&gt; Boolean, f: FutureArrow[A, A]) =</dt><dd><p>choose(predicate, f, identity[A])</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a FutureArrow that forwards to multiple FutureArrows and collects</p></li>
<li><p>the results into a <cite>Seq[B]</cite>. Results are gathered via Future.collect, so</p></li>
<li><p>failure semantics are inherited from that method.</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
<dt>def collect[A, B](arrows: Seq[FutureArrow[A, B]]): FutureArrow[A, Seq[B]] =</dt><dd><p>apply(a =&gt; Future.collect(arrows.map(arrow =&gt; arrow(a))))</p>
</dd>
<dt>private val RetryOnNonFailedFast: PartialFunction[Try[Any], Boolean] = {</dt><dd><p>case Throw(_: FailedFastException) =&gt; false
case Throw(_: Exception) =&gt; true</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A function encapsulating an asynchronous computation.</p></li>
<li></li>
<li><p>Background on the Arrow abstraction:</p></li>
<li><p><a class="reference external" href="http://en.wikipedia.org/wiki/Arrow_(computer_science">http://en.wikipedia.org/wiki/Arrow_(computer_science</a>)</p></li>
</ul>
<p><a href="#id29"><span class="problematic" id="id30">*</span></a>/</p>
</dd>
</dl>
<p>trait FutureArrow[-A, +B] extends (A =&gt; Future[B]) { self =&gt;</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Composes two FutureArrows. Produces a new FutureArrow that performs both in</p></li>
<li><p>series, depending on the success of the first.</p></li>
</ul>
<p><a href="#id31"><span class="problematic" id="id32">*</span></a>/</p>
</dd>
<dt>def andThen[C](next: FutureArrow[B, C]): FutureArrow[A, C] =</dt><dd><p>FutureArrow[A, C](a =&gt; self(a).flatMap(next.apply))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Combines this FutureArrow with another, producing one that translates a</p></li>
<li><p>tuple of its constituents’ arguments into a tuple of their results.</p></li>
</ul>
<p><a href="#id33"><span class="problematic" id="id34">*</span></a>/</p>
</dd>
<dt>def zipjoin[C, D](other: FutureArrow[C, D]): FutureArrow[(A, C), (B, D)] =</dt><dd><dl class="simple">
<dt>FutureArrow[(A, C), (B, D)] {</dt><dd><p>case (a, c) =&gt; self(a) join other(c)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Converts a FutureArrow on a scalar input and output value into a FutureArrow on a</p></li>
<li><p>Sequence of input values producing a pairwise sequence of output values.  The elements</p></li>
<li><p>of the input sequence are processed in parallel, so execution order is not guaranteed.</p></li>
<li><p>Results are gathered via Future.collect, so failure semantics are inherited from that method.</p></li>
</ul>
<p><a href="#id35"><span class="problematic" id="id36">*</span></a>/</p>
</dd>
<dt>def liftSeq: FutureArrow[Seq[A], Seq[B]] =</dt><dd><dl class="simple">
<dt>FutureArrow[Seq[A], Seq[B]] { seqA =&gt;</dt><dd><p>Future.collect(seqA.map(this))</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Converts this FutureArrow to a FutureEffect, where the result value is ignored.</p></li>
</ul>
<p><a href="#id37"><span class="problematic" id="id38">*</span></a>/</p>
</dd>
<dt>def asFutureEffect[A2 &lt;: A]: FutureEffect[A2] =</dt><dd><p>FutureEffect(this.unit)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Combines this FutureArrow with another, producing one that applies both</p></li>
<li><p>in parallel, producing a tuple of their results.</p></li>
</ul>
<p><a href="#id39"><span class="problematic" id="id40">*</span></a>/</p>
</dd>
<dt>def inParallel[A2 &lt;: A, C](other: FutureArrow[A2, C]): FutureArrow[A2, (B, C)] = {</dt><dd><p>val paired = self.zipjoin(other)
FutureArrow[A2, (B, C)](a =&gt; paired((a, a)))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Wrap a FutureArrow with an ExceptionCounter, thus providing</p></li>
<li><p>observability into the arrow’s success and failure.</p></li>
</ul>
<p><a href="#id41"><span class="problematic" id="id42">*</span></a>/</p>
</dd>
<dt>def countExceptions(</dt><dd><p>exceptionCounter: ExceptionCounter</p>
</dd>
<dt>): FutureArrow[A, B] =</dt><dd><p>FutureArrow[A, B](request =&gt; exceptionCounter(self(request)))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns a chained FutureArrow in which the given function will be called for any</p></li>
<li><p>input that succeeds.</p></li>
</ul>
<p><a href="#id43"><span class="problematic" id="id44">*</span></a>/</p>
</dd>
<dt>def onSuccess[A2 &lt;: A](f: (A2, B) =&gt; Unit): FutureArrow[A2, B] =</dt><dd><p>FutureArrow[A2, B](a =&gt; self(a).onSuccess(b =&gt; f(a, b)))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns a chained FutureArrow in which the given function will be called for any</p></li>
<li><p>input that fails.</p></li>
</ul>
<p><a href="#id45"><span class="problematic" id="id46">*</span></a>/</p>
</dd>
<dt>def onFailure[A2 &lt;: A](f: (A2, Throwable) =&gt; Unit): FutureArrow[A2, B] =</dt><dd><p>FutureArrow[A2, B](a =&gt; self(a).onFailure(t =&gt; f(a, t)))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Translate exception returned by a FutureArrow according to a</p></li>
<li><p>PartialFunction.</p></li>
</ul>
<p><a href="#id47"><span class="problematic" id="id48">*</span></a>/</p>
</dd>
<dt>def translateExceptions(</dt><dd><p>translateException: PartialFunction[Throwable, Throwable]</p>
</dd>
<dt>): FutureArrow[A, B] =</dt><dd><dl>
<dt>FutureArrow[A, B] { request =&gt;</dt><dd><dl class="simple">
<dt>self(request).rescue {</dt><dd><p>case t if translateException.isDefinedAt(t) =&gt; Future.exception(translateException(t))
case t =&gt; Future.exception(t)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Apply a FutureArrow, lifting any non-Future exceptions thrown into</p></li>
<li><p><a href="#id49"><span class="problematic" id="id50">`</span></a>Future.exception`s.</p></li>
</ul>
<p><a href="#id51"><span class="problematic" id="id52">*</span></a>/</p>
</dd>
<dt>def liftExceptions: FutureArrow[A, B] =</dt><dd><dl class="simple">
<dt>FutureArrow[A, B] { request =&gt;</dt><dd><p>// Flattening the Future[Future[Response]] is equivalent, but more concise
// than wrapping the arrow(request) call in a try/catch block that transforms
// the exception to a Future.exception, or at least was more concise before
// I added a four-line comment.
Future(self(request)).flatten</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Wrap a FutureArrow in exception-tracking and -translation. Given a</p></li>
<li><p>filter and a handler, exceptional results will be observed and translated</p></li>
<li><p>according to the function passed in this function’s second argument list.</p></li>
</ul>
<p><a href="#id53"><span class="problematic" id="id54">*</span></a>/</p>
</dd>
<dt>def cleanly(</dt><dd><p>exceptionCounter: ExceptionCounter</p>
</dd>
<dt>)(</dt><dd><p>translateException: PartialFunction[Throwable, Throwable] = { case t =&gt; t }</p>
</dd>
<dt>): FutureArrow[A, B] = {</dt><dd><dl class="simple">
<dt>liftExceptions</dt><dd><p>.translateExceptions(translateException)
.countExceptions(exceptionCounter)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a FutureArrow that tracks its own application latency.</p></li>
</ul>
<p><a href="#id55"><span class="problematic" id="id56">*</span></a>/</p>
</dd>
</dl>
<p>&#64;deprecated(“use trackLatency(StatsReceiver, (A2 =&gt; String)”, “2.11.1”)
def trackLatency[A2 &lt;: A](</p>
<blockquote>
<div><p>extractName: (A2 =&gt; String),
statsReceiver: StatsReceiver</p>
</div></blockquote>
<dl>
<dt>): FutureArrow[A2, B] =</dt><dd><p>trackLatency(statsReceiver, extractName)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a FutureArrow that tracks its own application latency.</p></li>
</ul>
<p><a href="#id57"><span class="problematic" id="id58">*</span></a>/</p>
</dd>
<dt>def trackLatency[A2 &lt;: A](</dt><dd><p>statsReceiver: StatsReceiver,
extractName: (A2 =&gt; String)</p>
</dd>
<dt>): FutureArrow[A2, B] =</dt><dd><dl>
<dt>FutureArrow[A2, B] { request =&gt;</dt><dd><dl class="simple">
<dt>Stat.timeFuture(statsReceiver.stat(extractName(request), “latency_ms”)) {</dt><dd><p>self(request)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a FutureArrow that tracks the outcome (i.e. success vs failure) of</p></li>
<li><p>requests.</p></li>
</ul>
<p><a href="#id59"><span class="problematic" id="id60">*</span></a>/</p>
</dd>
</dl>
<p>&#64;deprecated(“use trackOutcome(StatsReceiver, (A2 =&gt; String)”, “2.11.1”)
def trackOutcome[A2 &lt;: A](</p>
<blockquote>
<div><p>extractName: (A2 =&gt; String),
statsReceiver: StatsReceiver</p>
</div></blockquote>
<dl>
<dt>): FutureArrow[A2, B] =</dt><dd><p>trackOutcome(statsReceiver, extractName)</p>
</dd>
<dt>def trackOutcome[A2 &lt;: A](</dt><dd><p>statsReceiver: StatsReceiver,
extractName: (A2 =&gt; String)</p>
</dd>
<dt>): FutureArrow[A2, B] =</dt><dd><p>trackOutcome(statsReceiver, extractName, _ =&gt; None)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a FutureArrow that tracks the outcome (i.e. success vs failure) of</p></li>
<li><p>requests.</p></li>
</ul>
<p><a href="#id61"><span class="problematic" id="id62">*</span></a>/</p>
</dd>
<dt>def trackOutcome[A2 &lt;: A](</dt><dd><p>statsReceiver: StatsReceiver,
extractName: (A2 =&gt; String),
exceptionCategorizer: Throwable =&gt; Option[String]</p>
</dd>
<dt>): FutureArrow[A2, B] =</dt><dd><dl>
<dt>FutureArrow[A2, B] { request =&gt;</dt><dd><p>val scope = statsReceiver.scope(extractName(request))</p>
<dl>
<dt>self(request).respond { r =&gt;</dt><dd><p>statsReceiver.counter(“requests”).incr()
scope.counter(“requests”).incr()</p>
<dl class="simple">
<dt>r match {</dt><dd><dl class="simple">
<dt>case Return(_) =&gt;</dt><dd><p>statsReceiver.counter(“success”).incr()
scope.counter(“success”).incr()</p>
</dd>
<dt>case Throw(t) =&gt;</dt><dd><p>val category = exceptionCategorizer(t).getOrElse(“failures”)
statsReceiver.counter(category).incr()
scope.counter(category).incr()
scope.scope(category).counter(ThrowableHelper.sanitizeClassnameChain(t): _*).incr()</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Observe latency and success rate for any FutureArrow[A, B] where A is Observable</p></li>
</ul>
<p><a href="#id63"><span class="problematic" id="id64">*</span></a>/</p>
</dd>
<dt>def observed[A2 &lt;: A with Observable](</dt><dd><p>statsReceiver: StatsReceiver</p>
</dd>
<dt>): FutureArrow[A2, B] =</dt><dd><p>observed(statsReceiver, exceptionCategorizer = _ =&gt; None)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Observe latency and success rate for any FutureArrow[A, B] where A is Observable</p></li>
</ul>
<p><a href="#id65"><span class="problematic" id="id66">*</span></a>/</p>
</dd>
<dt>def observed[A2 &lt;: A with Observable](</dt><dd><p>statsReceiver: StatsReceiver,
exceptionCategorizer: Throwable =&gt; Option[String]</p>
</dd>
<dt>): FutureArrow[A2, B] =</dt><dd><dl class="simple">
<dt>self.observed(</dt><dd><p>statsReceiver.scope(“client_request”),
(a: A2) =&gt; a.requestName,
exceptionCategorizer</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Observe latency and success rate for any FutureArrow</p></li>
</ul>
<p><a href="#id67"><span class="problematic" id="id68">*</span></a>/</p>
</dd>
<dt>def observed[A2 &lt;: A](</dt><dd><p>statsReceiver: StatsReceiver,
statsScope: A2 =&gt; String,
exceptionCategorizer: Throwable =&gt; Option[String] = _ =&gt; None</p>
</dd>
<dt>): FutureArrow[A2, B] =</dt><dd><dl class="simple">
<dt>self</dt><dd><p>.trackLatency(statsReceiver, statsScope)
.trackOutcome(statsReceiver, statsScope, exceptionCategorizer)</p>
</dd>
</dl>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Trace the future arrow using local spans as documented here:</p></li>
<li><p><a class="reference external" href="https://docbird.twitter.biz/finagle/Tracing.html">https://docbird.twitter.biz/finagle/Tracing.html</a></p></li>
</ul>
<p><a href="#id69"><span class="problematic" id="id70">*</span></a>/</p>
</dd>
<dt>def traced[A2 &lt;: A](</dt><dd><p>traceScope: A2 =&gt; String</p>
</dd>
<dt>): FutureArrow[A2, B] = {</dt><dd><dl class="simple">
<dt>FutureArrow[A2, B] { a =&gt;</dt><dd><p>Trace.traceLocalFuture(traceScope(a))(self(a))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a new FutureArrow where the given function is applied to the input, and the result</p></li>
<li><p>passed to this FutureArrow.</p></li>
</ul>
<p><a href="#id71"><span class="problematic" id="id72">*</span></a>/</p>
</dd>
<dt>def contramap[C](f: C =&gt; A): FutureArrow[C, B] =</dt><dd><p>FutureArrow[C, B](f.andThen(self))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a new FutureArrow where the given function is applied to the result of this</p></li>
<li><p>FutureArrow.</p></li>
</ul>
<p><a href="#id73"><span class="problematic" id="id74">*</span></a>/</p>
</dd>
<dt>def map[C](f: B =&gt; C): FutureArrow[A, C] =</dt><dd><p>mapResult(_.map(f))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a new FutureArrow where the given function is applied to the resulting Future of</p></li>
<li><p>this FutureArrow.</p></li>
</ul>
<p><a href="#id75"><span class="problematic" id="id76">*</span></a>/</p>
</dd>
<dt>def mapResult[C](f: Future[B] =&gt; Future[C]): FutureArrow[A, C] =</dt><dd><p>FutureArrow[A, C](a =&gt; f(self(a)))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a new FutureArrow which translates exceptions into futures</p></li>
</ul>
<p><a href="#id77"><span class="problematic" id="id78">*</span></a>/</p>
</dd>
<dt>def rescue[B2 &gt;: B](</dt><dd><p>rescueException: PartialFunction[Throwable, Future[B2]]</p>
</dd>
<dt>): FutureArrow[A, B2] = {</dt><dd><dl class="simple">
<dt>FutureArrow[A, B2] { a =&gt;</dt><dd><p>self(a).rescue(rescueException)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a new FutureArrow where the result value is ignored, and Unit is returned.</p></li>
</ul>
<p><a href="#id79"><span class="problematic" id="id80">*</span></a>/</p>
</dd>
<dt>def unit: FutureArrow[A, Unit] =</dt><dd><p>mapResult(_.unit)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns a copy of this FutureArrow where the returned Future has its <cite>.masked</cite></p></li>
<li><p>method called.</p></li>
</ul>
<p><a href="#id81"><span class="problematic" id="id82">*</span></a>/</p>
</dd>
<dt>def masked: FutureArrow[A, B] =</dt><dd><p>mapResult(_.masked)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Wraps this FutureArrow by passing the underlying operation to the given retry handler</p></li>
<li><p>for possible retries.</p></li>
</ul>
<p><a href="#id83"><span class="problematic" id="id84">*</span></a>/</p>
</dd>
<dt>def retry(handler: RetryHandler[B]): FutureArrow[A, B] =</dt><dd><p>FutureArrow[A, B](a =&gt; handler(self(a)))</p>
</dd>
<dt>def retry[A2 &lt;: A](</dt><dd><p>policy: RetryPolicy[Try[B]],
timer: Timer,
statsReceiver: StatsReceiver,
extractName: (A2 =&gt; String)</p>
</dd>
<dt>): FutureArrow[A2, B] =</dt><dd><dl class="simple">
<dt>FutureArrow[A2, B] { a =&gt;</dt><dd><p>val scoped = statsReceiver.scope(extractName(a))
RetryHandler(policy, timer, scoped)(self(a))</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a new FutureArrow where the returned Future[B] must complete within the specified</p></li>
<li><p>timeout, otherwise the Future fails with a com.twitter.util.TimeoutException.</p></li>
<li></li>
<li><p>The [[timeout]] is passed by name to take advantage of deadlines passed in the request context.</p></li>
<li></li>
<li><p>‘’Note’’: On timeout, the underlying future is NOT interrupted.</p></li>
</ul>
<p><a href="#id85"><span class="problematic" id="id86">*</span></a>/</p>
</dd>
<dt>def withTimeout(timer: Timer, timeout: =&gt; Duration): FutureArrow[A, B] =</dt><dd><p>mapResult(_.within(timer, timeout))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a new FutureArrow where the returned Future must complete within the specified</p></li>
<li><p>timeout, otherwise the Future fails with the specified Throwable.</p></li>
<li></li>
<li><p>The [[timeout]] is passed by name to take advantage of deadlines passed in the request context.</p></li>
<li></li>
<li><p>‘’Note’’: On timeout, the underlying future is NOT interrupted.</p></li>
</ul>
<p><a href="#id87"><span class="problematic" id="id88">*</span></a>/</p>
</dd>
<dt>def withTimeout(timer: Timer, timeout: =&gt; Duration, exc: =&gt; Throwable): FutureArrow[A, B] =</dt><dd><p>mapResult(_.within(timer, timeout, exc))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a new FutureArrow where the returned Future[B] must complete within the specified</p></li>
<li><p>timeout, otherwise the Future fails with a com.twitter.util.TimeoutException.</p></li>
<li></li>
<li><p>The [[timeout]] is passed by name to take advantage of deadlines passed in the request context.</p></li>
<li></li>
<li><p>‘’Note’’: On timeout, the underlying future is interrupted.</p></li>
</ul>
<p><a href="#id89"><span class="problematic" id="id90">*</span></a>/</p>
</dd>
<dt>def raiseWithin(timer: Timer, timeout: =&gt; Duration): FutureArrow[A, B] =</dt><dd><p>mapResult(_.raiseWithin(timeout)(timer))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a new FutureArrow where the returned Future must complete within the specified</p></li>
<li><p>timeout, otherwise the Future fails with the specified Throwable.</p></li>
<li></li>
<li><p>[[timeout]] is passed by name to take advantage of deadlines passed in the request context.</p></li>
<li></li>
<li><p>‘’Note’’: On timeout, the underlying future is interrupted.</p></li>
</ul>
<p><a href="#id91"><span class="problematic" id="id92">*</span></a>/</p>
</dd>
<dt>def raiseWithin(timer: Timer, timeout: =&gt; Duration, exc: =&gt; Throwable): FutureArrow[A, B] =</dt><dd><p>mapResult(_.raiseWithin(timer, timeout, exc))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a finagle.Service instance that invokes this arrow.</p></li>
</ul>
<p><a href="#id93"><span class="problematic" id="id94">*</span></a>/</p>
</dd>
</dl>
<p>def asService: Service[A, B] = Service.mk(this)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a new FutureArrow with the given finagle.Filter applied to this instance.</p></li>
</ul>
<p><a href="#id95"><span class="problematic" id="id96">*</span></a>/</p>
</dd>
<dt>def withFilter[A2, B2](filter: Filter[A2, B2, A, B]): FutureArrow[A2, B2] =</dt><dd><p>FutureArrow[A2, B2](filter.andThen(asService))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a new FutureArrow with the given timeout which retries on Exceptions or timeouts and</p></li>
<li><p>records stats about the logical request.  This is only appropriate for idempotent operations.</p></li>
</ul>
<p><a href="#id97"><span class="problematic" id="id98">*</span></a>/</p>
</dd>
<dt>def observedWithTimeoutAndRetry[A2 &lt;: A](</dt><dd><p>statsReceiver: StatsReceiver,
extractName: (A2 =&gt; String),
timer: Timer,
timeout: Duration,
numTries: Int,
shouldRetry: PartialFunction[Try[B], Boolean] = FutureArrow.RetryOnNonFailedFast</p>
</dd>
<dt>): FutureArrow[A2, B] = {</dt><dd><p>val retryPolicy = RetryPolicy.tries(numTries, shouldRetry)
withTimeout(timer, timeout)</p>
<blockquote>
<div><p>.retry(retryPolicy, timer, statsReceiver, extractName)
.trackLatency(statsReceiver, extractName)
.trackOutcome(statsReceiver, extractName)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a new FutureArrow with the given timeout and records stats about the logical request.</p></li>
<li><p>This does not retry and is appropriate for non-idempotent operations.</p></li>
</ul>
<p><a href="#id99"><span class="problematic" id="id100">*</span></a>/</p>
</dd>
<dt>def observedWithTimeout[A2 &lt;: A](</dt><dd><p>statsReceiver: StatsReceiver,
extractName: (A2 =&gt; String),
timer: Timer,
timeout: Duration</p>
</dd>
<dt>): FutureArrow[A2, B] =</dt><dd><dl class="simple">
<dt>withTimeout(timer, timeout)</dt><dd><p>.trackLatency(statsReceiver, extractName)
.trackOutcome(statsReceiver, extractName)</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../../_sources/tweetypie/servo/util/src/main/scala/com/twitter/servo/util/FutureArrow.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>