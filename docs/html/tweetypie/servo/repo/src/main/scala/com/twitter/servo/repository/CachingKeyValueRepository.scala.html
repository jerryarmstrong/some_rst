<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../../" id="documentation_options" src="../../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.servo.repository</p>
<p>import com.twitter.logging.{Level, Logger}
import com.twitter.servo.cache._
import com.twitter.servo.util.{Effect, Gate, RateLimitingLogger}
import com.twitter.util._
import scala.collection.mutable
import scala.util.Random</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A set of classes that indicate how to handle cached results.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
</dl>
<p>sealed abstract class CachedResultAction[+V]</p>
<p>object CachedResultAction {</p>
<blockquote>
<div><p>/** Indicates a key should be fetched from the underlying repo <a href="#id3"><span class="problematic" id="id4">*</span></a>/
case object HandleAsMiss extends CachedResultAction[Nothing]</p>
<p>/** Indicates a key should be returned as not-found, and not fetched from the underlying repo <a href="#id5"><span class="problematic" id="id6">*</span></a>/
case object HandleAsNotFound extends CachedResultAction[Nothing]</p>
<p>/** Indicates the value should be returned as found <a href="#id7"><span class="problematic" id="id8">*</span></a>/
case class HandleAsFound[V](value: V) extends CachedResultAction[V]</p>
<p>/** Indicates the value should not be cached <a href="#id9"><span class="problematic" id="id10">*</span></a>/
case object HandleAsDoNotCache extends CachedResultAction[Nothing]</p>
<p>/** Indicates that the given action should be applied, and the given function applied to the resulting value <a href="#id11"><span class="problematic" id="id12">*</span></a>/
case class TransformSubAction[V](action: CachedResultAction[V], f: V =&gt; V)</p>
<blockquote>
<div><p>extends CachedResultAction[V]</p>
</div></blockquote>
<p>/** Indicates the key should be returned as a failure <a href="#id13"><span class="problematic" id="id14">*</span></a>/
case class HandleAsFailed(t: Throwable) extends CachedResultAction[Nothing]</p>
<dl class="simple">
<dt>/** Indicates that the value should be refetched asynchronously, be immediately treated</dt><dd><ul class="simple">
<li><p>as the given action. <a href="#id15"><span class="problematic" id="id16">*</span></a>/</p></li>
</ul>
</dd>
</dl>
<p>case class SoftExpiration[V](action: CachedResultAction[V]) extends CachedResultAction[V]</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A set of classes representing the various states for a cached result.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>sealed abstract class CachedResult[+K, +V] {</dt><dd><p>def key: K</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>object CachedResult {</dt><dd><p>import CachedResultAction._</p>
<p>/** Indicates the key was not in cache <a href="#id19"><span class="problematic" id="id20">*</span></a>/
case class NotFound[K](key: K) extends CachedResult[K, Nothing]</p>
<p>/** Indicates there was an error fetching the key <a href="#id21"><span class="problematic" id="id22">*</span></a>/
case class Failed[K](key: K, t: Throwable) extends CachedResult[K, Nothing]</p>
<p>/** Indicates the cached value could not be deserialized <a href="#id23"><span class="problematic" id="id24">*</span></a>/
case class DeserializationFailed[K](key: K) extends CachedResult[K, Nothing]</p>
<p>/** Indicates the cached value could not be serialized <a href="#id25"><span class="problematic" id="id26">*</span></a>/
case class SerializationFailed[K](key: K) extends CachedResult[K, Nothing]</p>
<p>/** Indicates that a NotFound tombstone was found in cached <a href="#id27"><span class="problematic" id="id28">*</span></a>/
case class CachedNotFound[K](</p>
<blockquote>
<div><p>key: K,
cachedAt: Time,
softTtlStep: Option[Short] = None)</p>
<blockquote>
<div><p>extends CachedResult[K, Nothing]</p>
</div></blockquote>
</div></blockquote>
<p>/** Indicates that a Deleted tombstone was found in cached <a href="#id29"><span class="problematic" id="id30">*</span></a>/
case class CachedDeleted[K](</p>
<blockquote>
<div><p>key: K,
cachedAt: Time,
softTtlStep: Option[Short] = None)</p>
<blockquote>
<div><p>extends CachedResult[K, Nothing]</p>
</div></blockquote>
</div></blockquote>
<p>/** Indicates that value was found in cached <a href="#id31"><span class="problematic" id="id32">*</span></a>/
case class CachedFound[K, V](</p>
<blockquote>
<div><p>key: K,
value: V,
cachedAt: Time,
softTtlStep: Option[Short] = None)</p>
<blockquote>
<div><p>extends CachedResult[K, V]</p>
</div></blockquote>
</div></blockquote>
<p>/** Indicates that value should not be cached until <a href="#id33"><span class="problematic" id="id34">*</span></a>/
case class DoNotCache[K](key: K, until: Option[Time]) extends CachedResult[K, Nothing]</p>
<p>type Handler[K, V] = CachedResult[K, V] =&gt; CachedResultAction[V]</p>
<p>type PartialHandler[K, V] = CachedResult[K, V] =&gt; Option[CachedResultAction[V]]</p>
<p>type HandlerFactory[Q, K, V] = Q =&gt; Handler[K, V]</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>companion object for Handler type</p></li>
</ul>
<p><a href="#id35"><span class="problematic" id="id36">*</span></a>/</p>
</dd>
</dl>
<p>object Handler {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>terminate a PartialHandler to produce a new Handler</p></li>
</ul>
<p><a href="#id37"><span class="problematic" id="id38">*</span></a>/</p>
</dd>
<dt>def apply[K, V](</dt><dd><p>partial: PartialHandler[K, V],
handler: Handler[K, V] = defaultHandler[K, V]</p>
</dd>
<dt>): Handler[K, V] = { cachedResult =&gt;</dt><dd><dl class="simple">
<dt>partial(cachedResult) match {</dt><dd><p>case Some(s) =&gt; s
case None =&gt; handler(cachedResult)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>companion object for PartialHandler type</p></li>
</ul>
<p><a href="#id39"><span class="problematic" id="id40">*</span></a>/</p>
</dd>
</dl>
<p>object PartialHandler {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Sugar to produce a PartialHandler from a PartialFunction. Successive calls to</p></li>
<li><p>isDefined MUST return the same result. Otherwise, take the syntax hit and wire</p></li>
<li><p>up your own PartialHandler.</p></li>
</ul>
<p><a href="#id41"><span class="problematic" id="id42">*</span></a>/</p>
</dd>
<dt>def apply[K, V](</dt><dd><p>partial: PartialFunction[CachedResult[K, V], CachedResultAction[V]]</p>
</dd>
</dl>
<p>): PartialHandler[K, V] = partial.lift</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>chain one PartialHandler after another to produce a new PartialHandler</p></li>
</ul>
<p><a href="#id43"><span class="problematic" id="id44">*</span></a>/</p>
</dd>
<dt>def orElse[K, V](</dt><dd><p>thisHandler: PartialHandler[K, V],
thatHandler: PartialHandler[K, V]</p>
</dd>
<dt>): PartialHandler[K, V] = { cachedResult =&gt;</dt><dd><dl class="simple">
<dt>thisHandler(cachedResult) match {</dt><dd><p>case some &#64; Some(_) =&gt; some
case None =&gt; thatHandler(cachedResult)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>companion object for HandlerFactory type</p></li>
</ul>
<p><a href="#id45"><span class="problematic" id="id46">*</span></a>/</p>
</dd>
<dt>object HandlerFactory {</dt><dd><p>def apply[Q, K, V](handler: Handler[K, V]): HandlerFactory[Q, K, V] = _ =&gt; handler</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def defaultHandlerFactory[Q, K, V]: HandlerFactory[Q, K, V] =</dt><dd><p>HandlerFactory[Q, K, V](defaultHandler)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>This is the default Handler. Failures are treated as misses.</p></li>
</ul>
<p><a href="#id47"><span class="problematic" id="id48">*</span></a>/</p>
</dd>
<dt>def defaultHandler[K, V]: Handler[K, V] = {</dt><dd><p>case NotFound(_) | Failed(_, _) =&gt; HandleAsMiss
case DeserializationFailed(_) | SerializationFailed(_) =&gt; HandleAsMiss
case CachedNotFound(_, _, _) | CachedDeleted(_, _, _) =&gt; HandleAsNotFound
case CachedFound(_, value, _, _) =&gt; HandleAsFound(value)
case DoNotCache(_, Some(time)) if Time.now &gt; time =&gt; HandleAsMiss
case DoNotCache(_, _) =&gt; HandleAsDoNotCache</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A PartialHandler that bubbles memcache failures up instead of converting</p></li>
<li><p>those failures to misses.</p></li>
</ul>
<p><a href="#id49"><span class="problematic" id="id50">*</span></a>/</p>
</dd>
<dt>def failuresAreFailures[K, V] = PartialHandler[K, V] {</dt><dd><p>case Failed(_, t) =&gt; HandleAsFailed(t)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A PartialHandler that doesn’t attempt to write back to cache if the initial</p></li>
<li><p>cache read failed, but still fetches from the underlying repo.</p></li>
</ul>
<p><a href="#id51"><span class="problematic" id="id52">*</span></a>/</p>
</dd>
<dt>def failuresAreDoNotCache[K, V] = PartialHandler[K, V] {</dt><dd><p>case Failed(_, _) =&gt; HandleAsDoNotCache</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A function that takes a cachedAt time and ttl, and returns an expiry time.  This function</p></li>
<li><p>_must_ be deterministic with respect to the arguments provided, otherwise, you might get a</p></li>
<li><p>MatchError when using this with softTtlExpiration.</p></li>
</ul>
<p><a href="#id53"><span class="problematic" id="id54">*</span></a>/</p>
</dd>
</dl>
<p>type Expiry = (Time, Duration) =&gt; Time</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>An Expiry function with an epsilon of zero.</p></li>
</ul>
<p><a href="#id55"><span class="problematic" id="id56">*</span></a>/</p>
</dd>
</dl>
<p>val fixedExpiry: Expiry = (cachedAt: Time, ttl: Duration) =&gt; cachedAt + ttl</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A repeatable “random” expiry function that perturbs the ttl with a random value</p></li>
<li><p>no greater than +/-(ttl * maxFactor).</p></li>
</ul>
<p><a href="#id57"><span class="problematic" id="id58">*</span></a>/</p>
</dd>
<dt>def randomExpiry(maxFactor: Float): Expiry = {</dt><dd><dl>
<dt>if (maxFactor == 0) {</dt><dd><p>fixedExpiry</p>
</dd>
<dt>} else { (cachedAt: Time, ttl: Duration) =&gt;</dt><dd><dl class="simple">
<dt>{</dt><dd><p>val factor = (2 * new Random(cachedAt.inMilliseconds).nextFloat - 1) * maxFactor
cachedAt + ttl + Duration.fromNanoseconds((factor * ttl.inNanoseconds).toLong)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>soft-expires CachedFound and CachedNotFound based on a ttl.</p></li>
<li></li>
<li><p>&#64;param ttl</p></li>
<li><p>values older than this will be considered expired, but still</p></li>
<li><p>returned, and asynchronously refreshed in cache.</p></li>
<li><p>&#64;param expiry</p></li>
<li><p>(optional) function to compute the expiry time</p></li>
</ul>
<p><a href="#id59"><span class="problematic" id="id60">*</span></a>/</p>
</dd>
<dt>def softTtlExpiration[K, V](</dt><dd><p>ttl: Duration,
expiry: Expiry = fixedExpiry</p>
</dd>
<dt>): PartialHandler[K, V] =</dt><dd><p>softTtlExpiration(_ =&gt; ttl, expiry)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>soft-expires CachedFound and CachedNotFound based on a ttl derived from the value</p></li>
<li></li>
<li><p>&#64;param ttl</p></li>
<li><p>values older than this will be considered expired, but still</p></li>
<li><p>returned, and asynchronously refreshed in cache.</p></li>
<li><p>&#64;param expiry</p></li>
<li><p>(optional) function to compute the expiry time</p></li>
</ul>
<p><a href="#id61"><span class="problematic" id="id62">*</span></a>/</p>
</dd>
<dt>def softTtlExpiration[K, V](</dt><dd><p>ttl: Option[V] =&gt; Duration,
expiry: Expiry</p>
</dd>
<dt>): PartialHandler[K, V] = PartialHandler[K, V] {</dt><dd><dl class="simple">
<dt>case CachedFound(_, value, cachedAt, _) if expiry(cachedAt, ttl(Some(value))) &lt; Time.now =&gt;</dt><dd><p>SoftExpiration(HandleAsFound(value))</p>
</dd>
<dt>case CachedNotFound(_, cachedAt, _) if expiry(cachedAt, ttl(None)) &lt; Time.now =&gt;</dt><dd><p>SoftExpiration(HandleAsNotFound)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>soft-expires CachedFound and CachedNotFound based on a ttl derived from both the value</p></li>
<li><p>and the softTtlStep</p></li>
<li></li>
<li><p>&#64;param ttl</p></li>
<li><p>values older than this will be considered expired, but still returned, and</p></li>
<li><p>asynchronously refreshed in cache.</p></li>
<li><p>&#64;param expiry</p></li>
<li><p>(optional) function to compute the expiry time</p></li>
</ul>
<p><a href="#id63"><span class="problematic" id="id64">*</span></a>/</p>
</dd>
<dt>def steppedSoftTtlExpiration[K, V](</dt><dd><p>ttl: (Option[V], Option[Short]) =&gt; Duration,
expiry: Expiry = fixedExpiry</p>
</dd>
<dt>): PartialHandler[K, V] = PartialHandler[K, V] {</dt><dd><dl>
<dt>case CachedFound(_, value, cachedAt, softTtlStep)</dt><dd><blockquote>
<div><p>if expiry(cachedAt, ttl(Some(value), softTtlStep)) &lt; Time.now =&gt;</p>
</div></blockquote>
<p>SoftExpiration(HandleAsFound(value))</p>
</dd>
<dt>case CachedNotFound(_, cachedAt, softTtlStep)</dt><dd><blockquote>
<div><p>if expiry(cachedAt, ttl(None, softTtlStep)) &lt; Time.now =&gt;</p>
</div></blockquote>
<p>SoftExpiration(HandleAsNotFound)</p>
</dd>
<dt>case CachedDeleted(_, cachedAt, softTtlStep)</dt><dd><blockquote>
<div><p>if expiry(cachedAt, ttl(None, softTtlStep)) &lt; Time.now =&gt;</p>
</div></blockquote>
<p>SoftExpiration(HandleAsNotFound)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>hard-expires CachedFound and CachedNotFound based on a ttl.</p></li>
<li></li>
<li><p>&#64;param ttl</p></li>
<li><p>values older than this will be considered a miss</p></li>
<li><p>&#64;param expiry</p></li>
<li><p>(optional) function to compute the expiry time</p></li>
</ul>
<p><a href="#id65"><span class="problematic" id="id66">*</span></a>/</p>
</dd>
<dt>def hardTtlExpiration[K, V](</dt><dd><p>ttl: Duration,
expiry: Expiry = fixedExpiry</p>
</dd>
<dt>): PartialHandler[K, V] =</dt><dd><p>hardTtlExpiration(_ =&gt; ttl, expiry)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>hard-expires CachedFound and CachedNotFound based on a ttl derived from the value</p></li>
<li></li>
<li><p>&#64;param ttl</p></li>
<li><p>values older than this will be considered a miss</p></li>
<li><p>&#64;param expiry</p></li>
<li><p>(optional) function to compute the expiry time</p></li>
</ul>
<p><a href="#id67"><span class="problematic" id="id68">*</span></a>/</p>
</dd>
<dt>def hardTtlExpiration[K, V](</dt><dd><p>ttl: Option[V] =&gt; Duration,
expiry: Expiry</p>
</dd>
<dt>): PartialHandler[K, V] = PartialHandler[K, V] {</dt><dd><dl class="simple">
<dt>case CachedFound(_, value, cachedAt, _) if expiry(cachedAt, ttl(Some(value))) &lt; Time.now =&gt;</dt><dd><p>HandleAsMiss</p>
</dd>
<dt>case CachedNotFound(_, cachedAt, _) if expiry(cachedAt, ttl(None)) &lt; Time.now =&gt;</dt><dd><p>HandleAsMiss</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>hard-expires a CachedNotFound tombstone based on a ttl</p></li>
<li></li>
<li><p>&#64;param ttl</p></li>
<li><p>values older than this will be considered expired</p></li>
<li><p>&#64;param expiry</p></li>
<li><p>(optional) function to compute the expiry time</p></li>
</ul>
<p><a href="#id69"><span class="problematic" id="id70">*</span></a>/</p>
</dd>
<dt>def notFoundHardTtlExpiration[K, V](</dt><dd><p>ttl: Duration,
expiry: Expiry = fixedExpiry</p>
</dd>
<dt>): PartialHandler[K, V] = PartialHandler[K, V] {</dt><dd><dl class="simple">
<dt>case CachedNotFound(_, cachedAt, _) =&gt;</dt><dd><dl class="simple">
<dt>if (expiry(cachedAt, ttl) &lt; Time.now)</dt><dd><p>HandleAsMiss</p>
</dd>
<dt>else</dt><dd><p>HandleAsNotFound</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>hard-expires a CachedDeleted tombstone based on a ttl</p></li>
<li></li>
<li><p>&#64;param ttl</p></li>
<li><p>values older than this will be considered expired</p></li>
<li><p>&#64;param expiry</p></li>
<li><p>(optional) function to compute the expiry time</p></li>
</ul>
<p><a href="#id71"><span class="problematic" id="id72">*</span></a>/</p>
</dd>
<dt>def deletedHardTtlExpiration[K, V](</dt><dd><p>ttl: Duration,
expiry: Expiry = fixedExpiry</p>
</dd>
<dt>): PartialHandler[K, V] = PartialHandler[K, V] {</dt><dd><dl class="simple">
<dt>case CachedDeleted(_, cachedAt, _) =&gt;</dt><dd><dl class="simple">
<dt>if (expiry(cachedAt, ttl) &lt; Time.now)</dt><dd><p>HandleAsMiss</p>
</dd>
<dt>else</dt><dd><p>HandleAsNotFound</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>read only from cache, never fall back to underlying KeyValueRepository</p></li>
</ul>
<p><a href="#id73"><span class="problematic" id="id74">*</span></a>/</p>
</dd>
<dt>def cacheOnly[K, V]: Handler[K, V] = {</dt><dd><p>case CachedFound(_, value, _, _) =&gt; HandleAsFound(value)
case _ =&gt; HandleAsNotFound</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>use either primary or backup Handler, depending on usePrimary result</p></li>
<li></li>
<li><p>&#64;param primaryHandler</p></li>
<li><p>the handler to be used if usePrimary evaluates to true</p></li>
<li><p>&#64;param backupHandler</p></li>
<li><p>the handle to be used if usePrimary evaluates to false</p></li>
<li><p>&#64;param usePrimary</p></li>
<li><p>evaluates the query to determine which handler to use</p></li>
</ul>
<p><a href="#id75"><span class="problematic" id="id76">*</span></a>/</p>
</dd>
<dt>def switchedHandlerFactory[Q, K, V](</dt><dd><p>primaryHandler: Handler[K, V],
backupHandler: Handler[K, V],
usePrimary: Q =&gt; Boolean</p>
</dd>
<dt>): HandlerFactory[Q, K, V] = { query =&gt;</dt><dd><dl class="simple">
<dt>if (usePrimary(query))</dt><dd><p>primaryHandler</p>
</dd>
<dt>else</dt><dd><p>backupHandler</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>object CacheResultObserver {</dt><dd><dl class="simple">
<dt>case class CachingRepositoryResult[K, V](</dt><dd><p>resultFromCache: KeyValueResult[K, Cached[V]],
resultFromCacheMissReadthrough: KeyValueResult[K, V],
resultFromSoftTtlReadthrough: KeyValueResult[K, V])</p>
</dd>
</dl>
<p>def unit[K, V] = Effect.unit[CachingRepositoryResult[K, V]]</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>object CachingKeyValueRepository {</dt><dd><p>type CacheResultObserver[K, V] = Effect[CacheResultObserver.CachingRepositoryResult[K, V]]</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Reads keyed values from a LockingCache, and reads through to an underlying</p></li>
<li><p>KeyValueRepository for misses. supports a “soft ttl”, beyond which values</p></li>
<li><p>will be read through out-of-band to the originating request</p></li>
<li></li>
<li><p>&#64;param underlying</p></li>
<li><p>the underlying KeyValueRepository</p></li>
<li><p>&#64;param cache</p></li>
<li><p>the locking cache to read from</p></li>
<li><p>&#64;param newQuery</p></li>
<li><p>a function for converting a subset of the keys of the original query into a new</p></li>
<li><p>query.  this is used to construct the query passed to the underlying repository</p></li>
<li><p>to fetch the cache misses.</p></li>
<li><p>&#64;param handlerFactory</p></li>
<li><p>A factory to produce functions that specify policies about how to handle results</p></li>
<li><p>from cache. (i.e. to handle failures as misses vs failures, etc)</p></li>
<li><p>&#64;param picker</p></li>
<li><p>used to choose between the value in cache and the value read from the DB when</p></li>
<li><p>storing values in the cache</p></li>
<li><p>&#64;param observer</p></li>
<li><p>a CacheObserver for collecting cache statistics*</p></li>
<li><p>&#64;param writeSoftTtlStep</p></li>
<li><p>Write the soft_ttl_step value to indicate number of consistent reads from underlying store</p></li>
<li><p>&#64;param cacheResultObserver</p></li>
<li><p>An [[Effect]] of type [[CacheResultObserver.CachingRepositoryResult]] which is useful for examining</p></li>
<li><p>the results from the cache, underlying storage, and any later read-throughs. The effect is</p></li>
<li><p>executed asynchronously from the request path and has no bearing on the Future[KeyValueResult]*</p></li>
<li><p>returned from this Repository.</p></li>
</ul>
<p><a href="#id77"><span class="problematic" id="id78">*</span></a>/</p>
</dd>
<dt>class CachingKeyValueRepository[Q &lt;: Seq[K], K, V](</dt><dd><p>underlying: KeyValueRepository[Q, K, V],
val cache: LockingCache[K, Cached[V]],
newQuery: SubqueryBuilder[Q, K],
handlerFactory: CachedResult.HandlerFactory[Q, K, V] =</p>
<blockquote>
<div><p>CachedResult.defaultHandlerFactory[Q, K, V],</p>
</div></blockquote>
<p>picker: LockingCache.Picker[Cached[V]] = new PreferNewestCached[V]: PreferNewestCached[V],
observer: CacheObserver = NullCacheObserver,
writeSoftTtlStep: Gate[Unit] = Gate.False,
cacheResultObserver: CachingKeyValueRepository.CacheResultObserver[K, V] =</p>
<blockquote>
<div><p>CacheResultObserver.unit[K, V]: Effect[CacheResultObserver.CachingRepositoryResult[K, V]])
extends KeyValueRepository[Q, K, V] {</p>
</div></blockquote>
<p>import CachedResult._
import CachedResultAction._</p>
<p>protected[this] val log = Logger.get(getClass.getSimpleName)
private[this] val rateLimitedLogger = new RateLimitingLogger(logger = log)</p>
<p>protected[this] val effectiveCacheStats = observer.scope(“effective”)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Calculates the softTtlStep based on result from cache and underlying store.</p></li>
<li><p>The softTtlStep indicates how many times we have</p></li>
<li><p>performed &amp; recorded a consistent read-through.</p></li>
<li><p>A value of None is equivalent to Some(0) - it indicates zero consistent read-throughs.</p></li>
</ul>
<p><a href="#id79"><span class="problematic" id="id80">*</span></a>/</p>
</dd>
<dt>protected[this] def updateSoftTtlStep(</dt><dd><p>underlyingResult: Option[V],
cachedResult: Cached[V]</p>
</dd>
<dt>): Option[Short] = {</dt><dd><dl>
<dt>if (writeSoftTtlStep() &amp;&amp; underlyingResult == cachedResult.value) {</dt><dd><dl class="simple">
<dt>cachedResult.softTtlStep match {</dt><dd><p>case Some(step) if step &lt; Short.MaxValue =&gt; Some((step + 1).toShort)
case Some(step) if step == Short.MaxValue =&gt; cachedResult.softTtlStep
case _ =&gt; Some(1)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>protected case class ProcessedCacheResult(</dt><dd><p>hits: Map[K, V],
misses: Seq[K],
doNotCache: Set[K],
failures: Map[K, Throwable],
tombstones: Set[K],
softExpirations: Seq[K],
transforms: Map[K, (V =&gt; V)])</p>
</dd>
<dt>override def apply(keys: Q): Future[KeyValueResult[K, V]] = {</dt><dd><dl>
<dt>getFromCache(keys).flatMap { cacheResult =&gt;</dt><dd><dl>
<dt>val ProcessedCacheResult(</dt><dd><p>hits,
misses,
doNotCache,
failures,
tombstones,
softExpirations,
transforms</p>
</dd>
<dt>) =</dt><dd><p>process(keys, cacheResult)</p>
</dd>
<dt>if (log.isLoggable(Level.TRACE)) {</dt><dd><dl>
<dt>log.trace(</dt><dd><dl class="simple">
<dt>“CachingKVR.apply keys %d hit %d miss %d noCache %d failure %d “ +</dt><dd><p>“tombstone %d softexp %d”,</p>
</dd>
</dl>
<p>keys.size,
hits.size,
misses.size,
doNotCache.size,
failures.size,
tombstones.size,
softExpirations.size</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}
recordCacheStats(</p>
<blockquote>
<div><p>keys,
notFound = misses.toSet,
doNotCache = doNotCache,
expired = softExpirations.toSet,
numFailures = failures.size,
numTombstones = tombstones.size</p>
</div></blockquote>
<p>)</p>
<p>// now read through all notFound
val underlyingQuery = newQuery(misses ++ doNotCache, keys)
val writeToCacheQuery = if (doNotCache.nonEmpty) newQuery(misses, keys) else underlyingQuery
val futureFromUnderlying = readThrough(underlyingQuery, writeToCacheQuery)</p>
<p>// async read-through for the expired results, ignore results
val softExpirationQuery = newQuery(softExpirations, keys)
val futureFromSoftExpiry = readThrough(softExpirationQuery, softExpirationQuery, cacheResult)</p>
<p>// merge all results together
for {</p>
<blockquote>
<div><p>fromUnderlying &lt;- futureFromUnderlying
fromCache = KeyValueResult(hits, tombstones, failures)
fromUnderlyingTransformed = transformResults(fromUnderlying, transforms)</p>
</div></blockquote>
<dl>
<dt>} yield {</dt><dd><dl>
<dt>futureFromSoftExpiry.onSuccess { readThroughResults =&gt;</dt><dd><dl>
<dt>cacheResultObserver(</dt><dd><dl class="simple">
<dt>CacheResultObserver.CachingRepositoryResult(</dt><dd><p>cacheResult,
fromUnderlyingTransformed,
readThroughResults</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}
KeyValueResult.sum(Seq(fromCache, fromUnderlyingTransformed))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Given results and a map of keys to transform functions, apply those transform functions</p></li>
<li><p>to the found results.</p></li>
</ul>
<p><a href="#id81"><span class="problematic" id="id82">*</span></a>/</p>
</dd>
<dt>protected[this] def transformResults(</dt><dd><p>results: KeyValueResult[K, V],
transforms: Map[K, (V =&gt; V)]</p>
</dd>
<dt>): KeyValueResult[K, V] = {</dt><dd><dl>
<dt>if (transforms.isEmpty) {</dt><dd><p>results</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>results.copy(found = results.found.map {</dt><dd><dl class="simple">
<dt>case (key, value) =&gt;</dt><dd><p>(key, transforms.get(key).map(_(value)).getOrElse(value))</p>
</dd>
</dl>
</dd>
</dl>
<p>})</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>protected[this] def getFromCache(keys: Seq[K]): Future[KeyValueResult[K, Cached[V]]] = {</dt><dd><p>val uniqueKeys = keys.distinct
cache.get(uniqueKeys) handle {</p>
<blockquote>
<div><dl>
<dt>case t: Throwable =&gt;</dt><dd><p>rateLimitedLogger.logThrowable(t, “exception caught in cache get”)</p>
<p>// treat total cache failure as a fetch that returned all failures
KeyValueResult(failed = uniqueKeys.map { _ -&gt; t }.toMap)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Buckets cache results according to the wishes of the CachedResultHandler</p></li>
</ul>
<p><a href="#id83"><span class="problematic" id="id84">*</span></a>/</p>
</dd>
<dt>protected[this] def process(</dt><dd><p>keys: Q,
cacheResult: KeyValueResult[K, Cached[V]]</p>
</dd>
<dt>): ProcessedCacheResult = {</dt><dd><p>val cachedResultHandler = handlerFactory(keys)</p>
<p>val hits = Map.newBuilder[K, V]
val misses = new mutable.ArrayBuffer[K]
val failures = Map.newBuilder[K, Throwable]
val tombstones = Set.newBuilder[K]
val softExpiredKeys = new mutable.ListBuffer[K]
val doNotCache = Set.newBuilder[K]
val transforms = Map.newBuilder[K, (V =&gt; V)]</p>
<dl>
<dt>for (key &lt;- keys) {</dt><dd><dl>
<dt>val cachedResult = cacheResult(key) match {</dt><dd><p>case Throw(t) =&gt; Failed(key, t)
case Return(None) =&gt; NotFound(key)
case Return(Some(cached)) =&gt;</p>
<blockquote>
<div><dl>
<dt>cached.status match {</dt><dd><dl>
<dt>case CachedValueStatus.Found =&gt;</dt><dd><dl>
<dt>cached.value match {</dt><dd><p>case None =&gt; NotFound(key)
case Some(value) =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>CachedFound(</dt><dd><p>key,
value,
cached.cachedAt,
cached.softTtlStep</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>case CachedValueStatus.NotFound =&gt; CachedNotFound(key, cached.cachedAt)
case CachedValueStatus.Deleted =&gt; CachedDeleted(key, cached.cachedAt)
case CachedValueStatus.SerializationFailed =&gt; SerializationFailed(key)
case CachedValueStatus.DeserializationFailed =&gt; DeserializationFailed(key)
case CachedValueStatus.Evicted =&gt; NotFound(key)
case CachedValueStatus.DoNotCache =&gt; DoNotCache(key, cached.doNotCacheUntil)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def processAction(action: CachedResultAction[V]): Unit = {</dt><dd><dl>
<dt>action match {</dt><dd><p>case HandleAsMiss =&gt; misses += key
case HandleAsFound(value) =&gt; hits += key -&gt; value
case HandleAsNotFound =&gt; tombstones += key
case HandleAsDoNotCache =&gt; doNotCache += key
case HandleAsFailed(t) =&gt; failures += key -&gt; t
case TransformSubAction(subAction, f) =&gt;</p>
<blockquote>
<div><p>transforms += key -&gt; f
processAction(subAction)</p>
</div></blockquote>
<dl class="simple">
<dt>case SoftExpiration(subAction) =&gt;</dt><dd><p>softExpiredKeys += key
processAction(subAction)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>processAction(cachedResultHandler(cachedResult))</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>ProcessedCacheResult(</dt><dd><p>hits.result(),
misses,
doNotCache.result(),
failures.result(),
tombstones.result(),
softExpiredKeys,
transforms.result()</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>protected[this] def recordCacheStats(</dt><dd><p>keys: Seq[K],
notFound: Set[K],
doNotCache: Set[K],
expired: Set[K],
numFailures: Int,
numTombstones: Int</p>
</dd>
<dt>): Unit = {</dt><dd><dl>
<dt>keys.foreach { key =&gt;</dt><dd><p>val wasntFound = notFound.contains(key)
val keyString = key.toString
if (wasntFound || expired.contains(key))</p>
<blockquote>
<div><p>effectiveCacheStats.miss(keyString)</p>
</div></blockquote>
<dl class="simple">
<dt>else</dt><dd><p>effectiveCacheStats.hit(keyString)</p>
</dd>
<dt>if (wasntFound)</dt><dd><p>observer.miss(keyString)</p>
</dd>
<dt>else</dt><dd><p>observer.hit(keyString)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
observer.expired(expired.size)
observer.failure(numFailures)
observer.tombstone(numTombstones)
observer.noCache(doNotCache.size)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>read through to the underlying repository</p></li>
<li></li>
<li><p>&#64;param cacheKeys</p></li>
<li><p>the keys to read and cache</p></li>
</ul>
<p><a href="#id85"><span class="problematic" id="id86">*</span></a>/</p>
</dd>
<dt>def readThrough(cacheKeys: Q): Future[KeyValueResult[K, V]] = {</dt><dd><p>readThrough(cacheKeys, cacheKeys)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>read through to the underlying repository</p></li>
<li></li>
<li><p>&#64;param writeToCacheQuery</p></li>
<li><p>the query to pass to the writeToCache method after getting a result back from the</p></li>
<li><p>underlying repository.  this query can be exactly the same as underlyingQuery if</p></li>
<li><p>all readThrough keys should be cached, or it may contain a subset of the keys if</p></li>
<li><p>some keys should not be written back to cache.</p></li>
<li><p>&#64;param cacheResult</p></li>
<li><p>the current cache results for underlyingQuery.</p></li>
</ul>
<p><a href="#id87"><span class="problematic" id="id88">*</span></a>/</p>
</dd>
<dt>def readThrough(</dt><dd><p>underlyingQuery: Q,
writeToCacheQuery: Q,
cacheResult: KeyValueResult[K, Cached[V]] = KeyValueResult.empty</p>
</dd>
<dt>): Future[KeyValueResult[K, V]] = {</dt><dd><dl>
<dt>if (underlyingQuery.isEmpty) {</dt><dd><p>KeyValueResult.emptyFuture</p>
</dd>
<dt>} else {</dt><dd><dl>
<dt>underlying(underlyingQuery).onSuccess { result =&gt;</dt><dd><dl class="simple">
<dt>if (writeToCacheQuery.nonEmpty) {</dt><dd><p>writeToCache(writeToCacheQuery, result, cacheResult)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Writes the contents of the given KeyValueResult to cache.</p></li>
</ul>
<p><a href="#id89"><span class="problematic" id="id90">*</span></a>/</p>
</dd>
<dt>def writeToCache(</dt><dd><p>keys: Q,
underlyingResult: KeyValueResult[K, V],
cacheResult: KeyValueResult[K, Cached[V]] = KeyValueResult[K, Cached[V]]()</p>
</dd>
<dt>): Unit = {</dt><dd><dl class="simple">
<dt>lazy val cachedEmpty = {</dt><dd><p>val now = Time.now
Cached[V](None, CachedValueStatus.NotFound, now, Some(now), softTtlStep = None)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>keys.foreach { key =&gt;</dt><dd><p>// only cache Returns from the underlying repo, skip Throws.
// iff cached value matches value from underlying store
// (for both NotFound and Found results), increment softTtlStep
// otherwise, set softTtlStep to None
underlyingResult(key) match {</p>
<blockquote>
<div><dl>
<dt>case Return(optUnderlyingVal) =&gt;</dt><dd><dl>
<dt>val softTtlStep =</dt><dd><dl class="simple">
<dt>cacheResult(key) match {</dt><dd><p>case Return(Some(cacheVal)) =&gt; updateSoftTtlStep(optUnderlyingVal, cacheVal)
case _ =&gt; None</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>val status =</dt><dd><dl class="simple">
<dt>optUnderlyingVal match {</dt><dd><p>case Some(_) =&gt; CachedValueStatus.Found
case None =&gt; CachedValueStatus.NotFound</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>val cached =</dt><dd><dl class="simple">
<dt>cachedEmpty.copy(</dt><dd><p>value = optUnderlyingVal,
status = status,
softTtlStep = softTtlStep</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>cache</dt><dd><p>.lockAndSet(key, LockingCache.PickingHandler(cached, picker))
.onFailure {</p>
<blockquote>
<div><dl class="simple">
<dt>case t: Throwable =&gt;</dt><dd><p>rateLimitedLogger.logThrowable(t, “exception caught in lockAndSet”)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>case Throw(_) =&gt; None</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../../_sources/tweetypie/servo/repo/src/main/scala/com/twitter/servo/repository/CachingKeyValueRepository.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>