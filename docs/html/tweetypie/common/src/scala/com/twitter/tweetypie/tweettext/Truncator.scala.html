<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../" id="documentation_options" src="../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie.tweettext</p>
<p>import com.twitter.tweetypie.tweettext.TweetText._
import com.twitter.twittertext.Extractor
import java.lang.Character
import scala.annotation.tailrec
import scala.collection.JavaConverters._</p>
<dl>
<dt>object Truncator {</dt><dd><p>val Ellipsis = “u2026”</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Truncate tweet text for a retweet. If the text is longer than</p></li>
<li><p>either of the length limits, code points are cut off from the end</p></li>
<li><p>of the text and replaced with an ellipsis. We keep as much of the</p></li>
<li><p>leading text as possible, subject to these constraints:</p></li>
<li></li>
<li><ul>
<li><p>There are no more than <cite>MaxDisplayLength</cite> characters.</p></li>
</ul>
</li>
<li></li>
<li><ul>
<li><p>When converted to UTF-8, the result does not exceed <cite>MaxByteLength</cite>.</p></li>
</ul>
</li>
<li></li>
<li><ul>
<li><p>We do not break within a single grapheme cluster.</p></li>
</ul>
</li>
<li></li>
<li><p>The input is assumed to be partial HTML-encoded and may or may</p></li>
<li><p>not be NFC normalized. The result will be partial HTML-encoded</p></li>
<li><p>and will be NFC normalized.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
</dl>
<p>def truncateForRetweet(input: String): String = truncateWithEllipsis(input, Ellipsis)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Truncate to [[com.twitter.tweetypie.tweettext.TweetText#OrginalMaxDisplayLength]] display</p></li>
<li><p>units, using “…” as an ellipsis. The resulting text is guaranteed to pass our tweet length</p></li>
<li><p>check, but it is not guaranteed to fit in a SMS message.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
</dl>
<p>def truncateForSms(input: String): String = truncateWithEllipsis(input, “…”)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Check the length of the given text, and truncate it if it is longer</p></li>
<li><p>than the allowed length for a Tweet. The result of this method will</p></li>
<li><p>always have:</p></li>
<li></li>
<li><ul>
<li><p>Display length &lt;= OriginalMaxDisplayLength.</p></li>
</ul>
</li>
<li><ul>
<li><p>Length when encoded as UTF-8 &lt;= OriginalMaxUtf8Length.</p></li>
</ul>
</li>
<li></li>
<li><p>If the input would violate this, then the text will be</p></li>
<li><p>truncated. When the text is truncated, it will be truncated such</p></li>
<li><p>that:</p></li>
<li></li>
<li><ul>
<li><p>Grapheme clusters will not be split.</p></li>
</ul>
</li>
<li><ul>
<li><p>The last character before the ellipsis will not be a whitespace</p></li>
</ul>
</li>
<li><p>character.</p></li>
<li><ul>
<li><p>The ellipsis text will be appended to the end.</p></li>
</ul>
</li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>private[this] def truncateWithEllipsis(input: String, ellipsis: String): String = {</dt><dd><p>val text = nfcNormalize(input)
val truncateAt =</p>
<blockquote>
<div><p>truncationPoint(text, OriginalMaxDisplayLength, OriginalMaxUtf8Length, Some(ellipsis))</p>
</div></blockquote>
<p>if (truncateAt.codeUnitOffset.toInt == text.length) text
else text.take(truncateAt.codeUnitOffset.toInt) + ellipsis</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Indicates a potential TruncationPoint in piece of text.</p></li>
<li></li>
<li><p>&#64;param charOffset the utf-16 character offset of the truncation point</p></li>
<li><p>&#64;param codePointOffset the offset in code points</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
</dl>
<p>case class TruncationPoint(codeUnitOffset: Offset.CodeUnit, codePointOffset: Offset.CodePoint)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Computes a TruncationPoint for the given text and length constraints.  If <cite>truncated</cite> on</p></li>
<li><p>the result is <cite>false</cite>, it means the text will fit within the given constraints without</p></li>
<li><p>truncation.  Otherwise, the result indicates both the character and code-point offsets</p></li>
<li><p>at which to perform the truncation, and the resulting display length and byte length of</p></li>
<li><p>the truncated string.</p></li>
<li></li>
<li><p>Text should be NFC normalized first for best results.</p></li>
<li></li>
<li><p>&#64;param withEllipsis if true, then the truncation point will be computed so that there is space</p></li>
<li><p>to append an ellipsis and to still remain within the limits.  The ellipsis is not counted</p></li>
<li><p>in the returned display and byte lengths.</p></li>
<li></li>
<li><p>&#64;param atomicUnits may contain a list of ranges that should be treated as atomic unit and</p></li>
<li><p>not split.  each tuple is half-open range in code points.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>def truncationPoint(</dt><dd><p>text: String,
maxDisplayLength: Int = OriginalMaxDisplayLength,
maxByteLength: Int = OriginalMaxUtf8Length,
withEllipsis: Option[String] = None,
atomicUnits: Offset.Ranges[Offset.CodePoint] = Offset.Ranges.Empty</p>
</dd>
<dt>): TruncationPoint = {</dt><dd><dl class="simple">
<dt>val breakPoints =</dt><dd><dl class="simple">
<dt>GraphemeIndexIterator</dt><dd><p>.ends(text)
.filterNot(Offset.Ranges.htmlEntities(text).contains)</p>
</dd>
</dl>
</dd>
<dt>val ellipsisDisplayUnits =</dt><dd><p>withEllipsis.map(Offset.DisplayUnit.length).getOrElse(Offset.DisplayUnit(0))</p>
</dd>
</dl>
<p>val maxTruncatedDisplayLength = Offset.DisplayUnit(maxDisplayLength) - ellipsisDisplayUnits</p>
<p>val ellipsisByteLength = withEllipsis.map(Offset.Utf8.length).getOrElse(Offset.Utf8(0))
val maxTruncatedByteLength = Offset.Utf8(maxByteLength) - ellipsisByteLength</p>
<p>var codeUnit = Offset.CodeUnit(0)
var codePoint = Offset.CodePoint(0)
var displayLength = Offset.DisplayUnit(0)
var byteLength = Offset.Utf8(0)
var truncateCodeUnit = codeUnit
var truncateCodePoint = codePoint</p>
<dl>
<dt>&#64;tailrec def go(): TruncationPoint =</dt><dd><dl class="simple">
<dt>if (displayLength.toInt &gt; maxDisplayLength || byteLength.toInt &gt; maxByteLength) {</dt><dd><p>TruncationPoint(truncateCodeUnit, truncateCodePoint)</p>
</dd>
<dt>} else if (codeUnit != truncateCodeUnit &amp;&amp;</dt><dd><p>displayLength &lt;= maxTruncatedDisplayLength &amp;&amp;
byteLength &lt;= maxTruncatedByteLength &amp;&amp;
(codeUnit.toInt == 0 || !Character.isWhitespace(text.codePointBefore(codeUnit.toInt))) &amp;&amp;
!atomicUnits.contains(codePoint)) {
// we can advance the truncation point
truncateCodeUnit = codeUnit
truncateCodePoint = codePoint
go()</p>
</dd>
<dt>} else if (breakPoints.hasNext) {</dt><dd><p>// there are further truncation points to consider
val nextCodeUnit = breakPoints.next
codePoint += Offset.CodePoint.count(text, codeUnit, nextCodeUnit)
displayLength += Offset.DisplayUnit.count(text, codeUnit, nextCodeUnit)
byteLength += Offset.Utf8.count(text, codeUnit, nextCodeUnit)
codeUnit = nextCodeUnit
go()</p>
</dd>
<dt>} else {</dt><dd><p>TruncationPoint(codeUnit, codePoint)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>go()</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Truncate the given text, avoiding chopping HTML entities and tweet</p></li>
<li><p>entities. This should only be used for testing because it performs</p></li>
<li><p>entity extraction, and so is very inefficient.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>def truncateForTests(</dt><dd><p>input: String,
maxDisplayLength: Int = OriginalMaxDisplayLength,
maxByteLength: Int = OriginalMaxUtf8Length</p>
</dd>
<dt>): String = {</dt><dd><p>val text = nfcNormalize(input)
val extractor = new Extractor
val entities = extractor.extractEntitiesWithIndices(text)
extractor.modifyIndicesFromUTF16ToUnicode(text, entities)
val avoid = Offset.Ranges.fromCodePointPairs(</p>
<blockquote>
<div><p>entities.asScala.map(e =&gt; (e.getStart().intValue, e.getEnd().intValue))</p>
</div></blockquote>
<p>)
val truncateAt = truncationPoint(text, maxDisplayLength, maxByteLength, None, avoid)
text.take(truncateAt.codeUnitOffset.toInt)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../_sources/tweetypie/common/src/scala/com/twitter/tweetypie/tweettext/Truncator.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>