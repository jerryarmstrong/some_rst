<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../" id="documentation_options" src="../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>/** Copyright 2010 Twitter, Inc. <a href="#id1"><span class="problematic" id="id2">*</span></a>/
package com.twitter.tweetypie
package tflock</p>
<p>import com.twitter.finagle.stats.Counter
import com.twitter.flockdb.client._
import com.twitter.flockdb.client.thriftscala.Priority
import com.twitter.snowflake.id.SnowflakeId
import com.twitter.tweetypie.serverutil.StoredCard
import com.twitter.tweetypie.thriftscala._
import com.twitter.util.Future
import scala.collection.mutable.ListBuffer</p>
<p>object TFlockIndexer {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Printable names for some edge types currently defined in [[com.twitter.flockdb.client]].</p></li>
<li><p>Used to defined stats counters for adding edges.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>val graphNames: Map[Int, String] =</dt><dd><dl class="simple">
<dt>Map(</dt><dd><p>CardTweetsGraph.id -&gt; “card_tweets”,
ConversationGraph.id -&gt; “conversation”,
DirectedAtUserIdGraph.id -&gt; “directed_at_user_id”,
InvitedUsersGraph.id -&gt; “invited_users”,
MediaTimelineGraph.id -&gt; “media_timeline”,
MentionsGraph.id -&gt; “mentions”,
NarrowcastSentTweetsGraph.id -&gt; “narrowcast_sent_tweets”,
NullcastedTweetsGraph.id -&gt; “nullcasted_tweets”,
QuotersGraph.id -&gt; “quoters”,
QuotesGraph.id -&gt; “quotes”,
QuoteTweetsIndexGraph.id -&gt; “quote_tweets_index”,
RepliesToTweetsGraph.id -&gt; “replies_to_tweets”,
RetweetsByMeGraph.id -&gt; “retweets_by_me”,
RetweetsGraph.id -&gt; “retweets”,
RetweetsOfMeGraph.id -&gt; “retweets_of_me”,
RetweetSourceGraph.id -&gt; “retweet_source”,
TweetsRetweetedGraph.id -&gt; “tweets_retweeted”,
UserTimelineGraph.id -&gt; “user_timeline”,
CreatorSubscriptionTimelineGraph.id -&gt; “creator_subscription_timeline”,
CreatorSubscriptionMediaTimelineGraph.id -&gt; “creator_subscription_image_timeline”,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>On edge deletion, edges are either archived permanently or retained for 3 months, based on</p></li>
<li><p>the retention policy in the above confluence page.</p></li>
<li></li>
<li><p>These two retention policies correspond to the two deletion techniques: archive and remove.</p></li>
<li><p>We call removeEdges for edges with a short retention policy and archiveEdges for edges with</p></li>
<li><p>a permanent retention policy.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>val graphsWithRemovedEdges: Seq[Int] =</dt><dd><dl class="simple">
<dt>Seq(</dt><dd><p>CardTweetsGraph.id,
CuratedTimelineGraph.id,
CuratedTweetsGraph.id,
DirectedAtUserIdGraph.id,
MediaTimelineGraph.id,
MutedConversationsGraph.id,
QuotersGraph.id,
QuotesGraph.id,
QuoteTweetsIndexGraph.id,
ReportedTweetsGraph.id,
RetweetsOfMeGraph.id,
RetweetSourceGraph.id,
SoftLikesGraph.id,
TweetsRetweetedGraph.id,
CreatorSubscriptionTimelineGraph.id,
CreatorSubscriptionMediaTimelineGraph.id,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>These edges should be left in place when bounced tweets are deleted.</p></li>
<li><p>These edges are removed during hard deletion.</p></li>
<li></li>
<li><p>This is done so external teams (timelines) can execute on these edges for</p></li>
<li><p>tombstone feature.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>val bounceDeleteGraphIds: Set[Int] =</dt><dd><dl class="simple">
<dt>Set(</dt><dd><p>UserTimelineGraph.id,
ConversationGraph.id</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>def makeCounters(stats: StatsReceiver, operation: String): Map[Int, Counter] = {</dt><dd><dl class="simple">
<dt>TFlockIndexer.graphNames</dt><dd><p>.mapValues(stats.scope(_).counter(operation))
.withDefaultValue(stats.scope(“unknown”).counter(operation))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>&#64;param backgroundIndexingPriority specifies the queue to use for</p></li>
<li><p>background indexing operations. This is useful for making the</p></li>
<li><p>effects of background indexing operations (such as deleting edges</p></li>
<li><p>for deleted Tweets) available sooner in testing scenarios</p></li>
<li><p>(end-to-end tests or development instances). It is set to</p></li>
<li><p>Priority.Low in production to reduce the load on high priority</p></li>
<li><p>queues that we use for prominently user-visible operations.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>class TFlockIndexer(</dt><dd><p>tflock: TFlockClient,
hasMedia: Tweet =&gt; Boolean,
backgroundIndexingPriority: Priority,
stats: StatsReceiver)</p>
<blockquote>
<div><p>extends TweetIndexer {</p>
</div></blockquote>
<p>private[this] val FutureNil = Future.Nil</p>
<p>private[this] val archiveCounters = TFlockIndexer.makeCounters(stats, “archive”)
private[this] val removeCounters = TFlockIndexer.makeCounters(stats, “remove”)
private[this] val insertCounters = TFlockIndexer.makeCounters(stats, “insert”)
private[this] val negateCounters = TFlockIndexer.makeCounters(stats, “negate”)</p>
<p>private[this] val foregroundIndexingPriority: Priority = Priority.High</p>
<dl>
<dt>override def createIndex(tweet: Tweet): Future[Unit] =</dt><dd><p>createEdges(tweet, isUndelete = false)</p>
</dd>
<dt>override def undeleteIndex(tweet: Tweet): Future[Unit] =</dt><dd><p>createEdges(tweet, isUndelete = true)</p>
</dd>
<dt>private[this] case class PartitionedEdges(</dt><dd><p>longRetention: Seq[ExecuteEdge[StatusGraph]] = Nil,
shortRetention: Seq[ExecuteEdge[StatusGraph]] = Nil,
negate: Seq[ExecuteEdge[StatusGraph]] = Nil,
ignore: Seq[ExecuteEdge[StatusGraph]] = Nil)</p>
</dd>
<dt>private[this] def partitionEdgesForDelete(</dt><dd><p>edges: Seq[ExecuteEdge[StatusGraph]],
isBounceDelete: Boolean</p>
</dd>
<dt>) =</dt><dd><dl>
<dt>edges.foldLeft(PartitionedEdges()) {</dt><dd><p>// Two dependees of UserTimelineGraph edge states to satisfy: timelines &amp; safety tools.
// Timelines show bounce-deleted tweets as tombstones; regular deletes are not shown.
//   - i.e. timelineIds = UserTimelineGraph(Normal || Negative)
// Safety tools show deleted tweets to authorized internal review agents
//   - i.e. deletedIds = UserTimelineGraph(Removed || Negative)
case (partitionedEdges, edge) if isBounceDelete &amp;&amp; edge.graphId == UserTimelineGraph.id =&gt;</p>
<blockquote>
<div><p>partitionedEdges.copy(negate = edge +: partitionedEdges.negate)</p>
</div></blockquote>
<dl>
<dt>case (partitionedEdges, edge) if isBounceDelete &amp;&amp; edge.graphId == ConversationGraph.id =&gt;</dt><dd><p>// Bounce-deleted tweets remain rendered as tombstones in conversations, so do not modify
// the ConversationGraph edge state
partitionedEdges.copy(ignore = edge +: partitionedEdges.ignore)</p>
</dd>
<dt>case (partitionedEdges, edge)</dt><dd><blockquote>
<div><p>if TFlockIndexer.graphsWithRemovedEdges.contains(edge.graphId) =&gt;</p>
</div></blockquote>
<p>partitionedEdges.copy(shortRetention = edge +: partitionedEdges.shortRetention)</p>
</dd>
<dt>case (partitionedEdges, edge) =&gt;</dt><dd><p>partitionedEdges.copy(longRetention = edge +: partitionedEdges.longRetention)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override def deleteIndex(tweet: Tweet, isBounceDelete: Boolean): Future[Unit] =</dt><dd><dl>
<dt>for {</dt><dd><p>edges &lt;- getEdges(tweet, isCreate = false, isDelete = true, isUndelete = false)
partitionedEdges = partitionEdgesForDelete(edges, isBounceDelete)
() &lt;-</p>
<blockquote>
<div><dl>
<dt>Future</dt><dd><dl>
<dt>.join(</dt><dd><dl>
<dt>tflock</dt><dd><p>.archiveEdges(partitionedEdges.longRetention, backgroundIndexingPriority)
.onSuccess(_ =&gt;</p>
<blockquote>
<div><p>partitionedEdges.longRetention.foreach(e =&gt; archiveCounters(e.graphId).incr())),</p>
</div></blockquote>
</dd>
<dt>tflock</dt><dd><p>.removeEdges(partitionedEdges.shortRetention, backgroundIndexingPriority)
.onSuccess(_ =&gt;</p>
<blockquote>
<div><p>partitionedEdges.shortRetention.foreach(e =&gt; removeCounters(e.graphId).incr())),</p>
</div></blockquote>
</dd>
<dt>tflock</dt><dd><p>.negateEdges(partitionedEdges.negate, backgroundIndexingPriority)
.onSuccess(_ =&gt;</p>
<blockquote>
<div><p>partitionedEdges.negate.foreach(e =&gt; negateCounters(e.graphId).incr()))</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>)
.unit</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>} yield ()</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>This operation is called when a user is put into or taken out of</p></li>
<li><p>a state in which their retweets should no longer be visible</p></li>
<li><p>(e.g. suspended or ROPO).</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>override def setRetweetVisibility(retweetId: TweetId, setVisible: Boolean): Future[Unit] = {</dt><dd><p>val retweetEdge = Seq(ExecuteEdge(retweetId, RetweetsGraph, None, Reverse))</p>
<dl class="simple">
<dt>if (setVisible) {</dt><dd><dl class="simple">
<dt>tflock</dt><dd><p>.insertEdges(retweetEdge, backgroundIndexingPriority)
.onSuccess(_ =&gt; insertCounters(RetweetsGraph.id).incr())</p>
</dd>
</dl>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>tflock</dt><dd><p>.archiveEdges(retweetEdge, backgroundIndexingPriority)
.onSuccess(_ =&gt; archiveCounters(RetweetsGraph.id).incr())</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private[this] def createEdges(tweet: Tweet, isUndelete: Boolean): Future[Unit] =</dt><dd><dl class="simple">
<dt>for {</dt><dd><p>edges &lt;- getEdges(tweet = tweet, isCreate = true, isDelete = false, isUndelete = isUndelete)
() &lt;- tflock.insertEdges(edges, foregroundIndexingPriority)</p>
</dd>
<dt>} yield {</dt><dd><p>// Count all the edges we’ve successfully added:
edges.foreach(e =&gt; insertCounters(e.graphId).incr())</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>private[this] def addRTEdges(</dt><dd><p>tweet: Tweet,
share: Share,
isCreate: Boolean,
edges: ListBuffer[ExecuteEdge[StatusGraph]],
futureEdges: ListBuffer[Future[Seq[ExecuteEdge[StatusGraph]]]]</p>
</dd>
</dl>
<p>): Unit = {</p>
<blockquote>
<div><p>edges += RetweetsOfMeGraph.edge(share.sourceUserId, tweet.id)
edges += RetweetsByMeGraph.edge(getUserId(tweet), tweet.id)
edges += RetweetsGraph.edge(share.sourceStatusId, tweet.id)</p>
<dl>
<dt>if (isCreate) {</dt><dd><dl class="simple">
<dt>edges += ExecuteEdge(</dt><dd><p>sourceId = getUserId(tweet),
graph = RetweetSourceGraph,
destinationIds = Some(Seq(share.sourceStatusId)),
direction = Forward,
position = Some(SnowflakeId(tweet.id).time.inMillis)</p>
</dd>
</dl>
<p>)
edges.append(TweetsRetweetedGraph.edge(share.sourceUserId, share.sourceStatusId))</p>
</dd>
<dt>} else {</dt><dd><p>edges += RetweetSourceGraph.edge(getUserId(tweet), share.sourceStatusId)</p>
<p>// if this is the last retweet we need to remove it from the source user’s
// tweets retweeted graph
futureEdges.append(</p>
<blockquote>
<div><dl>
<dt>tflock.count(RetweetsGraph.from(share.sourceStatusId)).flatMap { count =&gt;</dt><dd><dl>
<dt>if (count &lt;= 1) {</dt><dd><dl class="simple">
<dt>tflock.selectAll(RetweetsGraph.from(share.sourceStatusId)).map { tweets =&gt;</dt><dd><dl class="simple">
<dt>if (tweets.size &lt;= 1)</dt><dd><p>Seq(TweetsRetweetedGraph.edge(share.sourceUserId, share.sourceStatusId))</p>
</dd>
<dt>else</dt><dd><p>Nil</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>FutureNil</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private[this] def addReplyEdges(</dt><dd><p>tweet: Tweet,
edges: ListBuffer[ExecuteEdge[StatusGraph]]</p>
</dd>
<dt>): Unit = {</dt><dd><dl>
<dt>getReply(tweet).foreach { reply =&gt;</dt><dd><dl>
<dt>reply.inReplyToStatusId.flatMap { inReplyToStatusId =&gt;</dt><dd><p>edges += RepliesToTweetsGraph.edge(inReplyToStatusId, tweet.id)</p>
<p>// only index conversationId if this is a reply to another tweet
TweetLenses.conversationId.get(tweet).map { conversationId =&gt;</p>
<blockquote>
<div><p>edges += ConversationGraph.edge(conversationId, tweet.id)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private[this] def addDirectedAtEdges(</dt><dd><p>tweet: Tweet,
edges: ListBuffer[ExecuteEdge[StatusGraph]]</p>
</dd>
<dt>): Unit = {</dt><dd><dl class="simple">
<dt>TweetLenses.directedAtUser.get(tweet).foreach { directedAtUser =&gt;</dt><dd><p>edges += DirectedAtUserIdGraph.edge(directedAtUser.userId, tweet.id)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private[this] def addMentionEdges(</dt><dd><p>tweet: Tweet,
edges: ListBuffer[ExecuteEdge[StatusGraph]]</p>
</dd>
<dt>): Unit = {</dt><dd><dl>
<dt>getMentions(tweet)</dt><dd><dl class="simple">
<dt>.flatMap(_.userId).foreach { mention =&gt;</dt><dd><p>edges += MentionsGraph.edge(mention, tweet.id)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private[this] def addQTEdges(</dt><dd><p>tweet: Tweet,
edges: ListBuffer[ExecuteEdge[StatusGraph]],
futureEdges: ListBuffer[Future[Seq[ExecuteEdge[StatusGraph]]]],
isCreate: Boolean</p>
</dd>
<dt>): Unit = {</dt><dd><p>val userId = getUserId(tweet)</p>
<dl>
<dt>tweet.quotedTweet.foreach { quotedTweet =&gt;</dt><dd><p>// Regardless of tweet creates/deletes, we add the corresponding edges to the
// following two graphs. Note that we’re handling the case for
// the QuotersGraph slightly differently in the tweet delete case.
edges.append(QuotesGraph.edge(quotedTweet.userId, tweet.id))
edges.append(QuoteTweetsIndexGraph.edge(quotedTweet.tweetId, tweet.id))
if (isCreate) {</p>
<blockquote>
<div><p>// As mentioned above, for tweet creates we go ahead and add an edge
// to the QuotersGraph without any additional checks.
edges.append(QuotersGraph.edge(quotedTweet.tweetId, userId))</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>// For tweet deletes, we only add an edge to be deleted from the
// QuotersGraph if the tweeting user isn’t quoting the tweet anymore
// i.e. if a user has quoted a tweet multiple times, we only delete
// an edge from the QuotersGraph if they’ve deleted all the quotes,
// otherwise an edge should exist by definition of what the QuotersGraph
// represents.</p>
<p>// Note: There can be a potential edge case here due to a race condition
// in the following scenario.
// i)   A quotes a tweet T twice resulting in tweets T1 and T2.
// ii)  There should exist edges in the QuotersGraph from T -&gt; A and T1 &lt;-&gt; T, T2 &lt;-&gt; T in
//      the QuoteTweetsIndexGraph, but one of the edges haven’t been written
//      to the QuoteTweetsIndex graph in TFlock yet.
// iii) In this scenario, we shouldn’t really be deleting an edge as we’re doing below.
// The approach that we’re taking below is a “best effort” approach similar to what we
// currently do for RTs.</p>
<p>// Find all the quotes of the quoted tweet from the quoting user
val quotesFromQuotingUser = QuoteTweetsIndexGraph</p>
<blockquote>
<div><p>.from(quotedTweet.tweetId)
.intersect(UserTimelineGraph.from(userId))</p>
</div></blockquote>
<dl>
<dt>futureEdges.append(</dt><dd><dl>
<dt>tflock</dt><dd><dl>
<dt>.count(quotesFromQuotingUser).flatMap { count =&gt;</dt><dd><p>// If this is the last quote of the quoted tweet from the quoting user,
// we go ahead and delete the edge from the QuotersGraph.
if (count &lt;= 1) {</p>
<blockquote>
<div><dl>
<dt>tflock.selectAll(quotesFromQuotingUser).map { tweets =&gt;</dt><dd><dl class="simple">
<dt>if (tweets.size &lt;= 1) {</dt><dd><p>Seq(QuotersGraph.edge(quotedTweet.tweetId, userId))</p>
</dd>
<dt>} else {</dt><dd><p>Nil</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>FutureNil</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private[this] def addCardEdges(</dt><dd><p>tweet: Tweet,
edges: ListBuffer[ExecuteEdge[StatusGraph]]</p>
</dd>
<dt>): Unit = {</dt><dd><p>// Note that we are indexing only the TOO “stored” cards
// (cardUri=card://&lt;cardId&gt;). Rest of the cards are ignored here.
tweet.cardReference</p>
<blockquote>
<div><dl class="simple">
<dt>.collect {</dt><dd><dl class="simple">
<dt>case StoredCard(id) =&gt;</dt><dd><p>edges.append(CardTweetsGraph.edge(id, tweet.id))</p>
</dd>
</dl>
</dd>
</dl>
<p>}.getOrElse(())</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<p>// Note: on undelete, this method restores all archived edges, including those that may have
// been archived prior to the delete. This is incorrect behavior but in practice rarely
// causes problems, as undeletes are so rare.
private[this] def addEdgesForDeleteOrUndelete(</p>
<blockquote>
<div><p>tweet: Tweet,
edges: ListBuffer[ExecuteEdge[StatusGraph]]</p>
</div></blockquote>
<dl>
<dt>): Unit = {</dt><dd><dl>
<dt>edges.appendAll(</dt><dd><dl class="simple">
<dt>Seq(</dt><dd><p>MentionsGraph.edges(tweet.id, None, Reverse),
RepliesToTweetsGraph.edges(tweet.id, None)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
<p>// When we delete or undelete a conversation control root Tweet we want to archive or restore
// all the edges in InvitedUsersGraph from the Tweet id.
if (hasConversationControl(tweet) &amp;&amp; isConversationRoot(tweet)) {</p>
<blockquote>
<div><p>edges.append(InvitedUsersGraph.edges(tweet.id, None))</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private[this] def addSimpleEdges(</dt><dd><p>tweet: Tweet,
edges: ListBuffer[ExecuteEdge[StatusGraph]]</p>
</dd>
<dt>): Unit = {</dt><dd><dl>
<dt>if (TweetLenses.nullcast.get(tweet)) {</dt><dd><p>edges.append(NullcastedTweetsGraph.edge(getUserId(tweet), tweet.id))</p>
</dd>
<dt>} else if (TweetLenses.narrowcast.get(tweet).isDefined) {</dt><dd><p>edges.append(NarrowcastSentTweetsGraph.edge(getUserId(tweet), tweet.id))</p>
</dd>
<dt>} else {</dt><dd><p>edges.append(UserTimelineGraph.edge(getUserId(tweet), tweet.id))</p>
<dl class="simple">
<dt>if (hasMedia(tweet))</dt><dd><p>edges.append(MediaTimelineGraph.edge(getUserId(tweet), tweet.id))</p>
</dd>
</dl>
<p>// Index root creator subscription tweets.
// Ignore replies because those are not necessarily visible to a user who subscribes to tweet author
val isRootTweet: Boolean = tweet.coreData match {</p>
<blockquote>
<div><p>case Some(c) =&gt; c.reply.isEmpty &amp;&amp; c.share.isEmpty
case None =&gt; true</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>if (tweet.exclusiveTweetControl.isDefined &amp;&amp; isRootTweet) {</dt><dd><p>edges.append(CreatorSubscriptionTimelineGraph.edge(getUserId(tweet), tweet.id))</p>
<dl class="simple">
<dt>if (hasMedia(tweet))</dt><dd><p>edges.append(CreatorSubscriptionMediaTimelineGraph.edge(getUserId(tweet), tweet.id))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Issues edges for each mention of user in a conversation-controlled tweet. This way InvitedUsers</p></li>
<li><p>graph accumulates complete set of ids for &#64;mention-invited users, by conversation id.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>private def invitedUsersEdgesForCreate(</dt><dd><p>tweet: Tweet,
edges: ListBuffer[ExecuteEdge[StatusGraph]]</p>
</dd>
<dt>): Unit = {</dt><dd><p>val conversationId: Long = getConversationId(tweet).getOrElse(tweet.id)
val mentions: Seq[UserId] = getMentions(tweet).flatMap(_.userId)
edges.appendAll(mentions.map(userId =&gt; InvitedUsersGraph.edge(conversationId, userId)))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Issues edges of InviteUsersGraph that ought to be deleted for a conversation controlled reply.</p></li>
<li><p>These are mentions of users in the given tweet, only if the user was not mentioned elsewhere</p></li>
<li><p>in the conversation. This way for a conversation, InvitedUsersGraph would always hold a set</p></li>
<li><p>of all users invited to the conversation, and an edge is removed only after the last mention of</p></li>
<li><p>a user is deleted.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>private def invitedUsersEdgesForDelete(</dt><dd><p>tweet: Tweet,
futureEdges: ListBuffer[Future[Seq[ExecuteEdge[StatusGraph]]]]</p>
</dd>
<dt>): Unit = {</dt><dd><dl>
<dt>getConversationId(tweet).foreach { conversationId: Long =&gt;</dt><dd><p>val mentions: Seq[UserId] = getMentions(tweet).flatMap(_.userId)
mentions.foreach { userId =&gt;</p>
<blockquote>
<div><p>val tweetIdsWithinConversation = ConversationGraph.from(conversationId)
val tweetIdsThatMentionUser = MentionsGraph.from(userId)
futureEdges.append(</p>
<blockquote>
<div><dl>
<dt>tflock</dt><dd><dl>
<dt>.selectAll(</dt><dd><p>query = tweetIdsThatMentionUser.intersect(tweetIdsWithinConversation),
limit = Some(2), // Just need to know if it is &gt;1 or &lt;=1, so 2 are enough.
pageSize = None // Provide default, otherwise Mockito complains</p>
</dd>
<dt>).map { tweetIds: Seq[Long] =&gt;</dt><dd><dl class="simple">
<dt>if (tweetIds.size &lt;= 1) {</dt><dd><p>Seq(InvitedUsersGraph.edge(conversationId, userId))</p>
</dd>
<dt>} else {</dt><dd><p>Nil</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def hasInviteViaMention(tweet: Tweet): Boolean = {</dt><dd><dl class="simple">
<dt>tweet.conversationControl match {</dt><dd><dl class="simple">
<dt>case Some(ConversationControl.ByInvitation(controls)) =&gt;</dt><dd><p>controls.inviteViaMention.getOrElse(false)</p>
</dd>
<dt>case Some(ConversationControl.Community(controls)) =&gt;</dt><dd><p>controls.inviteViaMention.getOrElse(false)</p>
</dd>
<dt>case Some(ConversationControl.Followers(followers)) =&gt;</dt><dd><p>followers.inviteViaMention.getOrElse(false)</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>false</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private def hasConversationControl(tweet: Tweet): Boolean =</dt><dd><p>tweet.conversationControl.isDefined</p>
</dd>
</dl>
<p>// If a Tweet has a ConversationControl, it must have a ConversationId associated with it so we
// can compare the ConversationId with the current Tweet ID to determine if it’s the root of the
// conversation. See ConversationIdHydrator for more details
private def isConversationRoot(tweet: Tweet): Boolean =</p>
<blockquote>
<div><p>getConversationId(tweet).get == tweet.id</p>
</div></blockquote>
<dl>
<dt>private def addInvitedUsersEdges(</dt><dd><p>tweet: Tweet,
isCreate: Boolean,
isUndelete: Boolean,
edges: ListBuffer[ExecuteEdge[StatusGraph]],
futureEdges: ListBuffer[Future[Seq[ExecuteEdge[StatusGraph]]]]</p>
</dd>
<dt>): Unit = {</dt><dd><dl>
<dt>if (hasConversationControl(tweet)) {</dt><dd><dl>
<dt>if (isCreate) {</dt><dd><dl class="simple">
<dt>if (isConversationRoot(tweet) &amp;&amp; !isUndelete) {</dt><dd><p>// For root Tweets, only add edges for original creates, not for undeletes.
// Undeletes are handled by addEdgesForDeleteOrUndelete.
invitedUsersEdgesForCreate(tweet, edges)</p>
</dd>
</dl>
<p>}
if (!isConversationRoot(tweet) &amp;&amp; hasInviteViaMention(tweet)) {</p>
<blockquote>
<div><p>// For replies, only add edges when the conversation control is in inviteViaMention mode.
invitedUsersEdgesForCreate(tweet, edges)</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>if (!isConversationRoot(tweet)) {</dt><dd><p>invitedUsersEdgesForDelete(tweet, futureEdges)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private[this] def getEdges(</dt><dd><p>tweet: Tweet,
isCreate: Boolean,
isDelete: Boolean,
isUndelete: Boolean</p>
</dd>
<dt>): Future[Seq[ExecuteEdge[StatusGraph]]] = {</dt><dd><p>val edges = ListBuffer[ExecuteEdge[StatusGraph]]()
val futureEdges = ListBuffer[Future[Seq[ExecuteEdge[StatusGraph]]]]()</p>
<p>addSimpleEdges(tweet, edges)
getShare(tweet) match {</p>
<blockquote>
<div><p>case Some(share) =&gt; addRTEdges(tweet, share, isCreate, edges, futureEdges)
case _ =&gt;</p>
<blockquote>
<div><p>addInvitedUsersEdges(tweet, isCreate, isUndelete, edges, futureEdges)
addReplyEdges(tweet, edges)
addDirectedAtEdges(tweet, edges)
addMentionEdges(tweet, edges)
addQTEdges(tweet, edges, futureEdges, isCreate)
addCardEdges(tweet, edges)
if (isDelete || isUndelete) {</p>
<blockquote>
<div><p>addEdgesForDeleteOrUndelete(tweet, edges)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>Future</dt><dd><p>.collect(futureEdges)
.map { moreEdges =&gt; (edges ++= moreEdges.flatten).toList }</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../_sources/tweetypie/common/src/scala/com/twitter/tweetypie/tflock/TFlockIndexer.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>