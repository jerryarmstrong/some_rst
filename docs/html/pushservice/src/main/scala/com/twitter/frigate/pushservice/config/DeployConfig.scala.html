<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.frigate.pushservice.config</p>
<p>import com.twitter.abuse.detection.scoring.thriftscala.TweetScoringRequest
import com.twitter.abuse.detection.scoring.thriftscala.TweetScoringResponse
import com.twitter.audience_rewards.thriftscala.HasSuperFollowingRelationshipRequest
import com.twitter.bijection.scrooge.BinaryScalaCodec
import com.twitter.bijection.scrooge.CompactScalaCodec
import com.twitter.channels.common.thriftscala.ApiList
import com.twitter.channels.common.thriftscala.ApiListDisplayLocation
import com.twitter.channels.common.thriftscala.ApiListView
import com.twitter.content_mixer.thriftscala.ContentMixer
import com.twitter.conversions.DurationOps._
import com.twitter.cortex.deepbird.thriftjava.DeepbirdPredictionService
import com.twitter.cr_mixer.thriftscala.CrMixer
import com.twitter.datatools.entityservice.entities.sports.thriftscala.BaseballGameLiveUpdate
import com.twitter.datatools.entityservice.entities.sports.thriftscala.BasketballGameLiveUpdate
import com.twitter.datatools.entityservice.entities.sports.thriftscala.CricketMatchLiveUpdate
import com.twitter.datatools.entityservice.entities.sports.thriftscala.NflFootballGameLiveUpdate
import com.twitter.datatools.entityservice.entities.sports.thriftscala.SoccerMatchLiveUpdate
import com.twitter.discovery.common.configapi.ConfigParamsBuilder
import com.twitter.discovery.common.configapi.FeatureContextBuilder
import com.twitter.discovery.common.environment.{Environment =&gt; NotifEnvironment}
import com.twitter.escherbird.common.thriftscala.Domains
import com.twitter.escherbird.common.thriftscala.QualifiedId
import com.twitter.escherbird.metadata.thriftscala.EntityMegadata
import com.twitter.escherbird.metadata.thriftscala.MetadataService
import com.twitter.escherbird.util.metadatastitch.MetadataStitchClient
import com.twitter.escherbird.util.uttclient
import com.twitter.escherbird.util.uttclient.CacheConfigV2
import com.twitter.escherbird.util.uttclient.CachedUttClientV2
import com.twitter.escherbird.utt.strato.thriftscala.Environment
import com.twitter.eventbus.client.EventBusPublisherBuilder
import com.twitter.events.recos.thriftscala.EventsRecosService
import com.twitter.explore_ranker.thriftscala.ExploreRanker
import com.twitter.featureswitches.v2.FeatureSwitches
import com.twitter.finagle.Memcached
import com.twitter.finagle.ThriftMux
import com.twitter.finagle.client.BackupRequestFilter
import com.twitter.finagle.client.ClientRegistry
import com.twitter.finagle.loadbalancer.Balancers
import com.twitter.finagle.memcached.Client
import com.twitter.finagle.mtls.authentication.ServiceIdentifier
import com.twitter.finagle.mtls.client.MtlsStackClient._
import com.twitter.finagle.mux.transport.OpportunisticTls
import com.twitter.finagle.service.Retries
import com.twitter.finagle.service.RetryPolicy
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.finagle.thrift.ClientId
import com.twitter.finagle.thrift.RichClientParam
import com.twitter.finagle.util.DefaultTimer
import com.twitter.flockdb.client._
import com.twitter.flockdb.client.thriftscala.FlockDB
import com.twitter.frigate.common.base.RandomRanker
import com.twitter.frigate.common.candidate._
import com.twitter.frigate.common.config.RateLimiterGenerator
import com.twitter.frigate.common.entity_graph_client.RecommendedTweetEntitiesStore
import com.twitter.frigate.common.filter.DynamicRequestMeterFilter
import com.twitter.frigate.common.history._
import com.twitter.frigate.common.ml.feature._
import com.twitter.frigate.common.store._
import com.twitter.frigate.common.store.deviceinfo.DeviceInfoStore
import com.twitter.frigate.common.store.deviceinfo.MobileSdkStore
import com.twitter.frigate.common.store.interests._
import com.twitter.frigate.common.store.strato.StratoFetchableStore
import com.twitter.frigate.common.store.strato.StratoScannableStore
import com.twitter.frigate.common.util.Finagle.readOnlyThriftService
import com.twitter.frigate.common.util._
import com.twitter.frigate.data_pipeline.features_common.FeatureStoreUtil
import com.twitter.frigate.data_pipeline.features_common._
import com.twitter.frigate.data_pipeline.thriftscala.UserHistoryKey
import com.twitter.frigate.data_pipeline.thriftscala.UserHistoryValue
import com.twitter.frigate.dau_model.thriftscala.DauProbability
import com.twitter.frigate.magic_events.thriftscala.FanoutEvent
import com.twitter.frigate.pushcap.thriftscala.PushcapUserHistory
import com.twitter.frigate.pushservice.model.PushTypes.PushCandidate
import com.twitter.frigate.pushservice.model.PushTypes.Target
import com.twitter.frigate.pushservice.adaptor.LoggedOutPushCandidateSourceGenerator
import com.twitter.frigate.pushservice.adaptor.PushCandidateSourceGenerator
import com.twitter.frigate.pushservice.config.mlconfig.DeepbirdV2ModelConfig
import com.twitter.frigate.pushservice.ml._
import com.twitter.frigate.pushservice.params._
import com.twitter.frigate.pushservice.rank.LoggedOutRanker
import com.twitter.frigate.pushservice.rank.RFPHLightRanker
import com.twitter.frigate.pushservice.rank.RFPHRanker
import com.twitter.frigate.pushservice.rank.SubscriptionCreatorRanker
import com.twitter.frigate.pushservice.refresh_handler._
import com.twitter.frigate.pushservice.refresh_handler.cross.CandidateCopyExpansion
import com.twitter.frigate.pushservice.send_handler.SendHandlerPushCandidateHydrator
import com.twitter.frigate.pushservice.store._
import com.twitter.frigate.pushservice.take.CandidateNotifier
import com.twitter.frigate.pushservice.take.NotificationSender
import com.twitter.frigate.pushservice.take.NotificationServiceRequest
import com.twitter.frigate.pushservice.take.NotificationServiceSender
import com.twitter.frigate.pushservice.take.NtabOnlyChannelSelector
import com.twitter.frigate.pushservice.take.history.EventBusWriter
import com.twitter.frigate.pushservice.take.history.HistoryWriter
import com.twitter.frigate.pushservice.take.sender.Ibis2Sender
import com.twitter.frigate.pushservice.take.sender.NtabSender
import com.twitter.frigate.pushservice.take.LoggedOutRefreshForPushNotifier
import com.twitter.frigate.pushservice.util.RFPHTakeStepUtil
import com.twitter.frigate.pushservice.util.SendHandlerPredicateUtil
import com.twitter.frigate.scribe.thriftscala.NotificationScribe
import com.twitter.frigate.thriftscala._
import com.twitter.frigate.user_states.thriftscala.MRUserHmmState
import com.twitter.geoduck.backend.hydration.thriftscala.Hydration
import com.twitter.geoduck.common.thriftscala.PlaceQueryFields
import com.twitter.geoduck.common.thriftscala.PlaceType
import com.twitter.geoduck.common.thriftscala.{Location =&gt; GeoLocation}
import com.twitter.geoduck.service.common.clientmodules.GeoduckUserLocate
import com.twitter.geoduck.service.common.clientmodules.GeoduckUserLocateModule
import com.twitter.geoduck.service.thriftscala.LocationResponse
import com.twitter.geoduck.thriftscala.LocationService
import com.twitter.gizmoduck.context.thriftscala.ReadConfig
import com.twitter.gizmoduck.context.thriftscala.TestUserConfig
import com.twitter.gizmoduck.testusers.client.TestUserClientBuilder
import com.twitter.gizmoduck.thriftscala.LookupContext
import com.twitter.gizmoduck.thriftscala.QueryFields
import com.twitter.gizmoduck.thriftscala.User
import com.twitter.gizmoduck.thriftscala.UserService
import com.twitter.hermit.pop_geo.thriftscala.PopTweetsInPlace
import com.twitter.hermit.predicate.socialgraph.SocialGraphPredicate
import com.twitter.hermit.predicate.tweetypie.PerspectiveReadableStore
import com.twitter.hermit.store._
import com.twitter.hermit.store.common._
import com.twitter.hermit.store.gizmoduck.GizmoduckUserStore
import com.twitter.hermit.store.metastore.UserCountryStore
import com.twitter.hermit.store.metastore.UserLanguagesStore
import com.twitter.hermit.store.scarecrow.ScarecrowCheckEventStore
import com.twitter.hermit.store.semantic_core.MetaDataReadableStore
import com.twitter.hermit.store.semantic_core.SemanticEntityForQuery
import com.twitter.hermit.store.timezone.GizmoduckUserUtcOffsetStore
import com.twitter.hermit.store.timezone.UtcOffsetStore
import com.twitter.hermit.store.tweetypie.TweetyPieStore
import com.twitter.hermit.store.tweetypie.UserTweet
import com.twitter.hermit.store.user_htl_session_store.UserHTLLastVisitReadableStore
import com.twitter.hermit.stp.thriftscala.STPResult
import com.twitter.hss.api.thriftscala.UserHealthSignal
import com.twitter.hss.api.thriftscala.UserHealthSignal._
import com.twitter.hss.api.thriftscala.UserHealthSignalResponse
import com.twitter.interests.thriftscala.InterestId
import com.twitter.interests.thriftscala.InterestsThriftService
import com.twitter.interests.thriftscala.{UserInterests =&gt; Interests}
import com.twitter.interests_discovery.thriftscala.InterestsDiscoveryService
import com.twitter.interests_discovery.thriftscala.NonPersonalizedRecommendedLists
import com.twitter.interests_discovery.thriftscala.RecommendedListsRequest
import com.twitter.interests_discovery.thriftscala.RecommendedListsResponse
import com.twitter.kujaku.domain.thriftscala.MachineTranslationResponse
import com.twitter.livevideo.timeline.client.v2.LiveVideoTimelineClient
import com.twitter.livevideo.timeline.domain.v2.{Event =&gt; LiveEvent}
import com.twitter.livevideo.timeline.thrift.thriftscala.TimelineService
import com.twitter.logging.Logger
import com.twitter.ml.api.thriftscala.{DataRecord =&gt; ThriftDataRecord}
import com.twitter.ml.featurestore.catalog.entities.core.{Author =&gt; TweetAuthorEntity}
import com.twitter.ml.featurestore.catalog.entities.core.{User =&gt; TargetUserEntity}
import com.twitter.ml.featurestore.catalog.entities.core.{UserAuthor =&gt; UserAuthorEntity}
import com.twitter.ml.featurestore.catalog.entities.magicrecs.{SocialContext =&gt; SocialContextEntity}
import com.twitter.ml.featurestore.catalog.entities.magicrecs.{UserSocialContext =&gt; TargetUserSocialContextEntity}
import com.twitter.ml.featurestore.timelines.thriftscala.TimelineScorerScoreView
import com.twitter.notificationservice.api.thriftscala.DeleteCurrentTimelineForUserRequest
import com.twitter.notificationservice.genericfeedbackstore.FeedbackPromptValue
import com.twitter.notificationservice.genericfeedbackstore.GenericFeedbackStore
import com.twitter.notificationservice.genericfeedbackstore.GenericFeedbackStoreBuilder
import com.twitter.notificationservice.scribe.manhattan.FeedbackSignalManhattanClient
import com.twitter.notificationservice.scribe.manhattan.GenericNotificationsFeedbackRequest
import com.twitter.notificationservice.thriftscala.CaretFeedbackDetails
import com.twitter.notificationservice.thriftscala.CreateGenericNotificationRequest
import com.twitter.notificationservice.thriftscala.CreateGenericNotificationResponse
import com.twitter.notificationservice.thriftscala.DeleteGenericNotificationRequest
import com.twitter.notificationservice.thriftscala.GenericNotificationOverrideKey
import com.twitter.notificationservice.thriftscala.NotificationService$FinagleClient
import com.twitter.nrel.heavyranker.CandidateFeatureHydrator
import com.twitter.nrel.heavyranker.FeatureHydrator
import com.twitter.nrel.heavyranker.{PushPredictionServiceStore =&gt; RelevancePushPredictionServiceStore}
import com.twitter.nrel.heavyranker.{TargetFeatureHydrator =&gt; RelevanceTargetFeatureHydrator}
import com.twitter.nrel.lightranker.MagicRecsServeDataRecordLightRanker
import com.twitter.nrel.lightranker.{Config =&gt; LightRankerConfig}
import com.twitter.onboarding.task.service.thriftscala.FatigueFlowEnrollment
import com.twitter.periscope.api.thriftscala.AudioSpacesLookupContext
import com.twitter.permissions_storage.thriftscala.AppPermission
import com.twitter.recommendation.interests.discovery.core.config.{DeployConfig =&gt; InterestDeployConfig}
import com.twitter.recommendation.interests.discovery.popgeo.deploy.PopGeoInterestProvider
import com.twitter.recos.user_tweet_entity_graph.thriftscala.UserTweetEntityGraph
import com.twitter.recos.user_user_graph.thriftscala.UserUserGraph
import com.twitter.rux.common.strato.thriftscala.UserTargetingProperty
import com.twitter.scio.nsfw_user_segmentation.thriftscala.NSFWProducer
import com.twitter.scio.nsfw_user_segmentation.thriftscala.NSFWUserSegmentation
import com.twitter.search.earlybird.thriftscala.EarlybirdService
import com.twitter.service.gen.scarecrow.thriftscala.ScarecrowService
import com.twitter.service.metastore.gen.thriftscala.Location
import com.twitter.simclusters_v2.thriftscala.SimClustersInferredEntities
import com.twitter.socialgraph.thriftscala.SocialGraphService
import com.twitter.spam.rtf.thriftscala.SafetyLevel
import com.twitter.stitch.tweetypie.TweetyPie.TweetyPieResult
import com.twitter.storage.client.manhattan.kv.Guarantee
import com.twitter.storage.client.manhattan.kv.ManhattanKVClient
import com.twitter.storage.client.manhattan.kv.ManhattanKVClientMtlsParams
import com.twitter.storage.client.manhattan.kv.ManhattanKVEndpoint
import com.twitter.storage.client.manhattan.kv.ManhattanKVEndpointBuilder
import com.twitter.storehaus.ReadableStore
import com.twitter.storehaus_internal.manhattan.Apollo
import com.twitter.storehaus_internal.manhattan.Athena
import com.twitter.storehaus_internal.manhattan.Dataset
import com.twitter.storehaus_internal.manhattan.ManhattanStore
import com.twitter.storehaus_internal.manhattan.Nash
import com.twitter.storehaus_internal.manhattan.Omega
import com.twitter.storehaus_internal.memcache.MemcacheStore
import com.twitter.storehaus_internal.util.ClientName
import com.twitter.storehaus_internal.util.ZkEndPoint
import com.twitter.strato.catalog.Scan.Slice
import com.twitter.strato.client.Strato
import com.twitter.strato.client.UserId
import com.twitter.strato.columns.frigate.logged_out_web_notifications.thriftscala.LOWebNotificationMetadata
import com.twitter.strato.columns.notifications.thriftscala.SourceDestUserRequest
import com.twitter.strato.generated.client.geo.user.FrequentSoftUserLocationClientColumn
import com.twitter.strato.generated.client.ml.featureStore.TimelineScorerTweetScoresV1ClientColumn
import com.twitter.strato.generated.client.notifications.space_device_follow_impl.SpaceDeviceFollowingClientColumn
import com.twitter.strato.generated.client.periscope.CoreOnAudioSpaceClientColumn
import com.twitter.strato.generated.client.periscope.ParticipantsOnAudioSpaceClientColumn
import com.twitter.strato.generated.client.rux.TargetingPropertyOnUserClientColumn
import com.twitter.strato.generated.client.socialgraph.graphs.creatorSubscriptionTimeline.{CountEdgesBySourceClientColumn =&gt; CreatorSubscriptionNumTweetsColumn}
import com.twitter.strato.generated.client.translation.service.IsTweetTranslatableClientColumn
import com.twitter.strato.generated.client.translation.service.platform.MachineTranslateTweetClientColumn
import com.twitter.strato.generated.client.trends.trip.TripTweetsAirflowProdClientColumn
import com.twitter.strato.thrift.ScroogeConvImplicits._
import com.twitter.taxi.common.AppId
import com.twitter.taxi.deploy.Cluster
import com.twitter.taxi.deploy.Env
import com.twitter.topiclisting.TopicListing
import com.twitter.topiclisting.TopicListingBuilder
import com.twitter.trends.trip_v1.trip_tweets.thriftscala.TripDomain
import com.twitter.trends.trip_v1.trip_tweets.thriftscala.TripTweets
import com.twitter.tsp.thriftscala.TopicSocialProofRequest
import com.twitter.tsp.thriftscala.TopicSocialProofResponse
import com.twitter.tweetypie.thriftscala.GetTweetOptions
import com.twitter.tweetypie.thriftscala.Tweet.VisibleTextRangeField
import com.twitter.tweetypie.thriftscala.TweetService
import com.twitter.ubs.thriftscala.AudioSpace
import com.twitter.ubs.thriftscala.Participants
import com.twitter.ubs.thriftscala.SellerApplicationState
import com.twitter.user_session_store.thriftscala.UserSession
import com.twitter.util.Duration
import com.twitter.util.Future
import com.twitter.util.Timer
import com.twitter.util.tunable.TunableMap
import com.twitter.wtf.scalding.common.thriftscala.UserFeatures
import org.apache.thrift.protocol.TCompactProtocol
import com.twitter.timelinescorer.thriftscala.v1.ScoredTweet
import com.twitter.ubs.thriftscala.SellerTrack
import com.twitter.wtf.candidate.thriftscala.CandidateSeq</p>
<dl>
<dt>trait DeployConfig extends Config {</dt><dd><p>// Any finagle clients should not be defined as lazy. If defined lazy,
// ClientRegistry.expAllRegisteredClientsResolved() call in init will not ensure that the clients
// are active before thrift endpoint is active. We want the clients to be active, because zookeeper
// resolution triggered by first request(s) might result in the request(s) failing.</p>
<p>def serviceIdentifier: ServiceIdentifier</p>
<p>def tunableMap: TunableMap</p>
<p>def featureSwitches: FeatureSwitches</p>
<dl class="simple">
<dt>override val isProd: Boolean =</dt><dd><p>serviceIdentifier.environment == PushConstants.ServiceProdEnvironmentName</p>
</dd>
</dl>
<p>def shardParams: ShardParams</p>
<p>def log: Logger</p>
<p>implicit def statsReceiver: StatsReceiver</p>
<p>implicit val timer: Timer = DefaultTimer</p>
<p>def notifierThriftClientId: ClientId</p>
<p>def loggedOutNotifierThriftClientId: ClientId</p>
<p>def pushserviceThriftClientId: ClientId</p>
<p>def deepbirdv2PredictionServiceDest: String</p>
<p>def featureStoreUtil: FeatureStoreUtil</p>
<p>def targetLevelFeaturesConfig: PushFeaturesConfig</p>
<dl class="simple">
<dt>private val manhattanClientMtlsParams = ManhattanKVClientMtlsParams(</dt><dd><p>serviceIdentifier = serviceIdentifier,
opportunisticTls = OpportunisticTls.Required</p>
</dd>
</dl>
<p>)</p>
<p>// Commonly used clients
val gizmoduckClient = {</p>
<blockquote>
<div><dl>
<dt>val client = ThriftMux.client</dt><dd><p>.withMutualTls(serviceIdentifier)
.withClientId(pushserviceThriftClientId)
.build[UserService.MethodPerEndpoint](</p>
<blockquote>
<div><p>dest = “/s/gizmoduck/gizmoduck”</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>RequestContext test user config to allow reading test user accounts on pushservice for load</p></li>
<li><p>testing</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>val GizmoduckTestUserConfig = TestUserConfig(</dt><dd><p>clientId = Some(pushserviceThriftClientId.name),
readConfig = Some(ReadConfig(includeTestUsers = true))</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>TestUserClientBuilder[UserService.MethodPerEndpoint]</dt><dd><p>.withClient(client)
.withConfig(GizmoduckTestUserConfig)
.build()</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl>
<dt>val sgsClient = {</dt><dd><dl class="simple">
<dt>val service = readOnlyThriftService(</dt><dd><p>“”,
“/s/socialgraph/socialgraph”,
statsReceiver,
pushserviceThriftClientId,
mTLSServiceIdentifier = Some(serviceIdentifier)</p>
</dd>
</dl>
<p>)
new SocialGraphService.FinagledClient(service)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val tweetyPieClient = {</dt><dd><dl class="simple">
<dt>val service = readOnlyThriftService(</dt><dd><p>“”,
“/s/tweetypie/tweetypie”,
statsReceiver,
notifierThriftClientId,
mTLSServiceIdentifier = Some(serviceIdentifier)</p>
</dd>
</dl>
<p>)
new TweetService.FinagledClient(service)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>lazy val geoduckHydrationClient: Hydration.MethodPerEndpoint = {</dt><dd><dl class="simple">
<dt>val servicePerEndpoint = ThriftMux.client</dt><dd><p>.withLabel(“geoduck_hydration”)
.withClientId(pushserviceThriftClientId)
.withMutualTls(serviceIdentifier)
.methodBuilder(“/s/geo/hydration”)
.withTimeoutPerRequest(10.seconds)
.withTimeoutTotal(10.seconds)
.idempotent(maxExtraLoad = 0.0)
.servicePerEndpoint[Hydration.ServicePerEndpoint]</p>
</dd>
</dl>
<p>Hydration.MethodPerEndpoint(servicePerEndpoint)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>lazy val geoduckLocationClient: LocationService.MethodPerEndpoint = {</dt><dd><dl class="simple">
<dt>val servicePerEndpoint = ThriftMux.client</dt><dd><p>.withLabel(“geoduck_location”)
.withClientId(pushserviceThriftClientId)
.withMutualTls(serviceIdentifier)
.methodBuilder(“/s/geo/geoduck_locationservice”)
.withTimeoutPerRequest(10.seconds)
.withTimeoutTotal(10.seconds)
.idempotent(maxExtraLoad = 0.0)
.servicePerEndpoint[LocationService.ServicePerEndpoint]</p>
</dd>
</dl>
<p>LocationService.MethodPerEndpoint(servicePerEndpoint)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val geoDuckV2Store: ReadableStore[Long, LocationResponse] = {</dt><dd><dl class="simple">
<dt>val geoduckLocate: GeoduckUserLocate = GeoduckUserLocateModule.providesGeoduckUserLocate(</dt><dd><p>locationServiceClient = geoduckLocationClient,
hydrationClient = geoduckHydrationClient,
unscopedStatsReceiver = statsReceiver</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>val store: ReadableStore[Long, LocationResponse] = ReadableStore</dt><dd><dl>
<dt>.convert[GeoduckRequest, Long, LocationResponse, LocationResponse](</dt><dd><p>GeoduckStoreV2(geoduckLocate))({ userId: Long =&gt;
GeoduckRequest(</p>
<blockquote>
<div><p>userId,
placeTypes = Set(</p>
<blockquote>
<div><p>PlaceType.City,
PlaceType.Metro,
PlaceType.Country,
PlaceType.ZipCode,
PlaceType.Admin0,
PlaceType.Admin1),</p>
</div></blockquote>
<p>placeFields = Set(PlaceQueryFields.PlaceNames),
includeCountryCode = true</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>})({ locationResponse: LocationResponse =&gt; Future.value(locationResponse) })</p>
</dd>
</dl>
<p>val _cacheName = “geoduckv2_in_memory_cache”
ObservedCachedReadableStore.from(</p>
<blockquote>
<div><p>store,
ttl = 20.seconds,
maxKeys = 1000,
cacheName = _cacheName,
windowSize = 10000L</p>
</div></blockquote>
<p>)(statsReceiver.scope(_cacheName))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private val deepbirdServiceBase = ThriftMux.client</dt><dd><p>.withClientId(pushserviceThriftClientId)
.withMutualTls(serviceIdentifier)
.withLoadBalancer(Balancers.p2c())
.newService(deepbirdv2PredictionServiceDest, “DeepbirdV2PredictionService”)</p>
</dd>
<dt>val deepbirdPredictionServiceClient = new DeepbirdPredictionService.ServiceToClient(</dt><dd><dl>
<dt>Finagle</dt><dd><dl class="simple">
<dt>.retryReadFilter(</dt><dd><p>tries = 3,
statsReceiver = statsReceiver.scope(“DeepbirdV2PredictionService”))</p>
</dd>
</dl>
<p>.andThen(Finagle.timeoutFilter(timeout = 10.seconds))
.andThen(deepbirdServiceBase),</p>
</dd>
</dl>
<p>RichClientParam(serviceName = “DeepbirdV2PredictionService”, clientStats = statsReceiver)</p>
</dd>
</dl>
<p>)</p>
<p>val manhattanStarbuckAppId = “frigate_pushservice_starbuck”
val metastoreLocationAppId = “frigate_notifier_metastore_location”
val manhattanMetastoreAppId = “frigate_pushservice_penguin”</p>
<p>def pushServiceMHCacheDest: String
def pushServiceCoreSvcsCacheDest: String
def poptartImpressionsCacheDest: String = “/srv#/prod/local/cache/poptart_impressions”
def entityGraphCacheDest: String</p>
<dl class="simple">
<dt>val pushServiceCacheClient: Client = MemcacheStore.memcachedClient(</dt><dd><p>name = ClientName(“memcache-pushservice”),
dest = ZkEndPoint(pushServiceMHCacheDest),
statsReceiver = statsReceiver,
timeout = 2.seconds,
serviceIdentifier = serviceIdentifier</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>val pushServiceCoreSvcsCacheClient: Client =</dt><dd><dl class="simple">
<dt>MemcacheStore.memcachedClient(</dt><dd><p>name = ClientName(“memcache-pushservice-core-svcs”),
dest = ZkEndPoint(pushServiceCoreSvcsCacheDest),
statsReceiver = statsReceiver,
serviceIdentifier = serviceIdentifier,
timeout = 2.seconds,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val poptartImpressionsCacheClient: Client =</dt><dd><dl class="simple">
<dt>MemcacheStore.memcachedClient(</dt><dd><p>name = ClientName(“memcache-pushservice-poptart-impressions”),
dest = ZkEndPoint(poptartImpressionsCacheDest),
statsReceiver = statsReceiver,
serviceIdentifier = serviceIdentifier,
timeout = 2.seconds</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val entityGraphCacheClient: Client = MemcacheStore.memcachedClient(</dt><dd><p>name = ClientName(“memcache-pushservice-entity-graph”),
dest = ZkEndPoint(entityGraphCacheDest),
statsReceiver = statsReceiver,
serviceIdentifier = serviceIdentifier,
timeout = 2.seconds</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>val stratoClient = {</dt><dd><p>val pushserviceThriftClient = ThriftMux.client.withClientId(pushserviceThriftClientId)
val baseBuilder = Strato</p>
<blockquote>
<div><p>.Client(pushserviceThriftClient)
.withMutualTls(serviceIdentifier)</p>
</div></blockquote>
<dl class="simple">
<dt>val finalBuilder = if (isServiceLocal) {</dt><dd><p>baseBuilder.withRequestTimeout(Duration.fromSeconds(15))</p>
</dd>
<dt>} else {</dt><dd><p>baseBuilder.withRequestTimeout(Duration.fromSeconds(3))</p>
</dd>
</dl>
<p>}
finalBuilder.build()</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val interestThriftServiceClient = ThriftMux.client</dt><dd><p>.withClientId(pushserviceThriftClientId)
.withMutualTls(serviceIdentifier)
.withRequestTimeout(3.seconds)
.configured(Retries.Policy(RetryPolicy.tries(1)))
.configured(BackupRequestFilter.Configured(maxExtraLoad = 0.0, sendInterrupts = false))
.withStatsReceiver(statsReceiver)
.build[InterestsThriftService.MethodPerEndpoint](</p>
<blockquote>
<div><p>dest = “/s/interests-thrift-service/interests-thrift-service”,
label = “interests-lookup”</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>def memcacheCASDest: String</p>
<dl>
<dt>override val casLock: CasLock = {</dt><dd><dl class="simple">
<dt>val magicrecsCasMemcacheClient = Memcached.client</dt><dd><p>.withMutualTls(serviceIdentifier)
.withLabel(“mr-cas-memcache-client”)
.withRequestTimeout(3.seconds)
.withStatsReceiver(statsReceiver)
.configured(Retries.Policy(RetryPolicy.tries(3)))
.newTwemcacheClient(memcacheCASDest)
.withStrings</p>
</dd>
</dl>
<p>MemcacheCasLock(magicrecsCasMemcacheClient)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override val pushInfoStore: ReadableStore[Long, UserForPushTargeting] = {</dt><dd><dl class="simple">
<dt>StratoFetchableStore.withUnitView[Long, UserForPushTargeting](</dt><dd><p>stratoClient,
“frigate/magicrecs/pushRecsTargeting.User”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val loggedOutPushInfoStore: ReadableStore[Long, LOWebNotificationMetadata] = {</dt><dd><dl class="simple">
<dt>StratoFetchableStore.withUnitView[Long, LOWebNotificationMetadata](</dt><dd><p>stratoClient,
“frigate/magicrecs/web/loggedOutWebUserStoreMh”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<p>// Setting up model stores
override val dauProbabilityStore: ReadableStore[Long, DauProbability] = {</p>
<blockquote>
<div><dl class="simple">
<dt>StratoFetchableStore</dt><dd><p>.withUnitView[Long, DauProbability](stratoClient, “frigate/magicrecs/dauProbability.User”)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>override val nsfwConsumerStore = {</dt><dd><dl class="simple">
<dt>StratoFetchableStore.withUnitView[Long, NSFWUserSegmentation](</dt><dd><p>stratoClient,
“frigate/nsfw-user-segmentation/nsfwUserSegmentation.User”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val nsfwProducerStore = {</dt><dd><dl class="simple">
<dt>StratoFetchableStore.withUnitView[Long, NSFWProducer](</dt><dd><p>stratoClient,
“frigate/nsfw-user-segmentation/nsfwProducer.User”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val idsStore: ReadableStore[RecommendedListsRequest, RecommendedListsResponse] = {</dt><dd><dl class="simple">
<dt>val service = Finagle.readOnlyThriftService(</dt><dd><p>name = “interests-discovery-service”,
dest = “/s/interests_discovery/interests_discovery”,
statsReceiver,
pushserviceThriftClientId,
requestTimeout = 4.seconds,
tries = 2,
mTLSServiceIdentifier = Some(serviceIdentifier)</p>
</dd>
</dl>
<p>)
val client = new InterestsDiscoveryService.FinagledClient(</p>
<blockquote>
<div><p>service = service,
RichClientParam(serviceName = “interests-discovery-service”)</p>
</div></blockquote>
<p>)</p>
<p>InterestDiscoveryStore(client)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val popGeoLists = {</dt><dd><dl class="simple">
<dt>StratoFetchableStore.withUnitView[String, NonPersonalizedRecommendedLists](</dt><dd><p>stratoClient,
column = “recommendations/interests_discovery/recommendations_mh/OrganicPopgeoLists”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val listAPIStore = {</dt><dd><dl class="simple">
<dt>val fetcher = stratoClient</dt><dd><p>.fetcher[Long, ApiListView, ApiList](“channels/hydration/apiList.List”)</p>
</dd>
<dt>StratoFetchableStore.withView[Long, ApiListView, ApiList](</dt><dd><p>fetcher,
ApiListView(ApiListDisplayLocation.Recommendations)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val reactivatedUserInfoStore = {</dt><dd><dl class="simple">
<dt>val stratoFetchableStore = StratoFetchableStore</dt><dd><p>.withUnitView[Long, String](stratoClient, “ml/featureStore/recentReactivationTime.User”)</p>
</dd>
<dt>ObservedReadableStore(</dt><dd><p>stratoFetchableStore</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“RecentReactivationTime”))</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override val openedPushByHourAggregatedStore: ReadableStore[Long, Map[Int, Int]] = {</dt><dd><dl class="simple">
<dt>StratoFetchableStore</dt><dd><dl class="simple">
<dt>.withUnitView[Long, Map[Int, Int]](</dt><dd><p>stratoClient,
“frigate/magicrecs/opendPushByHourAggregated.User”)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private val lexClient: LiveVideoTimelineClient = {</dt><dd><dl>
<dt>val lexService =</dt><dd><dl>
<dt>new TimelineService.FinagledClient(</dt><dd><dl class="simple">
<dt>readOnlyThriftService(</dt><dd><p>name = “lex”,
dest = lexServiceDest,
statsReceiver = statsReceiver.scope(“lex-service”),
thriftClientId = pushserviceThriftClientId,
requestTimeout = 5.seconds,
mTLSServiceIdentifier = Some(serviceIdentifier)</p>
</dd>
</dl>
<p>),
clientParam = RichClientParam(serviceName = “lex”)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>new LiveVideoTimelineClient(lexService)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val lexServiceStore = {</dt><dd><dl class="simple">
<dt>ObservedCachedReadableStore.from[EventRequest, LiveEvent](</dt><dd><p>buildStore(LexServiceStore(lexClient), “lexServiceStore”),
ttl = 1.hour,
maxKeys = 1000,
cacheName = “lexServiceStore_cache”,
windowSize = 10000L</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“lexServiceStore_cache”))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val inferredEntitiesFromInterestedInKeyedByClusterColumn =</dt><dd><p>“recommendations/simclusters_v2/inferred_entities/inferredEntitiesFromInterestedInKeyedByCluster”</p>
</dd>
<dt>override val simClusterToEntityStore: ReadableStore[Int, SimClustersInferredEntities] = {</dt><dd><dl class="simple">
<dt>val store = StratoFetchableStore</dt><dd><dl class="simple">
<dt>.withUnitView[Int, SimClustersInferredEntities](</dt><dd><p>stratoClient,
inferredEntitiesFromInterestedInKeyedByClusterColumn)</p>
</dd>
</dl>
</dd>
<dt>ObservedCachedReadableStore.from[Int, SimClustersInferredEntities](</dt><dd><p>buildStore(store, “simcluster_entity_store_cache”),
ttl = 6.hours,
maxKeys = 1000,
cacheName = “simcluster_entity_store_cache”,
windowSize = 10000L</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“simcluster_entity_store_cache”))</p>
</dd>
</dl>
<p>}</p>
<p>def fanoutMetadataColumn: String</p>
<dl>
<dt>override val fanoutMetadataStore: ReadableStore[(Long, Long), FanoutEvent] = {</dt><dd><dl class="simple">
<dt>val store = StratoFetchableStore</dt><dd><p>.withUnitView[(Long, Long), FanoutEvent](stratoClient, fanoutMetadataColumn)</p>
</dd>
<dt>ObservedCachedReadableStore.from[(Long, Long), FanoutEvent](</dt><dd><p>buildStore(store, “fanoutMetadataStore”),
ttl = 10.minutes,
maxKeys = 1000,
cacheName = “fanoutMetadataStore_cache”,
windowSize = 10000L</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“fanoutMetadataStore_cache”))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>PostRanking Feature Store Client</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>override def postRankingFeatureStoreClient = {</dt><dd><p>val clientStats = statsReceiver.scope(“post_ranking_feature_store_client”)
val clientConfig =</p>
<blockquote>
<div><p>FeatureStoreClientBuilder.getClientConfig(PostRankingFeaturesConfig(), featureStoreUtil)</p>
</div></blockquote>
<p>FeatureStoreClientBuilder.getDynamicFeatureStoreClient(clientConfig, clientStats)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Interests lookup store</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>override val interestsWithLookupContextStore = {</dt><dd><dl>
<dt>ObservedCachedReadableStore.from[InterestsLookupRequestWithContext, Interests](</dt><dd><dl class="simple">
<dt>buildStore(</dt><dd><p>new InterestsWithLookupContextStore(interestThriftServiceClient, statsReceiver),
“InterestsWithLookupContextStore”</p>
</dd>
</dl>
<p>),
ttl = 1.minute,
maxKeys = 1000,
cacheName = “interestsWithLookupContextStore_cache”,
windowSize = 10000L</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>OptOutInterestsStore</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>override lazy val optOutUserInterestsStore: ReadableStore[Long, Seq[InterestId]] = {</dt><dd><dl class="simple">
<dt>buildStore(</dt><dd><p>InterestsOptOutwithLookUpContextStore(interestThriftServiceClient),
“InterestsOptOutStore”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val topicListing: TopicListing =</dt><dd><dl class="simple">
<dt>if (isServiceLocal) {</dt><dd><p>new TopicListingBuilder(statsReceiver.scope(“topiclisting”), Some(localConfigRepoPath)).build</p>
</dd>
<dt>} else {</dt><dd><p>new TopicListingBuilder(statsReceiver.scope(“topiclisting”), None).build</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>val cachedUttClient = {</dt><dd><p>val DefaultUttCacheConfig = CacheConfigV2(capacity = 100)
val uttClientCacheConfigs = uttclient.UttClientCacheConfigsV2(</p>
<blockquote>
<div><p>DefaultUttCacheConfig,
DefaultUttCacheConfig,
DefaultUttCacheConfig,
DefaultUttCacheConfig</p>
</div></blockquote>
<p>)
new CachedUttClientV2(stratoClient, Environment.Prod, uttClientCacheConfigs, statsReceiver)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val uttEntityHydrationStore =</dt><dd><p>new UttEntityHydrationStore(cachedUttClient, statsReceiver, log)</p>
</dd>
<dt>private lazy val dbv2PredictionServiceScoreStore: RelevancePushPredictionServiceStore =</dt><dd><dl class="simple">
<dt>DeepbirdV2ModelConfig.buildPredictionServiceScoreStore(</dt><dd><p>deepbirdPredictionServiceClient,
“deepbirdv2_magicrecs”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>// Customized model to PredictionServiceStoreMap
// It is used to specify the predictionServiceStore for the models not in the default dbv2PredictionServiceScoreStore
private lazy val modelToPredictionServiceStoreMap: Map[</p>
<blockquote>
<div><p>WeightedOpenOrNtabClickModel.ModelNameType,
RelevancePushPredictionServiceStore</p>
</div></blockquote>
<p>] = Map()</p>
<dl class="simple">
<dt>override lazy val weightedOpenOrNtabClickModelScorer = new PushMLModelScorer(</dt><dd><p>PushMLModel.WeightedOpenOrNtabClickProbability,
modelToPredictionServiceStoreMap,
dbv2PredictionServiceScoreStore,
statsReceiver.scope(“weighted_oonc_scoring”)</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>override lazy val optoutModelScorer = new PushMLModelScorer(</dt><dd><p>PushMLModel.OptoutProbability,
Map.empty,
dbv2PredictionServiceScoreStore,
statsReceiver.scope(“optout_scoring”)</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>override lazy val filteringModelScorer = new PushMLModelScorer(</dt><dd><p>PushMLModel.FilteringProbability,
Map.empty,
dbv2PredictionServiceScoreStore,
statsReceiver.scope(“filtering_scoring”)</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>private val queryFields: Set[QueryFields] = Set(</dt><dd><p>QueryFields.Profile,
QueryFields.Account,
QueryFields.Roles,
QueryFields.Discoverability,
QueryFields.Safety,
QueryFields.Takedowns,
QueryFields.Labels,
QueryFields.Counts,
QueryFields.ExtendedProfile</p>
</dd>
</dl>
<p>)</p>
<p>// Setting up safeUserStore
override val safeUserStore =</p>
<blockquote>
<div><p>// in-memory cache
ObservedCachedReadableStore.from[Long, User](</p>
<blockquote>
<div><dl>
<dt>ObservedReadableStore(</dt><dd><dl class="simple">
<dt>GizmoduckUserStore.safeStore(</dt><dd><p>client = gizmoduckClient,
queryFields = queryFields,
safetyLevel = SafetyLevel.FilterNone,
statsReceiver = statsReceiver</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“SafeUserStore”)),
ttl = 1.minute,
maxKeys = 5e4.toInt,
cacheName = “safeUserStore_cache”,
windowSize = 10000L</p>
</div></blockquote>
<p>)(statsReceiver.scope(“safeUserStore_cache”))</p>
</div></blockquote>
<dl class="simple">
<dt>val mobileSdkStore = MobileSdkStore(</dt><dd><p>“frigate_mobile_sdk_version_apollo”,
“mobile_sdk_versions_scalding”,
manhattanClientMtlsParams,
Apollo</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>val deviceUserStore = ObservedReadableStore(</dt><dd><dl class="simple">
<dt>GizmoduckUserStore(</dt><dd><p>client = gizmoduckClient,
queryFields = Set(QueryFields.Devices),
context = LookupContext(includeSoftUsers = true),
statsReceiver = statsReceiver</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“devicesUserStore”))</p>
<dl>
<dt>override val deviceInfoStore = DeviceInfoStore(</dt><dd><dl>
<dt>ObservedMemcachedReadableStore.fromCacheClient(</dt><dd><dl class="simple">
<dt>backingStore = ObservedReadableStore(</dt><dd><p>mobileSdkStore</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“uncachedMobileSdkVersionsStore”)),
cacheClient = pushServiceCacheClient,
ttl = 12.hours</p>
</dd>
<dt>)(</dt><dd><p>valueInjection = BinaryScalaCodec(SdkVersionValue),
statsReceiver = statsReceiver.scope(“MobileSdkVersionsStore”),
keyToString = {</p>
<blockquote>
<div><dl class="simple">
<dt>case SdkVersionKey(Some(userId), Some(clientId)) =&gt;</dt><dd><p>s”DeviceInfoStore/$userId/$clientId”</p>
</dd>
</dl>
<p>case SdkVersionKey(Some(userId), None) =&gt; s”DeviceInfoStore/$userId/_”
case SdkVersionKey(None, Some(clientId)) =&gt;</p>
<blockquote>
<div><p>s”DeviceInfoStore/_/$clientId”</p>
</div></blockquote>
<p>case SdkVersionKey(None, None) =&gt; s”DeviceInfoStore/_”</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>),
deviceUserStore</p>
</dd>
</dl>
<p>)</p>
<p>// Setting up edgeStore
override val edgeStore = SocialGraphPredicate.buildEdgeStore(sgsClient)</p>
<p>override val socialGraphServiceProcessStore = SocialGraphServiceProcessStore(edgeStore)</p>
<p>def userTweetEntityGraphDest: String
def userUserGraphDest: String
def lexServiceDest: String</p>
<p>// Setting up the history store
def frigateHistoryCacheDest: String</p>
<p>val notificationHistoryStore: NotificationHistoryStore = {</p>
<blockquote>
<div><dl>
<dt>val manhattanStackBasedClient = ThriftMux.client</dt><dd><p>.withClientId(notifierThriftClientId)
.withOpportunisticTls(OpportunisticTls.Required)
.withMutualTls(</p>
<blockquote>
<div><p>serviceIdentifier</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>val manhattanHistoryMethodBuilder = manhattanStackBasedClient</dt><dd><p>.withLabel(“manhattan_history_v2”)
.withRequestTimeout(10.seconds)
.withStatsReceiver(statsReceiver)
.methodBuilder(Omega.wilyName)
.withMaxRetries(3)</p>
</dd>
<dt>NotificationHistoryStore.build(</dt><dd><p>“frigate_notifier”,
“frigate_notifications_v2”,
manhattanHistoryMethodBuilder,
maxRetryCount = 3</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>val emailNotificationHistoryStore: ReadOnlyHistoryStore = {</dt><dd><dl>
<dt>val client = ManhattanKVClient(</dt><dd><p>appId = “frigate_email_history”,
dest = “/s/manhattan/omega.native-thrift”,
mtlsParams = ManhattanKVClientMtlsParams(</p>
<blockquote>
<div><p>serviceIdentifier = serviceIdentifier,
opportunisticTls = OpportunisticTls.Required</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)
val endpoint = ManhattanKVEndpointBuilder(client)</p>
<blockquote>
<div><p>.defaultGuarantee(Guarantee.SoftDcReadMyWrites)
.statsReceiver(statsReceiver)
.build()</p>
</div></blockquote>
<dl class="simple">
<dt>ReadOnlyHistoryStore(ManhattanKVHistoryStore(endpoint, dataset = “frigate_email_history”))(</dt><dd><p>statsReceiver)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val manhattanKVLoggedOutHistoryStoreEndpoint: ManhattanKVEndpoint = {</dt><dd><dl class="simple">
<dt>val mhClient = ManhattanKVClient(</dt><dd><p>“frigate_notification_logged_out_history”,
Nash.wilyName,
manhattanClientMtlsParams)</p>
</dd>
<dt>ManhattanKVEndpointBuilder(mhClient)</dt><dd><p>.defaultGuarantee(Guarantee.SoftDcReadMyWrites)
.defaultMaxTimeout(5.seconds)
.maxRetryCount(3)
.statsReceiver(statsReceiver)
.build()</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val manhattanKVNtabHistoryStoreEndpoint: ManhattanKVEndpoint = {</dt><dd><p>val mhClient = ManhattanKVClient(“frigate_ntab”, Omega.wilyName, manhattanClientMtlsParams)
ManhattanKVEndpointBuilder(mhClient)</p>
<blockquote>
<div><p>.defaultGuarantee(Guarantee.SoftDcReadMyWrites)
.defaultMaxTimeout(5.seconds)
.maxRetryCount(3)
.statsReceiver(statsReceiver)
.build()</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val nTabHistoryStore: ReadableWritableStore[(Long, String), GenericNotificationOverrideKey] = {</dt><dd><dl class="simple">
<dt>ObservedReadableWritableStore(</dt><dd><p>NTabHistoryStore(manhattanKVNtabHistoryStoreEndpoint, “frigate_ntab_generic_notif_history”)</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“NTabHistoryStore”))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override lazy val ocfFatigueStore: ReadableStore[OCFHistoryStoreKey, FatigueFlowEnrollment] =</dt><dd><dl class="simple">
<dt>new OCFPromptHistoryStore(</dt><dd><p>manhattanAppId = “frigate_pushservice_ocf_fatigue_store”,
dataset = “fatigue_v1”,
manhattanClientMtlsParams</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>def historyStore: PushServiceHistoryStore</p>
<p>def emailHistoryStore: PushServiceHistoryStore</p>
<p>def loggedOutHistoryStore: PushServiceHistoryStore</p>
<dl>
<dt>override val hydratedLabeledPushRecsStore: ReadableStore[UserHistoryKey, UserHistoryValue] = {</dt><dd><dl>
<dt>val labeledHistoryMemcacheClient = {</dt><dd><dl class="simple">
<dt>MemcacheStore.memcachedClient(</dt><dd><p>name = ClientName(“history-memcache”),
dest = ZkEndPoint(frigateHistoryCacheDest),
statsReceiver = statsReceiver,
timeout = 2.seconds,
serviceIdentifier = serviceIdentifier</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<p>implicit val keyCodec = CompactScalaCodec(UserHistoryKey)
implicit val valueCodec = CompactScalaCodec(UserHistoryValue)
val dataset: Dataset[UserHistoryKey, UserHistoryValue] =</p>
<blockquote>
<div><dl class="simple">
<dt>Dataset(</dt><dd><p>“”,
“frigate_data_pipeline_pushservice”,
“labeled_push_recs_aggregated_hydrated”,
Athena</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>ObservedMemcachedReadableStore.fromCacheClient(</dt><dd><dl class="simple">
<dt>backingStore = ObservedReadableStore(buildManhattanStore(dataset))(</dt><dd><p>statsReceiver.scope(“UncachedHydratedLabeledPushRecsStore”)</p>
</dd>
</dl>
<p>),
cacheClient = labeledHistoryMemcacheClient,
ttl = 6.hours</p>
</dd>
<dt>)(</dt><dd><p>valueInjection = valueCodec,
statsReceiver = statsReceiver.scope(“HydratedLabeledPushRecsStore”),
keyToString = {</p>
<blockquote>
<div><p>case UserHistoryKey.UserId(userId) =&gt; s”HLPRS/$userId”
case unknownKey =&gt;</p>
<blockquote>
<div><p>throw new IllegalArgumentException(s”Unknown userHistoryStore cache key $unknownKey”)</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val realTimeClientEventStore: RealTimeClientEventStore = {</dt><dd><dl class="simple">
<dt>val client = ManhattanKVClient(</dt><dd><p>“frigate_eventstream”,
“/s/manhattan/omega.native-thrift”,
manhattanClientMtlsParams</p>
</dd>
</dl>
<p>)
val endpoint =</p>
<blockquote>
<div><dl class="simple">
<dt>ManhattanKVEndpointBuilder(client)</dt><dd><p>.defaultGuarantee(Guarantee.SoftDcReadMyWrites)
.defaultMaxTimeout(3.seconds)
.statsReceiver(statsReceiver)
.build()</p>
</dd>
</dl>
</div></blockquote>
<p>ManhattanRealTimeClientEventStore(endpoint, “realtime_client_events”, statsReceiver, None)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override val onlineUserHistoryStore: ReadableStore[OnlineUserHistoryKey, UserHistoryValue] = {</dt><dd><p>OnlineUserHistoryStore(realTimeClientEventStore)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override val userMediaRepresentationStore = UserMediaRepresentationStore(</dt><dd><p>“user_media_representation”,
“user_media_representation_dataset”,
manhattanClientMtlsParams</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>override val producerMediaRepresentationStore = ObservedMemcachedReadableStore.fromCacheClient(</dt><dd><dl class="simple">
<dt>backingStore = UserMediaRepresentationStore(</dt><dd><p>“user_media_representation”,
“producer_media_representation_dataset”,
manhattanClientMtlsParams</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“UncachedProducerMediaRepStore”)),
cacheClient = pushServiceCacheClient,
ttl = 4.hours</p>
</dd>
<dt>)(</dt><dd><p>valueInjection = BinaryScalaCodec(UserMediaRepresentation),
keyToString = { k: Long =&gt; s”ProducerMediaRepStore/$k” },
statsReceiver.scope(“ProducerMediaRepStore”)</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>override val mrUserStatePredictionStore = {</dt><dd><dl class="simple">
<dt>StratoFetchableStore.withUnitView[Long, MRUserHmmState](</dt><dd><p>stratoClient,
“frigate/magicrecs/mrUserStatePrediction.User”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val userHTLLastVisitStore =</dt><dd><dl class="simple">
<dt>UserHTLLastVisitReadableStore(</dt><dd><p>“pushservice_htl_user_session”,
“tls_user_session_store”,
statsReceiver.scope(“userHTLLastVisitStore”),
manhattanClientMtlsParams</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val crMixerClient: CrMixer.MethodPerEndpoint = new CrMixer.FinagledClient(</dt><dd><dl class="simple">
<dt>readOnlyThriftService(</dt><dd><p>“cr-mixer”,
“/s/cr-mixer/cr-mixer-plus”,
statsReceiver,
pushserviceThriftClientId,
requestTimeout = 5.seconds,
mTLSServiceIdentifier = Some(serviceIdentifier)</p>
</dd>
</dl>
<p>),
clientParam = RichClientParam(serviceName = “cr-mixer”)</p>
</dd>
</dl>
<p>)</p>
<p>val crMixerStore = CrMixerTweetStore(crMixerClient)(statsReceiver.scope(“CrMixerTweetStore”))</p>
<dl>
<dt>val contentMixerClient: ContentMixer.MethodPerEndpoint = new ContentMixer.FinagledClient(</dt><dd><dl class="simple">
<dt>readOnlyThriftService(</dt><dd><p>“content-mixer”,
“/s/corgi-shared/content-mixer”,
statsReceiver,
pushserviceThriftClientId,
requestTimeout = 5.seconds,
mTLSServiceIdentifier = Some(serviceIdentifier)</p>
</dd>
</dl>
<p>),
clientParam = RichClientParam(serviceName = “content-mixer”)</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>val exploreRankerClient: ExploreRanker.MethodPerEndpoint =</dt><dd><dl>
<dt>new ExploreRanker.FinagledClient(</dt><dd><dl class="simple">
<dt>readOnlyThriftService(</dt><dd><p>“explore-ranker”,
“/s/explore-ranker/explore-ranker”,
statsReceiver,
pushserviceThriftClientId,
requestTimeout = 5.seconds,
mTLSServiceIdentifier = Some(serviceIdentifier)</p>
</dd>
</dl>
<p>),
clientParam = RichClientParam(serviceName = “explore-ranker”)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val contentMixerStore = {</dt><dd><dl class="simple">
<dt>ObservedReadableStore(ContentMixerStore(contentMixerClient))(</dt><dd><p>statsReceiver.scope(“ContentMixerStore”))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val exploreRankerStore = {</dt><dd><dl class="simple">
<dt>ObservedReadableStore(ExploreRankerStore(exploreRankerClient))(</dt><dd><p>statsReceiver.scope(“ExploreRankerStore”)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val gizmoduckUtcOffsetStore = ObservedReadableStore(</dt><dd><p>GizmoduckUserUtcOffsetStore.fromUserStore(safeUserStore)</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“GizmoUserUtcOffsetStore”))</p>
<dl>
<dt>override val userUtcOffsetStore =</dt><dd><dl>
<dt>UtcOffsetStore</dt><dd><dl class="simple">
<dt>.makeMemcachedUtcOffsetStore(</dt><dd><p>gizmoduckUtcOffsetStore,
pushServiceCoreSvcsCacheClient,
ReadableStore.empty,
manhattanStarbuckAppId,
manhattanClientMtlsParams</p>
</dd>
</dl>
<p>)(statsReceiver)
.mapValues(Duration.fromSeconds)</p>
</dd>
</dl>
</dd>
<dt>override val cachedTweetyPieStoreV2 = {</dt><dd><dl>
<dt>val getTweetOptions = Some(</dt><dd><dl class="simple">
<dt>GetTweetOptions(</dt><dd><p>safetyLevel = Some(SafetyLevel.MagicRecsV2),
includeRetweetCount = true,
includeReplyCount = true,
includeFavoriteCount = true,
includeQuotedTweet = true,
additionalFieldIds = Seq(VisibleTextRangeField.id)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)
buildCachedTweetyPieStore(getTweetOptions, “tp_v2”)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val cachedTweetyPieStoreV2NoVF = {</dt><dd><dl>
<dt>val getTweetOptions = Some(</dt><dd><dl class="simple">
<dt>GetTweetOptions(</dt><dd><p>safetyLevel = Some(SafetyLevel.FilterDefault),
includeRetweetCount = true,
includeReplyCount = true,
includeFavoriteCount = true,
includeQuotedTweet = true,
additionalFieldIds = Seq(VisibleTextRangeField.id),</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)
buildCachedTweetyPieStore(getTweetOptions, “tp_v2_noVF”)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val safeCachedTweetyPieStoreV2 = {</dt><dd><dl>
<dt>val getTweetOptions = Some(</dt><dd><dl class="simple">
<dt>GetTweetOptions(</dt><dd><p>safetyLevel = Some(SafetyLevel.MagicRecsAggressiveV2),
includeRetweetCount = true,
includeReplyCount = true,
includeFavoriteCount = true,
includeQuotedTweet = true,
additionalFieldIds = Seq(VisibleTextRangeField.id)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)
buildCachedTweetyPieStore(getTweetOptions, “sftp_v2”)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val userTweetTweetyPieStore: ReadableStore[UserTweet, TweetyPieResult] = {</dt><dd><dl>
<dt>val getTweetOptions = Some(</dt><dd><dl class="simple">
<dt>GetTweetOptions(</dt><dd><p>safetyLevel = Some(SafetyLevel.MagicRecsV2),
includeRetweetCount = true,
includeReplyCount = true,
includeFavoriteCount = true,
includeQuotedTweet = true,
additionalFieldIds = Seq(VisibleTextRangeField.id)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)
TweetyPieStore.buildUserTweetStore(</p>
<blockquote>
<div><p>client = tweetyPieClient,
options = getTweetOptions</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val safeUserTweetTweetyPieStore: ReadableStore[UserTweet, TweetyPieResult] = {</dt><dd><dl>
<dt>val getTweetOptions = Some(</dt><dd><dl class="simple">
<dt>GetTweetOptions(</dt><dd><p>safetyLevel = Some(SafetyLevel.MagicRecsAggressiveV2),
includeRetweetCount = true,
includeReplyCount = true,
includeFavoriteCount = true,
includeQuotedTweet = true,
additionalFieldIds = Seq(VisibleTextRangeField.id)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)
TweetyPieStore.buildUserTweetStore(</p>
<blockquote>
<div><p>client = tweetyPieClient,
options = getTweetOptions</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val tweetContentFeatureCacheStore: ReadableStore[Long, ThriftDataRecord] = {</dt><dd><dl class="simple">
<dt>ObservedMemcachedReadableStore.fromCacheClient(</dt><dd><p>backingStore = TweetContentFeatureReadableStore(stratoClient),
cacheClient = poptartImpressionsCacheClient,
ttl = 12.hours</p>
</dd>
<dt>)(</dt><dd><p>valueInjection = BinaryScalaCodec(ThriftDataRecord),
statsReceiver = statsReceiver.scope(“TweetContentFeaturesCacheStore”),
keyToString = { k: Long =&gt; s”tcf/$k” }</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>lazy val tweetTranslationStore: ReadableStore[</dt><dd><p>TweetTranslationStore.Key,
TweetTranslationStore.Value</p>
</dd>
<dt>] = {</dt><dd><dl>
<dt>val isTweetTranslatableStore =</dt><dd><dl>
<dt>StratoFetchableStore</dt><dd><dl class="simple">
<dt>.withUnitView[IsTweetTranslatableClientColumn.Key, Boolean](</dt><dd><p>fetcher = new IsTweetTranslatableClientColumn(stratoClient).fetcher</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
<dt>val translateTweetStore =</dt><dd><dl>
<dt>StratoFetchableStore</dt><dd><dl class="simple">
<dt>.withUnitView[MachineTranslateTweetClientColumn.Key, MachineTranslationResponse](</dt><dd><p>fetcher = new MachineTranslateTweetClientColumn(stratoClient).fetcher</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
<dt>ObservedReadableStore(</dt><dd><p>TweetTranslationStore(translateTweetStore, isTweetTranslatableStore, statsReceiver)</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“tweetTranslationStore”))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val scarecrowClient = new ScarecrowService.FinagledClient(</dt><dd><dl class="simple">
<dt>readOnlyThriftService(</dt><dd><p>“”,
“/s/abuse/scarecrow”,
statsReceiver,
notifierThriftClientId,
requestTimeout = 5.second,
mTLSServiceIdentifier = Some(serviceIdentifier)</p>
</dd>
</dl>
<p>),
clientParam = RichClientParam(serviceName = “”)</p>
</dd>
</dl>
<p>)</p>
<p>// Setting up scarecrow store
override val scarecrowCheckEventStore = {</p>
<blockquote>
<div><p>ScarecrowCheckEventStore(scarecrowClient)</p>
</div></blockquote>
<p>}</p>
<p>// setting up the perspective store
override val userTweetPerspectiveStore = {</p>
<blockquote>
<div><dl>
<dt>val service = new DynamicRequestMeterFilter(</dt><dd><p>tunableMap(PushServiceTunableKeys.TweetPerspectiveStoreQpsLimit),
RateLimiterGenerator.asTuple(_, shardParams.numShards, 40),
PushQPSLimitConstants.PerspectiveStoreQPS)(timer)
.andThen(</p>
<blockquote>
<div><dl class="simple">
<dt>readOnlyThriftService(</dt><dd><p>“tweetypie_perspective_service”,
“/s/tweetypie/tweetypie”,
statsReceiver,
notifierThriftClientId,
mTLSServiceIdentifier = Some(serviceIdentifier)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>val client = new TweetService.FinagledClient(</dt><dd><p>service,
clientParam = RichClientParam(serviceName = “tweetypie_perspective_client”))</p>
</dd>
<dt>ObservedReadableStore(</dt><dd><p>PerspectiveReadableStore(client)</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“TweetPerspectiveStore”))</p>
</div></blockquote>
<p>}</p>
<p>//user country code store, used in RecsWithheldContentPredicate - wrapped by memcache based cache
override val userCountryStore =</p>
<blockquote>
<div><dl>
<dt>ObservedMemcachedReadableStore.fromCacheClient(</dt><dd><dl class="simple">
<dt>backingStore = ObservedReadableStore(</dt><dd><p>UserCountryStore(metastoreLocationAppId, manhattanClientMtlsParams)</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“userCountryStore”)),
cacheClient = pushServiceCacheClient,
ttl = 12.hours</p>
</dd>
<dt>)(</dt><dd><p>valueInjection = BinaryScalaCodec(Location),
statsReceiver = statsReceiver.scope(“UserCountryStore”),
keyToString = { k: Long =&gt; s”UserCountryStore/$k” }</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>override val audioSpaceParticipantsStore: ReadableStore[String, Participants] = {</dt><dd><dl>
<dt>val store = StratoFetchableStore</dt><dd><dl class="simple">
<dt>.DefaultStratoFetchableStore(</dt><dd><p>fetcher = new ParticipantsOnAudioSpaceClientColumn(stratoClient).fetcher</p>
</dd>
<dt>).composeKeyMapping[String](broadcastId =&gt;</dt><dd><p>(broadcastId, AudioSpacesLookupContext(forUserId = None)))</p>
</dd>
</dl>
</dd>
<dt>ObservedCachedReadableStore</dt><dd><dl class="simple">
<dt>.from(</dt><dd><p>store = buildStore(store, “AudioSpaceParticipantsStore”),
ttl = 20.seconds,
maxKeys = 200,
cacheName = “AudioSpaceParticipantsStore”,
windowSize = 200</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override val topicSocialProofServiceStore: ReadableStore[</dt><dd><p>TopicSocialProofRequest,
TopicSocialProofResponse</p>
</dd>
<dt>] = {</dt><dd><dl class="simple">
<dt>StratoFetchableStore.withUnitView[TopicSocialProofRequest, TopicSocialProofResponse](</dt><dd><p>stratoClient,
“topic-signals/tsp/topic-social-proof”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val spaceDeviceFollowStore: ReadableStore[SourceDestUserRequest, Boolean] = {</dt><dd><dl class="simple">
<dt>StratoFetchableStore.withUnitView(</dt><dd><p>fetcher = new SpaceDeviceFollowingClientColumn(stratoClient).fetcher</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val audioSpaceStore: ReadableStore[String, AudioSpace] = {</dt><dd><dl>
<dt>val store = StratoFetchableStore</dt><dd><dl class="simple">
<dt>.DefaultStratoFetchableStore(</dt><dd><p>fetcher = new CoreOnAudioSpaceClientColumn(stratoClient).fetcher</p>
</dd>
<dt>).composeKeyMapping[String] { broadcastId =&gt;</dt><dd><p>(broadcastId, AudioSpacesLookupContext(forUserId = None))</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>ObservedCachedReadableStore</dt><dd><dl class="simple">
<dt>.from(</dt><dd><p>store = buildStore(store, “AudioSpaceVisibilityStore”),
ttl = 1.minute,
maxKeys = 5000,
cacheName = “AudioSpaceVisibilityStore”,
windowSize = 10000L)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override val userLanguagesStore = UserLanguagesStore(</dt><dd><p>manhattanMetastoreAppId,
manhattanClientMtlsParams,
statsReceiver.scope(“user_languages_store”)</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>val tflockClient: TFlockClient = new TFlockClient(</dt><dd><dl>
<dt>new FlockDB.FinagledClient(</dt><dd><dl class="simple">
<dt>readOnlyThriftService(</dt><dd><p>“tflockClient”,
“/s/tflock/tflock”,
statsReceiver,
pushserviceThriftClientId,
mTLSServiceIdentifier = Some(serviceIdentifier)</p>
</dd>
</dl>
<p>),
serviceName = “tflock”,
stats = statsReceiver</p>
</dd>
</dl>
<p>),
defaultPageSize = 1000</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>val rawFlockClient = ThriftMux.client</dt><dd><p>.withClientId(pushserviceThriftClientId)
.withMutualTls(serviceIdentifier)
.build[FlockDB.MethodPerEndpoint](“/s/flock/flock”)</p>
</dd>
<dt>val flockClient: FlockClient = new FlockClient(</dt><dd><p>rawFlockClient,
defaultPageSize = 100</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>override val recentFollowsStore: FlockFollowStore = {</dt><dd><p>val dStats = statsReceiver.scope(“FlockRecentFollowsStore”)
FlockFollowStore(flockClient, dStats)</p>
</dd>
</dl>
<p>}</p>
<p>def notificationServiceClient: NotificationService$FinagleClient</p>
<dl class="simple">
<dt>def notificationServiceSend(</dt><dd><p>target: Target,
request: CreateGenericNotificationRequest</p>
</dd>
</dl>
<p>): Future[CreateGenericNotificationResponse]</p>
<dl class="simple">
<dt>def notificationServiceDelete(</dt><dd><p>request: DeleteGenericNotificationRequest</p>
</dd>
</dl>
<p>): Future[Unit]</p>
<dl class="simple">
<dt>def notificationServiceDeleteTimeline(</dt><dd><p>request: DeleteCurrentTimelineForUserRequest</p>
</dd>
</dl>
<p>): Future[Unit]</p>
<dl>
<dt>override val notificationServiceSender: ReadableStore[</dt><dd><p>NotificationServiceRequest,
CreateGenericNotificationResponse</p>
</dd>
<dt>] = {</dt><dd><dl class="simple">
<dt>new NotificationServiceSender(</dt><dd><p>notificationServiceSend,
PushParams.EnableWritesToNotificationServiceParam,
PushParams.EnableWritesToNotificationServiceForAllEmployeesParam,
PushParams.EnableWritesToNotificationServiceForEveryoneParam</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val eventRecosServiceClient = {</dt><dd><p>val dest = “/s/events-recos/events-recos-service”
new EventsRecosService.FinagledClient(</p>
<blockquote>
<div><dl class="simple">
<dt>readOnlyThriftService(</dt><dd><p>“EventRecosService”,
dest,
statsReceiver,
pushserviceThriftClientId,
mTLSServiceIdentifier = Some(serviceIdentifier)</p>
</dd>
</dl>
<p>),
clientParam = RichClientParam(serviceName = “EventRecosService”)</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>lazy val recommendedTrendsCandidateSource = RecommendedTrendsCandidateSource(</dt><dd><p>TrendsRecommendationStore(eventRecosServiceClient, statsReceiver))</p>
</dd>
<dt>override val softUserGeoLocationStore: ReadableStore[Long, GeoLocation] =</dt><dd><dl class="simple">
<dt>StratoFetchableStore.withUnitView[Long, GeoLocation](fetcher =</dt><dd><p>new FrequentSoftUserLocationClientColumn(stratoClient).fetcher)</p>
</dd>
</dl>
</dd>
<dt>lazy val candidateSourceGenerator = new PushCandidateSourceGenerator(</dt><dd><p>earlybirdCandidateSource,
userTweetEntityGraphCandidates,
cachedTweetyPieStoreV2,
safeCachedTweetyPieStoreV2,
userTweetTweetyPieStore,
safeUserTweetTweetyPieStore,
cachedTweetyPieStoreV2NoVF,
edgeStore,
interestsWithLookupContextStore,
uttEntityHydrationStore,
geoDuckV2Store,
topTweetsByGeoStore,
topTweetsByGeoV2VersionedStore,
ruxTweetImpressionsStore,
recommendedTrendsCandidateSource,
recentTweetsByAuthorsStore,
topicSocialProofServiceStore,
crMixerStore,
contentMixerStore,
exploreRankerStore,
softUserGeoLocationStore,
tripTweetCandidateStore,
popGeoLists,
idsStore</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>lazy val loCandidateSourceGenerator = new LoggedOutPushCandidateSourceGenerator(</dt><dd><p>tripTweetCandidateStore,
geoDuckV2Store,
safeCachedTweetyPieStoreV2,
cachedTweetyPieStoreV2NoVF,
cachedTweetyPieStoreV2,
contentMixerStore,
softUserGeoLocationStore,
topTweetsByGeoStore,
topTweetsByGeoV2VersionedStore</p>
</dd>
</dl>
<p>)</p>
<p>lazy val rfphStatsRecorder = new RFPHStatsRecorder()</p>
<p>lazy val rfphRestrictStep = new RFPHRestrictStep()</p>
<p>lazy val rfphTakeStepUtil = new RFPHTakeStepUtil()(statsReceiver)</p>
<p>lazy val rfphPrerankFilter = new RFPHPrerankFilter()(statsReceiver)</p>
<p>lazy val rfphLightRanker = new RFPHLightRanker(lightRanker, statsReceiver)</p>
<p>lazy val sendHandlerPredicateUtil = new SendHandlerPredicateUtil()(statsReceiver)</p>
<dl>
<dt>lazy val ntabSender =</dt><dd><dl class="simple">
<dt>new NtabSender(</dt><dd><p>notificationServiceSender,
nTabHistoryStore,
notificationServiceDelete,
notificationServiceDeleteTimeline</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>lazy val ibis2Sender = new Ibis2Sender(pushIbisV2Store, tweetTranslationStore, statsReceiver)</p>
<p>lazy val historyWriter = new HistoryWriter(historyStore, statsReceiver)</p>
<p>lazy val loggedOutHistoryWriter = new HistoryWriter(loggedOutHistoryStore, statsReceiver)</p>
<p>lazy val eventBusWriter = new EventBusWriter(pushSendEventBusPublisher, statsReceiver)</p>
<p>lazy val ntabOnlyChannelSelector = new NtabOnlyChannelSelector</p>
<dl>
<dt>lazy val notificationSender =</dt><dd><dl class="simple">
<dt>new NotificationSender(</dt><dd><p>ibis2Sender,
ntabSender,
statsReceiver,
notificationScribe</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>lazy val candidateNotifier =</dt><dd><dl class="simple">
<dt>new CandidateNotifier(</dt><dd><p>notificationSender,
casLock = casLock,
historyWriter = historyWriter,
eventBusWriter = eventBusWriter,
ntabOnlyChannelSelector = ntabOnlyChannelSelector</p>
</dd>
</dl>
<p>)(statsReceiver)</p>
</dd>
<dt>lazy val loggedOutCandidateNotifier = new CandidateNotifier(</dt><dd><p>notificationSender,
casLock = casLock,
historyWriter = loggedOutHistoryWriter,
eventBusWriter = null,
ntabOnlyChannelSelector = ntabOnlyChannelSelector</p>
</dd>
</dl>
<p>)(statsReceiver)</p>
<dl>
<dt>lazy val rfphNotifier =</dt><dd><p>new RefreshForPushNotifier(rfphStatsRecorder, candidateNotifier)(statsReceiver)</p>
</dd>
<dt>lazy val loRfphNotifier =</dt><dd><dl class="simple">
<dt>new LoggedOutRefreshForPushNotifier(rfphStatsRecorder, loggedOutCandidateNotifier)(</dt><dd><p>statsReceiver)</p>
</dd>
</dl>
</dd>
<dt>lazy val rfphRanker = {</dt><dd><p>val randomRanker = RandomRanker[Target, PushCandidate]()
val subscriptionCreatorRanker =</p>
<blockquote>
<div><p>new SubscriptionCreatorRanker(superFollowEligibilityUserStore, statsReceiver)</p>
</div></blockquote>
<dl class="simple">
<dt>new RFPHRanker(</dt><dd><p>randomRanker,
weightedOpenOrNtabClickModelScorer,
subscriptionCreatorRanker,
userHealthSignalStore,
producerMediaRepresentationStore,
statsReceiver</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<p>lazy val rfphFeatureHydrator = new RFPHFeatureHydrator(featureHydrator)
lazy val loggedOutRFPHRanker = new LoggedOutRanker(cachedTweetyPieStoreV2, statsReceiver)</p>
<dl>
<dt>override val userFeaturesStore: ReadableStore[Long, UserFeatures] = {</dt><dd><p>implicit val valueCodec = new BinaryScalaCodec(UserFeatures)
val dataset: Dataset[Long, UserFeatures] =</p>
<blockquote>
<div><dl class="simple">
<dt>Dataset(</dt><dd><p>“”,
“user_features_pushservice_apollo”,
“recommendations_user_features_apollo”,
Apollo)</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>ObservedMemcachedReadableStore.fromCacheClient(</dt><dd><dl class="simple">
<dt>backingStore = ObservedReadableStore(buildManhattanStore(dataset))(</dt><dd><p>statsReceiver.scope(“UncachedUserFeaturesStore”)</p>
</dd>
</dl>
<p>),
cacheClient = pushServiceCacheClient,
ttl = 24.hours</p>
</dd>
<dt>)(</dt><dd><p>valueInjection = valueCodec,
statsReceiver = statsReceiver.scope(“UserFeaturesStore”),
keyToString = { k: Long =&gt; s”ufts/$k” }</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def htlScoreStore(userId: Long): ReadableStore[Long, ScoredTweet] = {</dt><dd><p>val fetcher = new TimelineScorerTweetScoresV1ClientColumn(stratoClient).fetcher
val htlStore = buildStore(</p>
<blockquote>
<div><dl class="simple">
<dt>StratoFetchableStore.withView[Long, TimelineScorerScoreView, ScoredTweet](</dt><dd><p>fetcher,
TimelineScorerScoreView(Some(userId))</p>
</dd>
</dl>
<p>),
“htlScoreStore”</p>
</div></blockquote>
<p>)
htlStore</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val userTargetingPropertyStore: ReadableStore[Long, UserTargetingProperty] = {</dt><dd><p>val name = “userTargetingPropertyStore”
val store = StratoFetchableStore</p>
<blockquote>
<div><p>.withUnitView(new TargetingPropertyOnUserClientColumn(stratoClient).fetcher)</p>
</div></blockquote>
<p>buildStore(store, name)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val timelinesUserSessionStore: ReadableStore[Long, UserSession] = {</dt><dd><p>implicit val valueCodec = new CompactScalaCodec(UserSession)
val dataset: Dataset[Long, UserSession] = Dataset[Long, UserSession](</p>
<blockquote>
<div><p>“”,
“frigate_realgraph”,
“real_graph_user_features”,
Apollo</p>
</div></blockquote>
<p>)</p>
<dl>
<dt>ObservedMemcachedReadableStore.fromCacheClient(</dt><dd><dl class="simple">
<dt>backingStore = ObservedReadableStore(buildManhattanStore(dataset))(</dt><dd><p>statsReceiver.scope(“UncachedTimelinesUserSessionStore”)</p>
</dd>
</dl>
<p>),
cacheClient = pushServiceCacheClient,
ttl = 6.hours</p>
</dd>
<dt>)(</dt><dd><p>valueInjection = valueCodec,
statsReceiver = statsReceiver.scope(“timelinesUserSessionStore”),
keyToString = { k: Long =&gt; s”tluss/$k” }</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>lazy val recentTweetsFromTflockStore: ReadableStore[Long, Seq[Long]] =</dt><dd><dl>
<dt>ObservedReadableStore(</dt><dd><dl class="simple">
<dt>RecentTweetsByAuthorsStore.usingRecentTweetsConfig(</dt><dd><p>tflockClient,
RecentTweetsConfig(maxResults = 1, maxAge = 3.days)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“RecentTweetsFromTflockStore”))</p>
</dd>
<dt>lazy val recentTweetsByAuthorsStore: ReadableStore[RecentTweetsQuery, Seq[Seq[Long]]] =</dt><dd><dl class="simple">
<dt>ObservedReadableStore(</dt><dd><p>RecentTweetsByAuthorsStore(tflockClient)</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“RecentTweetsByAuthorsStore”))</p>
</dd>
<dt>val jobConfig = PopGeoInterestProvider</dt><dd><dl>
<dt>.getPopularTweetsJobConfig(</dt><dd><dl class="simple">
<dt>InterestDeployConfig(</dt><dd><p>AppId(“PopularTweetsByInterestProd”),
Cluster.ATLA,
Env.Prod,
serviceIdentifier,
manhattanClientMtlsParams</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
<p>.withManhattanAppId(“frigate_pop_by_geo_tweets”)</p>
</dd>
<dt>override val topTweetsByGeoStore = TopTweetsStore.withMemCache(</dt><dd><p>jobConfig,
pushServiceCacheClient,
10.seconds</p>
</dd>
</dl>
<p>)(statsReceiver)</p>
<dl class="simple">
<dt>override val topTweetsByGeoV2VersionedStore: ReadableStore[String, PopTweetsInPlace] = {</dt><dd><dl class="simple">
<dt>StratoFetchableStore.withUnitView[String, PopTweetsInPlace](</dt><dd><p>stratoClient,
“recommendations/popgeo/popGeoTweetsVersioned”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override lazy val pushcapDynamicPredictionStore: ReadableStore[Long, PushcapUserHistory] = {</dt><dd><dl class="simple">
<dt>StratoFetchableStore.withUnitView[Long, PushcapUserHistory](</dt><dd><p>stratoClient,
“frigate/magicrecs/pushcapDynamicPrediction.User”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val tweetAuthorLocationFeatureBuilder =</dt><dd><dl class="simple">
<dt>UserLocationFeatureBuilder(Some(“TweetAuthor”))</dt><dd><p>.withStats()</p>
</dd>
</dl>
</dd>
<dt>override val tweetAuthorLocationFeatureBuilderById =</dt><dd><dl class="simple">
<dt>UserLocationFeatureBuilderById(</dt><dd><p>userCountryStore,
tweetAuthorLocationFeatureBuilder</p>
</dd>
</dl>
<p>).withStats()</p>
</dd>
<dt>override val socialContextActionsFeatureBuilder =</dt><dd><p>SocialContextActionsFeatureBuilder().withStats()</p>
</dd>
<dt>override val tweetContentFeatureBuilder =</dt><dd><p>TweetContentFeatureBuilder(tweetContentFeatureCacheStore).withStats()</p>
</dd>
<dt>override val tweetAuthorRecentRealGraphFeatureBuilder =</dt><dd><dl class="simple">
<dt>RecentRealGraphFeatureBuilder(</dt><dd><p>stratoClient,
UserAuthorEntity,
TargetUserEntity,
TweetAuthorEntity,
TweetAuthorRecentRealGraphFeatures(statsReceiver.scope(“TweetAuthorRecentRealGraphFeatures”))</p>
</dd>
</dl>
<p>).withStats()</p>
</dd>
<dt>override val socialContextRecentRealGraphFeatureBuilder =</dt><dd><dl>
<dt>SocialContextRecentRealGraphFeatureBuilder(</dt><dd><dl>
<dt>RecentRealGraphFeatureBuilder(</dt><dd><p>stratoClient,
TargetUserSocialContextEntity,
TargetUserEntity,
SocialContextEntity,
SocialContextRecentRealGraphFeatures(</p>
<blockquote>
<div><p>statsReceiver.scope(“SocialContextRecentRealGraphFeatures”))</p>
</div></blockquote>
</dd>
<dt>)(statsReceiver</dt><dd><p>.scope(“SocialContextRecentRealGraphFeatureBuilder”).scope(“RecentRealGraphFeatureBuilder”))</p>
</dd>
</dl>
</dd>
</dl>
<p>).withStats()</p>
</dd>
<dt>override val tweetSocialProofFeatureBuilder =</dt><dd><p>TweetSocialProofFeatureBuilder(Some(“TargetUser”)).withStats()</p>
</dd>
<dt>override val targetUserFullRealGraphFeatureBuilder =</dt><dd><p>TargetFullRealGraphFeatureBuilder(Some(“TargetUser”)).withStats()</p>
</dd>
<dt>override val postProcessingFeatureBuilder: PostProcessingFeatureBuilder =</dt><dd><p>PostProcessingFeatureBuilder()</p>
</dd>
<dt>override val mrOfflineUserCandidateSparseAggregatesFeatureBuilder =</dt><dd><p>MrOfflineUserCandidateSparseAggregatesFeatureBuilder(stratoClient, featureStoreUtil).withStats()</p>
</dd>
<dt>override val mrOfflineUserAggregatesFeatureBuilder =</dt><dd><p>MrOfflineUserAggregatesFeatureBuilder(stratoClient, featureStoreUtil).withStats()</p>
</dd>
<dt>override val mrOfflineUserCandidateAggregatesFeatureBuilder =</dt><dd><p>MrOfflineUserCandidateAggregatesFeatureBuilder(stratoClient, featureStoreUtil).withStats()</p>
</dd>
<dt>override val tweetAnnotationsFeatureBuilder =</dt><dd><p>TweetAnnotationsFeatureBuilder(stratoClient).withStats()</p>
</dd>
<dt>override val targetUserMediaRepresentationFeatureBuilder =</dt><dd><p>UserMediaRepresentationFeatureBuilder(userMediaRepresentationStore).withStats()</p>
</dd>
<dt>override val targetLevelFeatureBuilder =</dt><dd><p>TargetLevelFeatureBuilder(featureStoreUtil, targetLevelFeaturesConfig).withStats()</p>
</dd>
<dt>override val candidateLevelFeatureBuilder =</dt><dd><p>CandidateLevelFeatureBuilder(featureStoreUtil).withStats()</p>
</dd>
<dt>override lazy val targetFeatureHydrator = RelevanceTargetFeatureHydrator(</dt><dd><p>targetUserFullRealGraphFeatureBuilder,
postProcessingFeatureBuilder,
targetUserMediaRepresentationFeatureBuilder,
targetLevelFeatureBuilder</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>override lazy val featureHydrator =</dt><dd><p>FeatureHydrator(targetFeatureHydrator, candidateFeatureHydrator)</p>
</dd>
<dt>val pushServiceLightRankerConfig: LightRankerConfig = new LightRankerConfig(</dt><dd><p>pushserviceThriftClientId,
serviceIdentifier,
statsReceiver.scope(“lightRanker”),
deepbirdv2PredictionServiceDest,
“DeepbirdV2PredictionService”</p>
</dd>
</dl>
<p>)
val lightRanker: MagicRecsServeDataRecordLightRanker =</p>
<blockquote>
<div><p>pushServiceLightRankerConfig.lightRanker</p>
</div></blockquote>
<dl>
<dt>override val tweetImpressionStore: ReadableStore[Long, Seq[Long]] = {</dt><dd><p>val name = “htl_impression_store”
val store = buildStore(</p>
<blockquote>
<div><dl class="simple">
<dt>HtlTweetImpressionStore.createStoreWithTweetIds(</dt><dd><p>requestTimeout = 6.seconds,
label = “htl_tweet_impressions”,
serviceIdentifier = serviceIdentifier,
statsReceiver = statsReceiver</p>
</dd>
</dl>
<p>),
name</p>
</div></blockquote>
<p>)
val numTweetsReturned =</p>
<blockquote>
<div><p>statsReceiver.scope(name).stat(“num_tweets_returned_per_user”)</p>
</div></blockquote>
<dl class="simple">
<dt>new TransformedReadableStore(store)((userId: Long, tweetIds: Seq[Long]) =&gt; {</dt><dd><p>numTweetsReturned.add(tweetIds.size)
Future.value(Some(tweetIds))</p>
</dd>
</dl>
<p>})</p>
</dd>
</dl>
<p>}</p>
<p>val ruxTweetImpressionsStore = new TweetImpressionsStore(stratoClient)</p>
<dl>
<dt>override val strongTiesStore: ReadableStore[Long, STPResult] = {</dt><dd><p>implicit val valueCodec = new BinaryScalaCodec(STPResult)
val strongTieScoringDataset: Dataset[Long, STPResult] =</p>
<blockquote>
<div><p>Dataset(“”, “frigate_stp”, “stp_result_rerank”, Athena)</p>
</div></blockquote>
<p>buildManhattanStore(strongTieScoringDataset)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override lazy val earlybirdFeatureStore = ObservedReadableStore(</dt><dd><dl class="simple">
<dt>EarlybirdFeatureStore(</dt><dd><p>clientId = pushserviceThriftClientId.name,
earlybirdSearchStore = earlybirdSearchStore</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“EarlybirdFeatureStore”))</p>
<p>override lazy val earlybirdFeatureBuilder = EarlybirdFeatureBuilder(earlybirdFeatureStore)</p>
<dl>
<dt>override lazy val earlybirdSearchStore = {</dt><dd><p>val earlybirdClientName: String = “earlybird”
val earlybirdSearchStoreName: String = “EarlybirdSearchStore”</p>
<dl>
<dt>val earlybirdClient = new EarlybirdService.FinagledClient(</dt><dd><dl class="simple">
<dt>readOnlyThriftService(</dt><dd><p>earlybirdClientName,
earlybirdSearchDest,
statsReceiver,
pushserviceThriftClientId,
tries = 1,
requestTimeout = 3.seconds,
mTLSServiceIdentifier = Some(serviceIdentifier)</p>
</dd>
</dl>
<p>),
clientParam = RichClientParam(protocolFactory = new TCompactProtocol.Factory)</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>ObservedReadableStore(</dt><dd><p>EarlybirdSearchStore(earlybirdClient)(statsReceiver.scope(earlybirdSearchStoreName))</p>
</dd>
</dl>
<p>)(statsReceiver.scope(earlybirdSearchStoreName))</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override lazy val earlybirdCandidateSource: EarlybirdCandidateSource = EarlybirdCandidateSource(</dt><dd><p>clientId = pushserviceThriftClientId.name,
earlybirdSearchStore = earlybirdSearchStore</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>override val realGraphScoresTop500InStore: RealGraphScoresTop500InStore = {</dt><dd><dl>
<dt>val stratoRealGraphInStore =</dt><dd><dl class="simple">
<dt>StratoFetchableStore</dt><dd><dl class="simple">
<dt>.withUnitView[Long, CandidateSeq](</dt><dd><p>stratoClient,
“frigate/magicrecs/fanoutCoi500pRealGraphV2”)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>RealGraphScoresTop500InStore(</dt><dd><dl class="simple">
<dt>ObservedMemcachedReadableStore.fromCacheClient(</dt><dd><p>backingStore = stratoRealGraphInStore,
cacheClient = entityGraphCacheClient,
ttl = 24.hours</p>
</dd>
<dt>)(</dt><dd><p>valueInjection = BinaryScalaCodec(CandidateSeq),
statsReceiver = statsReceiver.scope(“CachedRealGraphScoresTop500InStore”),
keyToString = { k: Long =&gt; s”500p_test/$k” }</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val tweetEntityGraphStore = {</dt><dd><dl>
<dt>val tweetEntityGraphClient = new UserTweetEntityGraph.FinagledClient(</dt><dd><dl class="simple">
<dt>Finagle.readOnlyThriftService(</dt><dd><p>“user_tweet_entity_graph”,
userTweetEntityGraphDest,
statsReceiver,
pushserviceThriftClientId,
requestTimeout = 5.seconds,
mTLSServiceIdentifier = Some(serviceIdentifier)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)
ObservedReadableStore(</p>
<blockquote>
<div><dl class="simple">
<dt>RecommendedTweetEntitiesStore(</dt><dd><p>tweetEntityGraphClient,
statsReceiver.scope(“RecommendedTweetEntitiesStore”)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>)(statsReceiver.scope(“RecommendedTweetEntitiesStore”))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val userUserGraphStore = {</dt><dd><dl>
<dt>val userUserGraphClient = new UserUserGraph.FinagledClient(</dt><dd><dl class="simple">
<dt>Finagle.readOnlyThriftService(</dt><dd><p>“user_user_graph”,
userUserGraphDest,
statsReceiver,
pushserviceThriftClientId,
requestTimeout = 5.seconds,
mTLSServiceIdentifier = Some(serviceIdentifier)</p>
</dd>
</dl>
<p>),
clientParam = RichClientParam(serviceName = “user_user_graph”)</p>
</dd>
</dl>
<p>)
ObservedReadableStore(</p>
<blockquote>
<div><p>UserUserGraphStore(userUserGraphClient, statsReceiver.scope(“UserUserGraphStore”))</p>
</div></blockquote>
<p>)(statsReceiver.scope(“UserUserGraphStore”))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val ntabCaretFeedbackStore: ReadableStore[GenericNotificationsFeedbackRequest, Seq[</dt><dd><p>CaretFeedbackDetails</p>
</dd>
<dt>]] = {</dt><dd><dl class="simple">
<dt>val client = ManhattanKVClient(</dt><dd><p>“pushservice_ntab_caret_feedback_omega”,
Omega.wilyName,
manhattanClientMtlsParams</p>
</dd>
</dl>
<p>)
val endpoint = ManhattanKVEndpointBuilder(client)</p>
<blockquote>
<div><p>.defaultGuarantee(Guarantee.SoftDcReadMyWrites)
.defaultMaxTimeout(3.seconds)
.maxRetryCount(2)
.statsReceiver(statsReceiver)
.build()</p>
</div></blockquote>
<dl class="simple">
<dt>val feedbackSignalManhattanClient =</dt><dd><p>FeedbackSignalManhattanClient(endpoint, statsReceiver.scope(“FeedbackSignalManhattanClient”))</p>
</dd>
</dl>
<p>NtabCaretFeedbackStore(feedbackSignalManhattanClient)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val genericFeedbackStore: ReadableStore[FeedbackRequest, Seq[</dt><dd><p>FeedbackPromptValue</p>
</dd>
<dt>]] = {</dt><dd><dl>
<dt>FeedbackStore(</dt><dd><dl class="simple">
<dt>GenericFeedbackStoreBuilder.build(</dt><dd><p>manhattanKVClientAppId = “frigate_pushservice_ntabfeedback_prompt”,
environment = NotifEnvironment.apply(serviceIdentifier.environment),
svcIdentifier = serviceIdentifier,
statsReceiver = statsReceiver</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>override val genericNotificationFeedbackStore: GenericFeedbackStore = {</p>
<blockquote>
<div><dl class="simple">
<dt>GenericFeedbackStoreBuilder.build(</dt><dd><p>manhattanKVClientAppId = “frigate_pushservice_ntabfeedback_prompt”,
environment = NotifEnvironment.apply(serviceIdentifier.environment),
svcIdentifier = serviceIdentifier,
statsReceiver = statsReceiver</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>}</p>
<p>override val earlybirdSearchDest = “/s/earlybird-root-superroot/root-superroot”</p>
<p>// low latency as compared to default <cite>semanticCoreMetadataClient</cite>
private val lowLatencySemanticCoreMetadataClient: MetadataService.MethodPerEndpoint =</p>
<blockquote>
<div><dl>
<dt>new MetadataService.FinagledClient(</dt><dd><dl class="simple">
<dt>Finagle.readOnlyThriftService(</dt><dd><p>name = “semantic_core_metadata_service”,
dest = “/s/escherbird/metadataservice”,
statsReceiver = statsReceiver,
thriftClientId = pushserviceThriftClientId,
tries = 2, // total number of tries. number of retries = tries - 1
requestTimeout = 2.seconds,
mTLSServiceIdentifier = Some(serviceIdentifier)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl class="simple">
<dt>private val semanticCoreMetadataStitchClient = new MetadataStitchClient(</dt><dd><p>lowLatencySemanticCoreMetadataClient</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>override val semanticCoreMegadataStore: ReadableStore[SemanticEntityForQuery, EntityMegadata] = {</dt><dd><p>val name = “semantic_core_megadata_store_cached”
val store = MetaDataReadableStore.getMegadataReadableStore(</p>
<blockquote>
<div><p>metadataStitchClient = semanticCoreMetadataStitchClient,
typedMetadataDomains = Some(Set(Domains.EventsEntityService))</p>
</div></blockquote>
<p>)
ObservedCachedReadableStore</p>
<blockquote>
<div><dl>
<dt>.from(</dt><dd><dl class="simple">
<dt>store = ObservedReadableStore(store)(</dt><dd><dl class="simple">
<dt>statsReceiver</dt><dd><p>.scope(“store”)
.scope(“semantic_core_megadata_store”)</p>
</dd>
</dl>
</dd>
</dl>
<p>),
ttl = 1.hour,
maxKeys = 1000,
cacheName = “semantic_core_megadata_cache”,
windowSize = 10000L</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“store”, name))</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override val basketballGameScoreStore: ReadableStore[QualifiedId, BasketballGameLiveUpdate] = {</dt><dd><dl class="simple">
<dt>StratoFetchableStore.withUnitView[QualifiedId, BasketballGameLiveUpdate](</dt><dd><p>stratoClient,
“semanticCore/basketballGameScore.Entity”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override val baseballGameScoreStore: ReadableStore[QualifiedId, BaseballGameLiveUpdate] = {</dt><dd><dl class="simple">
<dt>StratoFetchableStore.withUnitView[QualifiedId, BaseballGameLiveUpdate](</dt><dd><p>stratoClient,
“semanticCore/baseballGameScore.Entity”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override val cricketMatchScoreStore: ReadableStore[QualifiedId, CricketMatchLiveUpdate] = {</dt><dd><dl class="simple">
<dt>StratoFetchableStore.withUnitView[QualifiedId, CricketMatchLiveUpdate](</dt><dd><p>stratoClient,
“semanticCore/cricketMatchScore.Entity”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val soccerMatchScoreStore: ReadableStore[QualifiedId, SoccerMatchLiveUpdate] = {</dt><dd><dl>
<dt>ObservedCachedReadableStore</dt><dd><dl>
<dt>.from(</dt><dd><dl class="simple">
<dt>store = StratoFetchableStore.withUnitView[QualifiedId, SoccerMatchLiveUpdate](</dt><dd><p>stratoClient,
“semanticCore/soccerMatchScore.Entity”),</p>
</dd>
</dl>
<p>ttl = 10.seconds,
maxKeys = 100,
cacheName = “SoccerMatchCachedStore”,
windowSize = 100L</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“SoccerMatchCachedStore”))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val nflGameScoreStore: ReadableStore[QualifiedId, NflFootballGameLiveUpdate] = {</dt><dd><dl>
<dt>ObservedCachedReadableStore</dt><dd><dl>
<dt>.from(</dt><dd><dl class="simple">
<dt>store = StratoFetchableStore.withUnitView[QualifiedId, NflFootballGameLiveUpdate](</dt><dd><p>stratoClient,
“semanticCore/nflFootballGameScore.Entity”),</p>
</dd>
</dl>
<p>ttl = 10.seconds,
maxKeys = 100,
cacheName = “NFLMatchCachedStore”,
windowSize = 100L</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“NFLMatchCachedStore”))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val userHealthSignalStore: ReadableStore[Long, UserHealthSignalResponse] = {</dt><dd><dl>
<dt>val userHealthSignalFetcher =</dt><dd><dl class="simple">
<dt>stratoClient.fetcher[Long, Seq[UserHealthSignal], UserHealthSignalResponse](</dt><dd><p>“hss/user_signals/api/healthSignals.User”</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val store = buildStore(</dt><dd><dl>
<dt>StratoFetchableStore.withView[Long, Seq[UserHealthSignal], UserHealthSignalResponse](</dt><dd><p>userHealthSignalFetcher,
Seq(</p>
<blockquote>
<div><p>AgathaRecentAbuseStrikeDouble,
AgathaCalibratedNsfwDouble,
AgathaCseDouble,
NsfwTextUserScoreDouble,
NsfwConsumerScoreDouble)),</p>
</div></blockquote>
</dd>
</dl>
<p>“UserHealthSignalFetcher”</p>
</dd>
</dl>
<p>)
if (!inMemCacheOff) {</p>
<blockquote>
<div><dl>
<dt>ObservedCachedReadableStore</dt><dd><dl>
<dt>.from(</dt><dd><dl class="simple">
<dt>store = ObservedReadableStore(store)(</dt><dd><p>statsReceiver.scope(“store”).scope(“user_health_model_score_store”)),</p>
</dd>
</dl>
<p>ttl = 12.hours,
maxKeys = 16777215,
cacheName = “user_health_model_score_store_cache”,
windowSize = 10000L</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“store”, “user_health_model_score_store_cached”))</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>store</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val tweetHealthScoreStore: ReadableStore[TweetScoringRequest, TweetScoringResponse] = {</dt><dd><dl>
<dt>val tweetHealthScoreFetcher =</dt><dd><dl class="simple">
<dt>stratoClient.fetcher[TweetScoringRequest, Unit, TweetScoringResponse](</dt><dd><p>“abuse/detection/tweetHealthModelScore”</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val store = buildStore(</dt><dd><p>StratoFetchableStore.withUnitView(tweetHealthScoreFetcher),
“TweetHealthScoreFetcher”</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>ObservedCachedReadableStore</dt><dd><dl>
<dt>.from(</dt><dd><dl class="simple">
<dt>store = ObservedReadableStore(store)(</dt><dd><p>statsReceiver.scope(“store”).scope(“tweet_health_model_score_store”)),</p>
</dd>
</dl>
<p>ttl = 30.minutes,
maxKeys = 1000,
cacheName = “tweet_health_model_score_store_cache”,
windowSize = 10000L</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“store”, “tweet_health_model_score_store_cached”))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val appPermissionStore: ReadableStore[(Long, (String, String)), AppPermission] = {</dt><dd><dl class="simple">
<dt>val store = StratoFetchableStore</dt><dd><dl class="simple">
<dt>.withUnitView[(Long, (String, String)), AppPermission](</dt><dd><p>stratoClient,
“clients/permissionsState”)</p>
</dd>
</dl>
</dd>
<dt>ObservedCachedReadableStore.from[(Long, (String, String)), AppPermission](</dt><dd><p>buildStore(store, “mr_app_permission_store”),
ttl = 30.minutes,
maxKeys = 1000,
cacheName = “mr_app_permission_store_cache”,
windowSize = 10000L</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“mr_app_permission_store_cached”))</p>
</dd>
</dl>
<p>}</p>
<p>def pushSendEventStreamName: String</p>
<dl>
<dt>override val pushSendEventBusPublisher = EventBusPublisherBuilder()</dt><dd><p>.clientId(“frigate_pushservice”)
.streamName(pushSendEventStreamName)
.thriftStruct(NotificationScribe)
.statsReceiver(statsReceiver.scope(“push_send_eventbus”))
.build()</p>
</dd>
<dt>override lazy val candidateFeatureHydrator: CandidateFeatureHydrator =</dt><dd><dl>
<dt>CandidateFeatureHydrator(</dt><dd><p>socialContextActionsFeatureBuilder = Some(socialContextActionsFeatureBuilder),
tweetSocialProofFeatureBuilder = Some(tweetSocialProofFeatureBuilder),
earlybirdFeatureBuilder = Some(earlybirdFeatureBuilder),
tweetContentFeatureBuilder = Some(tweetContentFeatureBuilder),
tweetAuthorRecentRealGraphFeatureBuilder = Some(tweetAuthorRecentRealGraphFeatureBuilder),
socialContextRecentRealGraphFeatureBuilder = Some(socialContextRecentRealGraphFeatureBuilder),
tweetAnnotationsFeatureBuilder = Some(tweetAnnotationsFeatureBuilder),
mrOfflineUserCandidateSparseAggregatesFeatureBuilder =</p>
<blockquote>
<div><p>Some(mrOfflineUserCandidateSparseAggregatesFeatureBuilder),</p>
</div></blockquote>
<p>candidateLevelFeatureBuilder = Some(candidateLevelFeatureBuilder)</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“push_feature_hydrator”))</p>
</dd>
<dt>private val candidateCopyCross =</dt><dd><p>new CandidateCopyExpansion(statsReceiver.scope(“refresh_handler/cross”))</p>
</dd>
<dt>override lazy val candidateHydrator: PushCandidateHydrator =</dt><dd><dl class="simple">
<dt>PushCandidateHydrator(</dt><dd><p>this.socialGraphServiceProcessStore,
safeUserStore,
listAPIStore,
candidateCopyCross)(
statsReceiver.scope(“push_candidate_hydrator”),
weightedOpenOrNtabClickModelScorer)</p>
</dd>
</dl>
</dd>
<dt>override lazy val sendHandlerCandidateHydrator: SendHandlerPushCandidateHydrator =</dt><dd><dl class="simple">
<dt>SendHandlerPushCandidateHydrator(</dt><dd><p>lexServiceStore,
fanoutMetadataStore,
semanticCoreMegadataStore,
safeUserStore,
simClusterToEntityStore,
audioSpaceStore,
interestsWithLookupContextStore,
uttEntityHydrationStore,
superFollowCreatorTweetCountStore</p>
</dd>
<dt>)(</dt><dd><p>statsReceiver.scope(“push_candidate_hydrator”),
weightedOpenOrNtabClickModelScorer</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>def mrRequestScriberNode: String
def loggedOutMrRequestScriberNode: String</p>
<dl class="simple">
<dt>override lazy val configParamsBuilder: ConfigParamsBuilder = ConfigParamsBuilder(</dt><dd><p>config = overridesConfig,
featureContextBuilder = FeatureContextBuilder(featureSwitches),
statsReceiver = statsReceiver</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>def buildStore[K, V](store: ReadableStore[K, V], name: String): ReadableStore[K, V] = {</dt><dd><p>ObservedReadableStore(store)(statsReceiver.scope(“store”).scope(name))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def buildManhattanStore[K, V](dataset: Dataset[K, V]): ReadableStore[K, V] = {</dt><dd><dl class="simple">
<dt>val manhattanKVClientParams = ManhattanKVClientMtlsParams(</dt><dd><p>serviceIdentifier = serviceIdentifier,
opportunisticTls = OpportunisticTls.Required</p>
</dd>
</dl>
<p>)
ManhattanStore</p>
<blockquote>
<div><dl class="simple">
<dt>.fromDatasetWithMtls[K, V](</dt><dd><p>dataset,
mtlsParams = manhattanKVClientParams,
statsReceiver = statsReceiver.scope(dataset.datasetName))</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def buildCachedTweetyPieStore(</dt><dd><p>getTweetOptions: Option[GetTweetOptions],
keyPrefix: String</p>
</dd>
<dt>): ReadableStore[Long, TweetyPieResult] = {</dt><dd><dl>
<dt>def discardAdditionalMediaInfo(tweetypieResult: TweetyPieResult) = {</dt><dd><dl class="simple">
<dt>val updatedMedia = tweetypieResult.tweet.media.map { mediaSeq =&gt;</dt><dd><p>mediaSeq.map { media =&gt; media.copy(additionalMetadata = None, sizes = Nil.toSet) }</p>
</dd>
</dl>
<p>}
val updatedTweet = tweetypieResult.tweet.copy(media = updatedMedia)
tweetypieResult.copy(tweet = updatedTweet)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val tweetypieStoreWithoutAdditionalMediaInfo = TweetyPieStore(</dt><dd><p>tweetyPieClient,
getTweetOptions,
transformTweetypieResult = discardAdditionalMediaInfo</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“tweetypie_without_additional_media_info”))</p>
<dl class="simple">
<dt>ObservedMemcachedReadableStore.fromCacheClient(</dt><dd><p>backingStore = tweetypieStoreWithoutAdditionalMediaInfo,
cacheClient = pushServiceCoreSvcsCacheClient,
ttl = 12.hours</p>
</dd>
<dt>)(</dt><dd><p>valueInjection = TweetyPieResultInjection,
statsReceiver = statsReceiver.scope(“TweetyPieStore”),
keyToString = { k: Long =&gt; s”$keyPrefix/$k” }</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def init(): Future[Unit] =</dt><dd><dl class="simple">
<dt>ClientRegistry.expAllRegisteredClientsResolved().map { clients =&gt;</dt><dd><p>log.info(“Done resolving clients: “ + clients.mkString(“[”, “, “, “]”))</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>val InlineActionsMhColumn =</dt><dd><p>“frigate/magicrecs/inlineActionsMh”</p>
</dd>
<dt>override val inlineActionHistoryStore: ReadableStore[Long, Seq[(Long, String)]] =</dt><dd><dl>
<dt>StratoScannableStore</dt><dd><p>.withUnitView[(Long, Slice[Long]), (Long, Long), String](stratoClient, InlineActionsMhColumn)
.composeKeyMapping[Long] { userId =&gt;</p>
<blockquote>
<div><p>(userId, Slice[Long](from = None, to = None, limit = None))</p>
</div></blockquote>
<dl>
<dt>}.mapValues { response =&gt;</dt><dd><dl class="simple">
<dt>response.map {</dt><dd><p>case (key, value) =&gt; (key._2, value)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
<dt>override val tripTweetCandidateStore: ReadableStore[TripDomain, TripTweets] = {</dt><dd><dl class="simple">
<dt>StratoFetchableStore</dt><dd><dl class="simple">
<dt>.withUnitView[TripDomain, TripTweets](</dt><dd><p>new TripTweetsAirflowProdClientColumn(stratoClient).fetcher)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override val softUserFollowingStore: ReadableStore[User, Seq[Long]] = new SoftUserFollowingStore(</dt><dd><p>stratoClient)</p>
</dd>
<dt>override val superFollowEligibilityUserStore: ReadableStore[Long, Boolean] = {</dt><dd><dl class="simple">
<dt>StratoFetchableStore.withUnitView[Long, Boolean](</dt><dd><p>stratoClient,
“audiencerewards/audienceRewardsService/getSuperFollowEligibility.User”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val superFollowCreatorTweetCountStore: ReadableStore[UserId, Int] = {</dt><dd><dl>
<dt>ObservedCachedReadableStore</dt><dd><dl>
<dt>.from(</dt><dd><dl class="simple">
<dt>store = StratoFetchableStore</dt><dd><p>.withUnitView[UserId, Int](new CreatorSubscriptionNumTweetsColumn(stratoClient).fetcher),</p>
</dd>
</dl>
<p>ttl = 5.minutes,
maxKeys = 1000,
cacheName = “SuperFollowCreatorTweetCountStore”,
windowSize = 10000L</p>
</dd>
</dl>
<p>)(statsReceiver.scope(“SuperFollowCreatorTweetCountStore”))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override val hasSuperFollowingRelationshipStore: ReadableStore[</dt><dd><p>HasSuperFollowingRelationshipRequest,
Boolean</p>
</dd>
<dt>] = {</dt><dd><dl class="simple">
<dt>StratoFetchableStore.withUnitView[HasSuperFollowingRelationshipRequest, Boolean](</dt><dd><p>stratoClient,
“audiencerewards/superFollows/hasSuperFollowingRelationshipV2”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override val superFollowApplicationStatusStore: ReadableStore[</dt><dd><p>(Long, SellerTrack),
SellerApplicationState</p>
</dd>
<dt>] = {</dt><dd><dl class="simple">
<dt>StratoFetchableStore.withUnitView[(Long, SellerTrack), SellerApplicationState](</dt><dd><p>stratoClient,
“periscope/eligibility/applicationStatus”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>def historyStoreMemcacheDest: String</p>
<dl class="simple">
<dt>override lazy val recentHistoryCacheClient = {</dt><dd><p>RecentHistoryCacheClient.build(historyStoreMemcacheDest, serviceIdentifier, statsReceiver)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override val openAppUserStore: ReadableStore[Long, Boolean] = {</dt><dd><p>buildStore(OpenAppUserStore(stratoClient), “OpenAppUserStore”)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/pushservice/src/main/scala/com/twitter/frigate/pushservice/config/DeployConfig.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>