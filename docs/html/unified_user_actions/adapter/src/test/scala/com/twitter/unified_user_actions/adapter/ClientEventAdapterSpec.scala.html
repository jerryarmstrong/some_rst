<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.unified_user_actions.adapter</p>
<p>import com.twitter.clientapp.thriftscala.EventNamespace
import com.twitter.clientapp.thriftscala.{Item =&gt; LogEventItem}
import com.twitter.clientapp.thriftscala.ItemType
import com.twitter.clientapp.thriftscala.LogEvent
import com.twitter.clientapp.thriftscala.NotificationTabDetails
import com.twitter.clientapp.thriftscala.ReportDetails
import com.twitter.clientapp.thriftscala.SearchDetails
import com.twitter.clientapp.thriftscala.SuggestionDetails
import com.twitter.inject.Test
import com.twitter.logbase.thriftscala.ClientEventReceiver
import com.twitter.reportflow.thriftscala.ReportType
import com.twitter.suggests.controller_data.thriftscala.ControllerData
import com.twitter.unified_user_actions.adapter.client_event.ClientEventAdapter
import com.twitter.unified_user_actions.thriftscala._
import com.twitter.util.Time
import org.scalatest.prop.TableDrivenPropertyChecks
import org.scalatest.prop.TableFor1
import org.scalatest.prop.TableFor2
import scala.language.implicitConversions</p>
<dl>
<dt>class ClientEventAdapterSpec extends Test with TableDrivenPropertyChecks {</dt><dd><p>// Tests for invalid client-events
test(“should ignore events”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl class="simple">
<dt>val eventsToBeIgnored: TableFor2[String, LogEvent] = Table(</dt><dd><p>(“namespace”, “event”),
(“ddg”, ddgEvent),
(“qig_ranker”, qigRankerEvent),
(“timelnemixer”, timelineMixerEvent),
(“timelineservice”, timelineServiceEvent),
(“tweetconvosvc”, tweetConcServiceEvent),
(“item-type is non-tweet”, renderNonTweetItemTypeEvent)</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>forEvery(eventsToBeIgnored) { (_: String, event: LogEvent) =&gt;</dt><dd><p>val actual = ClientEventAdapter.adaptEvent(event)
assert(actual.isEmpty)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>test(“Tests for ItemType filter”) {</dt><dd><p>/// Tweet events
new TestFixtures.ClientEventFixture {</p>
<blockquote>
<div><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl class="simple">
<dt>val events = Table(</dt><dd><p>(“itemType”, “expectedUUA”),
(Some(ItemType.Tweet), Seq(expectedTweetRenderDefaultTweetUUA)),
(Some(ItemType.QuotedTweet), Seq(expectedTweetRenderDefaultTweetUUA)),
(Some(ItemType.Topic), Nil),
(None, Nil)</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>forEvery(events) { (itemTypeOpt: Option[ItemType], expected: Seq[UnifiedUserAction]) =&gt;</dt><dd><dl>
<dt>val actual = ClientEventAdapter.adaptEvent(</dt><dd><dl class="simple">
<dt>actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(ceRenderEventNamespace),
itemTypeOpt = itemTypeOpt</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
<p>assert(expected === actual)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>/// Topic events
new TestFixtures.ClientEventFixture {</p>
<blockquote>
<div><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl class="simple">
<dt>val expected: UnifiedUserAction = mkExpectedUUAForActionTowardTopicEvent(</dt><dd><p>topicId = topicId,
clientEventNamespace = Some(uuaTopicFollowClientEventNamespace1),
actionType = ActionType.ClientTopicFollow</p>
</dd>
</dl>
<p>)
val events = Table(</p>
<blockquote>
<div><p>(“itemType”, “expectedUUA”),
(Some(ItemType.Tweet), Seq(expected)),
(Some(ItemType.QuotedTweet), Seq(expected)),
(Some(ItemType.Topic), Seq(expected)),
(None, Nil)</p>
</div></blockquote>
<p>)</p>
<dl>
<dt>forEvery(events) { (itemTypeOpt: Option[ItemType], expected: Seq[UnifiedUserAction]) =&gt;</dt><dd><dl>
<dt>val actual = ClientEventAdapter.adaptEvent(</dt><dd><dl>
<dt>actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(ceTopicFollow1),
itemId = None,
suggestionDetails =</p>
<blockquote>
<div><p>Some(SuggestionDetails(decodedControllerData = Some(homeTweetControllerData()))),</p>
</div></blockquote>
<p>itemTypeOpt = itemTypeOpt</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
<p>assert(expected === actual)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// Tests for ClientTweetRenderImpression
test(“ClientTweetRenderImpression”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val clientEvents = Table(</dt><dd><p>(“actionTweetType”, “clientEvent”, “expectedUUAEvent”),
(</p>
<blockquote>
<div><p>“Default”,
actionTowardDefaultTweetEvent(eventNamespace = Some(ceRenderEventNamespace)),
Seq(expectedTweetRenderDefaultTweetUUA)),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>“Reply”,
actionTowardReplyEvent(eventNamespace = Some(ceRenderEventNamespace)),
Seq(expectedTweetRenderReplyUUA)),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>“Retweet”,
actionTowardRetweetEvent(eventNamespace = Some(ceRenderEventNamespace)),
Seq(expectedTweetRenderRetweetUUA)),</p>
</dd>
</dl>
<dl>
<dt>(</dt><dd><p>“Quote”,
actionTowardQuoteEvent(</p>
<blockquote>
<div><p>eventNamespace = Some(ceRenderEventNamespace),
quotedAuthorId = Some(456L)),</p>
</div></blockquote>
<p>Seq(expectedTweetRenderQuoteUUA1, expectedTweetRenderQuoteUUA2)),</p>
</dd>
</dl>
<dl>
<dt>(</dt><dd><p>“Retweet of a reply that quoted another Tweet”,
actionTowardRetweetEventWithReplyAndQuote(eventNamespace =</p>
<blockquote>
<div><p>Some(ceRenderEventNamespace)),</p>
</div></blockquote>
<dl class="simple">
<dt>Seq(</dt><dd><p>expectedTweetRenderRetweetWithReplyAndQuoteUUA1,
expectedTweetRenderRetweetWithReplyAndQuoteUUA2))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>)
forEvery(clientEvents) {</p>
<blockquote>
<div><dl class="simple">
<dt>(_: String, event: LogEvent, expectedUUA: Seq[UnifiedUserAction]) =&gt;</dt><dd><p>val actual = ClientEventAdapter.adaptEvent(event)
actual should contain theSameElementsAs expectedUUA</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>test(“ClientTweetGallery/DetailImpression”) {</dt><dd><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val clientEvents = Table(</dt><dd><p>(“actionTweetType”, “clientEvent”, “expectedUUAEvent”),
(</p>
<blockquote>
<div><p>“DetailImpression: tweet::tweet::impression”,
actionTowardDefaultTweetEvent(eventNamespace = Some(ceTweetDetailsEventNamespace1)),
expectedTweetDetailImpressionUUA1),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>“GalleryImpression: gallery:photo:impression”,
actionTowardDefaultTweetEvent(eventNamespace = Some(ceGalleryEventNamespace)),
expectedTweetGalleryImpressionUUA),</p>
</dd>
</dl>
</dd>
</dl>
<p>)
forEvery(clientEvents) { (_: String, event: LogEvent, expectedUUA: UnifiedUserAction) =&gt;</p>
<blockquote>
<div><p>val actual = ClientEventAdapter.adaptEvent(event)
assert(Seq(expectedUUA) === actual)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// Tests for ClientTweetLingerImpression
test(“ClientTweetLingerImpression”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val clientEvents = Table(</dt><dd><p>(“actionTweetType”, “clientEvent”, “expectedUUAEvent”),
(“Default”, lingerDefaultTweetEvent, expectedTweetLingerDefaultTweetUUA),
(“Reply”, lingerReplyEvent, expectedTweetLingerReplyUUA),
(“Retweet”, lingerRetweetEvent, expectedTweetLingerRetweetUUA),
(“Quote”, lingerQuoteEvent, expectedTweetLingerQuoteUUA),
(</p>
<blockquote>
<div><p>“Retweet of a reply that quoted another Tweet”,
lingerRetweetWithReplyAndQuoteEvent,
expectedTweetLingerRetweetWithReplyAndQuoteUUA),</p>
</div></blockquote>
</dd>
</dl>
<p>)
forEvery(clientEvents) { (_: String, event: LogEvent, expectedUUA: UnifiedUserAction) =&gt;</p>
<blockquote>
<div><p>val actual = ClientEventAdapter.adaptEvent(event)
assert(Seq(expectedUUA) === actual)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetClickQuote
test(</p>
<blockquote>
<div><p>“ClickQuote, which is the click on the quote button, results in setting retweeting, inReplyTo, quoted tweet ids”) {
new TestFixtures.ClientEventFixture {</p>
<blockquote>
<div><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val actual = ClientEventAdapter.adaptEvent(</dt><dd><p>// there shouldn’t be any quotingTweetId in CE when it is “quote”
actionTowardRetweetEventWithReplyAndQuote(eventNamespace = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>EventNamespace(</dt><dd><p>action = Some(“quote”)</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>assert(Seq(expectedTweetClickQuoteUUA) === actual)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetQuote
test(</p>
<blockquote>
<div><p>“Quote, which is sending the quote, results in setting retweeting, inReplyTo, quoted tweet ids”) {
new TestFixtures.ClientEventFixture {</p>
<blockquote>
<div><dl class="simple">
<dt>val actions: TableFor1[String] = Table(</dt><dd><p>“action”,
“send_quote_tweet”,
“retweet_with_comment”</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>forEvery(actions) { action =&gt;</dt><dd><dl>
<dt>val actual = ClientEventAdapter.adaptEvent(</dt><dd><p>// there shouldn’t be any quotingTweetId in CE when it is “quote”
actionTowardRetweetEventWithReplyAndQuote(eventNamespace = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>EventNamespace(</dt><dd><p>action = Some(action)</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>assert(Seq(expectedTweetQuoteUUA(action)) === actual)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetFav and ClientTweetUnfav
test(“ClientTweetFav and ClientTweetUnfav”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val clientEvents = Table(</dt><dd><p>(“actionTweetType”, “clientEvent”, “expectedUUAEvent”),
(</p>
<blockquote>
<div><p>“Default Tweet favorite”,
actionTowardDefaultTweetEvent(eventNamespace = Some(ceFavoriteEventNamespace)),
expectedTweetFavoriteDefaultTweetUUA),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>“Reply Tweet favorite”,
actionTowardReplyEvent(eventNamespace = Some(ceFavoriteEventNamespace)),
expectedTweetFavoriteReplyUUA),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>“Retweet Tweet favorite”,
actionTowardRetweetEvent(eventNamespace = Some(ceFavoriteEventNamespace)),
expectedTweetFavoriteRetweetUUA),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>“Quote Tweet favorite”,
actionTowardQuoteEvent(eventNamespace = Some(ceFavoriteEventNamespace)),
expectedTweetFavoriteQuoteUUA),</p>
</dd>
</dl>
<dl>
<dt>(</dt><dd><p>“Retweet of a reply that quoted another Tweet favorite”,
actionTowardRetweetEventWithReplyAndQuote(eventNamespace =</p>
<blockquote>
<div><p>Some(ceFavoriteEventNamespace)),</p>
</div></blockquote>
<p>expectedTweetFavoriteRetweetWithReplyAndQuoteUUA),</p>
</dd>
</dl>
<dl>
<dt>(</dt><dd><p>“Default Tweet unfavorite”,
actionTowardDefaultTweetEvent(</p>
<blockquote>
<div><p>eventNamespace = Some(EventNamespace(action = Some(“unfavorite”))),</p>
</div></blockquote>
<p>),
mkExpectedUUAForActionTowardDefaultTweetEvent(</p>
<blockquote>
<div><p>clientEventNamespace = Some(ClientEventNamespace(action = Some(“unfavorite”))),
actionType = ActionType.ClientTweetUnfav</p>
</div></blockquote>
<p>))</p>
</dd>
</dl>
</dd>
</dl>
<p>)
forEvery(clientEvents) { (_: String, event: LogEvent, expectedUUA: UnifiedUserAction) =&gt;</p>
<blockquote>
<div><p>val actual = ClientEventAdapter.adaptEvent(event)
assert(Seq(expectedUUA) === actual)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetClickReply
test(“ClientTweetClickReply”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val clientEvents = Table(</dt><dd><p>(“actionTweetType”, “clientEvent”, “expectedUUAEvent”),
(</p>
<blockquote>
<div><p>“Default”,
actionTowardDefaultTweetEvent(eventNamespace = Some(ceClickReplyEventNamespace)),
expectedTweetClickReplyDefaultTweetUUA),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>“Reply”,
actionTowardReplyEvent(eventNamespace = Some(ceClickReplyEventNamespace)),
expectedTweetClickReplyReplyUUA),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>“Retweet”,
actionTowardRetweetEvent(eventNamespace = Some(ceClickReplyEventNamespace)),
expectedTweetClickReplyRetweetUUA),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>“Quote”,
actionTowardQuoteEvent(eventNamespace = Some(ceClickReplyEventNamespace)),
expectedTweetClickReplyQuoteUUA),</p>
</dd>
</dl>
<dl>
<dt>(</dt><dd><p>“Retweet of a reply that quoted another Tweet”,
actionTowardRetweetEventWithReplyAndQuote(eventNamespace =</p>
<blockquote>
<div><p>Some(ceClickReplyEventNamespace)),</p>
</div></blockquote>
<p>expectedTweetClickReplyRetweetWithReplyAndQuoteUUA)</p>
</dd>
</dl>
</dd>
</dl>
<p>)
forEvery(clientEvents) { (_: String, event: LogEvent, expectedUUA: UnifiedUserAction) =&gt;</p>
<blockquote>
<div><p>val actual = ClientEventAdapter.adaptEvent(event)
assert(Seq(expectedUUA) === actual)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetReply
test(“ClientTweetReply”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val clientEvents = Table(</dt><dd><p>(“actionTweetType”, “clientEvent”, “expectedUUAEvent”),
(“DefaultOrReply”, replyToDefaultTweetOrReplyEvent, expectedTweetReplyDefaultTweetUUA),
(“Retweet”, replyToRetweetEvent, expectedTweetReplyRetweetUUA),
(“Quote”, replyToQuoteEvent, expectedTweetReplyQuoteUUA),
(</p>
<blockquote>
<div><p>“Retweet of a reply that quoted another Tweet”,
replyToRetweetWithReplyAndQuoteEvent,
expectedTweetReplyRetweetWithReplyAndQuoteUUA)</p>
</div></blockquote>
</dd>
</dl>
<p>)
forEvery(clientEvents) { (_: String, event: LogEvent, expectedUUA: UnifiedUserAction) =&gt;</p>
<blockquote>
<div><p>val actual = ClientEventAdapter.adaptEvent(event)
assert(Seq(expectedUUA) === actual)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetRetweet and ClientTweetUnretweet
test(“ClientTweetRetweet and ClientTweetUnretweet”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val clientEvents = Table(</dt><dd><p>(“actionTweetType”, “clientEvent”, “expectedUUAEvent”),
(</p>
<blockquote>
<div><p>“Default Tweet retweet”,
actionTowardDefaultTweetEvent(eventNamespace = Some(ceRetweetEventNamespace)),
expectedTweetRetweetDefaultTweetUUA),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>“Reply Tweet retweet”,
actionTowardReplyEvent(eventNamespace = Some(ceRetweetEventNamespace)),
expectedTweetRetweetReplyUUA),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>“Retweet Tweet retweet”,
actionTowardRetweetEvent(eventNamespace = Some(ceRetweetEventNamespace)),
expectedTweetRetweetRetweetUUA),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>“Quote Tweet retweet”,
actionTowardQuoteEvent(eventNamespace = Some(ceRetweetEventNamespace)),
expectedTweetRetweetQuoteUUA),</p>
</dd>
</dl>
<dl>
<dt>(</dt><dd><p>“Retweet of a reply that quoted another Tweet retweet”,
actionTowardRetweetEventWithReplyAndQuote(eventNamespace =</p>
<blockquote>
<div><p>Some(ceRetweetEventNamespace)),</p>
</div></blockquote>
<p>expectedTweetRetweetRetweetWithReplyAndQuoteUUA),</p>
</dd>
</dl>
<dl>
<dt>(</dt><dd><p>“Default Tweet unretweet”,
actionTowardDefaultTweetEvent(</p>
<blockquote>
<div><p>eventNamespace = Some(EventNamespace(action = Some(“unretweet”))),</p>
</div></blockquote>
<p>),
mkExpectedUUAForActionTowardDefaultTweetEvent(</p>
<blockquote>
<div><p>clientEventNamespace = Some(ClientEventNamespace(action = Some(“unretweet”))),
actionType = ActionType.ClientTweetUnretweet</p>
</div></blockquote>
<p>))</p>
</dd>
</dl>
</dd>
</dl>
<p>)
forEvery(clientEvents) { (_: String, event: LogEvent, expectedUUA: UnifiedUserAction) =&gt;</p>
<blockquote>
<div><p>val actual = ClientEventAdapter.adaptEvent(event)
assert(Seq(expectedUUA) === actual)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>test(“include Topic Id”) {</dt><dd><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl class="simple">
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><p>val actual = ClientEventAdapter.adaptEvent(renderDefaultTweetWithTopicIdEvent)
assert(Seq(expectedTweetRenderDefaultTweetWithTopicIdUUA) === actual)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// Tests for ClientTweetVideoPlayback0, 25, 50, 75, 95, 100 PlayFromTap, QualityView,
// VideoView, MrcView, ViewThreshold
test(“ClientTweetVideoPlayback*”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val clientEvents = Table(</dt><dd><p>(“ceNamespace”, “uuaNamespace”, “uuaActionType”),
(</p>
<blockquote>
<div><p>ceVideoPlayback25,
uuaVideoPlayback25ClientEventNamespace,
ActionType.ClientTweetVideoPlayback25),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>ceVideoPlayback50,
uuaVideoPlayback50ClientEventNamespace,
ActionType.ClientTweetVideoPlayback50),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>ceVideoPlayback75,
uuaVideoPlayback75ClientEventNamespace,
ActionType.ClientTweetVideoPlayback75),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>ceVideoPlayback95,
uuaVideoPlayback95ClientEventNamespace,
ActionType.ClientTweetVideoPlayback95),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>ceVideoPlayFromTap,
uuaVideoPlayFromTapClientEventNamespace,
ActionType.ClientTweetVideoPlayFromTap),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>ceVideoQualityView,
uuaVideoQualityViewClientEventNamespace,
ActionType.ClientTweetVideoQualityView),</p>
</dd>
</dl>
<p>(ceVideoView, uuaVideoViewClientEventNamespace, ActionType.ClientTweetVideoView),
(ceVideoMrcView, uuaVideoMrcViewClientEventNamespace, ActionType.ClientTweetVideoMrcView),
(</p>
<blockquote>
<div><p>ceVideoViewThreshold,
uuaVideoViewThresholdClientEventNamespace,
ActionType.ClientTweetVideoViewThreshold),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>ceVideoCtaUrlClick,
uuaVideoCtaUrlClickClientEventNamespace,
ActionType.ClientTweetVideoCtaUrlClick),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>ceVideoCtaWatchClick,
uuaVideoCtaWatchClickClientEventNamespace,
ActionType.ClientTweetVideoCtaWatchClick),</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
<dl>
<dt>for (element &lt;- videoEventElementValues) {</dt><dd><dl>
<dt>forEvery(clientEvents) {</dt><dd><dl>
<dt>(</dt><dd><p>ceNamespace: EventNamespace,
uuaNamespace: ClientEventNamespace,
uuaActionType: ActionType</p>
</dd>
<dt>) =&gt;</dt><dd><dl class="simple">
<dt>val event = actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(ceNamespace.copy(element = Some(element))),
mediaDetailsV2 = Some(mediaDetailsV2),
clientMediaEvent = Some(clientMediaEvent),
cardDetails = Some(cardDetails)</p>
</dd>
</dl>
<p>)
val expectedUUA = mkExpectedUUAForActionTowardDefaultTweetEvent(</p>
<blockquote>
<div><p>clientEventNamespace = Some(uuaNamespace.copy(element = Some(element))),
actionType = uuaActionType,
tweetActionInfo = Some(videoMetadata)</p>
</div></blockquote>
<p>)
val actual = ClientEventAdapter.adaptEvent(event)
assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetPhotoExpand
test(“Client Tweet Photo Expand”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><p>val clientEvent = actionTowardDefaultTweetEvent(eventNamespace = Some(cePhotoExpand))
val expectedUUA = mkExpectedUUAForActionTowardDefaultTweetEvent(</p>
<blockquote>
<div><p>clientEventNamespace = Some(uuaPhotoExpandClientEventNamespace),
actionType = ActionType.ClientTweetPhotoExpand</p>
</div></blockquote>
<p>)
assert(Seq(expectedUUA) === ClientEventAdapter.adaptEvent(clientEvent))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientCardClick
test(“Client Card Related”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val clientEvents = Table(</dt><dd><p>(“ceNamespace”, “ceItemType”, “uuaNamespace”, “uuaActionType”),
(</p>
<blockquote>
<div><p>ceCardClick,
ItemType.Tweet,
uuaCardClickClientEventNamespace,
ActionType.ClientCardClick),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>ceCardClick,
ItemType.User,
uuaCardClickClientEventNamespace,
ActionType.ClientCardClick),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>ceCardOpenApp,
ItemType.Tweet,
uuaCardOpenAppClientEventNamespace,
ActionType.ClientCardOpenApp),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>ceCardAppInstallAttempt,
ItemType.Tweet,
uuaCardAppInstallAttemptClientEventNamespace,
ActionType.ClientCardAppInstallAttempt),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>cePollCardVote1,
ItemType.Tweet,
uuaPollCardVote1ClientEventNamespace,
ActionType.ClientPollCardVote),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>cePollCardVote2,
ItemType.Tweet,
uuaPollCardVote2ClientEventNamespace,
ActionType.ClientPollCardVote),</p>
</dd>
</dl>
</dd>
</dl>
<p>)
forEvery(clientEvents) {</p>
<blockquote>
<div><dl>
<dt>(</dt><dd><p>ceNamespace: EventNamespace,
ceItemType: ItemType,
uuaNamespace: ClientEventNamespace,
uuaActionType: ActionType</p>
</dd>
<dt>) =&gt;</dt><dd><dl class="simple">
<dt>val event = actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(ceNamespace),
itemTypeOpt = Some(ceItemType),
authorId = Some(authorId)</p>
</dd>
</dl>
<p>)
val expectedUUA = mkExpectedUUAForCardEvent(</p>
<blockquote>
<div><p>id = Some(itemTweetId),
clientEventNamespace = Some(uuaNamespace),
actionType = uuaActionType,
itemType = Some(ceItemType),
authorId = Some(authorId)</p>
</div></blockquote>
<p>)
val actual = ClientEventAdapter.adaptEvent(event)
assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetClickMentionScreenName
test(“ClientTweetClickMentionScreenName”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><p>val userHandle = “someHandle”
val clientEvent = actionTowardDefaultTweetEvent(</p>
<blockquote>
<div><p>eventNamespace = Some(ceMentionClick),
targets = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>Seq(</dt><dd><dl class="simple">
<dt>LogEventItem(</dt><dd><p>itemType = Some(ItemType.User),
id = Some(userId),
name = Some(userHandle)))))</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<dl>
<dt>val expectedUUA = mkExpectedUUAForActionTowardDefaultTweetEvent(</dt><dd><p>clientEventNamespace = Some(uuaMentionClickClientEventNamespace),
actionType = ActionType.ClientTweetClickMentionScreenName,
tweetActionInfo = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>TweetActionInfo.ClientTweetClickMentionScreenName(</dt><dd><p>ClientTweetClickMentionScreenName(actionProfileId = userId, handle = userHandle)))</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>)
assert(Seq(expectedUUA) === ClientEventAdapter.adaptEvent(clientEvent))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for Topic Follow/Unfollow actions
test(“Topic Follow/Unfollow Actions”) {</p>
<blockquote>
<div><p>// The Topic Id is mostly from TimelineTopic controller data or HomeTweets controller data!
new TestFixtures.ClientEventFixture {</p>
<blockquote>
<div><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val clientEvents = Table(</dt><dd><p>(“clientEventNamesapce”, “expectedUUANamespace”, “controllerData”, “actionType”),
(</p>
<blockquote>
<div><p>ceTopicFollow1,
uuaTopicFollowClientEventNamespace1,
timelineTopicControllerData(),
ActionType.ClientTopicFollow</p>
</div></blockquote>
<p>),
(</p>
<blockquote>
<div><p>ceTopicFollow1,
uuaTopicFollowClientEventNamespace1,
homeTweetControllerData(),
ActionType.ClientTopicFollow),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>ceTopicFollow2,
uuaTopicFollowClientEventNamespace2,
timelineTopicControllerData(),
ActionType.ClientTopicFollow</p>
</dd>
</dl>
<p>),
(</p>
<blockquote>
<div><p>ceTopicFollow2,
uuaTopicFollowClientEventNamespace2,
homeTweetControllerData(),
ActionType.ClientTopicFollow),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>ceTopicFollow3,
uuaTopicFollowClientEventNamespace3,
timelineTopicControllerData(),
ActionType.ClientTopicFollow</p>
</dd>
</dl>
<p>),
(</p>
<blockquote>
<div><p>ceTopicFollow3,
uuaTopicFollowClientEventNamespace3,
homeTweetControllerData(),
ActionType.ClientTopicFollow),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>ceTopicUnfollow1,
uuaTopicUnfollowClientEventNamespace1,
timelineTopicControllerData(),
ActionType.ClientTopicUnfollow</p>
</dd>
</dl>
<p>),
(</p>
<blockquote>
<div><p>ceTopicUnfollow1,
uuaTopicUnfollowClientEventNamespace1,
homeTweetControllerData(),
ActionType.ClientTopicUnfollow),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>ceTopicUnfollow2,
uuaTopicUnfollowClientEventNamespace2,
timelineTopicControllerData(),
ActionType.ClientTopicUnfollow</p>
</dd>
</dl>
<p>),
(</p>
<blockquote>
<div><p>ceTopicFollow2,
uuaTopicFollowClientEventNamespace2,
homeTweetControllerData(),
ActionType.ClientTopicFollow),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>ceTopicUnfollow3,
uuaTopicUnfollowClientEventNamespace3,
timelineTopicControllerData(),
ActionType.ClientTopicUnfollow</p>
</dd>
</dl>
<p>),
(</p>
<blockquote>
<div><p>ceTopicUnfollow3,
uuaTopicUnfollowClientEventNamespace3,
homeTweetControllerData(),
ActionType.ClientTopicUnfollow),</p>
</div></blockquote>
</dd>
</dl>
<p>)</p>
<dl>
<dt>forEvery(clientEvents) {</dt><dd><dl>
<dt>(</dt><dd><p>eventNamespace: EventNamespace,
uuaNs: ClientEventNamespace,
controllerData: ControllerData,
actionType: ActionType</p>
</dd>
<dt>) =&gt;</dt><dd><dl>
<dt>val event = actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(eventNamespace),
itemId = None,
suggestionDetails =</p>
<blockquote>
<div><p>Some(SuggestionDetails(decodedControllerData = Some(controllerData)))</p>
</div></blockquote>
</dd>
</dl>
<p>)
val expectedUUA = mkExpectedUUAForActionTowardTopicEvent(</p>
<blockquote>
<div><p>topicId = topicId,
traceId = None,
clientEventNamespace = Some(uuaNs),
actionType = actionType</p>
</div></blockquote>
<p>)
val actual = ClientEventAdapter.adaptEvent(event)
assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for Topic NotInterestedIn &amp; its Undo actions
test(“Topic NotInterestedIn &amp; its Undo actions”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val clientEvents = Table(</dt><dd><p>(“clientEventNamesapce”, “expectedUUANamespace”, “controllerData”, “actionType”),
(</p>
<blockquote>
<div><p>ceTopicNotInterestedIn1,
uuaTopicNotInterestedInClientEventNamespace1,
timelineTopicControllerData(),
ActionType.ClientTopicNotInterestedIn</p>
</div></blockquote>
<p>),
(</p>
<blockquote>
<div><p>ceTopicNotInterestedIn1,
uuaTopicNotInterestedInClientEventNamespace1,
homeTweetControllerData(),
ActionType.ClientTopicNotInterestedIn),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>ceTopicNotInterestedIn2,
uuaTopicNotInterestedInClientEventNamespace2,
timelineTopicControllerData(),
ActionType.ClientTopicNotInterestedIn</p>
</dd>
</dl>
<p>),
(</p>
<blockquote>
<div><p>ceTopicNotInterestedIn2,
uuaTopicNotInterestedInClientEventNamespace2,
homeTweetControllerData(),
ActionType.ClientTopicNotInterestedIn),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>ceTopicUndoNotInterestedIn1,
uuaTopicUndoNotInterestedInClientEventNamespace1,
timelineTopicControllerData(),
ActionType.ClientTopicUndoNotInterestedIn</p>
</dd>
</dl>
<p>),
(</p>
<blockquote>
<div><p>ceTopicUndoNotInterestedIn1,
uuaTopicUndoNotInterestedInClientEventNamespace1,
homeTweetControllerData(),
ActionType.ClientTopicUndoNotInterestedIn),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>ceTopicUndoNotInterestedIn2,
uuaTopicUndoNotInterestedInClientEventNamespace2,
timelineTopicControllerData(),
ActionType.ClientTopicUndoNotInterestedIn</p>
</dd>
</dl>
<p>),
(</p>
<blockquote>
<div><p>ceTopicUndoNotInterestedIn2,
uuaTopicUndoNotInterestedInClientEventNamespace2,
homeTweetControllerData(),
ActionType.ClientTopicUndoNotInterestedIn),</p>
</div></blockquote>
</dd>
</dl>
<p>)</p>
<dl>
<dt>forEvery(clientEvents) {</dt><dd><dl>
<dt>(</dt><dd><p>eventNamespace: EventNamespace,
uuaNs: ClientEventNamespace,
controllerData: ControllerData,
actionType: ActionType</p>
</dd>
<dt>) =&gt;</dt><dd><dl>
<dt>val event = actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(eventNamespace),
itemId = None,
suggestionDetails =</p>
<blockquote>
<div><p>Some(SuggestionDetails(decodedControllerData = Some(controllerData)))</p>
</div></blockquote>
</dd>
</dl>
<p>)
val expectedUUA = mkExpectedUUAForActionTowardTopicEvent(</p>
<blockquote>
<div><p>topicId = topicId,
traceId = None,
clientEventNamespace = Some(uuaNs),
actionType = actionType</p>
</div></blockquote>
<p>)
val actual = ClientEventAdapter.adaptEvent(event)
assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for authorInfo
test(“authorInfo”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl class="simple">
<dt>val clientEvents = Table(</dt><dd><p>(“authorIdOpt”, “isFollowedByActingUser”, “isFollowingActingUser”),
(Some(authorId), true, false),
(Some(authorId), true, true),
(Some(authorId), false, true),
(Some(authorId), false, false),
(None, true, true),</p>
</dd>
</dl>
<p>)
forEvery(clientEvents) {</p>
<blockquote>
<div><dl>
<dt>(</dt><dd><p>authorIdOpt: Option[Long],
isFollowedByActingUser: Boolean,
isFollowingActingUser: Boolean</p>
</dd>
<dt>) =&gt;</dt><dd><dl>
<dt>val actual = ClientEventAdapter.adaptEvent(</dt><dd><dl class="simple">
<dt>renderDefaultTweetUserFollowStatusEvent(</dt><dd><p>authorId = authorIdOpt,
isFollowedByActingUser = isFollowedByActingUser,
isFollowingActingUser = isFollowingActingUser</p>
</dd>
</dl>
<p>))</p>
</dd>
<dt>val expected =</dt><dd><dl>
<dt>expectedTweetRenderDefaultTweetWithAuthorInfoUUA(authorInfo = authorIdOpt.map { id =&gt;</dt><dd><dl class="simple">
<dt>AuthorInfo(</dt><dd><p>authorId = Some(id),
isFollowedByActingUser = Some(isFollowedByActingUser),
isFollowingActingUser = Some(isFollowingActingUser)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>})</p>
</dd>
</dl>
<p>assert(Seq(expected) === actual)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetReport
test(“ClientTweetReport”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val ceNTabTweetReport: EventNamespace =</dt><dd><p>ceTweetReport.copy(page = Some(“ntab”), section = Some(“all”), component = Some(“urt”))</p>
</dd>
<dt>val uuaNTabTweetReport: ClientEventNamespace =</dt><dd><p>uuaTweetReport.copy(page = Some(“ntab”), section = Some(“all”), component = Some(“urt”))</p>
</dd>
<dt>val params = Table(</dt><dd><dl class="simple">
<dt>(</dt><dd><p>“eventType”,
“ceNamespace”,
“ceNotificationTabDetails”,
“ceReportDetails”,
“uuaNamespace”,
“uuaTweetActionInfo”,
“uuaProductSurface”,
“uuaProductSurfaceInfo”),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>“ntabReportTweetClick”,
ceNTabTweetReport.copy(action = Some(“click”)),
Some(notificationTabTweetEventDetails),
None,
uuaNTabTweetReport.copy(action = Some(“click”)),
reportTweetClick,
Some(ProductSurface.NotificationTab),
Some(notificationTabProductSurfaceInfo)</p>
</dd>
</dl>
<p>),
(</p>
<blockquote>
<div><p>“ntabReportTweetDone”,
ceNTabTweetReport.copy(action = Some(“done”)),
Some(notificationTabTweetEventDetails),
None,
uuaNTabTweetReport.copy(action = Some(“done”)),
reportTweetDone,
Some(ProductSurface.NotificationTab),
Some(notificationTabProductSurfaceInfo)</p>
</div></blockquote>
<p>),
(</p>
<blockquote>
<div><p>“defaultReportTweetDone”,
ceTweetReport.copy(page = Some(“tweet”), action = Some(“done”)),
None,
None,
uuaTweetReport.copy(page = Some(“tweet”), action = Some(“done”)),
reportTweetDone,
None,
None</p>
</div></blockquote>
<p>),
(</p>
<blockquote>
<div><p>“defaultReportTweetWithReportFlowId”,
ceTweetReport.copy(page = Some(“tweet”), action = Some(“done”)),
None,
Some(ReportDetails(reportFlowId = Some(reportFlowId))),
uuaTweetReport.copy(page = Some(“tweet”), action = Some(“done”)),
reportTweetWithReportFlowId,
None,
None</p>
</div></blockquote>
<p>),
(</p>
<blockquote>
<div><p>“defaultReportTweetWithoutReportFlowId”,
ceTweetReport.copy(page = Some(“tweet”), action = Some(“done”)),
None,
None,
uuaTweetReport.copy(page = Some(“tweet”), action = Some(“done”)),
reportTweetWithoutReportFlowId,
None,
None</p>
</div></blockquote>
<p>),</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>forEvery(params) {</dt><dd><dl>
<dt>(</dt><dd><p>_: String,
ceNamespace: EventNamespace,
ceNotificationTabDetails: Option[NotificationTabDetails],
ceReportDetails: Option[ReportDetails],
uuaNamespace: ClientEventNamespace,
uuaTweetActionInfo: TweetActionInfo,
productSurface: Option[ProductSurface],
productSurfaceInfo: Option[ProductSurfaceInfo]</p>
</dd>
<dt>) =&gt;</dt><dd><dl class="simple">
<dt>val actual = ClientEventAdapter.adaptEvent(</dt><dd><dl class="simple">
<dt>actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(ceNamespace),
notificationTabDetails = ceNotificationTabDetails,
reportDetails = ceReportDetails))</p>
</dd>
</dl>
</dd>
<dt>val expectedUUA = mkExpectedUUAForActionTowardDefaultTweetEvent(</dt><dd><p>clientEventNamespace = Some(uuaNamespace),
actionType = ActionType.ClientTweetReport,
tweetActionInfo = Some(uuaTweetActionInfo),
productSurface = productSurface,
productSurfaceInfo = productSurfaceInfo</p>
</dd>
</dl>
<p>)</p>
<p>assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetNotHelpful and ClientTweetUndoNotHelpful
test(“ClientTweetNotHelpful &amp; UndoNotHelpful”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><p>val actions = Table((“action”), “click”, “undo”)
val element = “feedback_givefeedback”
forEvery(actions) { action =&gt;</p>
<blockquote>
<div><dl>
<dt>val clientEvent =</dt><dd><dl class="simple">
<dt>actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(ceEventNamespace(element, action)),</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val expectedUUA = mkExpectedUUAForActionTowardDefaultTweetEvent(</dt><dd><p>clientEventNamespace = Some(uuaClientEventNamespace(element, action)),
actionType = action match {</p>
<blockquote>
<div><p>case “click” =&gt; ActionType.ClientTweetNotHelpful
case “undo” =&gt; ActionType.ClientTweetUndoNotHelpful</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>)</p>
<p>val actual = ClientEventAdapter.adaptEvent(clientEvent)
assert(Seq(expectedUUA) === actual)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetNotInterestedIn and ClientTweetUndoNotInterestedIn
test(“ClientTweetNotInterestedIn &amp; UndoNotInterestedIn”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><p>val actions = Table((“action”), “click”, “undo”)
val element = “feedback_dontlike”
forEvery(actions) { action =&gt;</p>
<blockquote>
<div><dl>
<dt>val clientEvent =</dt><dd><dl class="simple">
<dt>actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(ceEventNamespace(element, action)),</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val expectedUUA = mkExpectedUUAForActionTowardDefaultTweetEvent(</dt><dd><p>clientEventNamespace = Some(uuaClientEventNamespace(element, action)),
actionType = action match {</p>
<blockquote>
<div><p>case “click” =&gt; ActionType.ClientTweetNotInterestedIn
case “undo” =&gt; ActionType.ClientTweetUndoNotInterestedIn</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>)</p>
<p>val actual = ClientEventAdapter.adaptEvent(clientEvent)
assert(Seq(expectedUUA) === actual)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetNotAboutTopic &amp; ClientTweetUndoNotAboutTopic
test(“ClientTweetNotAboutTopic &amp; ClientTweetUndoNotAboutTopic”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><p>val actions = Table((“action”), “click”, “undo”)
val element = “feedback_notabouttopic”
forEvery(actions) { action =&gt;</p>
<blockquote>
<div><dl>
<dt>val clientEvent =</dt><dd><dl class="simple">
<dt>actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(ceEventNamespace(element, action)),</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val expectedUUA = mkExpectedUUAForActionTowardDefaultTweetEvent(</dt><dd><p>clientEventNamespace = Some(uuaClientEventNamespace(element, action)),
actionType = action match {</p>
<blockquote>
<div><p>case “click” =&gt; ActionType.ClientTweetNotAboutTopic
case “undo” =&gt; ActionType.ClientTweetUndoNotAboutTopic</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>)</p>
<p>val actual = ClientEventAdapter.adaptEvent(clientEvent)
assert(Seq(expectedUUA) === actual)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetNotRecent and ClientTweetUndoNotRecent
test(“ClientTweetNotRecent &amp; UndoNotRecent”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><p>val actions = Table((“action”), “click”, “undo”)
val element = “feedback_notrecent”
forEvery(actions) { action =&gt;</p>
<blockquote>
<div><dl>
<dt>val clientEvent =</dt><dd><dl class="simple">
<dt>actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(ceEventNamespace(element, action)),</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val expectedUUA = mkExpectedUUAForActionTowardDefaultTweetEvent(</dt><dd><p>clientEventNamespace = Some(uuaClientEventNamespace(element, action)),
actionType = action match {</p>
<blockquote>
<div><p>case “click” =&gt; ActionType.ClientTweetNotRecent
case “undo” =&gt; ActionType.ClientTweetUndoNotRecent</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>)</p>
<p>val actual = ClientEventAdapter.adaptEvent(clientEvent)
assert(Seq(expectedUUA) === actual)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetSeeFewer and ClientTweetUndoSeeFewer
test(“ClientTweetSeeFewer &amp; ClientTweetUndoSeeFewer”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><p>val actions = Table((“action”), “click”, “undo”)
val element = “feedback_seefewer”
forEvery(actions) { action =&gt;</p>
<blockquote>
<div><dl>
<dt>val clientEvent =</dt><dd><dl class="simple">
<dt>actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(ceEventNamespace(element, action)),</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val expectedUUA = mkExpectedUUAForActionTowardDefaultTweetEvent(</dt><dd><p>clientEventNamespace = Some(uuaClientEventNamespace(element, action)),
actionType = action match {</p>
<blockquote>
<div><p>case “click” =&gt; ActionType.ClientTweetSeeFewer
case “undo” =&gt; ActionType.ClientTweetUndoSeeFewer</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>)</p>
<p>val actual = ClientEventAdapter.adaptEvent(clientEvent)
assert(Seq(expectedUUA) === actual)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for getEventMetadata
test(“getEventMetadata”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val clientEvents = Table(</dt><dd><p>(“clientEventNamesapce”, “expectedUUANamespace”, “controllerData”),
(</p>
<blockquote>
<div><p>ceRenderEventNamespace,
uuaRenderClientEventNamespace,
homeTweetControllerData()</p>
</div></blockquote>
<p>),</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>forEvery(clientEvents) {</dt><dd><dl>
<dt>(</dt><dd><p>eventNamespace: EventNamespace,
uuaNs: ClientEventNamespace,
controllerData: ControllerData</p>
</dd>
<dt>) =&gt;</dt><dd><dl>
<dt>val event = actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(eventNamespace),
suggestionDetails =</p>
<blockquote>
<div><p>Some(SuggestionDetails(decodedControllerData = Some(controllerData)))</p>
</div></blockquote>
</dd>
</dl>
<p>)
val expectedEventMetaData = mkUUAEventMetadata(</p>
<blockquote>
<div><p>clientEventNamespace = Some(uuaNs)</p>
</div></blockquote>
<p>)
val actual = ClientEventAdapter.adaptEvent(event).head.eventMetadata
assert(expectedEventMetaData === actual)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for getSourceTimestamp
test(“getSourceTimestamp”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val params = Table(</dt><dd><p>(“testCase”, “clientEvent”, “expectedUUAEventTimestamp”),
(</p>
<blockquote>
<div><p>“CES event with DriftAdjustedEventCreatedAtMs”,
actionTowardDefaultTweetEvent(eventNamespace = Some(ceRenderEventNamespace)),
logBase.driftAdjustedEventCreatedAtMs),</p>
</div></blockquote>
<dl>
<dt>(</dt><dd><p>“CES event without DriftAdjustedEventCreatedAtMs: ignore”,
actionTowardDefaultTweetEvent(</p>
<blockquote>
<div><p>eventNamespace = Some(ceRenderEventNamespace),
logBase = logBase.unsetDriftAdjustedEventCreatedAtMs),</p>
</div></blockquote>
<p>None),</p>
</dd>
</dl>
<dl>
<dt>(</dt><dd><p>“Non-CES event without DriftAdjustedEventCreatedAtMs: use logBase.timestamp”,
actionTowardDefaultTweetEvent(</p>
<blockquote>
<div><p>eventNamespace = Some(ceRenderEventNamespace),
logBase = logBase</p>
<blockquote>
<div><dl class="simple">
<dt>.copy(</dt><dd><dl class="simple">
<dt>clientEventReceiver =</dt><dd><p>Some(ClientEventReceiver.Unknown)).unsetDriftAdjustedEventCreatedAtMs</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>),
Some(logBase.timestamp))</p>
</dd>
</dl>
</dd>
</dl>
<p>)
forEvery(params) { (_: String, event: LogEvent, expectedUUAEventTimestamp: Option[Long]) =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>val actual =</dt><dd><p>ClientEventAdapter.adaptEvent(event).map(_.eventMetadata.sourceTimestampMs).headOption</p>
</dd>
</dl>
<p>assert(expectedUUAEventTimestamp === actual)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ServerTweetReport
test(“ServerTweetReport”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val params = Table(</dt><dd><p>(“eventType”, “ceNamespace”, “ceReportDetails”, “uuaNamespace”, “uuaTweetActionInfo”),
(</p>
<blockquote>
<div><p>“ReportImpressionIsNotAdapted”,
ceTweetReportFlow(page = “report_abuse”, action = “impression”),
Some(ReportDetails(reportFlowId = Some(reportFlowId))),
None,
None</p>
</div></blockquote>
<p>),
(</p>
<blockquote>
<div><p>“ReportSubmitIsAdapted”,
ceTweetReportFlow(page = “report_abuse”, action = “submit”),
Some(</p>
<blockquote>
<div><dl class="simple">
<dt>ReportDetails(</dt><dd><p>reportFlowId = Some(reportFlowId),
reportType = Some(ReportType.Abuse))),</p>
</dd>
</dl>
</div></blockquote>
<p>Some(uuaTweetReportFlow(page = “report_abuse”, action = “submit”)),
Some(reportTweetSubmit)</p>
</div></blockquote>
<p>),</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>forEvery(params) {</dt><dd><dl>
<dt>(</dt><dd><p>_: String,
ceNamespace: EventNamespace,
ceReportDetails: Option[ReportDetails],
uuaNamespace: Option[ClientEventNamespace],
uuaTweetActionInfo: Option[TweetActionInfo]</p>
</dd>
<dt>) =&gt;</dt><dd><dl>
<dt>val actual = ClientEventAdapter.adaptEvent(</dt><dd><dl class="simple">
<dt>actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(ceNamespace),
reportDetails = ceReportDetails))</p>
</dd>
</dl>
</dd>
<dt>val expectedUUA =</dt><dd><dl>
<dt>if (ceNamespace.action.contains(“submit”))</dt><dd><dl>
<dt>Seq(</dt><dd><dl class="simple">
<dt>mkExpectedUUAForActionTowardDefaultTweetEvent(</dt><dd><p>clientEventNamespace = uuaNamespace,
actionType = ActionType.ServerTweetReport,
tweetActionInfo = uuaTweetActionInfo</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
</dl>
<p>else Nil</p>
</dd>
</dl>
<p>assert(expectedUUA === actual)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientNotificationOpen
test(“ClientNotificationOpen”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val clientEvent =</dt><dd><dl class="simple">
<dt>pushNotificationEvent(</dt><dd><p>eventNamespace = Some(ceNotificationOpen),
notificationDetails = Some(notificationDetails))</p>
</dd>
</dl>
</dd>
<dt>val expectedUUA = mkExpectedUUAForNotificationEvent(</dt><dd><p>clientEventNamespace = Some(uuaNotificationOpen),
actionType = ActionType.ClientNotificationOpen,
notificationContent = tweetNotificationContent,
productSurface = Some(ProductSurface.PushNotification),
productSurfaceInfo = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>ProductSurfaceInfo.PushNotificationInfo(</dt><dd><p>PushNotificationInfo(notificationId = notificationId)))</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>)</p>
<p>val actual = ClientEventAdapter.adaptEvent(clientEvent)
assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientNotificationClick
test(“ClientNotificationClick”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val params = Table(</dt><dd><p>(“notificationType”, “ceNotificationTabDetails”, “uuaNotificationContent”),
(“tweetNotification”, notificationTabTweetEventDetails, tweetNotificationContent),
(</p>
<blockquote>
<div><p>“multiTweetNotification”,
notificationTabMultiTweetEventDetails,
multiTweetNotificationContent),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>“unknownNotification”,
notificationTabUnknownEventDetails,
unknownNotificationContent</p>
</dd>
</dl>
<p>),</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>forEvery(params) {</dt><dd><dl>
<dt>(</dt><dd><p>_: String,
ceNotificationTabDetails: NotificationTabDetails,
uuaNotificationContent: NotificationContent</p>
</dd>
<dt>) =&gt;</dt><dd><dl class="simple">
<dt>val actual = ClientEventAdapter.adaptEvent(</dt><dd><dl class="simple">
<dt>actionTowardNotificationEvent(</dt><dd><p>eventNamespace = Some(ceNotificationClick),
notificationTabDetails = Some(ceNotificationTabDetails)))</p>
</dd>
</dl>
</dd>
<dt>val expectedUUA = mkExpectedUUAForNotificationEvent(</dt><dd><p>clientEventNamespace = Some(uuaNotificationClick),
actionType = ActionType.ClientNotificationClick,
notificationContent = uuaNotificationContent,
productSurface = Some(ProductSurface.NotificationTab),
productSurfaceInfo = Some(notificationTabProductSurfaceInfo)</p>
</dd>
</dl>
<p>)</p>
<p>assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientNotificationSeeLessOften
test(“ClientNotificationSeeLessOften”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val params = Table(</dt><dd><p>(“notificationType”, “ceNotificationTabDetails”, “uuaNotificationContent”),
(“tweetNotification”, notificationTabTweetEventDetails, tweetNotificationContent),
(</p>
<blockquote>
<div><p>“multiTweetNotification”,
notificationTabMultiTweetEventDetails,
multiTweetNotificationContent),</p>
</div></blockquote>
<p>(“unknownNotification”, notificationTabUnknownEventDetails, unknownNotificationContent),</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>forEvery(params) {</dt><dd><dl>
<dt>(</dt><dd><p>_: String,
ceNotificationTabDetails: NotificationTabDetails,
uuaNotificationContent: NotificationContent</p>
</dd>
<dt>) =&gt;</dt><dd><dl class="simple">
<dt>val actual = ClientEventAdapter.adaptEvent(</dt><dd><dl class="simple">
<dt>actionTowardNotificationEvent(</dt><dd><p>eventNamespace = Some(ceNotificationSeeLessOften),
notificationTabDetails = Some(ceNotificationTabDetails)))</p>
</dd>
</dl>
</dd>
<dt>val expectedUUA = mkExpectedUUAForNotificationEvent(</dt><dd><p>clientEventNamespace = Some(uuaNotificationSeeLessOften),
actionType = ActionType.ClientNotificationSeeLessOften,
notificationContent = uuaNotificationContent,
productSurface = Some(ProductSurface.NotificationTab),
productSurfaceInfo = Some(notificationTabProductSurfaceInfo)</p>
</dd>
</dl>
<p>)</p>
<p>assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetClick
test(“ClientTweetClick”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val params = Table(</dt><dd><p>(“eventName”, “page”, “nTabDetails”, “uuaProductSurface”, “uuaProductSurfaceInfo”),
(“tweetClick”, “messages”, None, None, None),
(</p>
<blockquote>
<div><p>“tweetClickInNTab”,
“ntab”,
Some(notificationTabTweetEventDetails),
Some(ProductSurface.NotificationTab),
Some(notificationTabProductSurfaceInfo))</p>
</div></blockquote>
</dd>
</dl>
<p>)</p>
<dl>
<dt>forEvery(params) {</dt><dd><dl>
<dt>(</dt><dd><p>_: String,
page: String,
notificationTabDetails: Option[NotificationTabDetails],
uuaProductSurface: Option[ProductSurface],
uuaProductSurfaceInfo: Option[ProductSurfaceInfo]</p>
</dd>
<dt>) =&gt;</dt><dd><dl class="simple">
<dt>val actual = ClientEventAdapter.adaptEvent(</dt><dd><dl class="simple">
<dt>actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(ceTweetClick.copy(page = Some(page))),
notificationTabDetails = notificationTabDetails))</p>
</dd>
</dl>
</dd>
<dt>val expectedUUA = mkExpectedUUAForActionTowardDefaultTweetEvent(</dt><dd><p>clientEventNamespace = Some(uuaTweetClick.copy(page = Some(page))),
actionType = ActionType.ClientTweetClick,
productSurface = uuaProductSurface,
productSurfaceInfo = uuaProductSurfaceInfo</p>
</dd>
</dl>
<p>)</p>
<p>assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetClickProfile
test(“ClientTweetClickProfile”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val actual =</dt><dd><dl class="simple">
<dt>ClientEventAdapter.adaptEvent(</dt><dd><p>profileClickEvent(eventNamespace = Some(ceTweetClickProfile)))</p>
</dd>
</dl>
</dd>
<dt>val expectedUUA = mkExpectedUUAForProfileClick(</dt><dd><p>clientEventNamespace = Some(uuaTweetClickProfile),
actionType = ActionType.ClientTweetClickProfile,
authorInfo = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>AuthorInfo(</dt><dd><p>authorId = Some(authorId)</p>
</dd>
</dl>
<p>)))</p>
</div></blockquote>
</dd>
</dl>
<p>assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetClickShare
test(“ClientTweetClickShare”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val actual =</dt><dd><dl>
<dt>ClientEventAdapter.adaptEvent(</dt><dd><dl class="simple">
<dt>actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(EventNamespace(action = Some(“share_menu_click”))),
authorId = Some(authorId),
tweetPosition = Some(1),
promotedId = Some(“promted_123”)</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
<dt>val expectedUUA = mkExpectedUUAForActionTowardDefaultTweetEvent(</dt><dd><p>clientEventNamespace = Some(ClientEventNamespace(action = Some(“share_menu_click”))),
actionType = ActionType.ClientTweetClickShare,
authorInfo = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>AuthorInfo(</dt><dd><p>authorId = Some(authorId)</p>
</dd>
</dl>
<p>)),</p>
</div></blockquote>
<p>tweetPosition = Some(1),
promotedId = Some(“promted_123”)</p>
</dd>
</dl>
<p>)
assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetShareVia* and ClientTweetUnbookmark
test(“ClientTweetShareVia and Unbookmark”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl class="simple">
<dt>val input = Table(</dt><dd><p>(“eventNamespaceAction”, “uuaActionTypes”),
(“bookmark”, Seq(ActionType.ClientTweetShareViaBookmark, ActionType.ClientTweetBookmark)),
(“copy_link”, Seq(ActionType.ClientTweetShareViaCopyLink)),
(“share_via_dm”, Seq(ActionType.ClientTweetClickSendViaDirectMessage)),
(“unbookmark”, Seq(ActionType.ClientTweetUnbookmark))</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>forEvery(input) { (eventNamespaceAction: String, uuaActionTypes: Seq[ActionType]) =&gt;</dt><dd><dl class="simple">
<dt>val actual: Seq[UnifiedUserAction] =</dt><dd><dl class="simple">
<dt>ClientEventAdapter.adaptEvent(</dt><dd><dl class="simple">
<dt>actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(EventNamespace(action = Some(eventNamespaceAction))),
authorId = Some(authorId)))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>implicit def any2iterable[A](a: A): Iterable[A] = Some(a)
val expectedUUA: Seq[UnifiedUserAction] = uuaActionTypes.flatMap { uuaActionType =&gt;</p>
<blockquote>
<div><dl>
<dt>mkExpectedUUAForActionTowardDefaultTweetEvent(</dt><dd><dl class="simple">
<dt>clientEventNamespace =</dt><dd><p>Some(ClientEventNamespace(action = Some(eventNamespaceAction))),</p>
</dd>
</dl>
<p>actionType = uuaActionType,
authorInfo = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>AuthorInfo(</dt><dd><p>authorId = Some(authorId)</p>
</dd>
</dl>
<p>))</p>
</div></blockquote>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>}
assert(expectedUUA === actual)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Test for ClientTweetClickHashtag
test(“ClientTweetClickHashtag”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val events = Table(</dt><dd><p>(“targets”, “tweetActionInfo”),
(</p>
<blockquote>
<div><p>Some(Seq(LogEventItem(name = Some(“test_hashtag”)))),
Some(</p>
<blockquote>
<div><dl class="simple">
<dt>TweetActionInfo.ClientTweetClickHashtag(</dt><dd><p>ClientTweetClickHashtag(hashtag = Some(“test_hashtag”))))),</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>Some(Seq.empty[LogEventItem]),
Some(TweetActionInfo.ClientTweetClickHashtag(ClientTweetClickHashtag(hashtag = None)))),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>Some(Nil),
Some(TweetActionInfo.ClientTweetClickHashtag(ClientTweetClickHashtag(hashtag = None)))),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>None,
Some(TweetActionInfo.ClientTweetClickHashtag(ClientTweetClickHashtag(hashtag = None))))</p>
</dd>
</dl>
</dd>
</dl>
<p>)
forEvery(events) {</p>
<blockquote>
<div><dl>
<dt>(targets: Option[Seq[LogEventItem]], tweetActionInfo: Option[TweetActionInfo]) =&gt;</dt><dd><dl class="simple">
<dt>val clientEvent =</dt><dd><dl class="simple">
<dt>actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(ceClickHashtag),
targets = targets)</p>
</dd>
</dl>
</dd>
<dt>val expectedUUA = mkExpectedUUAForActionTowardDefaultTweetEvent(</dt><dd><p>clientEventNamespace = Some(uuaClickHashtagClientEventNamespace),
actionType = ActionType.ClientTweetClickHashtag,
tweetActionInfo = tweetActionInfo</p>
</dd>
</dl>
<p>)
assert(Seq(expectedUUA) === ClientEventAdapter.adaptEvent(clientEvent))</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetVideoPlaybackStart and ClientTweetVideoPlaybackComplete
test(“Client Tweet Video Playback Start and Complete”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val input = Table(</dt><dd><p>(“ceNamespace”, “uuaNamespace”, “uuaActionType”),
(</p>
<blockquote>
<div><p>ceVideoPlaybackStart,
uuaVideoPlaybackStartClientEventNamespace,
ActionType.ClientTweetVideoPlaybackStart),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>ceVideoPlaybackComplete,
uuaVideoPlaybackCompleteClientEventNamespace,
ActionType.ClientTweetVideoPlaybackComplete),</p>
</dd>
</dl>
</dd>
</dl>
<p>)
for (element &lt;- videoEventElementValues) {</p>
<blockquote>
<div><dl>
<dt>forEvery(input) {</dt><dd><dl>
<dt>(</dt><dd><p>ceNamespace: EventNamespace,
uuaNamespace: ClientEventNamespace,
uuaActionType: ActionType</p>
</dd>
<dt>) =&gt;</dt><dd><dl class="simple">
<dt>val clientEvent = actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(ceNamespace.copy(element = Some(element))),
mediaDetailsV2 = Some(mediaDetailsV2),
clientMediaEvent = Some(clientMediaEvent),
cardDetails = Some(cardDetails)</p>
</dd>
</dl>
<p>)
val expectedUUA = mkExpectedUUAForActionTowardDefaultTweetEvent(</p>
<blockquote>
<div><p>clientEventNamespace = Some(uuaNamespace.copy(element = Some(element))),
actionType = uuaActionType,
tweetActionInfo = Some(videoMetadata)</p>
</div></blockquote>
<p>)
assert(ClientEventAdapter.adaptEvent(clientEvent).contains(expectedUUA))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>for (element &lt;- invalidVideoEventElementValues) {</dt><dd><dl>
<dt>forEvery(input) {</dt><dd><dl>
<dt>(</dt><dd><p>ceNamespace: EventNamespace,
uuaNamespace: ClientEventNamespace,
uuaActionType: ActionType</p>
</dd>
<dt>) =&gt;</dt><dd><dl class="simple">
<dt>val clientEvent = actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(ceNamespace.copy(element = Some(element))),
mediaDetailsV2 = Some(mediaDetailsV2),
clientMediaEvent = Some(clientMediaEvent)</p>
</dd>
</dl>
<p>)
val unexpectedUUA = mkExpectedUUAForActionTowardDefaultTweetEvent(</p>
<blockquote>
<div><p>clientEventNamespace = Some(uuaNamespace.copy(element = Some(element))),
actionType = uuaActionType,
tweetActionInfo = Some(videoMetadata)</p>
</div></blockquote>
<p>)
assert(!ClientEventAdapter.adaptEvent(clientEvent).contains(unexpectedUUA))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetNotRelevant and ClientTweetUndoNotRelevant
test(“ClientTweetNotRelevant &amp; UndoNotRelevant”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><p>val actions = Table((“action”), “click”, “undo”)
val element = “feedback_notrelevant”
forEvery(actions) { action =&gt;</p>
<blockquote>
<div><dl>
<dt>val clientEvent =</dt><dd><dl class="simple">
<dt>actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(ceEventNamespace(element, action)),</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val expectedUUA = mkExpectedUUAForActionTowardDefaultTweetEvent(</dt><dd><p>clientEventNamespace = Some(uuaClientEventNamespace(element, action)),
actionType = action match {</p>
<blockquote>
<div><p>case “click” =&gt; ActionType.ClientTweetNotRelevant
case “undo” =&gt; ActionType.ClientTweetUndoNotRelevant</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>)</p>
<p>val actual = ClientEventAdapter.adaptEvent(clientEvent)
assert(Seq(expectedUUA) === actual)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientNotificationDismiss
test(“ClientNotificationDismiss”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val clientEvent =</dt><dd><dl class="simple">
<dt>pushNotificationEvent(</dt><dd><p>eventNamespace = Some(ceNotificationDismiss),
notificationDetails = Some(notificationDetails))</p>
</dd>
</dl>
</dd>
<dt>val expectedUUA = mkExpectedUUAForNotificationEvent(</dt><dd><p>clientEventNamespace = Some(uuaNotificationDismiss),
actionType = ActionType.ClientNotificationDismiss,
notificationContent = tweetNotificationContent,
productSurface = Some(ProductSurface.PushNotification),
productSurfaceInfo = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>ProductSurfaceInfo.PushNotificationInfo(</dt><dd><p>PushNotificationInfo(notificationId = notificationId)))</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>)</p>
<p>val actual = ClientEventAdapter.adaptEvent(clientEvent)
assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTypeaheadClick
test(“ClientTypeaheadClick”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><p>val searchQuery = “searchQuery”</p>
<dl>
<dt>val input = Table(</dt><dd><p>(“clientEventTargets”, “typeaheadActionInfo”),
(</p>
<blockquote>
<div><p>Some(Seq(LogEventItem(id = Some(userId), itemType = Some(ItemType.User)))),
TypeaheadActionInfo.UserResult(UserResult(profileId = userId))),</p>
</div></blockquote>
<dl>
<dt>(</dt><dd><p>Some(Seq(LogEventItem(name = Some(s”$searchQuery”), itemType = Some(ItemType.Search)))),
TypeaheadActionInfo.TopicQueryResult(</p>
<blockquote>
<div><p>TopicQueryResult(suggestedTopicQuery = s”$searchQuery”)))</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>)
forEvery(input) {</p>
<blockquote>
<div><dl>
<dt>(</dt><dd><p>clientEventTargets: Option[Seq[LogEventItem]],
typeaheadActionInfo: TypeaheadActionInfo,</p>
</dd>
<dt>) =&gt;</dt><dd><dl class="simple">
<dt>val clientEvent =</dt><dd><dl class="simple">
<dt>actionTowardsTypeaheadEvent(</dt><dd><p>eventNamespace = Some(ceTypeaheadClick),
targets = clientEventTargets,
searchQuery = searchQuery)</p>
</dd>
</dl>
</dd>
<dt>val expectedUUA = mkExpectedUUAForTypeaheadAction(</dt><dd><p>clientEventNamespace = Some(uuaTypeaheadClick),
actionType = ActionType.ClientTypeaheadClick,
typeaheadActionInfo = typeaheadActionInfo,
searchQuery = searchQuery</p>
</dd>
</dl>
<p>)
val actual = ClientEventAdapter.adaptEvent(clientEvent)
assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
</div></blockquote>
<p>}
// Testing invalid target item type case
assert(</p>
<blockquote>
<div><dl>
<dt>Seq() === ClientEventAdapter.adaptEvent(</dt><dd><dl>
<dt>actionTowardsTypeaheadEvent(</dt><dd><p>eventNamespace = Some(ceTypeaheadClick),
targets =</p>
<blockquote>
<div><p>Some(Seq(LogEventItem(id = Some(itemTweetId), itemType = Some(ItemType.Tweet)))),</p>
</div></blockquote>
<p>searchQuery = searchQuery)))</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientFeedbackPromptSubmit
test(“ClientFeedbackPromptSubmit”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><p>val searchQuery: String = “searchQuery”
val searchDetails = Some(SearchDetails(query = Some(searchQuery)))
val input = Table(</p>
<blockquote>
<div><p>(“logEvent”, “uuaNamespace”, “uuaActionType”, “FeedbackPromptInfo”),
(</p>
<blockquote>
<div><dl class="simple">
<dt>actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(ceTweetRelevantToSearch),
searchDetails = searchDetails</p>
</dd>
</dl>
<p>),
uuaTweetRelevantToSearch,
ActionType.ClientFeedbackPromptSubmit,
FeedbackPromptInfo(feedbackPromptActionInfo =</p>
<blockquote>
<div><dl class="simple">
<dt>FeedbackPromptActionInfo.TweetRelevantToSearch(</dt><dd><dl class="simple">
<dt>TweetRelevantToSearch(</dt><dd><p>searchQuery = searchQuery,
tweetId = itemTweetId,
isRelevant = Some(true))))),</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<dl>
<dt>(</dt><dd><dl class="simple">
<dt>actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(ceTweetNotRelevantToSearch),
searchDetails = searchDetails</p>
</dd>
</dl>
<p>),
uuaTweetNotRelevantToSearch,
ActionType.ClientFeedbackPromptSubmit,
FeedbackPromptInfo(feedbackPromptActionInfo =</p>
<blockquote>
<div><dl class="simple">
<dt>FeedbackPromptActionInfo.TweetRelevantToSearch(</dt><dd><dl class="simple">
<dt>TweetRelevantToSearch(</dt><dd><p>searchQuery = searchQuery,
tweetId = itemTweetId,
isRelevant = Some(false))))),</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<dl>
<dt>(</dt><dd><dl class="simple">
<dt>actionTowardSearchResultPageEvent(</dt><dd><p>eventNamespace = Some(ceSearchResultsRelevant),
searchDetails = searchDetails,
items = Some(Seq(LogEventItem(itemType = Some(ItemType.RelevancePrompt))))</p>
</dd>
</dl>
<p>),
uuaSearchResultsRelevant,
ActionType.ClientFeedbackPromptSubmit,
FeedbackPromptInfo(feedbackPromptActionInfo =</p>
<blockquote>
<div><dl class="simple">
<dt>FeedbackPromptActionInfo.DidYouFindItSearch(</dt><dd><p>DidYouFindItSearch(searchQuery = searchQuery, isRelevant = Some(true))))),</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<dl>
<dt>(</dt><dd><dl class="simple">
<dt>actionTowardSearchResultPageEvent(</dt><dd><p>eventNamespace = Some(ceSearchResultsNotRelevant),
searchDetails = searchDetails,
items = Some(Seq(LogEventItem(itemType = Some(ItemType.RelevancePrompt))))</p>
</dd>
</dl>
<p>),
uuaSearchResultsNotRelevant,
ActionType.ClientFeedbackPromptSubmit,
FeedbackPromptInfo(feedbackPromptActionInfo =</p>
<blockquote>
<div><dl class="simple">
<dt>FeedbackPromptActionInfo.DidYouFindItSearch(</dt><dd><p>DidYouFindItSearch(searchQuery = searchQuery, isRelevant = Some(false)))))</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>)</p>
<dl>
<dt>forEvery(input) {</dt><dd><dl>
<dt>(</dt><dd><p>logEvent: LogEvent,
uuaNamespace: ClientEventNamespace,
uuaActionType: ActionType,
feedbackPromptInfo: FeedbackPromptInfo</p>
</dd>
<dt>) =&gt;</dt><dd><dl class="simple">
<dt>val actual =</dt><dd><p>ClientEventAdapter.adaptEvent(logEvent)</p>
</dd>
<dt>val expectedUUA = mkExpectedUUAForFeedbackSubmitAction(</dt><dd><p>clientEventNamespace = Some(uuaNamespace),
actionType = uuaActionType,
feedbackPromptInfo = feedbackPromptInfo,
searchQuery = searchQuery)</p>
</dd>
</dl>
<p>assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientProfile*
test(“ClientProfile*”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val input = Table(</dt><dd><p>(“eventName”, “ceNamespace”, “uuaNamespace”, “uuaActionType”),
(“profile_block”, ceProfileBlock, uuaProfileBlock, ActionType.ClientProfileBlock),
(“profile_unblock”, ceProfileUnblock, uuaProfileUnblock, ActionType.ClientProfileUnblock),
(“profile_mute”, ceProfileMute, uuaProfileMute, ActionType.ClientProfileMute),
(“profile_report”, ceProfileReport, uuaProfileReport, ActionType.ClientProfileReport),
(“profile_follow”, ceProfileFollow, uuaProfileFollow, ActionType.ClientProfileFollow),
(“profile_click”, ceProfileClick, uuaProfileClick, ActionType.ClientProfileClick),
(</p>
<blockquote>
<div><p>“profile_follow_attempt”,
ceProfileFollowAttempt,
uuaProfileFollowAttempt,
ActionType.ClientProfileFollowAttempt),</p>
</div></blockquote>
<p>(“profile_show”, ceProfileShow, uuaProfileShow, ActionType.ClientProfileShow),</p>
</dd>
</dl>
<p>)
forEvery(input) {</p>
<blockquote>
<div><dl>
<dt>(</dt><dd><p>eventName: String,
ceNamespace: EventNamespace,
uuaNamespace: ClientEventNamespace,
uuaActionType: ActionType</p>
</dd>
<dt>) =&gt;</dt><dd><dl>
<dt>val actual =</dt><dd><dl>
<dt>ClientEventAdapter.adaptEvent(</dt><dd><dl class="simple">
<dt>actionTowardProfileEvent(</dt><dd><p>eventName = eventName,
eventNamespace = Some(ceNamespace)</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
<dt>val expectedUUA = mkExpectedUUAForProfileAction(</dt><dd><p>clientEventNamespace = Some(uuaNamespace),
actionType = uuaActionType,
actionProfileId = itemProfileId)</p>
</dd>
</dl>
<p>assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
// Tests for ClientTweetEngagementAttempt
test(“ClientTweetEngagementAttempt”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val clientEvents = Table(</dt><dd><p>(“eventName”, “ceNamespace”, “uuaNamespace”, “uuaActionType”),
(</p>
<blockquote>
<div><p>“tweet_favourite_attempt”,
ceTweetFavoriteAttempt,
uuaTweetFavoriteAttempt,
ActionType.ClientTweetFavoriteAttempt),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>“tweet_retweet_attempt”,
ceTweetRetweetAttempt,
uuaTweetRetweetAttempt,
ActionType.ClientTweetRetweetAttempt),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>“tweet_reply_attempt”,
ceTweetReplyAttempt,
uuaTweetReplyAttempt,
ActionType.ClientTweetReplyAttempt),</p>
</dd>
</dl>
</dd>
</dl>
<p>)
forEvery(clientEvents) {</p>
<blockquote>
<div><dl>
<dt>(</dt><dd><p>eventName: String,
ceNamespace: EventNamespace,
uuaNamespace: ClientEventNamespace,
uuaActionType: ActionType</p>
</dd>
<dt>) =&gt;</dt><dd><dl class="simple">
<dt>val actual =</dt><dd><p>ClientEventAdapter.adaptEvent(actionTowardDefaultTweetEvent(Some(ceNamespace)))</p>
</dd>
<dt>val expectedUUA = mkExpectedUUAForActionTowardDefaultTweetEvent(</dt><dd><p>clientEventNamespace = Some(uuaNamespace),
actionType = uuaActionType)</p>
</dd>
</dl>
<p>assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for LoggedOut for ClientLogin*
test(“ClientLogin*”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val clientEvents = Table(</dt><dd><p>(“eventName”, “ceNamespace”, “uuaNamespace”, “uuaActionType”),
(</p>
<blockquote>
<div><p>“client_click_login”,
ceClientCTALoginClick,
uuaClientCTALoginClick,
ActionType.ClientCTALoginClick),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>“client_click_show”,
ceClientCTALoginStart,
uuaClientCTALoginStart,
ActionType.ClientCTALoginStart),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>“client_login_success”,
ceClientCTALoginSuccess,
uuaClientCTALoginSuccess,
ActionType.ClientCTALoginSuccess),</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
<dl>
<dt>forEvery(clientEvents) {</dt><dd><dl>
<dt>(</dt><dd><p>eventName: String,
ceNamespace: EventNamespace,
uuaNamespace: ClientEventNamespace,
uuaActionType: ActionType</p>
</dd>
<dt>) =&gt;</dt><dd><dl class="simple">
<dt>val actual =</dt><dd><dl class="simple">
<dt>ClientEventAdapter.adaptEvent(</dt><dd><dl class="simple">
<dt>mkLogEvent(</dt><dd><p>eventName,
Some(ceNamespace),
logBase = Some(logBase1),
eventDetails = None,
pushNotificationDetails = None,
reportDetails = None,
searchDetails = None))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>val expectedUUA = mkExpectedUUAForActionTowardCTAEvent(</dt><dd><p>clientEventNamespace = Some(uuaNamespace),
actionType = uuaActionType,
guestIdMarketingOpt = logBase1.guestIdMarketing</p>
</dd>
</dl>
<p>)</p>
<p>assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for LoggedOut for ClientSignup*
test(“ClientSignup*”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val clientEvents = Table(</dt><dd><p>(“eventName”, “ceNamespace”, “uuaNamespace”, “uuaActionType”),
(</p>
<blockquote>
<div><p>“client_click_signup”,
ceClientCTASignupClick,
uuaClientCTASignupClick,
ActionType.ClientCTASignupClick),</p>
</div></blockquote>
<dl class="simple">
<dt>(</dt><dd><p>“client_signup_success”,
ceClientCTASignupSuccess,
uuaClientCTASignupSuccess,
ActionType.ClientCTASignupSuccess),</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
<dl>
<dt>forEvery(clientEvents) {</dt><dd><dl>
<dt>(</dt><dd><p>eventName: String,
ceNamespace: EventNamespace,
uuaNamespace: ClientEventNamespace,
uuaActionType: ActionType</p>
</dd>
<dt>) =&gt;</dt><dd><dl class="simple">
<dt>val actual =</dt><dd><dl class="simple">
<dt>ClientEventAdapter.adaptEvent(</dt><dd><dl class="simple">
<dt>mkLogEvent(</dt><dd><p>eventName,
Some(ceNamespace),
logBase = Some(logBase1),
eventDetails = None,
pushNotificationDetails = None,
reportDetails = None,
searchDetails = None))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>val expectedUUA = mkExpectedUUAForActionTowardCTAEvent(</dt><dd><p>clientEventNamespace = Some(uuaNamespace),
actionType = uuaActionType,
guestIdMarketingOpt = logBase1.guestIdMarketing</p>
</dd>
</dl>
<p>)
assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetFollowAuthor
test(“ClientTweetFollowAuthor”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl class="simple">
<dt>val testEventsList = Seq(</dt><dd><p>(ceTweetFollowAuthor1, uuaTweetFollowAuthor1, TweetAuthorFollowClickSource.CaretMenu),
(ceTweetFollowAuthor2, uuaTweetFollowAuthor2, TweetAuthorFollowClickSource.ProfileImage)</p>
</dd>
</dl>
<p>)
testEventsList.foreach {</p>
<blockquote>
<div><dl>
<dt>case (eventNamespace, clientEventNamespace, followClickSource) =&gt;</dt><dd><dl>
<dt>val actual =</dt><dd><dl>
<dt>ClientEventAdapter.adaptEvent(</dt><dd><dl class="simple">
<dt>tweetActionTowardAuthorEvent(</dt><dd><p>eventName = “tweet_follow_author”,
eventNamespace = Some(eventNamespace)</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
<dt>val expectedUUA = mkExpectedUUAForTweetActionTowardAuthor(</dt><dd><p>clientEventNamespace = Some(clientEventNamespace),
actionType = ActionType.ClientTweetFollowAuthor,
authorInfo = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>AuthorInfo(</dt><dd><p>authorId = Some(authorId)</p>
</dd>
</dl>
<p>)),</p>
</div></blockquote>
<dl>
<dt>tweetActionInfo = Some(</dt><dd><dl class="simple">
<dt>TweetActionInfo.ClientTweetFollowAuthor(</dt><dd><p>ClientTweetFollowAuthor(followClickSource)</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
</dl>
<p>)
assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetUnfollowAuthor
test(“ClientTweetUnfollowAuthor”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val testEventsList = Seq(</dt><dd><dl class="simple">
<dt>(</dt><dd><p>ceTweetUnfollowAuthor1,
uuaTweetUnfollowAuthor1,
TweetAuthorUnfollowClickSource.CaretMenu),</p>
</dd>
</dl>
<dl class="simple">
<dt>(</dt><dd><p>ceTweetUnfollowAuthor2,
uuaTweetUnfollowAuthor2,
TweetAuthorUnfollowClickSource.ProfileImage)</p>
</dd>
</dl>
</dd>
</dl>
<p>)
testEventsList.foreach {</p>
<blockquote>
<div><dl>
<dt>case (eventNamespace, clientEventNamespace, unfollowClickSource) =&gt;</dt><dd><dl>
<dt>val actual =</dt><dd><dl>
<dt>ClientEventAdapter.adaptEvent(</dt><dd><dl class="simple">
<dt>tweetActionTowardAuthorEvent(</dt><dd><p>eventName = “tweet_unfollow_author”,
eventNamespace = Some(eventNamespace)</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
<dt>val expectedUUA = mkExpectedUUAForTweetActionTowardAuthor(</dt><dd><p>clientEventNamespace = Some(clientEventNamespace),
actionType = ActionType.ClientTweetUnfollowAuthor,
authorInfo = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>AuthorInfo(</dt><dd><p>authorId = Some(authorId)</p>
</dd>
</dl>
<p>)),</p>
</div></blockquote>
<dl>
<dt>tweetActionInfo = Some(</dt><dd><dl class="simple">
<dt>TweetActionInfo.ClientTweetUnfollowAuthor(</dt><dd><p>ClientTweetUnfollowAuthor(unfollowClickSource)</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
</dl>
<p>)
assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetMuteAuthor
test(“ClientTweetMuteAuthor”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val actual =</dt><dd><dl>
<dt>ClientEventAdapter.adaptEvent(</dt><dd><dl class="simple">
<dt>tweetActionTowardAuthorEvent(</dt><dd><p>eventName = “tweet_mute_author”,
eventNamespace = Some(ceTweetMuteAuthor)</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
<dt>val expectedUUA = mkExpectedUUAForTweetActionTowardAuthor(</dt><dd><p>clientEventNamespace = Some(uuaTweetMuteAuthor),
actionType = ActionType.ClientTweetMuteAuthor,
authorInfo = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>AuthorInfo(</dt><dd><p>authorId = Some(authorId)</p>
</dd>
</dl>
<p>)))</p>
</div></blockquote>
</dd>
</dl>
<p>assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetBlockAuthor
test(“ClientTweetBlockAuthor”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val actual =</dt><dd><dl>
<dt>ClientEventAdapter.adaptEvent(</dt><dd><dl class="simple">
<dt>tweetActionTowardAuthorEvent(</dt><dd><p>eventName = “tweet_block_author”,
eventNamespace = Some(ceTweetBlockAuthor)</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
<dt>val expectedUUA = mkExpectedUUAForTweetActionTowardAuthor(</dt><dd><p>clientEventNamespace = Some(uuaTweetBlockAuthor),
actionType = ActionType.ClientTweetBlockAuthor,
authorInfo = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>AuthorInfo(</dt><dd><p>authorId = Some(authorId)</p>
</dd>
</dl>
<p>)))</p>
</div></blockquote>
</dd>
</dl>
<p>assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Tests for ClientTweetUnblockAuthor
test(“ClientTweetUnblockAuthor”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val actual =</dt><dd><dl>
<dt>ClientEventAdapter.adaptEvent(</dt><dd><dl class="simple">
<dt>tweetActionTowardAuthorEvent(</dt><dd><p>eventName = “tweet_unblock_author”,
eventNamespace = Some(ceTweetUnblockAuthor)</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
<dt>val expectedUUA = mkExpectedUUAForTweetActionTowardAuthor(</dt><dd><p>clientEventNamespace = Some(uuaTweetUnblockAuthor),
actionType = ActionType.ClientTweetUnblockAuthor,
authorInfo = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>AuthorInfo(</dt><dd><p>authorId = Some(authorId)</p>
</dd>
</dl>
<p>)))</p>
</div></blockquote>
</dd>
</dl>
<p>assert(Seq(expectedUUA) === actual)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Test for ClientTweetOpenLink
test(“ClientTweetOpenLink”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl class="simple">
<dt>val input = Table(</dt><dd><p>(“url”, “tweetActionInfo”),
(Some(“go/url”), clientOpenLinkWithUrl),
(None, clientOpenLinkWithoutUrl)</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>forEvery(input) { (url: Option[String], tweetActionInfo: TweetActionInfo) =&gt;</dt><dd><dl class="simple">
<dt>val clientEvent =</dt><dd><p>actionTowardDefaultTweetEvent(eventNamespace = Some(ceOpenLink), url = url)</p>
</dd>
<dt>val expectedUUA = mkExpectedUUAForActionTowardDefaultTweetEvent(</dt><dd><p>clientEventNamespace = Some(uuaOpenLinkClientEventNamespace),
actionType = ActionType.ClientTweetOpenLink,
tweetActionInfo = Some(tweetActionInfo)</p>
</dd>
</dl>
<p>)
assert(Seq(expectedUUA) === ClientEventAdapter.adaptEvent(clientEvent))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Test for ClientTweetTakeScreenshot
test(“Client take screenshot”) {</p>
<blockquote>
<div><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl class="simple">
<dt>val clientEvent =</dt><dd><dl class="simple">
<dt>actionTowardDefaultTweetEvent(</dt><dd><p>eventNamespace = Some(ceTakeScreenshot),
percentVisibleHeight100k = Some(100))</p>
</dd>
</dl>
</dd>
<dt>val expectedUUA = mkExpectedUUAForActionTowardDefaultTweetEvent(</dt><dd><p>clientEventNamespace = Some(uuaTakeScreenshotClientEventNamespace),
actionType = ActionType.ClientTweetTakeScreenshot,
tweetActionInfo = Some(clientTakeScreenshot)</p>
</dd>
</dl>
<p>)
assert(Seq(expectedUUA) === ClientEventAdapter.adaptEvent(clientEvent))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>test(“Home / Search product surface meta data”) {</dt><dd><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><dl>
<dt>val clientEvents = Table(</dt><dd><p>(“actionTweetType”, “clientEvent”, “expectedUUAEvent”),
(</p>
<blockquote>
<div><p>“homeTweetEventWithControllerData”,
actionTowardDefaultTweetEvent(</p>
<blockquote>
<div><p>eventNamespace = Some(ceHomeFavoriteEventNamespace),
suggestionDetails = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>SuggestionDetails(decodedControllerData = Some(</dt><dd><dl class="simple">
<dt>homeTweetControllerDataV2(</dt><dd><p>injectedPosition = Some(1),
traceId = Some(traceId),
requestJoinId = Some(requestJoinId)</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>),
expectedHomeTweetEventWithControllerData),</p>
</div></blockquote>
<dl>
<dt>(</dt><dd><p>“homeTweetEventWithSuggestionType”,
actionTowardDefaultTweetEvent(</p>
<blockquote>
<div><p>eventNamespace = Some(ceHomeFavoriteEventNamespace),
suggestionDetails = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>SuggestionDetails(</dt><dd><p>suggestionType = Some(“Test_type”)</p>
</dd>
</dl>
<p>))),</p>
</div></blockquote>
</div></blockquote>
<p>expectedHomeTweetEventWithSuggestType),</p>
</dd>
</dl>
<dl>
<dt>(</dt><dd><p>“homeTweetEventWithControllerDataSuggestionType”,
actionTowardDefaultTweetEvent(</p>
<blockquote>
<div><p>eventNamespace = Some(ceHomeFavoriteEventNamespace),
suggestionDetails = Some(</p>
<blockquote>
<div><dl>
<dt>SuggestionDetails(</dt><dd><p>suggestionType = Some(“Test_type”),
decodedControllerData = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>homeTweetControllerDataV2(</dt><dd><p>injectedPosition = Some(1),
traceId = Some(traceId),
requestJoinId = Some(requestJoinId)))</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>))</p>
</div></blockquote>
</div></blockquote>
<p>),
expectedHomeTweetEventWithControllerDataSuggestType),</p>
</dd>
</dl>
<dl>
<dt>(</dt><dd><p>“homeLatestTweetEventWithControllerData”,
actionTowardDefaultTweetEvent(</p>
<blockquote>
<div><p>eventNamespace = Some(ceHomeLatestFavoriteEventNamespace),
suggestionDetails = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>SuggestionDetails(decodedControllerData = Some(</dt><dd><dl class="simple">
<dt>homeTweetControllerDataV2(</dt><dd><p>injectedPosition = Some(1),
traceId = Some(traceId),
requestJoinId = Some(requestJoinId)</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>),
expectedHomeLatestTweetEventWithControllerData),</p>
</dd>
</dl>
<dl>
<dt>(</dt><dd><p>“homeLatestTweetEventWithSuggestionType”,
actionTowardDefaultTweetEvent(</p>
<blockquote>
<div><p>eventNamespace = Some(ceHomeLatestFavoriteEventNamespace),
suggestionDetails = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>SuggestionDetails(</dt><dd><p>suggestionType = Some(“Test_type”)</p>
</dd>
</dl>
<p>))),</p>
</div></blockquote>
</div></blockquote>
<p>expectedHomeLatestTweetEventWithSuggestType),</p>
</dd>
</dl>
<dl>
<dt>(</dt><dd><p>“homeLatestTweetEventWithControllerDataSuggestionType”,
actionTowardDefaultTweetEvent(</p>
<blockquote>
<div><p>eventNamespace = Some(ceHomeLatestFavoriteEventNamespace),
suggestionDetails = Some(</p>
<blockquote>
<div><dl>
<dt>SuggestionDetails(</dt><dd><p>suggestionType = Some(“Test_type”),
decodedControllerData = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>homeTweetControllerDataV2(</dt><dd><p>injectedPosition = Some(1),
traceId = Some(traceId),
requestJoinId = Some(requestJoinId)))</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>))</p>
</div></blockquote>
</div></blockquote>
<p>),
expectedHomeLatestTweetEventWithControllerDataSuggestType),</p>
</dd>
</dl>
<dl>
<dt>(</dt><dd><p>“searchTweetEventWithControllerData”,
actionTowardDefaultTweetEvent(</p>
<blockquote>
<div><p>eventNamespace = Some(ceSearchFavoriteEventNamespace),
suggestionDetails = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>SuggestionDetails(decodedControllerData = Some(</dt><dd><dl class="simple">
<dt>mkSearchResultControllerData(</dt><dd><p>queryOpt = Some(“twitter”),
traceId = Some(traceId),
requestJoinId = Some(requestJoinId)</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>),
expectedSearchTweetEventWithControllerData),</p>
</dd>
</dl>
</dd>
</dl>
<p>)
forEvery(clientEvents) { (_: String, event: LogEvent, expectedUUA: UnifiedUserAction) =&gt;</p>
<blockquote>
<div><p>val actual = ClientEventAdapter.adaptEvent(event)
assert(Seq(expectedUUA) === actual)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>test(“ClientAppExit”) {</dt><dd><dl>
<dt>new TestFixtures.ClientEventFixture {</dt><dd><dl>
<dt>Time.withTimeAt(frozenTime) { _ =&gt;</dt><dd><p>val duration: Option[Long] = Some(10000L)
val inputTable = Table(</p>
<blockquote>
<div><p>(“eventType”, “clientAppId”, “section”, “duration”, “isValidEvent”),
(“uas-iPhone”, Some(129032L), Some(“enter_background”), duration, true),
(“uas-iPad”, Some(191841L), Some(“enter_background”), duration, true),
(“uas-android”, Some(258901L), None, duration, true),
(“none-clientId”, None, None, duration, false),
(“invalid-clientId”, Some(1L), None, duration, false),
(“none-duration”, Some(258901L), None, None, false),
(“non-uas-iPhone”, Some(129032L), None, duration, false)</p>
</div></blockquote>
<p>)</p>
<dl>
<dt>forEvery(inputTable) {</dt><dd><dl>
<dt>(</dt><dd><p>_: String,
clientAppId: Option[Long],
section: Option[String],
duration: Option[Long],
isValidEvent: Boolean</p>
</dd>
<dt>) =&gt;</dt><dd><dl>
<dt>val actual = ClientEventAdapter.adaptEvent(</dt><dd><dl class="simple">
<dt>actionTowardsUasEvent(</dt><dd><p>eventNamespace = Some(ceAppExit.copy(section = section)),
clientAppId = clientAppId,
duration = duration</p>
</dd>
</dl>
<p>))</p>
</dd>
<dt>if (isValidEvent) {</dt><dd><p>// create UUA UAS event
val expectedUUA = mkExpectedUUAForUasEvent(</p>
<blockquote>
<div><p>clientEventNamespace = Some(uuaAppExit.copy(section = section)),
actionType = ActionType.ClientAppExit,
clientAppId = clientAppId,
duration = duration</p>
</div></blockquote>
<p>)
assert(Seq(expectedUUA) === actual)</p>
</dd>
<dt>} else {</dt><dd><p>// ignore the event and do not create UUA UAS event
assert(actual.isEmpty)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/unified_user_actions/adapter/src/test/scala/com/twitter/unified_user_actions/adapter/ClientEventAdapterSpec.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>