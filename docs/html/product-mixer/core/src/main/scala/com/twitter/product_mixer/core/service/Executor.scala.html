<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../../" id="documentation_options" src="../../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.product_mixer.core.service</p>
<p>import com.twitter.finagle.stats.BroadcastStatsReceiver
import com.twitter.finagle.stats.Counter
import com.twitter.finagle.stats.DefaultStatsReceiver
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.finagle.tracing.Annotation
import com.twitter.finagle.tracing.Record
import com.twitter.finagle.tracing.Trace
import com.twitter.finagle.tracing.TraceId
import com.twitter.finagle.tracing.TraceServiceName
import com.twitter.finagle.tracing.Tracing.LocalBeginAnnotation
import com.twitter.finagle.tracing.Tracing.LocalEndAnnotation
import com.twitter.product_mixer.core.feature.Feature
import com.twitter.product_mixer.core.feature.featuremap.FeatureMap
import com.twitter.product_mixer.core.feature.featuremap.FeatureMapBuilder
import com.twitter.product_mixer.core.model.common.identifier.CandidateSourceIdentifier
import com.twitter.product_mixer.core.model.common.identifier.ComponentIdentifier
import com.twitter.product_mixer.core.model.common.identifier.ComponentIdentifierStack
import com.twitter.product_mixer.core.model.common.identifier.ProductPipelineIdentifier
import com.twitter.product_mixer.core.model.common.identifier.PipelineStepIdentifier
import com.twitter.product_mixer.core.pipeline.FailOpenPolicy
import com.twitter.product_mixer.core.pipeline.PipelineResult
import com.twitter.product_mixer.core.pipeline.pipeline_failure.FeatureHydrationFailed
import com.twitter.product_mixer.core.pipeline.pipeline_failure.MisconfiguredFeatureMapFailure
import com.twitter.product_mixer.core.pipeline.pipeline_failure.PipelineFailure
import com.twitter.product_mixer.core.pipeline.pipeline_failure.PipelineFailureClassifier
import com.twitter.product_mixer.core.pipeline.pipeline_failure.UncategorizedServerFailure
import com.twitter.product_mixer.core.quality_factor.QualityFactorObserver
import com.twitter.product_mixer.core.service.Executor.AlwaysFailOpenIncludingProgrammerErrors
import com.twitter.product_mixer.core.service.Executor.Context
import com.twitter.product_mixer.core.service.Executor.TracingConfig
import com.twitter.product_mixer.core.service.Executor.toPipelineFailureWithComponentIdentifierStack
import com.twitter.servo.util.CancelledExceptionExtractor
import com.twitter.stitch.Arrow
import com.twitter.stitch.Stitch
import com.twitter.stitch.Stitch.Letter
import com.twitter.util.Duration
import com.twitter.util.Return
import com.twitter.util.Throw
import com.twitter.util.Time
import com.twitter.util.Try</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Base trait that all executors implement</p></li>
<li></li>
<li><p>All executors should:</p></li>
<li><ul>
<li><p>implement a <cite>def arrow</cite> or <cite>def apply</cite> with the relevant types for their use case</p></li>
</ul>
</li>
<li><p>and take in an implicit [[PipelineFailureClassifier]] and [[ComponentIdentifierStack]].</p></li>
<li><ul>
<li><p>add a <cite>&#64;singleton</cite> annotation to the class and <cite>&#64;inject</cite> annotation to the argument list</p></li>
</ul>
</li>
<li><ul>
<li><p>take in a [[StatsReceiver]]</p></li>
</ul>
</li>
<li></li>
<li><p>&#64;example {{{</p></li>
<li><p>&#64;Singleton class MyExecutor &#64;Inject() (</p></li>
<li><p>override val statsReceiver: StatsReceiver</p></li>
<li><p>) extends Executor {</p></li>
<li><p>def arrow(</p></li>
<li><p>arg: MyArg,</p></li>
<li><p>…,</p></li>
<li><p>context: Context</p></li>
<li><p>): Arrow[In,Out] = ???</p></li>
<li><p>}</p></li>
<li><p>}}}</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>private[core] trait Executor {</dt><dd><p>val statsReceiver: StatsReceiver</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Applies the <cite>pipelineFailureClassifier</cite> to the output of the <cite>arrow</cite></p></li>
<li><p>and adds the <cite>componentStack</cite> to the [[PipelineFailure]]</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>def wrapWithErrorHandling[In, Out](</dt><dd><p>context: Context,
currentComponentIdentifier: ComponentIdentifier</p>
</dd>
<dt>)(</dt><dd><p>arrow: Arrow[In, Out]</p>
</dd>
<dt>): Arrow[In, Out] = {</dt><dd><dl class="simple">
<dt>arrow.mapFailure(</dt><dd><p>toPipelineFailureWithComponentIdentifierStack(context, currentComponentIdentifier))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Chain a <cite>Seq</cite> of [[Arrow.Iso]], only passing successful results to the next [[Arrow.Iso]]</p></li>
<li></li>
<li><p>&#64;note the resulting [[Arrow]] runs the passed in [[Arrow]]s one after the other,</p></li>
<li><p>as an ordered execution, this means that each [[Arrow]] is dependent</p></li>
<li><p>on all previous [[Arrow]]s in the <cite>Seq</cite> so no <cite>Stitch</cite> batching can occur</p></li>
<li><p>between them.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>def isoArrowsSequentially[T](arrows: Seq[Arrow.Iso[T]]): Arrow.Iso[T] = {</dt><dd><p>// avoid excess Arrow complexity when there is only a single Arrow
arrows match {</p>
<blockquote>
<div><p>case Seq() =&gt; Arrow.identity
case Seq(onlyOneArrow) =&gt; onlyOneArrow
case Seq(head, tail &#64; _*) =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>tail.foldLeft(head) {</dt><dd><p>case (combinedArrow, nextArrow) =&gt; combinedArrow.flatMapArrow(nextArrow)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Start running the [[Arrow]] in the background returning a [[Stitch.Ref]] which will complete</p></li>
<li><p>when the background task is finished</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>def startArrowAsync[In, Out](arrow: Arrow[In, Out]): Arrow[In, Stitch[Out]] = {</dt><dd><dl>
<dt>Arrow</dt><dd><dl class="simple">
<dt>.map { arg: In =&gt;</dt><dd><p>// wrap in a <cite>ref</cite> so we only compute it’s value once
Stitch.ref(arrow(arg))</p>
</dd>
</dl>
<p>}
.andThen(</p>
<blockquote>
<div><dl class="simple">
<dt>Arrow.zipWithArg(</dt><dd><p>// satisfy the <cite>ref</cite> async
Arrow.async(Arrow.flatMap[Stitch[Out], Out](identity))))</p>
</dd>
</dl>
</div></blockquote>
<p>.map { case (ref, _) =&gt; ref }</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>for [[com.twitter.product_mixer.core.model.common.Component]]s which</p></li>
<li><p>are executed per-candidate or which we don’t want to record stats for.</p></li>
<li><p>This performs Tracing but does not record Stats</p></li>
<li></li>
<li><p>&#64;note This should be used around the computation that includes the execution of the</p></li>
<li><p>underlying Component over all the Candidates, not around each execution</p></li>
<li><p>of the component around each candidate for per-candidate Components.</p></li>
<li></li>
<li><p>&#64;note when using this you should only use [[wrapPerCandidateComponentWithExecutorBookkeepingWithoutTracing]]</p></li>
<li><p>for handling Stats.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>def wrapComponentsWithTracingOnly[In, Out](</dt><dd><p>context: Context,
currentComponentIdentifier: ComponentIdentifier</p>
</dd>
<dt>)(</dt><dd><p>arrow: Arrow[In, Out]</p>
</dd>
<dt>): Arrow[In, Out] = {</dt><dd><dl>
<dt>Executor.wrapArrowWithLocalTracingSpan(</dt><dd><dl>
<dt>Arrow</dt><dd><p>.time(arrow)
.map {</p>
<blockquote>
<div><dl>
<dt>case (result, latency) =&gt;</dt><dd><dl class="simple">
<dt>Executor.recordTraceData(</dt><dd><p>componentStack = context.componentStack,
componentIdentifier = currentComponentIdentifier,
result = result,
latency = latency,
size = None)</p>
</dd>
</dl>
<p>result</p>
</dd>
</dl>
</div></blockquote>
<p>}.lowerFromTry)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>for [[com.twitter.product_mixer.core.model.common.Component]]s which</p></li>
<li><p>are executed per-candidate. Records Stats but does not do Tracing.</p></li>
<li></li>
<li><p>&#64;note when using this you should only use [[wrapPerCandidateComponentsWithTracingOnly]]</p></li>
<li><p>for handling Tracing</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>def wrapPerCandidateComponentWithExecutorBookkeepingWithoutTracing[In, Out](</dt><dd><p>context: Context,
currentComponentIdentifier: ComponentIdentifier</p>
</dd>
<dt>)(</dt><dd><p>arrow: Arrow[In, Out]</p>
</dd>
<dt>): Arrow[In, Out] = {</dt><dd><dl class="simple">
<dt>val observerSideEffect =</dt><dd><p>ExecutorObserver.executorObserver[Out](context, currentComponentIdentifier, statsReceiver)</p>
</dd>
<dt>Executor.wrapWithExecutorBookkeeping[In, Out, Out](</dt><dd><p>context = context,
currentComponentIdentifier = currentComponentIdentifier,
executorResultSideEffect = observerSideEffect,
transformer = Return(_),
tracingConfig = TracingConfig.NoTracing</p>
</dd>
</dl>
<p>)(arrow)</p>
</dd>
</dl>
<p>}</p>
<p>/** for [[com.twitter.product_mixer.core.model.common.Component]]s <a href="#id13"><span class="problematic" id="id14">*</span></a>/
def wrapComponentWithExecutorBookkeeping[In, Out](</p>
<blockquote>
<div><p>context: Context,
currentComponentIdentifier: ComponentIdentifier</p>
</div></blockquote>
<dl>
<dt>)(</dt><dd><p>arrow: Arrow[In, Out]</p>
</dd>
<dt>): Arrow[In, Out] = {</dt><dd><dl class="simple">
<dt>val observerSideEffect =</dt><dd><p>ExecutorObserver.executorObserver[Out](context, currentComponentIdentifier, statsReceiver)</p>
</dd>
<dt>Executor.wrapWithExecutorBookkeeping[In, Out, Out](</dt><dd><p>context = context,
currentComponentIdentifier = currentComponentIdentifier,
executorResultSideEffect = observerSideEffect,
transformer = Return(_)</p>
</dd>
</dl>
<p>)(arrow)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>for [[com.twitter.product_mixer.core.model.common.Component]]s which an <cite>onSuccess</cite></p></li>
<li><p>to add custom stats or logging of results</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>def wrapComponentWithExecutorBookkeeping[In, Out](</dt><dd><p>context: Context,
currentComponentIdentifier: ComponentIdentifier,
onSuccess: Out =&gt; Unit</p>
</dd>
<dt>)(</dt><dd><p>arrow: Arrow[In, Out]</p>
</dd>
<dt>): Arrow[In, Out] = {</dt><dd><dl class="simple">
<dt>val observerSideEffect =</dt><dd><p>ExecutorObserver.executorObserver[Out](context, currentComponentIdentifier, statsReceiver)</p>
</dd>
<dt>Executor.wrapWithExecutorBookkeeping[In, Out, Out](</dt><dd><p>context = context,
currentComponentIdentifier = currentComponentIdentifier,
executorResultSideEffect = observerSideEffect,
transformer = Return(_),
onComplete = (transformed: Try[Out]) =&gt; transformed.onSuccess(onSuccess)</p>
</dd>
</dl>
<p>)(arrow)</p>
</dd>
</dl>
<p>}</p>
<p>/** for [[com.twitter.product_mixer.core.pipeline.Pipeline]]s <a href="#id17"><span class="problematic" id="id18">*</span></a>/
def wrapPipelineWithExecutorBookkeeping[In, Out &lt;: PipelineResult[_]](</p>
<blockquote>
<div><p>context: Context,
currentComponentIdentifier: ComponentIdentifier,
qualityFactorObserver: Option[QualityFactorObserver],
failOpenPolicy: FailOpenPolicy = FailOpenPolicy.Never</p>
</div></blockquote>
<dl>
<dt>)(</dt><dd><p>arrow: Arrow[In, Out]</p>
</dd>
<dt>): Arrow[In, Out] = {</dt><dd><dl class="simple">
<dt>val observerSideEffect =</dt><dd><dl class="simple">
<dt>ExecutorObserver</dt><dd><p>.pipelineExecutorObserver[Out](context, currentComponentIdentifier, statsReceiver)</p>
</dd>
</dl>
</dd>
<dt>Executor.wrapWithExecutorBookkeeping[In, Out, Out](</dt><dd><p>context = context,
currentComponentIdentifier = currentComponentIdentifier,
executorResultSideEffect = observerSideEffect,
transformer = (result: Out) =&gt; result.toTry,
size = Some(_.resultSize()),
failOpenPolicy = failOpenPolicy,
qualityFactorObserver = qualityFactorObserver</p>
</dd>
</dl>
<p>)(arrow)</p>
</dd>
</dl>
<p>}</p>
<p>/** for [[com.twitter.product_mixer.core.pipeline.product.ProductPipeline]]s <a href="#id19"><span class="problematic" id="id20">*</span></a>/
def wrapProductPipelineWithExecutorBookkeeping[In, Out &lt;: PipelineResult[_]](</p>
<blockquote>
<div><p>context: Context,
currentComponentIdentifier: ProductPipelineIdentifier</p>
</div></blockquote>
<dl class="simple">
<dt>)(</dt><dd><p>arrow: Arrow[In, Out]</p>
</dd>
</dl>
<p>): Arrow[In, Out] = {</p>
<blockquote>
<div><dl>
<dt>val observerSideEffect =</dt><dd><dl class="simple">
<dt>ExecutorObserver</dt><dd><p>.productPipelineExecutorObserver[Out](currentComponentIdentifier, statsReceiver)</p>
</dd>
</dl>
</dd>
<dt>Executor.wrapWithExecutorBookkeeping[In, Out, Out](</dt><dd><p>context = context,
currentComponentIdentifier = currentComponentIdentifier,
executorResultSideEffect = observerSideEffect,
transformer = _.toTry,
size = Some(_.resultSize()),
failOpenPolicy =</p>
<blockquote>
<div><p>// always save Failures in the Result object instead of failing the request
AlwaysFailOpenIncludingProgrammerErrors</p>
</div></blockquote>
</dd>
</dl>
<p>)(arrow)</p>
</div></blockquote>
<p>}</p>
<p>/** for [[com.twitter.product_mixer.core.model.common.Component]]s which need a result size stat <a href="#id21"><span class="problematic" id="id22">*</span></a>/
def wrapComponentWithExecutorBookkeepingWithSize[In, Out](</p>
<blockquote>
<div><p>context: Context,
currentComponentIdentifier: CandidateSourceIdentifier,
size: Out =&gt; Int</p>
</div></blockquote>
<dl>
<dt>)(</dt><dd><p>arrow: Arrow[In, Out]</p>
</dd>
<dt>): Arrow[In, Out] = {</dt><dd><dl class="simple">
<dt>val observerSideEffect =</dt><dd><p>ExecutorObserver.executorObserverWithSize(context, currentComponentIdentifier, statsReceiver)</p>
</dd>
<dt>Executor.wrapWithExecutorBookkeeping[In, Out, Int](</dt><dd><p>context = context,
currentComponentIdentifier = currentComponentIdentifier,
executorResultSideEffect = observerSideEffect,
transformer = (out: Out) =&gt; Try(size(out)),
size = Some(identity)</p>
</dd>
</dl>
<p>)(arrow)</p>
</dd>
</dl>
<p>}</p>
<p>/** for [[com.twitter.product_mixer.core.pipeline.PipelineBuilder.Step]]s <a href="#id23"><span class="problematic" id="id24">*</span></a>/
def wrapStepWithExecutorBookkeeping[In, Out](</p>
<blockquote>
<div><p>context: Context,
identifier: PipelineStepIdentifier,
arrow: Arrow[In, Out],
transformer: Out =&gt; Try[Unit]</p>
</div></blockquote>
<dl>
<dt>): Arrow[In, Out] = {</dt><dd><dl class="simple">
<dt>val observerSideEffect =</dt><dd><p>ExecutorObserver.stepExecutorObserver(context, identifier, statsReceiver)</p>
</dd>
<dt>Executor.wrapWithExecutorBookkeeping[In, Out, Unit](</dt><dd><p>context = context,
currentComponentIdentifier = identifier,
executorResultSideEffect = observerSideEffect,
transformer = transformer,
failOpenPolicy = AlwaysFailOpenIncludingProgrammerErrors</p>
</dd>
</dl>
<p>)(arrow)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>private[core] object Executor {</p>
<blockquote>
<div><p>private[service] object TracingConfig {</p>
<blockquote>
<div><p>/** Used to specify whether a wrapped Arrow should be Traced in [[wrapWithExecutorBookkeeping]] <a href="#id25"><span class="problematic" id="id26">*</span></a>/
sealed trait TracingConfig
case object NoTracing extends TracingConfig
case object WrapWithSpanAndTracingData extends TracingConfig</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Always fail-open and return the [[com.twitter.product_mixer.core.pipeline.product.ProductPipelineResult]]</p></li>
<li><p>containing the exception, this differs from [[FailOpenPolicy.Always]] in that this will still</p></li>
<li><p>fail-open and return the overall result object even if the underlying failure is the result</p></li>
<li><p>of programmer error.</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
</dl>
<p>private val AlwaysFailOpenIncludingProgrammerErrors: FailOpenPolicy = _ =&gt; true</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Wraps an [[Arrow]] so that bookkeeping around the execution occurs uniformly.</p></li>
<li></li>
<li><p>&#64;note should __never__ be called directly!</p></li>
<li></li>
<li><ul>
<li><p>For successful results, apply the <cite>transformer</cite></p></li>
</ul>
</li>
<li><ul>
<li><p>convert any exceptions to PipelineFailures</p></li>
</ul>
</li>
<li><ul>
<li><p>record stats and update [[QualityFactorObserver]]</p></li>
</ul>
</li>
<li><ul>
<li><p>wraps the execution in a Trace span and record Trace data (can be turned off by [[TracingConfig]])</p></li>
</ul>
</li>
<li><ul>
<li><p>applies a trace span and records metadata to the provided <cite>arrow</cite></p></li>
</ul>
</li>
<li><ul>
<li><p>determine whether to fail-open based on <cite>result.flatMap(transformer)</cite></p></li>
</ul>
</li>
<li><ul>
<li><p>if failing-open, always return the original result</p></li>
</ul>
</li>
<li><ul>
<li><p>if failing-closed and successful, return the original result</p></li>
</ul>
</li>
<li><ul>
<li><p>otherwise, return the failure (from <cite>result.flatMap(transformer)</cite>)</p></li>
</ul>
</li>
<li></li>
<li><p>&#64;param context                    the [[Executor.Context]]</p></li>
<li><p>&#64;param currentComponentIdentifier the current component’s [[ComponentIdentifier]]</p></li>
<li><p>&#64;param executorResultSideEffect   the [[ExecutorObserver]] used to record stats</p></li>
<li><p>&#64;param transformer                function to convert a successful result into possibly a failed result</p></li>
<li><p>&#64;param failOpenPolicy             [[FailOpenPolicy]] to apply to the results of <cite>result.flatMap(transformer)</cite></p></li>
<li><p>&#64;param qualityFactorObserver      [[QualityFactorObserver]] to update based on the results of <cite>result.flatMap(transformer)</cite></p></li>
<li><p>&#64;param tracingConfig              indicates whether the [[Arrow]] should be wrapped with Tracing</p></li>
<li><p>&#64;param onComplete                 runs the function for its side effects with the result of <cite>result.flatMap(transformer)</cite></p></li>
<li><p>&#64;param arrow                      an input [[Arrow]] to wrap so that after it’s execution, we perform all these operations</p></li>
<li></li>
<li><p>&#64;return the wrapped [[Arrow]]</p></li>
</ul>
<p><a href="#id29"><span class="problematic" id="id30">*</span></a>/</p>
</dd>
<dt>private[service] def wrapWithExecutorBookkeeping[In, Out, Transformed](</dt><dd><p>context: Context,
currentComponentIdentifier: ComponentIdentifier,
executorResultSideEffect: ExecutorObserver[Transformed],
transformer: Out =&gt; Try[Transformed],
size: Option[Transformed =&gt; Int] = None,
failOpenPolicy: FailOpenPolicy = FailOpenPolicy.Never,
qualityFactorObserver: Option[QualityFactorObserver] = None,
tracingConfig: TracingConfig.TracingConfig = TracingConfig.WrapWithSpanAndTracingData,
onComplete: Try[Transformed] =&gt; Unit = { _: Try[Transformed] =&gt; () }</p>
</dd>
<dt>)(</dt><dd><p>arrow: Arrow[In, Out]</p>
</dd>
</dl>
<p>): Arrow[In, Out] = {</p>
<blockquote>
<div><dl class="simple">
<dt>val failureClassifier =</dt><dd><p>toPipelineFailureWithComponentIdentifierStack(context, currentComponentIdentifier)</p>
</dd>
</dl>
<p>/** transform the results, mapping all exceptions to [[PipelineFailure]]s, and tuple with original result <a href="#id31"><span class="problematic" id="id32">*</span></a>/
val transformResultAndClassifyFailures: Arrow[Out, (Out, Try[Transformed])] =</p>
<blockquote>
<div><dl>
<dt>Arrow.join(</dt><dd><p>Arrow.mapFailure(failureClassifier),
Arrow</p>
<blockquote>
<div><dl class="simple">
<dt>.transformTry[Out, Transformed](result =&gt;</dt><dd><dl class="simple">
<dt>result</dt><dd><p>.flatMap(transformer)
.rescue { case t =&gt; Throw(failureClassifier(t)) })</p>
</dd>
</dl>
</dd>
</dl>
<p>.liftToTry</p>
</div></blockquote>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>/** Only record tracing data if [[TracingConfig.WrapWithSpanAndTracingData]] <a href="#id33"><span class="problematic" id="id34">*</span></a>/
val maybeRecordTracingData: (Try[Transformed], Duration) =&gt; Unit = tracingConfig match {</p>
<blockquote>
<div><p>case TracingConfig.NoTracing =&gt; (_, _) =&gt; ()
case TracingConfig.WrapWithSpanAndTracingData =&gt;</p>
<blockquote>
<div><dl>
<dt>(transformedAndClassifiedResult, latency) =&gt;</dt><dd><dl class="simple">
<dt>recordTraceData(</dt><dd><p>context.componentStack,
currentComponentIdentifier,
transformedAndClassifiedResult,
latency,
transformedAndClassifiedResult.toOption.flatMap(result =&gt; size.map(_.apply(result)))</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>}</p>
<p>/** Will never be in a failed state so we can do a simple [[Arrow.map]] <a href="#id35"><span class="problematic" id="id36">*</span></a>/
val recordStatsAndUpdateQualityFactor =</p>
<blockquote>
<div><dl>
<dt>Arrow</dt><dd><dl>
<dt>.map[(Try[(Out, Try[Transformed])], Duration), Unit] {</dt><dd><dl>
<dt>case (tryResultAndTryTransformed, latency) =&gt;</dt><dd><dl class="simple">
<dt>val transformedAndClassifiedResult = tryResultAndTryTransformed.flatMap {</dt><dd><p>case (_, transformed) =&gt; transformed</p>
</dd>
</dl>
<p>}
executorResultSideEffect(transformedAndClassifiedResult, latency)
qualityFactorObserver.foreach(_.apply(transformedAndClassifiedResult, latency))
onComplete(transformedAndClassifiedResult)
maybeRecordTracingData(transformedAndClassifiedResult, latency)</p>
</dd>
</dl>
</dd>
</dl>
<p>}.unit</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Applies the provided [[FailOpenPolicy]] based on the [[transformer]]’s results,</p></li>
<li><p>returning the original result or an exception</p></li>
</ul>
<p><a href="#id37"><span class="problematic" id="id38">*</span></a>/</p>
</dd>
<dt>val applyFailOpenPolicyBasedOnTransformedResult: Arrow[</dt><dd><p>(Try[(Out, Try[Transformed])], Duration),
Out</p>
</dd>
<dt>] =</dt><dd><dl>
<dt>Arrow</dt><dd><dl class="simple">
<dt>.map[(Try[(Out, Try[Transformed])], Duration), Try[(Out, Try[Transformed])]] {</dt><dd><p>case (tryResultAndTryTransformed, _) =&gt; tryResultAndTryTransformed</p>
</dd>
</dl>
<p>}
.lowerFromTry
.map {</p>
<blockquote>
<div><dl>
<dt>case (result, Throw(pipelineFailure: PipelineFailure))</dt><dd><blockquote>
<div><p>if failOpenPolicy(pipelineFailure.category) =&gt;</p>
</div></blockquote>
<p>Return(result)</p>
</dd>
</dl>
<p>case (_, t: Throw[_]) =&gt; t.asInstanceOf[Throw[Out]]
case (result, _) =&gt; Return(result)</p>
</div></blockquote>
<p>}.lowerFromTry</p>
</dd>
</dl>
</dd>
</dl>
<p>/** The complete Arrow minus a Local span wrapping <a href="#id39"><span class="problematic" id="id40">*</span></a>/
val arrowWithTimingExecutorSideEffects = Arrow</p>
<blockquote>
<div><p>.time(arrow.andThen(transformResultAndClassifyFailures))
.applyEffect(recordStatsAndUpdateQualityFactor)
.andThen(applyFailOpenPolicyBasedOnTransformedResult)</p>
</div></blockquote>
<p>/** Dont wrap with a span if we are not tracing <a href="#id41"><span class="problematic" id="id42">*</span></a>/
tracingConfig match {</p>
<blockquote>
<div><dl class="simple">
<dt>case TracingConfig.WrapWithSpanAndTracingData =&gt;</dt><dd><p>wrapArrowWithLocalTracingSpan(arrowWithTimingExecutorSideEffects)</p>
</dd>
<dt>case TracingConfig.NoTracing =&gt;</dt><dd><p>arrowWithTimingExecutorSideEffects</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>/** Let-scopes a [[TraceId]] around a computation <a href="#id43"><span class="problematic" id="id44">*</span></a>/
private[this] object TracingLetter extends Letter[TraceId] {</p>
<blockquote>
<div><p>override def let[S](traceId: TraceId)(s: =&gt; S): S = Trace.letId(traceId)(s)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Wraps the Arrow’s execution in a new trace span as a child of the current parent span</p></li>
<li></li>
<li><p>&#64;note Should __never__ be called directly!</p></li>
<li></li>
<li><p>It’s expected that the contained <cite>arrow</cite> will invoke [[recordTraceData]] exactly ONCE</p></li>
<li><p>during it’s execution.</p></li>
<li></li>
<li><p>&#64;note this does not record any data about the trace, it only sets the [[Trace]] Span</p></li>
<li><p>for the execution of <cite>arrow</cite></p></li>
</ul>
<p><a href="#id45"><span class="problematic" id="id46">*</span></a>/</p>
</dd>
<dt>private[service] def wrapArrowWithLocalTracingSpan[In, Out](</dt><dd><p>arrow: Arrow[In, Out]</p>
</dd>
<dt>): Arrow[In, Out] =</dt><dd><dl class="simple">
<dt>Arrow.ifelse(</dt><dd><p>_ =&gt; Trace.isActivelyTracing,
Arrow.let(TracingLetter)(Trace.nextId)(arrow),
arrow</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>private[this] object Tracing {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Duplicate of [[com.twitter.finagle.tracing.Tracing]]’s <cite>localSpans</cite> which</p></li>
<li><p>uses an un-scoped [[StatsReceiver]]</p></li>
<li></li>
<li><p>Since we needed to roll-our-own latency measurement we are unable to increment the</p></li>
<li><p><cite>local_spans</cite> metric automatically, this is important in the event a service is</p></li>
<li><p>unexpectedly not recording spans or unexpectedly recording too many, so we manually</p></li>
<li><p>increment it</p></li>
</ul>
<p><a href="#id47"><span class="problematic" id="id48">*</span></a>/</p>
</dd>
</dl>
<p>val localSpans: Counter = DefaultStatsReceiver.counter(“tracing”, “local_spans”)</p>
<p>/** Local Component field of a span in the UI <a href="#id49"><span class="problematic" id="id50">*</span></a>/
val localComponentTag = “lc”
val sizeTag = “product_mixer.result.size”
val successTag = “product_mixer.result.success”
val successValue = “success”
val cancelledTag = “product_mixer.result.cancelled”
val failureTag = “product_mixer.result.failure”</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Records metadata onto the current [[Trace]] Span</p></li>
<li></li>
<li><p>&#64;note Should __never__ be called directly!</p></li>
<li></li>
<li><p>This should be called exactly ONCE in the Arrow passed into [[wrapArrowWithLocalTracingSpan]]</p></li>
<li><p>to record data for the Span.</p></li>
</ul>
<p><a href="#id51"><span class="problematic" id="id52">*</span></a>/</p>
</dd>
<dt>private[service] def recordTraceData[T](</dt><dd><p>componentStack: ComponentIdentifierStack,
componentIdentifier: ComponentIdentifier,
result: Try[T],
latency: Duration,
size: Option[Int] = None</p>
</dd>
<dt>): Unit = {</dt><dd><dl>
<dt>if (Trace.isActivelyTracing) {</dt><dd><p>Tracing.localSpans.incr()
val traceId = Trace.id
val endTime = Time.nowNanoPrecision</p>
<p>// These annotations are needed for the Zipkin UI to display the span properly
TraceServiceName().foreach(Trace.recordServiceName)
Trace.recordRpc(componentIdentifier.snakeCase) // name of the span in the UI
Trace.recordBinary(</p>
<blockquote>
<div><p>Tracing.localComponentTag,
componentStack.peek.toString + “/” + componentIdentifier.toString)</p>
</div></blockquote>
<p>Trace.record(Record(traceId, endTime - latency, Annotation.Message(LocalBeginAnnotation)))
Trace.record(Record(traceId, endTime, Annotation.Message(LocalEndAnnotation)))</p>
<p>// product mixer specific zipkin data
size.foreach(size =&gt; Trace.recordBinary(Tracing.sizeTag, size))
result match {</p>
<blockquote>
<div><dl class="simple">
<dt>case Return(_) =&gt;</dt><dd><p>Trace.recordBinary(Tracing.successTag, Tracing.successValue)</p>
</dd>
<dt>case Throw(CancelledExceptionExtractor(e)) =&gt;</dt><dd><p>Trace.recordBinary(Tracing.cancelledTag, e)</p>
</dd>
<dt>case Throw(e) =&gt;</dt><dd><p>Trace.recordBinary(Tracing.failureTag, e)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns a tuple of the stats scopes for the current component and the relative scope for</p></li>
<li><p>the parent component and the current component together</p></li>
<li></li>
<li><p>This is useful when recording stats for a component by itself as well as stats for calls to that component from it’s parent.</p></li>
<li></li>
<li><p>&#64;example if the current component has a scope of “currentComponent” and the parent component has a scope of “parentComponent”</p></li>
<li><p>then this will return <cite>(Seq(“currentComponent”), Seq(“parentComponent”, “currentComponent”))</cite></p></li>
</ul>
<p><a href="#id53"><span class="problematic" id="id54">*</span></a>/</p>
</dd>
<dt>def buildScopes(</dt><dd><p>context: Context,
currentComponentIdentifier: ComponentIdentifier</p>
</dd>
<dt>): Executor.Scopes = {</dt><dd><p>val parentScopes = context.componentStack.peek.toScopes
val componentScopes = currentComponentIdentifier.toScopes
val relativeScopes = parentScopes ++ componentScopes
Executor.Scopes(componentScopes, relativeScopes)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Makes a [[BroadcastStatsReceiver]] that will broadcast stats to the correct</p></li>
<li><p>current component’s scope and to the scope relative to the parent.</p></li>
</ul>
<p><a href="#id55"><span class="problematic" id="id56">*</span></a>/</p>
</dd>
<dt>def broadcastStatsReceiver(</dt><dd><p>context: Context,
currentComponentIdentifier: ComponentIdentifier,
statsReceiver: StatsReceiver</p>
</dd>
<dt>): StatsReceiver = {</dt><dd><dl class="simple">
<dt>val Executor.Scopes(componentScopes, relativeScopes) =</dt><dd><p>Executor.buildScopes(context, currentComponentIdentifier)</p>
</dd>
<dt>BroadcastStatsReceiver(</dt><dd><p>Seq(statsReceiver.scope(relativeScopes: _*), statsReceiver.scope(componentScopes: _*)))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns a feature map containing all the [[com.twitter.product_mixer.core.feature.Feature]]s</p></li>
<li><p>stored as failures using the exception provided with as the reason wrapped in a PipelineFailure.</p></li>
<li><p>e.g, for features A &amp; B that threw an ExampleException b, this will return:</p></li>
<li><p>{ A -&gt; Throw(PipelineFailure(…)), B -&gt; Throw(PipelineFailure(…)) }</p></li>
</ul>
<p><a href="#id57"><span class="problematic" id="id58">*</span></a>/</p>
</dd>
<dt>def featureMapWithFailuresForFeatures(</dt><dd><p>features: Set[Feature[_, _]],
error: Throwable,
context: Executor.Context</p>
</dd>
<dt>): FeatureMap = {</dt><dd><p>val builder = FeatureMapBuilder()
features.foreach { feature =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>val pipelineFailure = PipelineFailure(</dt><dd><p>FeatureHydrationFailed,
s”Feature hydration failed for ${feature.toString}”,
Some(error),
Some(context.componentStack))</p>
</dd>
</dl>
<p>builder.addFailure(feature, pipelineFailure)</p>
</div></blockquote>
<p>}
builder.build()</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Validates and returns back the passed feature map if it passes validation. A feature map</p></li>
<li><p>is considered valid if it contains only the passed <cite>registeredFeatures</cite> features in it,</p></li>
<li><p>nothing else and nothing missing.</p></li>
</ul>
<p><a href="#id59"><span class="problematic" id="id60">*</span></a>/</p>
</dd>
</dl>
<p>&#64;throws(classOf[PipelineFailure])
def validateFeatureMap(</p>
<blockquote>
<div><p>registeredFeatures: Set[Feature[_, _]],
featureMap: FeatureMap,
context: Executor.Context</p>
</div></blockquote>
<dl>
<dt>): FeatureMap = {</dt><dd><p>val hydratedFeatures = featureMap.getFeatures
if (hydratedFeatures == registeredFeatures) {</p>
<blockquote>
<div><p>featureMap</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>val missingFeatures = registeredFeatures – hydratedFeatures
val unregisteredFeatures = hydratedFeatures – registeredFeatures
throw PipelineFailure(</p>
<blockquote>
<div><p>MisconfiguredFeatureMapFailure,
s”Unregistered features $unregisteredFeatures and missing features $missingFeatures”,
None,
Some(context.componentStack)</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>object NotAMisconfiguredFeatureMapFailure {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Will return any exception that isn’t a [[MisconfiguredFeatureMapFailure]] [[PipelineFailure]]</p></li>
<li><p>Allows for easy [[Arrow.handle]]ing all exceptions that aren’t [[MisconfiguredFeatureMapFailure]]s</p></li>
</ul>
<p><a href="#id61"><span class="problematic" id="id62">*</span></a>/</p>
</dd>
<dt>def unapply(e: Throwable): Option[Throwable] = e match {</dt><dd><dl>
<dt>case pipelineFailure: PipelineFailure</dt><dd><blockquote>
<div><p>if pipelineFailure.category == MisconfiguredFeatureMapFailure =&gt;</p>
</div></blockquote>
<p>None</p>
</dd>
</dl>
<p>case e =&gt; Some(e)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>contains the scopes for recording metrics for the component by itself and</p></li>
<li><p>the relative scope of that component within it’s parent component scope</p></li>
<li></li>
<li><p>&#64;see [[Executor.buildScopes]]</p></li>
</ul>
<p><a href="#id63"><span class="problematic" id="id64">*</span></a>/</p>
</dd>
</dl>
<p>case class Scopes(componentScopes: Seq[String], relativeScope: Seq[String])</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Wrap the [[Throwable]] in a [[UncategorizedServerFailure]] [[PipelineFailure]] with the original</p></li>
<li><p>[[Throwable]] as the cause, even if it’s already a [[PipelineFailure]].</p></li>
<li></li>
<li><p>This ensures that any access to the stored feature will result in a meaningful [[UncategorizedServerFailure]]</p></li>
<li><p>[[com.twitter.product_mixer.core.pipeline.pipeline_failure.PipelineFailureCategory]] in stats which is more useful</p></li>
<li><p>for customers components which access a failed [[Feature]] than the original [[com.twitter.product_mixer.core.pipeline.pipeline_failure.PipelineFailureCategory]].</p></li>
</ul>
<p><a href="#id65"><span class="problematic" id="id66">*</span></a>/</p>
</dd>
<dt>def uncategorizedServerFailure(</dt><dd><p>componentStack: ComponentIdentifierStack,
throwable: Throwable</p>
</dd>
<dt>): PipelineFailure = {</dt><dd><dl class="simple">
<dt>PipelineFailure(</dt><dd><p>UncategorizedServerFailure,
reason = “Unclassified Failure in Pipeline”,
Some(throwable),
Some(componentStack)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>[[PartialFunction]] that converts any [[Throwable]] into a</p></li>
<li><p>[[PipelineFailure]] based on the provided <cite>failureClassifier</cite></p></li>
</ul>
<p><a href="#id67"><span class="problematic" id="id68">*</span></a>/</p>
</dd>
<dt>def toPipelineFailureWithComponentIdentifierStack(</dt><dd><p>context: Context,
currentComponentIdentifier: ComponentIdentifier</p>
</dd>
<dt>): PipelineFailureClassifier = {</dt><dd><p>// if given a <cite>currentComponentIdentifier</cite> then ensure we correctly handle <cite>BasedOnParentComponent</cite> identifier types
val contextWithCurrentComponentIdentifier =</p>
<blockquote>
<div><p>context.pushToComponentStack(currentComponentIdentifier)</p>
</div></blockquote>
<dl>
<dt>PipelineFailureClassifier(</dt><dd><dl>
<dt>contextWithCurrentComponentIdentifier.pipelineFailureClassifier</dt><dd><dl>
<dt>.orElse[Throwable, PipelineFailure] {</dt><dd><p>case CancelledExceptionExtractor(throwable) =&gt; throw throwable
case pipelineFailure: PipelineFailure =&gt; pipelineFailure
case throwable =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>uncategorizedServerFailure(</dt><dd><p>contextWithCurrentComponentIdentifier.componentStack,
throwable)</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>}.andThen { pipelineFailure =&gt;</dt><dd><dl>
<dt>pipelineFailure.componentStack match {</dt><dd><p>case _: Some[_] =&gt; pipelineFailure
case None =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>pipelineFailure.copy(componentStack =</dt><dd><p>Some(contextWithCurrentComponentIdentifier.componentStack))</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>information used by an [[Executor]] that provides context around execution</p></li>
</ul>
<p><a href="#id69"><span class="problematic" id="id70">*</span></a>/</p>
</dd>
<dt>case class Context(</dt><dd><p>pipelineFailureClassifier: PipelineFailureClassifier,
componentStack: ComponentIdentifierStack) {</p>
<dl class="simple">
<dt>def pushToComponentStack(newComponentIdentifier: ComponentIdentifier): Context =</dt><dd><p>copy(componentStack = componentStack.push(newComponentIdentifier))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../../_sources/product-mixer/core/src/main/scala/com/twitter/product_mixer/core/service/Executor.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>