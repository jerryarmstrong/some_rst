<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.cr_mixer.controller</p>
<p>import com.twitter.core_workflows.user_model.thriftscala.UserState
import com.twitter.cr_mixer.candidate_generation.AdsCandidateGenerator
import com.twitter.cr_mixer.candidate_generation.CrCandidateGenerator
import com.twitter.cr_mixer.candidate_generation.FrsTweetCandidateGenerator
import com.twitter.cr_mixer.candidate_generation.RelatedTweetCandidateGenerator
import com.twitter.cr_mixer.candidate_generation.RelatedVideoTweetCandidateGenerator
import com.twitter.cr_mixer.candidate_generation.TopicTweetCandidateGenerator
import com.twitter.cr_mixer.candidate_generation.UtegTweetCandidateGenerator
import com.twitter.cr_mixer.featureswitch.ParamsBuilder
import com.twitter.cr_mixer.logging.CrMixerScribeLogger
import com.twitter.cr_mixer.logging.RelatedTweetScribeLogger
import com.twitter.cr_mixer.logging.AdsRecommendationsScribeLogger
import com.twitter.cr_mixer.logging.RelatedTweetScribeMetadata
import com.twitter.cr_mixer.logging.ScribeMetadata
import com.twitter.cr_mixer.logging.UtegTweetScribeLogger
import com.twitter.cr_mixer.model.AdsCandidateGeneratorQuery
import com.twitter.cr_mixer.model.CrCandidateGeneratorQuery
import com.twitter.cr_mixer.model.FrsTweetCandidateGeneratorQuery
import com.twitter.cr_mixer.model.InitialCandidate
import com.twitter.cr_mixer.model.RankedAdsCandidate
import com.twitter.cr_mixer.model.RankedCandidate
import com.twitter.cr_mixer.model.RelatedTweetCandidateGeneratorQuery
import com.twitter.cr_mixer.model.RelatedVideoTweetCandidateGeneratorQuery
import com.twitter.cr_mixer.model.TopicTweetCandidateGeneratorQuery
import com.twitter.cr_mixer.model.TweetWithScoreAndSocialProof
import com.twitter.cr_mixer.model.UtegTweetCandidateGeneratorQuery
import com.twitter.cr_mixer.param.AdsParams
import com.twitter.cr_mixer.param.FrsParams.FrsBasedCandidateGenerationMaxCandidatesNumParam
import com.twitter.cr_mixer.param.GlobalParams
import com.twitter.cr_mixer.param.RelatedTweetGlobalParams
import com.twitter.cr_mixer.param.RelatedVideoTweetGlobalParams
import com.twitter.cr_mixer.param.TopicTweetParams
import com.twitter.cr_mixer.param.decider.CrMixerDecider
import com.twitter.cr_mixer.param.decider.DeciderConstants
import com.twitter.cr_mixer.param.decider.EndpointLoadShedder
import com.twitter.cr_mixer.thriftscala.AdTweetRecommendation
import com.twitter.cr_mixer.thriftscala.AdsRequest
import com.twitter.cr_mixer.thriftscala.AdsResponse
import com.twitter.cr_mixer.thriftscala.CrMixerTweetRequest
import com.twitter.cr_mixer.thriftscala.CrMixerTweetResponse
import com.twitter.cr_mixer.thriftscala.FrsTweetRequest
import com.twitter.cr_mixer.thriftscala.FrsTweetResponse
import com.twitter.cr_mixer.thriftscala.RelatedTweet
import com.twitter.cr_mixer.thriftscala.RelatedTweetRequest
import com.twitter.cr_mixer.thriftscala.RelatedTweetResponse
import com.twitter.cr_mixer.thriftscala.RelatedVideoTweet
import com.twitter.cr_mixer.thriftscala.RelatedVideoTweetRequest
import com.twitter.cr_mixer.thriftscala.RelatedVideoTweetResponse
import com.twitter.cr_mixer.thriftscala.TopicTweet
import com.twitter.cr_mixer.thriftscala.TopicTweetRequest
import com.twitter.cr_mixer.thriftscala.TopicTweetResponse
import com.twitter.cr_mixer.thriftscala.TweetRecommendation
import com.twitter.cr_mixer.thriftscala.UtegTweet
import com.twitter.cr_mixer.thriftscala.UtegTweetRequest
import com.twitter.cr_mixer.thriftscala.UtegTweetResponse
import com.twitter.cr_mixer.util.MetricTagUtil
import com.twitter.cr_mixer.util.SignalTimestampStatsUtil
import com.twitter.cr_mixer.{thriftscala =&gt; t}
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.finatra.thrift.Controller
import com.twitter.hermit.store.common.ReadableWritableStore
import com.twitter.simclusters_v2.common.UserId
import com.twitter.simclusters_v2.thriftscala.TopicId
import com.twitter.storehaus.ReadableStore
import com.twitter.timelines.timeline_logging.{thriftscala =&gt; thriftlog}
import com.twitter.timelines.tracing.lensview.funnelseries.TweetScoreFunnelSeries
import com.twitter.util.Future
import com.twitter.util.Time
import java.util.UUID
import javax.inject.Inject
import org.apache.commons.lang.exception.ExceptionUtils</p>
<dl>
<dt>class CrMixerThriftController &#64;Inject() (</dt><dd><p>crCandidateGenerator: CrCandidateGenerator,
relatedTweetCandidateGenerator: RelatedTweetCandidateGenerator,
relatedVideoTweetCandidateGenerator: RelatedVideoTweetCandidateGenerator,
utegTweetCandidateGenerator: UtegTweetCandidateGenerator,
frsTweetCandidateGenerator: FrsTweetCandidateGenerator,
topicTweetCandidateGenerator: TopicTweetCandidateGenerator,
crMixerScribeLogger: CrMixerScribeLogger,
relatedTweetScribeLogger: RelatedTweetScribeLogger,
utegTweetScribeLogger: UtegTweetScribeLogger,
adsRecommendationsScribeLogger: AdsRecommendationsScribeLogger,
adsCandidateGenerator: AdsCandidateGenerator,
decider: CrMixerDecider,
paramsBuilder: ParamsBuilder,
endpointLoadShedder: EndpointLoadShedder,
signalTimestampStatsUtil: SignalTimestampStatsUtil,
tweetRecommendationResultsStore: ReadableWritableStore[UserId, CrMixerTweetResponse],
userStateStore: ReadableStore[UserId, UserState],
statsReceiver: StatsReceiver)</p>
<blockquote>
<div><p>extends Controller(t.CrMixer) {</p>
</div></blockquote>
<p>lazy private val tweetScoreFunnelSeries = new TweetScoreFunnelSeries(statsReceiver)</p>
<dl>
<dt>private def logErrMessage(endpoint: String, e: Throwable): Unit = {</dt><dd><dl class="simple">
<dt>val msg = Seq(</dt><dd><p>s”Failed endpoint $endpoint: ${e.getLocalizedMessage}”,
ExceptionUtils.getStackTrace(e)</p>
</dd>
</dl>
<p>).mkString(”n”)</p>
<dl>
<dt>/** *</dt><dd><ul class="simple">
<li><p>We chose logger.info() here to print message instead of logger.error since that</p></li>
<li><p>logger.error sometimes suppresses detailed stacktrace.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
</dl>
<p>logger.info(msg)</p>
</dd>
</dl>
<p>}</p>
<p>private def generateRequestUUID(): Long = {</p>
<blockquote>
<div><dl>
<dt>/** *</dt><dd><ul class="simple">
<li><p>We generate unique UUID via bitwise operations. See the below link for more:</p></li>
<li><p><a class="reference external" href="https://stackoverflow.com/questions/15184820/how-to-generate-unique-positive-long-using-uuid">https://stackoverflow.com/questions/15184820/how-to-generate-unique-positive-long-using-uuid</a></p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
</dl>
<p>UUID.randomUUID().getMostSignificantBits &amp; Long.MaxValue</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>handle(t.CrMixer.GetTweetRecommendations) { args: t.CrMixer.GetTweetRecommendations.Args =&gt;</dt><dd><p>val endpointName = “getTweetRecommendations”</p>
<p>val requestUUID = generateRequestUUID()
val startTime = Time.now.inMilliseconds
val userId = args.request.clientContext.userId.getOrElse(</p>
<blockquote>
<div><p>throw new IllegalArgumentException(“userId must be present in the Thrift clientContext”)</p>
</div></blockquote>
<p>)
val queryFut = buildCrCandidateGeneratorQuery(args.request, requestUUID, userId)
queryFut.flatMap { query =&gt;</p>
<blockquote>
<div><p>val scribeMetadata = ScribeMetadata.from(query)
endpointLoadShedder(endpointName, query.product.originalName) {</p>
<blockquote>
<div><p>val response = crCandidateGenerator.get(query)</p>
<dl>
<dt>val blueVerifiedScribedResponse = response.flatMap { rankedCandidates =&gt;</dt><dd><dl class="simple">
<dt>val hasBlueVerifiedCandidate = rankedCandidates.exists { tweet =&gt;</dt><dd><p>tweet.tweetInfo.hasBlueVerifiedAnnotation.contains(true)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (hasBlueVerifiedCandidate) {</dt><dd><dl class="simple">
<dt>crMixerScribeLogger.scribeGetTweetRecommendationsForBlueVerified(</dt><dd><p>scribeMetadata,
response)</p>
</dd>
</dl>
</dd>
<dt>} else {</dt><dd><p>response</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val thriftResponse = blueVerifiedScribedResponse.map { candidates =&gt;</dt><dd><dl class="simple">
<dt>if (query.product == t.Product.Home) {</dt><dd><p>scribeTweetScoreFunnelSeries(candidates)</p>
</dd>
</dl>
<p>}
buildThriftResponse(candidates)</p>
</dd>
</dl>
<p>}</p>
<p>cacheTweetRecommendationResults(args.request, thriftResponse)</p>
<dl class="simple">
<dt>crMixerScribeLogger.scribeGetTweetRecommendations(</dt><dd><p>args.request,
startTime,
scribeMetadata,
thriftResponse)</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>}.rescue {</dt><dd><dl class="simple">
<dt>case EndpointLoadShedder.LoadSheddingException =&gt;</dt><dd><p>Future(CrMixerTweetResponse(Seq.empty))</p>
</dd>
<dt>case e =&gt;</dt><dd><p>logErrMessage(endpointName, e)
Future(CrMixerTweetResponse(Seq.empty))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/** *</dt><dd><ul class="simple">
<li><p>GetRelatedTweetsForQueryTweet and GetRelatedTweetsForQueryAuthor are essentially</p></li>
<li><p>doing very similar things, except that one passes in TweetId which calls TweetBased engine,</p></li>
<li><p>and the other passes in AuthorId which calls ProducerBased engine.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>handle(t.CrMixer.GetRelatedTweetsForQueryTweet) {</dt><dd><dl class="simple">
<dt>args: t.CrMixer.GetRelatedTweetsForQueryTweet.Args =&gt;</dt><dd><p>val endpointName = “getRelatedTweetsForQueryTweet”
getRelatedTweets(endpointName, args.request)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>handle(t.CrMixer.GetRelatedVideoTweetsForQueryTweet) {</dt><dd><dl class="simple">
<dt>args: t.CrMixer.GetRelatedVideoTweetsForQueryTweet.Args =&gt;</dt><dd><p>val endpointName = “getRelatedVideoTweetsForQueryVideoTweet”
getRelatedVideoTweets(endpointName, args.request)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>handle(t.CrMixer.GetRelatedTweetsForQueryAuthor) {</dt><dd><dl class="simple">
<dt>args: t.CrMixer.GetRelatedTweetsForQueryAuthor.Args =&gt;</dt><dd><p>val endpointName = “getRelatedTweetsForQueryAuthor”
getRelatedTweets(endpointName, args.request)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getRelatedTweets(</dt><dd><p>endpointName: String,
request: RelatedTweetRequest</p>
</dd>
<dt>): Future[RelatedTweetResponse] = {</dt><dd><p>val requestUUID = generateRequestUUID()
val startTime = Time.now.inMilliseconds
val queryFut = buildRelatedTweetQuery(request, requestUUID)</p>
<dl>
<dt>queryFut.flatMap { query =&gt;</dt><dd><p>val relatedTweetScribeMetadata = RelatedTweetScribeMetadata.from(query)
endpointLoadShedder(endpointName, query.product.originalName) {</p>
<blockquote>
<div><dl>
<dt>relatedTweetScribeLogger.scribeGetRelatedTweets(</dt><dd><p>request,
startTime,
relatedTweetScribeMetadata,
relatedTweetCandidateGenerator</p>
<blockquote>
<div><p>.get(query)
.map(buildRelatedTweetResponse))</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>}.rescue {</dt><dd><dl class="simple">
<dt>case EndpointLoadShedder.LoadSheddingException =&gt;</dt><dd><p>Future(RelatedTweetResponse(Seq.empty))</p>
</dd>
<dt>case e =&gt;</dt><dd><p>logErrMessage(endpointName, e)
Future(RelatedTweetResponse(Seq.empty))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getRelatedVideoTweets(</dt><dd><p>endpointName: String,
request: RelatedVideoTweetRequest</p>
</dd>
<dt>): Future[RelatedVideoTweetResponse] = {</dt><dd><p>val requestUUID = generateRequestUUID()
val queryFut = buildRelatedVideoTweetQuery(request, requestUUID)</p>
<dl>
<dt>queryFut.flatMap { query =&gt;</dt><dd><dl>
<dt>endpointLoadShedder(endpointName, query.product.originalName) {</dt><dd><dl class="simple">
<dt>relatedVideoTweetCandidateGenerator.get(query).map { initialCandidateSeq =&gt;</dt><dd><p>buildRelatedVideoTweetResponse(initialCandidateSeq)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>}.rescue {</dt><dd><dl class="simple">
<dt>case EndpointLoadShedder.LoadSheddingException =&gt;</dt><dd><p>Future(RelatedVideoTweetResponse(Seq.empty))</p>
</dd>
<dt>case e =&gt;</dt><dd><p>logErrMessage(endpointName, e)
Future(RelatedVideoTweetResponse(Seq.empty))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>handle(t.CrMixer.GetFrsBasedTweetRecommendations) {</dt><dd><dl>
<dt>args: t.CrMixer.GetFrsBasedTweetRecommendations.Args =&gt;</dt><dd><p>val endpointName = “getFrsBasedTweetRecommendations”</p>
<p>val requestUUID = generateRequestUUID()
val queryFut = buildFrsBasedTweetQuery(args.request, requestUUID)
queryFut.flatMap { query =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>endpointLoadShedder(endpointName, query.product.originalName) {</dt><dd><p>frsTweetCandidateGenerator.get(query).map(FrsTweetResponse(_))</p>
</dd>
<dt>}.rescue {</dt><dd><dl class="simple">
<dt>case e =&gt;</dt><dd><p>logErrMessage(endpointName, e)
Future(FrsTweetResponse(Seq.empty))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>handle(t.CrMixer.GetTopicTweetRecommendations) {</dt><dd><dl>
<dt>args: t.CrMixer.GetTopicTweetRecommendations.Args =&gt;</dt><dd><p>val endpointName = “getTopicTweetRecommendations”</p>
<p>val requestUUID = generateRequestUUID()
val query = buildTopicTweetQuery(args.request, requestUUID)</p>
<dl class="simple">
<dt>endpointLoadShedder(endpointName, query.product.originalName) {</dt><dd><p>topicTweetCandidateGenerator.get(query).map(TopicTweetResponse(_))</p>
</dd>
<dt>}.rescue {</dt><dd><dl class="simple">
<dt>case e =&gt;</dt><dd><p>logErrMessage(endpointName, e)
Future(TopicTweetResponse(Map.empty[Long, Seq[TopicTweet]]))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>handle(t.CrMixer.GetUtegTweetRecommendations) {</dt><dd><dl>
<dt>args: t.CrMixer.GetUtegTweetRecommendations.Args =&gt;</dt><dd><p>val endpointName = “getUtegTweetRecommendations”</p>
<p>val requestUUID = generateRequestUUID()
val startTime = Time.now.inMilliseconds
val queryFut = buildUtegTweetQuery(args.request, requestUUID)
queryFut</p>
<blockquote>
<div><dl>
<dt>.flatMap { query =&gt;</dt><dd><p>val scribeMetadata = ScribeMetadata.from(query)
endpointLoadShedder(endpointName, query.product.originalName) {</p>
<blockquote>
<div><dl>
<dt>utegTweetScribeLogger.scribeGetUtegTweetRecommendations(</dt><dd><p>args.request,
startTime,
scribeMetadata,
utegTweetCandidateGenerator</p>
<blockquote>
<div><p>.get(query)
.map(buildUtegTweetResponse)</p>
</div></blockquote>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl class="simple">
<dt>}.rescue {</dt><dd><dl class="simple">
<dt>case e =&gt;</dt><dd><p>logErrMessage(endpointName, e)
Future(UtegTweetResponse(Seq.empty))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>handle(t.CrMixer.GetAdsRecommendations) { args: t.CrMixer.GetAdsRecommendations.Args =&gt;</dt><dd><p>val endpointName = “getAdsRecommendations”
val queryFut = buildAdsCandidateGeneratorQuery(args.request)
val startTime = Time.now.inMilliseconds
queryFut.flatMap { query =&gt;</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>val scribeMetadata = ScribeMetadata.from(query)
val response = adsCandidateGenerator</p>
<blockquote>
<div><dl class="simple">
<dt>.get(query).map { candidates =&gt;</dt><dd><p>buildAdsResponse(candidates)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>adsRecommendationsScribeLogger.scribeGetAdsRecommendations(</dt><dd><p>args.request,
startTime,
scribeMetadata,
response,
query.params(AdsParams.EnableScribe)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>}.rescue {</dt><dd><dl class="simple">
<dt>case e =&gt;</dt><dd><p>logErrMessage(endpointName, e)
Future(AdsResponse(Seq.empty))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private def buildCrCandidateGeneratorQuery(</dt><dd><p>thriftRequest: CrMixerTweetRequest,
requestUUID: Long,
userId: Long</p>
</dd>
</dl>
<p>): Future[CrCandidateGeneratorQuery] = {</p>
<blockquote>
<div><p>val product = thriftRequest.product
val productContext = thriftRequest.productContext
val scopedStats = statsReceiver</p>
<blockquote>
<div><p>.scope(product.toString).scope(“CrMixerTweetRequest”)</p>
</div></blockquote>
<dl>
<dt>userStateStore</dt><dd><dl>
<dt>.get(userId).map { userStateOpt =&gt;</dt><dd><dl class="simple">
<dt>val userState = userStateOpt</dt><dd><p>.getOrElse(UserState.EnumUnknownUserState(100))</p>
</dd>
</dl>
<p>scopedStats.scope(“UserState”).counter(userState.toString).incr()</p>
<dl>
<dt>val params =</dt><dd><dl class="simple">
<dt>paramsBuilder.buildFromClientContext(</dt><dd><p>thriftRequest.clientContext,
thriftRequest.product,
userState</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>// Specify product-specific behavior mapping here
val maxNumResults = (product, productContext) match {</p>
<blockquote>
<div><dl>
<dt>case (t.Product.Home, Some(t.ProductContext.HomeContext(homeContext))) =&gt;</dt><dd><p>homeContext.maxResults.getOrElse(9999)</p>
</dd>
<dt>case (t.Product.Notifications, Some(t.ProductContext.NotificationsContext(cxt))) =&gt;</dt><dd><p>params(GlobalParams.MaxCandidatesPerRequestParam)</p>
</dd>
<dt>case (t.Product.Email, None) =&gt;</dt><dd><p>params(GlobalParams.MaxCandidatesPerRequestParam)</p>
</dd>
<dt>case (t.Product.ImmersiveMediaViewer, None) =&gt;</dt><dd><p>params(GlobalParams.MaxCandidatesPerRequestParam)</p>
</dd>
<dt>case (t.Product.VideoCarousel, None) =&gt;</dt><dd><p>params(GlobalParams.MaxCandidatesPerRequestParam)</p>
</dd>
<dt>case _ =&gt;</dt><dd><dl class="simple">
<dt>throw new IllegalArgumentException(</dt><dd><p>s”Product ${product} and ProductContext ${productContext} are not allowed in CrMixer”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>CrCandidateGeneratorQuery(</dt><dd><p>userId = userId,
product = product,
userState = userState,
maxNumResults = maxNumResults,
impressedTweetList = thriftRequest.excludedTweetIds.getOrElse(Nil).toSet,
params = params,
requestUUID = requestUUID,
languageCode = thriftRequest.clientContext.languageCode</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>private def buildRelatedTweetQuery(</dt><dd><p>thriftRequest: RelatedTweetRequest,
requestUUID: Long</p>
</dd>
</dl>
<p>): Future[RelatedTweetCandidateGeneratorQuery] = {</p>
<blockquote>
<div><p>val product = thriftRequest.product
val scopedStats = statsReceiver</p>
<blockquote>
<div><p>.scope(product.toString).scope(“RelatedTweetRequest”)</p>
</div></blockquote>
<dl class="simple">
<dt>val userStateFut: Future[UserState] = (thriftRequest.clientContext.userId match {</dt><dd><p>case Some(userId) =&gt; userStateStore.get(userId)
case None =&gt; Future.value(Some(UserState.EnumUnknownUserState(100)))</p>
</dd>
</dl>
<p>}).map(_.getOrElse(UserState.EnumUnknownUserState(100)))</p>
<dl>
<dt>userStateFut.map { userState =&gt;</dt><dd><p>scopedStats.scope(“UserState”).counter(userState.toString).incr()
val params =</p>
<blockquote>
<div><dl class="simple">
<dt>paramsBuilder.buildFromClientContext(</dt><dd><p>thriftRequest.clientContext,
thriftRequest.product,
userState)</p>
</dd>
</dl>
</div></blockquote>
<p>// Specify product-specific behavior mapping here
// Currently, Home takes 10, and RUX takes 100
val maxNumResults = params(RelatedTweetGlobalParams.MaxCandidatesPerRequestParam)</p>
<dl class="simple">
<dt>RelatedTweetCandidateGeneratorQuery(</dt><dd><p>internalId = thriftRequest.internalId,
clientContext = thriftRequest.clientContext,
product = product,
maxNumResults = maxNumResults,
impressedTweetList = thriftRequest.excludedTweetIds.getOrElse(Nil).toSet,
params = params,
requestUUID = requestUUID</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private def buildAdsCandidateGeneratorQuery(</dt><dd><p>thriftRequest: AdsRequest</p>
</dd>
<dt>): Future[AdsCandidateGeneratorQuery] = {</dt><dd><dl class="simple">
<dt>val userId = thriftRequest.clientContext.userId.getOrElse(</dt><dd><p>throw new IllegalArgumentException(“userId must be present in the Thrift clientContext”)</p>
</dd>
</dl>
<p>)
val product = thriftRequest.product
val requestUUID = generateRequestUUID()
userStateStore</p>
<blockquote>
<div><dl>
<dt>.get(userId).map { userStateOpt =&gt;</dt><dd><dl class="simple">
<dt>val userState = userStateOpt</dt><dd><p>.getOrElse(UserState.EnumUnknownUserState(100))</p>
</dd>
<dt>val params =</dt><dd><dl class="simple">
<dt>paramsBuilder.buildFromClientContext(</dt><dd><p>thriftRequest.clientContext,
thriftRequest.product,
userState)</p>
</dd>
</dl>
</dd>
</dl>
<p>val maxNumResults = params(AdsParams.AdsCandidateGenerationMaxCandidatesNumParam)
AdsCandidateGeneratorQuery(</p>
<blockquote>
<div><p>userId = userId,
product = product,
userState = userState,
params = params,
maxNumResults = maxNumResults,
requestUUID = requestUUID</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private def buildRelatedVideoTweetQuery(</dt><dd><p>thriftRequest: RelatedVideoTweetRequest,
requestUUID: Long</p>
</dd>
</dl>
<p>): Future[RelatedVideoTweetCandidateGeneratorQuery] = {</p>
<blockquote>
<div><p>val product = thriftRequest.product
val scopedStats = statsReceiver</p>
<blockquote>
<div><p>.scope(product.toString).scope(“RelatedVideoTweetRequest”)</p>
</div></blockquote>
<dl class="simple">
<dt>val userStateFut: Future[UserState] = (thriftRequest.clientContext.userId match {</dt><dd><p>case Some(userId) =&gt; userStateStore.get(userId)
case None =&gt; Future.value(Some(UserState.EnumUnknownUserState(100)))</p>
</dd>
</dl>
<p>}).map(_.getOrElse(UserState.EnumUnknownUserState(100)))</p>
<dl>
<dt>userStateFut.map { userState =&gt;</dt><dd><p>scopedStats.scope(“UserState”).counter(userState.toString).incr()
val params =</p>
<blockquote>
<div><dl class="simple">
<dt>paramsBuilder.buildFromClientContext(</dt><dd><p>thriftRequest.clientContext,
thriftRequest.product,
userState)</p>
</dd>
</dl>
</div></blockquote>
<p>val maxNumResults = params(RelatedVideoTweetGlobalParams.MaxCandidatesPerRequestParam)</p>
<dl class="simple">
<dt>RelatedVideoTweetCandidateGeneratorQuery(</dt><dd><p>internalId = thriftRequest.internalId,
clientContext = thriftRequest.clientContext,
product = product,
maxNumResults = maxNumResults,
impressedTweetList = thriftRequest.excludedTweetIds.getOrElse(Nil).toSet,
params = params,
requestUUID = requestUUID</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>private def buildUtegTweetQuery(</dt><dd><p>thriftRequest: UtegTweetRequest,
requestUUID: Long</p>
</dd>
</dl>
<p>): Future[UtegTweetCandidateGeneratorQuery] = {</p>
<blockquote>
<div><dl class="simple">
<dt>val userId = thriftRequest.clientContext.userId.getOrElse(</dt><dd><p>throw new IllegalArgumentException(“userId must be present in the Thrift clientContext”)</p>
</dd>
</dl>
<p>)
val product = thriftRequest.product
val productContext = thriftRequest.productContext
val scopedStats = statsReceiver</p>
<blockquote>
<div><p>.scope(product.toString).scope(“UtegTweetRequest”)</p>
</div></blockquote>
<dl>
<dt>userStateStore</dt><dd><dl>
<dt>.get(userId).map { userStateOpt =&gt;</dt><dd><dl class="simple">
<dt>val userState = userStateOpt</dt><dd><p>.getOrElse(UserState.EnumUnknownUserState(100))</p>
</dd>
</dl>
<p>scopedStats.scope(“UserState”).counter(userState.toString).incr()</p>
<dl>
<dt>val params =</dt><dd><dl class="simple">
<dt>paramsBuilder.buildFromClientContext(</dt><dd><p>thriftRequest.clientContext,
thriftRequest.product,
userState</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>// Specify product-specific behavior mapping here
val maxNumResults = (product, productContext) match {</p>
<blockquote>
<div><dl>
<dt>case (t.Product.Home, Some(t.ProductContext.HomeContext(homeContext))) =&gt;</dt><dd><p>homeContext.maxResults.getOrElse(9999)</p>
</dd>
<dt>case _ =&gt;</dt><dd><dl class="simple">
<dt>throw new IllegalArgumentException(</dt><dd><p>s”Product ${product} and ProductContext ${productContext} are not allowed in CrMixer”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>UtegTweetCandidateGeneratorQuery(</dt><dd><p>userId = userId,
product = product,
userState = userState,
maxNumResults = maxNumResults,
impressedTweetList = thriftRequest.excludedTweetIds.getOrElse(Nil).toSet,
params = params,
requestUUID = requestUUID</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl>
<dt>private def buildTopicTweetQuery(</dt><dd><p>thriftRequest: TopicTweetRequest,
requestUUID: Long</p>
</dd>
<dt>): TopicTweetCandidateGeneratorQuery = {</dt><dd><dl class="simple">
<dt>val userId = thriftRequest.clientContext.userId.getOrElse(</dt><dd><dl class="simple">
<dt>throw new IllegalArgumentException(</dt><dd><p>“userId must be present in the TopicTweetRequest clientContext”)</p>
</dd>
</dl>
</dd>
</dl>
<p>)
val product = thriftRequest.product
val productContext = thriftRequest.productContext</p>
<p>// Specify product-specific behavior mapping here
val isVideoOnly = (product, productContext) match {</p>
<blockquote>
<div><dl>
<dt>case (t.Product.ExploreTopics, Some(t.ProductContext.ExploreContext(context))) =&gt;</dt><dd><p>context.isVideoOnly</p>
</dd>
<dt>case (t.Product.TopicLandingPage, None) =&gt;</dt><dd><p>false</p>
</dd>
<dt>case (t.Product.HomeTopicsBackfill, None) =&gt;</dt><dd><p>false</p>
</dd>
<dt>case (t.Product.TopicTweetsStrato, None) =&gt;</dt><dd><p>false</p>
</dd>
<dt>case _ =&gt;</dt><dd><dl class="simple">
<dt>throw new IllegalArgumentException(</dt><dd><p>s”Product ${product} and ProductContext ${productContext} are not allowed in CrMixer”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>statsReceiver.scope(product.toString).counter(TopicTweetRequest.toString).incr()</p>
<dl>
<dt>val params =</dt><dd><dl class="simple">
<dt>paramsBuilder.buildFromClientContext(</dt><dd><p>thriftRequest.clientContext,
product,
UserState.EnumUnknownUserState(100)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val topicIds = thriftRequest.topicIds.map { topicId =&gt;</dt><dd><dl class="simple">
<dt>TopicId(</dt><dd><p>entityId = topicId,
language = thriftRequest.clientContext.languageCode,
country = None</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}.toSet</p>
<dl class="simple">
<dt>TopicTweetCandidateGeneratorQuery(</dt><dd><p>userId = userId,
topicIds = topicIds,
product = product,
maxNumResults = params(TopicTweetParams.MaxTopicTweetCandidatesParam),
impressedTweetList = thriftRequest.excludedTweetIds.getOrElse(Nil).toSet,
params = params,
requestUUID = requestUUID,
isVideoOnly = isVideoOnly</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def buildFrsBasedTweetQuery(</dt><dd><p>thriftRequest: FrsTweetRequest,
requestUUID: Long</p>
</dd>
<dt>): Future[FrsTweetCandidateGeneratorQuery] = {</dt><dd><dl class="simple">
<dt>val userId = thriftRequest.clientContext.userId.getOrElse(</dt><dd><dl class="simple">
<dt>throw new IllegalArgumentException(</dt><dd><p>“userId must be present in the FrsTweetRequest clientContext”)</p>
</dd>
</dl>
</dd>
</dl>
<p>)
val product = thriftRequest.product
val productContext = thriftRequest.productContext</p>
<dl>
<dt>val scopedStats = statsReceiver</dt><dd><p>.scope(product.toString).scope(“FrsTweetRequest”)</p>
</dd>
<dt>userStateStore</dt><dd><dl>
<dt>.get(userId).map { userStateOpt =&gt;</dt><dd><dl class="simple">
<dt>val userState = userStateOpt</dt><dd><p>.getOrElse(UserState.EnumUnknownUserState(100))</p>
</dd>
</dl>
<p>scopedStats.scope(“UserState”).counter(userState.toString).incr()</p>
<dl>
<dt>val params =</dt><dd><dl class="simple">
<dt>paramsBuilder.buildFromClientContext(</dt><dd><p>thriftRequest.clientContext,
thriftRequest.product,
userState</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val maxNumResults = (product, productContext) match {</dt><dd><dl class="simple">
<dt>case (t.Product.Home, Some(t.ProductContext.HomeContext(homeContext))) =&gt;</dt><dd><dl class="simple">
<dt>homeContext.maxResults.getOrElse(</dt><dd><p>params(FrsBasedCandidateGenerationMaxCandidatesNumParam))</p>
</dd>
</dl>
</dd>
<dt>case _ =&gt;</dt><dd><p>params(FrsBasedCandidateGenerationMaxCandidatesNumParam)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>FrsTweetCandidateGeneratorQuery(</dt><dd><p>userId = userId,
product = product,
maxNumResults = maxNumResults,
impressedTweetList = thriftRequest.excludedTweetIds.getOrElse(Nil).toSet,
impressedUserList = thriftRequest.excludedUserIds.getOrElse(Nil).toSet,
params = params,
languageCodeOpt = thriftRequest.clientContext.languageCode,
countryCodeOpt = thriftRequest.clientContext.countryCode,
requestUUID = requestUUID</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private def buildThriftResponse(</dt><dd><p>candidates: Seq[RankedCandidate]</p>
</dd>
</dl>
<p>): CrMixerTweetResponse = {</p>
<blockquote>
<div><dl>
<dt>val tweets = candidates.map { candidate =&gt;</dt><dd><dl>
<dt>TweetRecommendation(</dt><dd><p>tweetId = candidate.tweetId,
score = candidate.predictionScore,
metricTags = Some(MetricTagUtil.buildMetricTags(candidate)),
latestSourceSignalTimestampInMillis =</p>
<blockquote>
<div><p>SignalTimestampStatsUtil.buildLatestSourceSignalTimestamp(candidate)</p>
</div></blockquote>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}
signalTimestampStatsUtil.statsSignalTimestamp(tweets)
CrMixerTweetResponse(tweets)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private def scribeTweetScoreFunnelSeries(</dt><dd><p>candidates: Seq[RankedCandidate]</p>
</dd>
<dt>): Seq[RankedCandidate] = {</dt><dd><p>// 202210210901 is a random number for code search of Lensview
tweetScoreFunnelSeries.startNewSpan(</p>
<blockquote>
<div><p>name = “GetTweetRecommendationsTopLevelTweetSimilarityEngineType”,
codePtr = 202210210901L) {
(</p>
<blockquote>
<div><p>candidates,
candidates.map { candidate =&gt;</p>
<blockquote>
<div><dl>
<dt>thriftlog.TweetDimensionMeasure(</dt><dd><dl class="simple">
<dt>dimension = Some(</dt><dd><dl class="simple">
<dt>thriftlog</dt><dd><dl class="simple">
<dt>.RequestTweetDimension(</dt><dd><p>candidate.tweetId,
candidate.reasonChosen.similarityEngineInfo.similarityEngineType.value)),</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>measure = Some(thriftlog.RequestTweetMeasure(candidate.predictionScore))</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def buildRelatedTweetResponse(candidates: Seq[InitialCandidate]): RelatedTweetResponse = {</dt><dd><dl>
<dt>val tweets = candidates.map { candidate =&gt;</dt><dd><dl class="simple">
<dt>RelatedTweet(</dt><dd><p>tweetId = candidate.tweetId,
score = Some(candidate.getSimilarityScore),
authorId = Some(candidate.tweetInfo.authorId)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}
RelatedTweetResponse(tweets)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def buildRelatedVideoTweetResponse(</dt><dd><p>candidates: Seq[InitialCandidate]</p>
</dd>
<dt>): RelatedVideoTweetResponse = {</dt><dd><dl>
<dt>val tweets = candidates.map { candidate =&gt;</dt><dd><dl class="simple">
<dt>RelatedVideoTweet(</dt><dd><p>tweetId = candidate.tweetId,
score = Some(candidate.getSimilarityScore)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}
RelatedVideoTweetResponse(tweets)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def buildUtegTweetResponse(</dt><dd><p>candidates: Seq[TweetWithScoreAndSocialProof]</p>
</dd>
<dt>): UtegTweetResponse = {</dt><dd><dl>
<dt>val tweets = candidates.map { candidate =&gt;</dt><dd><dl class="simple">
<dt>UtegTweet(</dt><dd><p>tweetId = candidate.tweetId,
score = candidate.score,
socialProofByType = candidate.socialProofByType</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}
UtegTweetResponse(tweets)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def buildAdsResponse(</dt><dd><p>candidates: Seq[RankedAdsCandidate]</p>
</dd>
<dt>): AdsResponse = {</dt><dd><dl class="simple">
<dt>AdsResponse(ads = candidates.map { candidate =&gt;</dt><dd><dl class="simple">
<dt>AdTweetRecommendation(</dt><dd><p>tweetId = candidate.tweetId,
score = candidate.predictionScore,
lineItems = Some(candidate.lineItemInfo))</p>
</dd>
</dl>
</dd>
</dl>
<p>})</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private def cacheTweetRecommendationResults(</dt><dd><p>request: CrMixerTweetRequest,
response: Future[CrMixerTweetResponse]</p>
</dd>
</dl>
<p>): Unit = {</p>
<blockquote>
<div><dl>
<dt>val userId = request.clientContext.userId.getOrElse(</dt><dd><dl class="simple">
<dt>throw new IllegalArgumentException(</dt><dd><p>“userId must be present in getTweetRecommendations() Thrift clientContext”))</p>
</dd>
</dl>
</dd>
<dt>if (decider.isAvailableForId(userId, DeciderConstants.getTweetRecommendationsCacheRate)) {</dt><dd><dl>
<dt>response.map { crMixerTweetResponse =&gt;</dt><dd><dl>
<dt>{</dt><dd><dl>
<dt>(</dt><dd><p>request.product,
request.clientContext.userId,
crMixerTweetResponse.tweets.nonEmpty) match {
case (t.Product.Home, Some(userId), true) =&gt;</p>
<blockquote>
<div><p>tweetRecommendationResultsStore.put((userId, crMixerTweetResponse))</p>
</div></blockquote>
<p>case _ =&gt; Future.value(Unit)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/cr-mixer/server/src/main/scala/com/twitter/cr_mixer/controller/CrMixerThriftController.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>