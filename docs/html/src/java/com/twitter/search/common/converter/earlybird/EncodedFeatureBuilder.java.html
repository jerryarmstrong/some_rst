<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../" id="documentation_options" src="../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.common.converter.earlybird;</p>
<p>import java.io.IOException;
import java.util.HashSet;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;</p>
<p>import com.google.common.base.Joiner;
import com.google.common.base.Preconditions;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;</p>
<p>import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;</p>
<p>import com.twitter.common.text.token.TokenizedCharSequence;
import com.twitter.common.text.token.TokenizedCharSequenceStream;
import com.twitter.common.text.util.TokenStreamSerializer;
import com.twitter.common_internal.text.version.PenguinVersion;
import com.twitter.search.common.indexing.thriftjava.Place;
import com.twitter.search.common.indexing.thriftjava.PotentialLocation;
import com.twitter.search.common.indexing.thriftjava.ProfileGeoEnrichment;
import com.twitter.search.common.indexing.thriftjava.ThriftExpandedUrl;
import com.twitter.search.common.indexing.thriftjava.VersionedTweetFeatures;
import com.twitter.search.common.metrics.SearchCounter;
import com.twitter.search.common.relevance.entities.PotentialLocationObject;
import com.twitter.search.common.relevance.entities.TwitterMessage;
import com.twitter.search.common.relevance.features.FeatureSink;
import com.twitter.search.common.relevance.features.MutableFeatureNormalizers;
import com.twitter.search.common.relevance.features.RelevanceSignalConstants;
import com.twitter.search.common.relevance.features.TweetTextFeatures;
import com.twitter.search.common.relevance.features.TweetTextQuality;
import com.twitter.search.common.relevance.features.TweetUserFeatures;
import com.twitter.search.common.schema.base.FeatureConfiguration;
import com.twitter.search.common.schema.base.ImmutableSchemaInterface;
import com.twitter.search.common.schema.earlybird.EarlybirdEncodedFeatures;
import com.twitter.search.common.schema.earlybird.EarlybirdFieldConstants.EarlybirdFieldConstant;
import com.twitter.search.common.util.lang.ThriftLanguageUtil;
import com.twitter.search.common.util.text.LanguageIdentifierHelper;
import com.twitter.search.common.util.text.NormalizerHelper;
import com.twitter.search.common.util.text.SourceNormalizer;
import com.twitter.search.common.util.text.TokenizerHelper;
import com.twitter.search.common.util.text.TokenizerResult;
import com.twitter.search.common.util.text.TweetTokenStreamSerializer;
import com.twitter.search.common.util.url.LinkVisibilityUtils;
import com.twitter.search.common.util.url.NativeVideoClassificationUtils;
import com.twitter.search.ingester.model.VisibleTokenRatioUtil;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>EncodedFeatureBuilder helps to build encoded features for TwitterMessage.</p></li>
<li></li>
<li><p>This is stateful so should only be used one tweet at a time</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public class EncodedFeatureBuilder {</dt><dd><p>private static final Logger LOG = LoggerFactory.getLogger(EncodedFeatureBuilder.class);</p>
<dl class="simple">
<dt>private static final SearchCounter NUM_TWEETS_WITH_INVALID_TWEET_ID_IN_PHOTO_URL =</dt><dd><p>SearchCounter.export(“tweets_with_invalid_tweet_id_in_photo_url”);</p>
</dd>
</dl>
<p>// TwitterTokenStream for converting TokenizedCharSequence into a stream for serialization
// This is stateful so should only be used one tweet at a time
private final TokenizedCharSequenceStream tokenSeqStream = new TokenizedCharSequenceStream();</p>
<p>// SUPPRESS CHECKSTYLE:OFF LineLength
private static final Pattern TWITTER_PHOTO_PERMA_LINK_PATTERN =</p>
<blockquote>
<div><p>Pattern.compile(“(?i:^(?:(?:https?\:\/\/)?(?:www\.)?)?twitter\.com\/(?:\?[^#]+)?(?:#!?\/?)?\w{1,20}\/status\/(\d+)\/photo\/\d*$)”);</p>
</div></blockquote>
<dl class="simple">
<dt>private static final Pattern TWITTER_PHOTO_COPY_PASTE_LINK_PATTERN =</dt><dd><p>Pattern.compile(“(?i:^(?:(?:https?\:\/\/)?(?:www\.)?)?twitter\.com\/(?:#!?\/)?\w{1,20}\/status\/(\d+)\/photo\/\d*$)”);</p>
</dd>
</dl>
<p>// SUPPRESS CHECKSTYLE:ON LineLength</p>
<p>private static final VisibleTokenRatioUtil VISIBLE_TOKEN_RATIO = new VisibleTokenRatioUtil();</p>
<dl>
<dt>private static final Map&lt;PenguinVersion, SearchCounter&gt; SERIALIZE_FAILURE_COUNTERS_MAP =</dt><dd><p>Maps.newEnumMap(PenguinVersion.class);</p>
</dd>
<dt>static {</dt><dd><dl>
<dt>for (PenguinVersion penguinVersion<span class="classifier">PenguinVersion.values()) {</span></dt><dd><dl>
<dt>SERIALIZE_FAILURE_COUNTERS_MAP.put(</dt><dd><p>penguinVersion,
SearchCounter.export(</p>
<blockquote>
<div><p>“<a href="#id13"><span class="problematic" id="id14">tokenstream_serialization_failure_</span></a>” + penguinVersion.name().toLowerCase()));</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>public static class TweetFeatureWithEncodeFeatures {</dt><dd><p>public final VersionedTweetFeatures versionedFeatures;
public final EarlybirdEncodedFeatures encodedFeatures;
public final EarlybirdEncodedFeatures extendedEncodedFeatures;</p>
<dl>
<dt>public TweetFeatureWithEncodeFeatures(</dt><dd><blockquote>
<div><p>VersionedTweetFeatures versionedFeatures,
EarlybirdEncodedFeatures encodedFeatures,
EarlybirdEncodedFeatures extendedEncodedFeatures) {</p>
</div></blockquote>
<p>this.versionedFeatures = versionedFeatures;
this.encodedFeatures = encodedFeatures;
this.extendedEncodedFeatures = extendedEncodedFeatures;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Create tweet text features and the encoded features.</p></li>
<li></li>
<li><p>&#64;param message the tweet message</p></li>
<li><p>&#64;param penguinVersion the based penguin version to create the features</p></li>
<li><p>&#64;param schemaSnapshot the schema associated with the features</p></li>
<li><p>&#64;return the text features and the encoded features</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>public TweetFeatureWithEncodeFeatures createTweetFeaturesFromTwitterMessage(</dt><dd><blockquote>
<div><p>TwitterMessage message,
PenguinVersion penguinVersion,
ImmutableSchemaInterface schemaSnapshot) {</p>
</div></blockquote>
<p>VersionedTweetFeatures versionedTweetFeatures = new VersionedTweetFeatures();</p>
<p>// Write extendedPackedFeatures.
EarlybirdEncodedFeatures extendedEncodedFeatures =</p>
<blockquote>
<div><p>createExtendedEncodedFeaturesFromTwitterMessage(message, penguinVersion, schemaSnapshot);</p>
</div></blockquote>
<dl class="simple">
<dt>if (extendedEncodedFeatures != null) {</dt><dd><dl class="simple">
<dt>extendedEncodedFeatures</dt><dd><p>.writeExtendedFeaturesToVersionedTweetFeatures(versionedTweetFeatures);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>setSourceAndNormalizedSource(</dt><dd><p>message.getStrippedSource(), versionedTweetFeatures, penguinVersion);</p>
</dd>
</dl>
<p>TweetTextFeatures textFeatures = message.getTweetTextFeatures(penguinVersion);</p>
<p>// Add hashtags and mentions
textFeatures.getHashtags().forEach(versionedTweetFeatures::addToHashtags);
textFeatures.getMentions().forEach(versionedTweetFeatures::addToMentions);</p>
<p>// Extract some extra information from the message text.
// Index stock symbols with $ prepended
textFeatures.getStocks().stream()</p>
<blockquote>
<div><p>.filter(stock -&gt; stock != null)
.forEach(stock -&gt; versionedTweetFeatures.addToStocks(stock.toLowerCase()));</p>
</div></blockquote>
<p>// Question marks
versionedTweetFeatures.setHasQuestionMark(textFeatures.hasQuestionMark());
// Smileys
versionedTweetFeatures.setHasPositiveSmiley(textFeatures.hasPositiveSmiley());
versionedTweetFeatures.setHasNegativeSmiley(textFeatures.hasNegativeSmiley());</p>
<dl class="simple">
<dt>TokenStreamSerializer streamSerializer =</dt><dd><p>TweetTokenStreamSerializer.getTweetTokenStreamSerializer();</p>
</dd>
</dl>
<p>TokenizedCharSequence tokenSeq = textFeatures.getTokenSequence();
tokenSeqStream.reset(tokenSeq);
int tokenPercent = VISIBLE_TOKEN_RATIO.extractAndNormalizeTokenPercentage(tokenSeqStream);
tokenSeqStream.reset(tokenSeq);</p>
<p>// Write packedFeatures.
EarlybirdEncodedFeatures encodedFeatures = createEncodedFeaturesFromTwitterMessage(</p>
<blockquote>
<div><p>message, penguinVersion, schemaSnapshot, tokenPercent);</p>
</div></blockquote>
<p>encodedFeatures.writeFeaturesToVersionedTweetFeatures(versionedTweetFeatures);</p>
<dl>
<dt>try {</dt><dd><p>versionedTweetFeatures.setTweetTokenStream(streamSerializer.serialize(tokenSeqStream));
versionedTweetFeatures.setTweetTokenStreamText(tokenSeq.toString());</p>
</dd>
<dt>} catch (IOException e) {</dt><dd><dl class="simple">
<dt>LOG.error(“TwitterTokenStream serialization error! Could not serialize: “</dt><dd><ul class="simple">
<li><p>tokenSeq.toString());</p></li>
</ul>
</dd>
</dl>
<p>SERIALIZE_FAILURE_COUNTERS_MAP.get(penguinVersion).increment();
versionedTweetFeatures.unsetTweetTokenStream();
versionedTweetFeatures.unsetTweetTokenStreamText();</p>
</dd>
</dl>
<p>}</p>
<p>// User name features
if (message.getFromUserDisplayName().isPresent()) {</p>
<blockquote>
<div><dl class="simple">
<dt>Locale locale = LanguageIdentifierHelper</dt><dd><p>.identifyLanguage(message.getFromUserDisplayName().get());</p>
</dd>
<dt>String normalizedDisplayName = NormalizerHelper.normalize(</dt><dd><p>message.getFromUserDisplayName().get(), locale, penguinVersion);</p>
</dd>
<dt>TokenizerResult result = TokenizerHelper</dt><dd><p>.tokenizeTweet(normalizedDisplayName, locale, penguinVersion);</p>
</dd>
</dl>
<p>tokenSeqStream.reset(result.tokenSequence);
try {</p>
<blockquote>
<div><dl class="simple">
<dt>versionedTweetFeatures.setUserDisplayNameTokenStream(</dt><dd><p>streamSerializer.serialize(tokenSeqStream));</p>
</dd>
</dl>
<p>versionedTweetFeatures.setUserDisplayNameTokenStreamText(result.tokenSequence.toString());</p>
</div></blockquote>
<dl>
<dt>} catch (IOException e) {</dt><dd><dl class="simple">
<dt>LOG.error(“TwitterTokenStream serialization error! Could not serialize: “</dt><dd><ul class="simple">
<li><p>message.getFromUserDisplayName().get());</p></li>
</ul>
</dd>
</dl>
<p>SERIALIZE_FAILURE_COUNTERS_MAP.get(penguinVersion).increment();
versionedTweetFeatures.unsetUserDisplayNameTokenStream();
versionedTweetFeatures.unsetUserDisplayNameTokenStreamText();</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>String resolvedUrlsText = Joiner.on(” “).skipNulls().join(textFeatures.getResolvedUrlTokens());
versionedTweetFeatures.setNormalizedResolvedUrlText(resolvedUrlsText);</p>
<p>addPlace(message, versionedTweetFeatures, penguinVersion);
addProfileGeoEnrichment(message, versionedTweetFeatures, penguinVersion);</p>
<p>versionedTweetFeatures.setTweetSignature(message.getTweetSignature(penguinVersion));</p>
<dl class="simple">
<dt>return new TweetFeatureWithEncodeFeatures(</dt><dd><p>versionedTweetFeatures, encodedFeatures, extendedEncodedFeatures);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>protected static void setSourceAndNormalizedSource(</dt><dd><blockquote>
<div><p>String strippedSource,
VersionedTweetFeatures versionedTweetFeatures,
PenguinVersion penguinVersion) {</p>
</div></blockquote>
<dl>
<dt>if (strippedSource != null &amp;&amp; !strippedSource.isEmpty()) {</dt><dd><p>// normalize source for searchable field - replaces whitespace with underscores (???).
versionedTweetFeatures.setNormalizedSource(</p>
<blockquote>
<div><p>SourceNormalizer.normalize(strippedSource, penguinVersion));</p>
</div></blockquote>
<p>// source facet has simpler normalization.
Locale locale = LanguageIdentifierHelper.identifyLanguage(strippedSource);
versionedTweetFeatures.setSource(NormalizerHelper.normalizeKeepCase(</p>
<blockquote>
<div><p>strippedSource, locale, penguinVersion));</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Adds the given photo url to the thrift status if it is a twitter photo permalink.</p></li>
<li><p>Returns true, if this was indeed a twitter photo, false otherwise.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>public static boolean addPhotoUrl(TwitterMessage message, String photoPermalink) {</dt><dd><p>Matcher matcher = TWITTER_PHOTO_COPY_PASTE_LINK_PATTERN.matcher(photoPermalink);
if (!matcher.matches() || matcher.groupCount() &lt; 1) {</p>
<blockquote>
<div><p>matcher = TWITTER_PHOTO_PERMA_LINK_PATTERN.matcher(photoPermalink);</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>if (matcher.matches() &amp;&amp; matcher.groupCount() == 1) {</dt><dd><p>// this is a native photo url which we need to store in a separate field
String idStr = matcher.group(1);
if (idStr != null) {</p>
<blockquote>
<div><p>// idStr should be a valid tweet ID (and therefore, should fit into a Long), but we have
// tweets for which idStr is a long sequence of digits that does not fit into a Long.
try {</p>
<blockquote>
<div><p>long photoStatusId = Long.parseLong(idStr);
message.addPhotoUrl(photoStatusId, null);</p>
</div></blockquote>
<dl class="simple">
<dt>} catch (NumberFormatException e) {</dt><dd><p>LOG.warn(“Found a tweet with a photo URL with an invalid tweet ID: “ + message);
NUM_TWEETS_WITH_INVALID_TWEET_ID_IN_PHOTO_URL.increment();</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return true;</p>
</dd>
</dl>
<p>}
return false;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void addPlace(TwitterMessage message,</dt><dd><blockquote>
<div><p>VersionedTweetFeatures versionedTweetFeatures,
PenguinVersion penguinVersion) {</p>
</div></blockquote>
<p>String placeId = message.getPlaceId();
if (placeId == null) {</p>
<blockquote>
<div><p>return;</p>
</div></blockquote>
<p>}</p>
<p>// Tweet.Place.id and Tweet.Place.full_name are both required fields.
String placeFullName = message.getPlaceFullName();
Preconditions.checkNotNull(placeFullName, “Tweet.Place without full_name.”);</p>
<p>Locale placeFullNameLocale = LanguageIdentifierHelper.identifyLanguage(placeFullName);
String normalizedPlaceFullName =</p>
<blockquote>
<div><p>NormalizerHelper.normalize(placeFullName, placeFullNameLocale, penguinVersion);</p>
</div></blockquote>
<dl class="simple">
<dt>String tokenizedPlaceFullName = StringUtils.join(</dt><dd><p>TokenizerHelper.tokenizeQuery(normalizedPlaceFullName, placeFullNameLocale, penguinVersion),
“ “);</p>
</dd>
</dl>
<p>Place place = new Place(placeId, tokenizedPlaceFullName);
String placeCountryCode = message.getPlaceCountryCode();
if (placeCountryCode != null) {</p>
<blockquote>
<div><p>Locale placeCountryCodeLocale = LanguageIdentifierHelper.identifyLanguage(placeCountryCode);
place.setCountryCode(</p>
<blockquote>
<div><p>NormalizerHelper.normalize(placeCountryCode, placeCountryCodeLocale, penguinVersion));</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
<p>versionedTweetFeatures.setTokenizedPlace(place);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void addProfileGeoEnrichment(TwitterMessage message,</dt><dd><blockquote>
<div><p>VersionedTweetFeatures versionedTweetFeatures,
PenguinVersion penguinVersion) {</p>
</div></blockquote>
<p>List&lt;PotentialLocationObject&gt; potentialLocations = message.getPotentialLocations();
if (potentialLocations.isEmpty()) {</p>
<blockquote>
<div><p>return;</p>
</div></blockquote>
<p>}</p>
<p>List&lt;PotentialLocation&gt; thriftPotentialLocations = Lists.newArrayList();
for (PotentialLocationObject potentialLocation : potentialLocations) {</p>
<blockquote>
<div><p>thriftPotentialLocations.add(potentialLocation.toThriftPotentialLocation(penguinVersion));</p>
</div></blockquote>
<p>}
versionedTweetFeatures.setTokenizedProfileGeoEnrichment(</p>
<blockquote>
<div><p>new ProfileGeoEnrichment(thriftPotentialLocations));</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<p>/** Returns the encoded features. <a href="#id7"><span class="problematic" id="id8">*</span></a>/
public static EarlybirdEncodedFeatures createEncodedFeaturesFromTwitterMessage(</p>
<blockquote>
<div><blockquote>
<div><p>TwitterMessage message,
PenguinVersion penguinVersion,
ImmutableSchemaInterface schema,
int normalizedTokenPercentBucket) {</p>
</div></blockquote>
<p>FeatureSink sink = new FeatureSink(schema);</p>
<p>// Static features
sink.setBooleanValue(EarlybirdFieldConstant.IS_RETWEET_FLAG, message.isRetweet())</p>
<blockquote>
<div><p>.setBooleanValue(EarlybirdFieldConstant.IS_REPLY_FLAG, message.isReply())
.setBooleanValue(</p>
<blockquote>
<div><p>EarlybirdFieldConstant.FROM_VERIFIED_ACCOUNT_FLAG, message.isUserVerified())</p>
</div></blockquote>
<dl class="simple">
<dt>.setBooleanValue(</dt><dd><p>EarlybirdFieldConstant.FROM_BLUE_VERIFIED_ACCOUNT_FLAG, message.isUserBlueVerified())</p>
</dd>
</dl>
<p>.setBooleanValue(EarlybirdFieldConstant.IS_SENSITIVE_CONTENT, message.isSensitiveContent());</p>
</div></blockquote>
<p>TweetTextFeatures textFeatures = message.getTweetTextFeatures(penguinVersion);
if (textFeatures != null) {</p>
<blockquote>
<div><dl>
<dt>final FeatureConfiguration featureConfigNumHashtags = schema.getFeatureConfigurationByName(</dt><dd><p>EarlybirdFieldConstant.NUM_HASHTAGS.getFieldName());</p>
</dd>
<dt>final FeatureConfiguration featureConfigNumMentions = schema.getFeatureConfigurationByName(</dt><dd><p>EarlybirdFieldConstant.NUM_MENTIONS.getFieldName());</p>
</dd>
<dt>sink.setNumericValue(</dt><dd><blockquote>
<div><p>EarlybirdFieldConstant.NUM_HASHTAGS,
Math.min(textFeatures.getHashtagsSize(), featureConfigNumHashtags.getMaxValue()))</p>
</div></blockquote>
<dl class="simple">
<dt>.setNumericValue(</dt><dd><p>EarlybirdFieldConstant.NUM_MENTIONS,
Math.min(textFeatures.getMentionsSize(), featureConfigNumMentions.getMaxValue()))</p>
</dd>
<dt>.setBooleanValue(</dt><dd><p>EarlybirdFieldConstant.HAS_MULTIPLE_HASHTAGS_OR_TRENDS_FLAG,
TwitterMessage.hasMultipleHashtagsOrTrends(textFeatures))</p>
</dd>
<dt>.setBooleanValue(</dt><dd><p>EarlybirdFieldConstant.HAS_TREND_FLAG,
textFeatures.getTrendingTermsSize() &gt; 0);</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>TweetTextQuality textQuality = message.getTweetTextQuality(penguinVersion);
if (textQuality != null) {</p>
<blockquote>
<div><p>sink.setNumericValue(EarlybirdFieldConstant.TEXT_SCORE, textQuality.getTextScore());
sink.setBooleanValue(</p>
<blockquote>
<div><p>EarlybirdFieldConstant.IS_OFFENSIVE_FLAG,
textQuality.hasBoolQuality(TweetTextQuality.BooleanQualityType.OFFENSIVE)</p>
<blockquote>
<div><p>|| textQuality.hasBoolQuality(TweetTextQuality.BooleanQualityType.OFFENSIVE_USER)
// Note: if json message “possibly_sensitive” flag is set, we consider the tweet
// sensitive and is currently filtered out in safe search mode via a hacky setup:
// earlybird does not create _filter_sensitive_content field, only
// _is_offensive field is created, and used in filter:safe operator
|| textQuality.hasBoolQuality(TweetTextQuality.BooleanQualityType.SENSITIVE));</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>if (textQuality.hasBoolQuality(TweetTextQuality.BooleanQualityType.SENSITIVE)) {</dt><dd><p>sink.setBooleanValue(EarlybirdFieldConstant.IS_SENSITIVE_CONTENT, true);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>// we don’t have text score, for whatever reason, set to sentinel value so we won’t be
// skipped by scoring function
sink.setNumericValue(EarlybirdFieldConstant.TEXT_SCORE,</p>
<blockquote>
<div><p>RelevanceSignalConstants.UNSET_TEXT_SCORE_SENTINEL);</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (message.isSetLocale()) {</dt><dd><dl class="simple">
<dt>sink.setNumericValue(EarlybirdFieldConstant.LANGUAGE,</dt><dd><p>ThriftLanguageUtil.getThriftLanguageOf(message.getLocale()).getValue());</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>// User features
TweetUserFeatures userFeatures = message.getTweetUserFeatures(penguinVersion);
if (userFeatures != null) {</p>
<blockquote>
<div><dl class="simple">
<dt>sink.setBooleanValue(EarlybirdFieldConstant.IS_USER_SPAM_FLAG, userFeatures.isSpam())</dt><dd><p>.setBooleanValue(EarlybirdFieldConstant.IS_USER_NSFW_FLAG, userFeatures.isNsfw())
.setBooleanValue(EarlybirdFieldConstant.IS_USER_BOT_FLAG, userFeatures.isBot());</p>
</dd>
</dl>
</div></blockquote>
<p>}
if (message.getUserReputation() != TwitterMessage.DOUBLE_FIELD_NOT_PRESENT) {</p>
<blockquote>
<div><dl class="simple">
<dt>sink.setNumericValue(EarlybirdFieldConstant.USER_REPUTATION,</dt><dd><p>(byte) message.getUserReputation());</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><dl class="simple">
<dt>sink.setNumericValue(EarlybirdFieldConstant.USER_REPUTATION,</dt><dd><p>RelevanceSignalConstants.UNSET_REPUTATION_SENTINEL);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>sink.setBooleanValue(EarlybirdFieldConstant.IS_NULLCAST_FLAG, message.getNullcast());</p>
<p>// Realtime Ingestion does not write engagement features. Updater does that.
if (message.getNumFavorites() &gt; 0) {</p>
<blockquote>
<div><dl class="simple">
<dt>sink.setNumericValue(EarlybirdFieldConstant.FAVORITE_COUNT,</dt><dd><p>MutableFeatureNormalizers.BYTE_NORMALIZER.normalize(message.getNumFavorites()));</p>
</dd>
</dl>
</div></blockquote>
<p>}
if (message.getNumRetweets() &gt; 0) {</p>
<blockquote>
<div><dl class="simple">
<dt>sink.setNumericValue(EarlybirdFieldConstant.RETWEET_COUNT,</dt><dd><p>MutableFeatureNormalizers.BYTE_NORMALIZER.normalize(message.getNumRetweets()));</p>
</dd>
</dl>
</div></blockquote>
<p>}
if (message.getNumReplies() &gt; 0) {</p>
<blockquote>
<div><dl class="simple">
<dt>sink.setNumericValue(EarlybirdFieldConstant.REPLY_COUNT,</dt><dd><p>MutableFeatureNormalizers.BYTE_NORMALIZER.normalize(message.getNumReplies()));</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>sink.setNumericValue(EarlybirdFieldConstant.VISIBLE_TOKEN_RATIO, normalizedTokenPercentBucket);</p>
<dl class="simple">
<dt>EarlybirdEncodedFeatures encodedFeatures =</dt><dd><dl class="simple">
<dt>(EarlybirdEncodedFeatures) sink.getFeaturesForBaseField(</dt><dd><p>EarlybirdFieldConstant.ENCODED_TWEET_FEATURES_FIELD.getFieldName());</p>
</dd>
</dl>
</dd>
</dl>
<p>updateLinkEncodedFeatures(encodedFeatures, message);
return encodedFeatures;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the extended encoded features.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>public static EarlybirdEncodedFeatures createExtendedEncodedFeaturesFromTwitterMessage(</dt><dd><p>TwitterMessage message,
PenguinVersion penguinVersion,
ImmutableSchemaInterface schema) {
FeatureSink sink = new FeatureSink(schema);</p>
<p>TweetTextFeatures textFeatures = message.getTweetTextFeatures(penguinVersion);</p>
<dl class="simple">
<dt>if (textFeatures != null) {</dt><dd><dl class="simple">
<dt>setExtendedEncodedFeatureIntValue(sink, schema,</dt><dd><p>EarlybirdFieldConstant.NUM_HASHTAGS_V2, textFeatures.getHashtagsSize());</p>
</dd>
<dt>setExtendedEncodedFeatureIntValue(sink, schema,</dt><dd><p>EarlybirdFieldConstant.NUM_MENTIONS_V2, textFeatures.getMentionsSize());</p>
</dd>
<dt>setExtendedEncodedFeatureIntValue(sink, schema,</dt><dd><p>EarlybirdFieldConstant.NUM_STOCKS, textFeatures.getStocksSize());</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>Optional&lt;Long&gt; referenceAuthorId = message.getReferenceAuthorId();
if (referenceAuthorId.isPresent()) {</p>
<blockquote>
<div><p>setEncodedReferenceAuthorId(sink, referenceAuthorId.get());</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>return (EarlybirdEncodedFeatures) sink.getFeaturesForBaseField(</dt><dd><p>EarlybirdFieldConstant.EXTENDED_ENCODED_TWEET_FEATURES_FIELD.getFieldName());</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Updates all URL-related features, based on the values stored in the given message.</p></li>
<li></li>
<li><p>&#64;param encodedFeatures The features to be updated.</p></li>
<li><p>&#64;param message The message.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>public static void updateLinkEncodedFeatures(</dt><dd><blockquote>
<div><p>EarlybirdEncodedFeatures encodedFeatures, TwitterMessage message) {</p>
</div></blockquote>
<dl class="simple">
<dt>if (message.getLinkLocale() != null) {</dt><dd><dl class="simple">
<dt>encodedFeatures.setFeatureValue(</dt><dd><p>EarlybirdFieldConstant.LINK_LANGUAGE,
ThriftLanguageUtil.getThriftLanguageOf(message.getLinkLocale()).getValue());</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (message.hasCard()) {</dt><dd><p>encodedFeatures.setFlag(EarlybirdFieldConstant.HAS_CARD_FLAG);</p>
</dd>
</dl>
<p>}</p>
<p>// Set HAS_IMAGE HAS_NEWS HAS_VIDEO etc. flags for expanded urls.
if (message.getExpandedUrlMapSize() &gt; 0) {</p>
<blockquote>
<div><p>encodedFeatures.setFlag(EarlybirdFieldConstant.HAS_LINK_FLAG);</p>
<dl>
<dt>for (ThriftExpandedUrl url<span class="classifier">message.getExpandedUrlMap().values()) {</span></dt><dd><dl>
<dt>if (url.isSetMediaType()) {</dt><dd><dl class="simple">
<dt>switch (url.getMediaType()) {</dt><dd><dl class="simple">
<dt>case NATIVE_IMAGE:</dt><dd><p>encodedFeatures.setFlag(EarlybirdFieldConstant.HAS_IMAGE_URL_FLAG);
encodedFeatures.setFlag(EarlybirdFieldConstant.HAS_NATIVE_IMAGE_FLAG);
break;</p>
</dd>
<dt>case IMAGE:</dt><dd><p>encodedFeatures.setFlag(EarlybirdFieldConstant.HAS_IMAGE_URL_FLAG);
break;</p>
</dd>
<dt>case VIDEO:</dt><dd><p>encodedFeatures.setFlag(EarlybirdFieldConstant.HAS_VIDEO_URL_FLAG);
break;</p>
</dd>
<dt>case NEWS:</dt><dd><p>encodedFeatures.setFlag(EarlybirdFieldConstant.HAS_NEWS_URL_FLAG);
break;</p>
</dd>
<dt>case UNKNOWN:</dt><dd><p>break;</p>
</dd>
<dt>default:</dt><dd><p>throw new IllegalStateException(“Unexpected enum value: “ + url.getMediaType());</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>Set&lt;String&gt; canonicalLastHopUrlsStrings = message.getCanonicalLastHopUrls();
Set&lt;String&gt; expandedUrlsStrings = message.getExpandedUrls()</p>
<blockquote>
<div><p>.stream()
.map(ThriftExpandedUrl::getExpandedUrl)
.collect(Collectors.toSet());</p>
</div></blockquote>
<p>Set&lt;String&gt; expandedAndLastHopUrlsStrings = new HashSet&lt;&gt;();
expandedAndLastHopUrlsStrings.addAll(expandedUrlsStrings);
expandedAndLastHopUrlsStrings.addAll(canonicalLastHopUrlsStrings);
// Check both expanded and last hop url for consumer videos as consumer video urls are
// sometimes redirected to the url of the tweets containing the videos (SEARCH-42612).
if (NativeVideoClassificationUtils.hasConsumerVideo(expandedAndLastHopUrlsStrings)) {</p>
<blockquote>
<div><p>encodedFeatures.setFlag(EarlybirdFieldConstant.HAS_CONSUMER_VIDEO_FLAG);</p>
</div></blockquote>
<p>}
if (NativeVideoClassificationUtils.hasProVideo(canonicalLastHopUrlsStrings)) {</p>
<blockquote>
<div><p>encodedFeatures.setFlag(EarlybirdFieldConstant.HAS_PRO_VIDEO_FLAG);</p>
</div></blockquote>
<p>}
if (NativeVideoClassificationUtils.hasVine(canonicalLastHopUrlsStrings)) {</p>
<blockquote>
<div><p>encodedFeatures.setFlag(EarlybirdFieldConstant.HAS_VINE_FLAG);</p>
</div></blockquote>
<p>}
if (NativeVideoClassificationUtils.hasPeriscope(canonicalLastHopUrlsStrings)) {</p>
<blockquote>
<div><p>encodedFeatures.setFlag(EarlybirdFieldConstant.HAS_PERISCOPE_FLAG);</p>
</div></blockquote>
<p>}
if (LinkVisibilityUtils.hasVisibleLink(message.getExpandedUrls())) {</p>
<blockquote>
<div><p>encodedFeatures.setFlag(EarlybirdFieldConstant.HAS_VISIBLE_LINK_FLAG);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private static void setExtendedEncodedFeatureIntValue(</dt><dd><blockquote>
<div><p>FeatureSink sink,
ImmutableSchemaInterface schema,
EarlybirdFieldConstant field,
int value) {</p>
</div></blockquote>
<p>boolean fieldInSchema = schema.hasField(field.getFieldName());
if (fieldInSchema) {</p>
<blockquote>
<div><dl class="simple">
<dt>FeatureConfiguration featureConfig =</dt><dd><p>schema.getFeatureConfigurationByName(field.getFieldName());</p>
</dd>
</dl>
<p>sink.setNumericValue(field, Math.min(value, featureConfig.getMaxValue()));</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private static void setEncodedReferenceAuthorId(FeatureSink sink, long referenceAuthorId) {</dt><dd><dl class="simple">
<dt>LongIntConverter.IntegerRepresentation ints =</dt><dd><p>LongIntConverter.convertOneLongToTwoInt(referenceAuthorId);</p>
</dd>
<dt>sink.setNumericValue(</dt><dd><p>EarlybirdFieldConstant.REFERENCE_AUTHOR_ID_LEAST_SIGNIFICANT_INT, ints.leastSignificantInt);</p>
</dd>
<dt>sink.setNumericValue(</dt><dd><p>EarlybirdFieldConstant.REFERENCE_AUTHOR_ID_MOST_SIGNIFICANT_INT, ints.mostSignificantInt);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../_sources/src/java/com/twitter/search/common/converter/earlybird/EncodedFeatureBuilder.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>