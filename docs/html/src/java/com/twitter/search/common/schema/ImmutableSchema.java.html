<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../" id="documentation_options" src="../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.common.schema;</p>
<p>import java.io.IOException;
import java.io.ObjectOutputStream;
import java.util.Collection;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.TreeMap;
import java.util.concurrent.atomic.AtomicLong;
import javax.annotation.Nullable;
import javax.annotation.concurrent.Immutable;
import javax.annotation.concurrent.ThreadSafe;</p>
<p>import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.collect.ImmutableCollection;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import com.google.common.collect.ImmutableSortedMap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;</p>
<p>import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.facet.FacetsConfig;
import org.apache.lucene.index.DocValuesType;
import org.apache.lucene.index.FieldInfos;
import org.apache.lucene.index.IndexOptions;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;</p>
<p>import com.twitter.common.collections.Pair;
import com.twitter.common.text.util.TokenStreamSerializer;
import com.twitter.search.common.features.ExternalTweetFeature;
import com.twitter.search.common.features.SearchResultFeature;
import com.twitter.search.common.features.thrift.ThriftSearchFeatureSchema;
import com.twitter.search.common.features.thrift.ThriftSearchFeatureSchemaEntry;
import com.twitter.search.common.features.thrift.ThriftSearchFeatureSchemaSpecifier;
import com.twitter.search.common.features.thrift.ThriftSearchFeatureType;
import com.twitter.search.common.metrics.SearchCounter;
import com.twitter.search.common.metrics.SearchLongGauge;
import com.twitter.search.common.schema.base.EarlybirdFieldType;
import com.twitter.search.common.schema.base.FeatureConfiguration;
import com.twitter.search.common.schema.base.FieldWeightDefault;
import com.twitter.search.common.schema.base.ImmutableSchemaInterface;
import com.twitter.search.common.schema.base.IndexedNumericFieldSettings;
import com.twitter.search.common.schema.thriftjava.ThriftAnalyzer;
import com.twitter.search.common.schema.thriftjava.ThriftCSFFieldSettings;
import com.twitter.search.common.schema.thriftjava.ThriftCSFType;
import com.twitter.search.common.schema.thriftjava.ThriftCSFViewSettings;
import com.twitter.search.common.schema.thriftjava.ThriftFacetFieldSettings;
import com.twitter.search.common.schema.thriftjava.ThriftFieldConfiguration;
import com.twitter.search.common.schema.thriftjava.ThriftFieldSettings;
import com.twitter.search.common.schema.thriftjava.ThriftIndexedFieldSettings;
import com.twitter.search.common.schema.thriftjava.ThriftSchema;
import com.twitter.search.common.schema.thriftjava.ThriftSearchFieldSettings;
import com.twitter.search.common.schema.thriftjava.ThriftTokenStreamSerializer;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A schema instance that does not change at run time.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
</dl>
<p>&#64;Immutable &#64;ThreadSafe
public class ImmutableSchema implements ImmutableSchemaInterface {</p>
<blockquote>
<div><p>private static final Logger LOG = LoggerFactory.getLogger(ImmutableSchema.class);
private static final ImmutableSet&lt;ThriftCSFType&gt; CAN_FACET_ON_CSF_TYPES =</p>
<blockquote>
<div><dl class="simple">
<dt>ImmutableSet.&lt;ThriftCSFType&gt;builder()</dt><dd><p>.add(ThriftCSFType.BYTE)
.add(ThriftCSFType.INT)
.add(ThriftCSFType.LONG)
.build();</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>private static final SearchCounter FEATURES_EXISTED_IN_OLD_SCHEMA =</dt><dd><p>SearchCounter.export(“features_existed_in_old_schema”);</p>
</dd>
</dl>
<p>// Currently our index uses 4 bits to store the facet field id.
public static final int MAX_FACET_FIELD_ID = 15;</p>
<p>public static final String HF_TERM_PAIRS_FIELD = “hf_term_pairs”;
public static final String HF_PHRASE_PAIRS_FIELD = “hf_phrase_pairs”;</p>
<p>private final ImmutableMap&lt;Integer, FieldInfo&gt; fieldSettingsMapById;
private final ImmutableMap&lt;String, FieldInfo&gt; fieldSettingsMapByName;
private final ImmutableMap&lt;String, FeatureConfiguration&gt; featureConfigMapByName;
private final ImmutableMap&lt;Integer, FeatureConfiguration&gt; featureConfigMapById;</p>
<p>&#64;Nullable
private final ThriftAnalyzer defaultAnalyzer;
private final AnalyzerFactory analyzerFactory;</p>
<p>private final ImmutableMap&lt;String, FieldWeightDefault&gt; fieldWeightMap;
private final Map&lt;String, FieldInfo&gt; facetNameToFieldMap = Maps.newHashMap();
private final int numFacetFields;
private final ImmutableSet&lt;FieldInfo&gt; csfFacetFields;</p>
<p>// This is the search result feature schema - it has the definition for all the column stride
// view fields.
private final ThriftSearchFeatureSchema searchFeatureSchema;</p>
<p>private final int majorVersionNumber;
private final int minorVersionNumber;
private final String versionDesc;
private final boolean isVersionOfficial;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Construct a Schema instance with the given ThriftSchema and AnalyzerFactory.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>public ImmutableSchema(ThriftSchema thriftSchema,</dt><dd><blockquote>
<div><p>AnalyzerFactory analyzerFactory,
String featureSchemaVersionPrefix) throws SchemaValidationException {</p>
</div></blockquote>
<p>Pair&lt;Integer, String&gt; versionPair = parseVersionString(thriftSchema.getVersion());
this.majorVersionNumber = thriftSchema.getMajorVersionNumber();
this.minorVersionNumber = thriftSchema.getMinorVersionNumber();
this.versionDesc = versionPair.getSecond();
this.isVersionOfficial = thriftSchema.isVersionIsOfficial();</p>
<p>this.analyzerFactory = analyzerFactory;</p>
<p>Map&lt;Integer, FieldInfo&gt; tmpMap = Maps.newLinkedHashMap();
Set&lt;FieldInfo&gt; tmpSet = Sets.newHashSet();</p>
<dl class="simple">
<dt>if (thriftSchema.isSetDefaultAnalyzer()) {</dt><dd><p>this.defaultAnalyzer = thriftSchema.getDefaultAnalyzer().deepCopy();</p>
</dd>
<dt>} else {</dt><dd><p>this.defaultAnalyzer = null;</p>
</dd>
</dl>
<p>}</p>
<p>Map&lt;Integer, ThriftFieldConfiguration&gt; configs = thriftSchema.getFieldConfigs();</p>
<p>// Collect all the CSF Views, so that we can later verify that they are appropriately
// configured once we’ve processed all the other field settings.
Map&lt;Integer, ThriftFieldConfiguration&gt; csfViewFields = Maps.newHashMap();
boolean requiresHfPairFields = false;
boolean hasHfTermPairField = false;
boolean hasHfPhrasePairField = false;
int numFacets = 0;
for (Map.Entry&lt;Integer, ThriftFieldConfiguration&gt; entry : configs.entrySet()) {</p>
<blockquote>
<div><p>int fieldId = entry.getKey();</p>
<dl class="simple">
<dt>if (tmpMap.containsKey(fieldId)) {</dt><dd><p>throw new SchemaValidationException(“Duplicate field id “ + fieldId);</p>
</dd>
</dl>
<p>}</p>
<p>ThriftFieldConfiguration config = entry.getValue();
FieldInfo fieldInfo = parseThriftFieldSettings(fieldId, config, csfViewFields);
validate(fieldInfo);
if (fieldInfo.getFieldType().isFacetField()) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (numFacets &gt; MAX_FACET_FIELD_ID) {</dt><dd><dl class="simple">
<dt>throw new SchemaValidationException(</dt><dd><p>“Maximum supported facet field ID is:  “ + MAX_FACET_FIELD_ID);</p>
</dd>
</dl>
</dd>
</dl>
<p>}
numFacets++;
facetNameToFieldMap.put(fieldInfo.getFieldType().getFacetName(), fieldInfo);</p>
<dl class="simple">
<dt>if (fieldInfo.getFieldType().isUseCSFForFacetCounting()) {</dt><dd><p>tmpSet.add(fieldInfo);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>tmpMap.put(fieldId, fieldInfo);</p>
<dl class="simple">
<dt>if (fieldInfo.getFieldType().isIndexHFTermPairs()) {</dt><dd><p>requiresHfPairFields = true;</p>
</dd>
</dl>
<p>}
if (fieldInfo.getName().equals(HF_TERM_PAIRS_FIELD)) {</p>
<blockquote>
<div><p>hasHfTermPairField = true;</p>
</div></blockquote>
<p>}
if (fieldInfo.getName().equals(HF_PHRASE_PAIRS_FIELD)) {</p>
<blockquote>
<div><p>hasHfPhrasePairField = true;</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>this.numFacetFields = numFacets;
this.csfFacetFields = ImmutableSet.copyOf(tmpSet);</p>
<p>// If any field requires high frequency term/phrase pair fields, make sure they exist
if (requiresHfPairFields) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (!hasHfTermPairField || !hasHfPhrasePairField) {</dt><dd><dl class="simple">
<dt>throw new SchemaValidationException(</dt><dd><p>“High frequency term/phrase pair fields do not exist in the schema.”);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>this.fieldSettingsMapById = ImmutableMap.copyOf(tmpMap);</p>
<dl class="simple">
<dt>Pair&lt;ImmutableMap&lt;String, FeatureConfiguration&gt;, ImmutableMap&lt;Integer, FeatureConfiguration&gt;&gt;</dt><dd><p>featureConfigMapPair = buildFeatureMaps(csfViewFields);</p>
</dd>
</dl>
<p>this.featureConfigMapByName = featureConfigMapPair.getFirst();
this.featureConfigMapById = featureConfigMapPair.getSecond();</p>
<dl class="simple">
<dt>for (ThriftFieldConfiguration csfViewField<span class="classifier">csfViewFields.values()) {</span></dt><dd><p>SchemaBuilder.verifyCSFViewSettings(configs, csfViewField);</p>
</dd>
</dl>
<p>}</p>
<p>ImmutableMap.Builder&lt;String, FieldInfo&gt; builder = ImmutableMap.builder();</p>
<dl class="simple">
<dt>for (FieldInfo info<span class="classifier">fieldSettingsMapById.values()) {</span></dt><dd><p>info.getFieldType().freeze();
builder.put(info.getName(), info);</p>
</dd>
</dl>
<p>}
this.fieldSettingsMapByName = builder.build();</p>
<p>ImmutableMap.Builder&lt;String, FieldWeightDefault&gt; fieldWeightMapBuilder = ImmutableMap.builder();</p>
<dl>
<dt>for (FieldInfo fi<span class="classifier">getFieldInfos()) {</span></dt><dd><p>// CSF fields are not searchable. All other fields are.
if (fi.getFieldType().isIndexedField()) {</p>
<blockquote>
<div><dl>
<dt>fieldWeightMapBuilder.put(</dt><dd><p>fi.getName(),
new FieldWeightDefault(</p>
<blockquote>
<div><p>fi.getFieldType().isTextSearchableByDefault(),
fi.getFieldType().getTextSearchableFieldWeight()));</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>this.fieldWeightMap = fieldWeightMapBuilder.build();
// Create features with extra Earlybird derived fields, extra fields won’t change the version
// but they do change the checksum.
this.searchFeatureSchema = createSearchResultFeatureSchema(</p>
<blockquote>
<div><p>featureSchemaVersionPrefix, fieldSettingsMapByName, featureConfigMapByName);</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Add a set of features to a schema if they don’t exist yet, and update the schema checksum.</p></li>
<li><p>if there’s conflict, RuntimeException will be thrown.</p></li>
<li><p>Old map won’t be touched, a new map will be returned will old and new data combined.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>public static Map&lt;Integer, ThriftSearchFeatureSchemaEntry&gt; appendToFeatureSchema(</dt><dd><blockquote>
<div><p>Map&lt;Integer, ThriftSearchFeatureSchemaEntry&gt; oldEntryMap,
Set&lt;? extends SearchResultFeature&gt; features) throws SchemaValidationException {</p>
</div></blockquote>
<dl class="simple">
<dt>if (oldEntryMap == null) {</dt><dd><dl class="simple">
<dt>throw new SchemaValidationException(</dt><dd><p>“Cannot append features to schema, the entryMap is null”);</p>
</dd>
</dl>
</dd>
</dl>
<p>}
// make a copy of the existing map
ImmutableMap.Builder&lt;Integer, ThriftSearchFeatureSchemaEntry&gt; builder =</p>
<blockquote>
<div><dl class="simple">
<dt>ImmutableSortedMap.&lt;Integer, ThriftSearchFeatureSchemaEntry&gt;naturalOrder()</dt><dd><p>.putAll(oldEntryMap);</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>for (SearchResultFeature feature<span class="classifier">features) {</span></dt><dd><dl class="simple">
<dt>if (oldEntryMap.containsKey(feature.getId())) {</dt><dd><p>FEATURES_EXISTED_IN_OLD_SCHEMA.increment();</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>builder.put(feature.getId(), new ThriftSearchFeatureSchemaEntry()</dt><dd><p>.setFeatureName(feature.getName())
.setFeatureType(feature.getType()));</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return builder.build();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Append external features to create a new schema.</p></li>
<li><p>&#64;param oldSchema The old schema to build on top of</p></li>
<li><p>&#64;param features a list of features to be appended to the schema</p></li>
<li><p>&#64;param versionSuffix the version suffix, if not-null, it will be attached to the end of</p></li>
<li><p>original schema’s version.</p></li>
<li><p>&#64;return A new schema object with the appended fields</p></li>
<li><p>&#64;throws SchemaValidationException thrown when the checksum cannot be computed</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>public static ThriftSearchFeatureSchema appendToCreateNewFeatureSchema(</dt><dd><blockquote>
<div><p>ThriftSearchFeatureSchema oldSchema,
Set&lt;ExternalTweetFeature&gt; features,
&#64;Nullable String versionSuffix) throws SchemaValidationException {</p>
</div></blockquote>
<p>ThriftSearchFeatureSchema newSchema = new ThriftSearchFeatureSchema();
// copy over all the entries plus the new ones
newSchema.setEntries(appendToFeatureSchema(oldSchema.getEntries(), features));</p>
<p>ThriftSearchFeatureSchemaSpecifier spec = new ThriftSearchFeatureSchemaSpecifier();
// the version is directly inherited or with a suffix
Preconditions.checkArgument(versionSuffix == null || !versionSuffix.isEmpty());
spec.setVersion(versionSuffix == null</p>
<blockquote>
<div><p>? oldSchema.getSchemaSpecifier().getVersion()
: oldSchema.getSchemaSpecifier().getVersion() + versionSuffix);</p>
</div></blockquote>
<p>spec.setChecksum(getChecksum(newSchema.getEntries()));
newSchema.setSchemaSpecifier(spec);
return newSchema;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public FieldInfos getLuceneFieldInfos(Predicate&lt;String&gt; acceptedFields) {</p>
<blockquote>
<div><p>List&lt;org.apache.lucene.index.FieldInfo&gt; acceptedFieldInfos = Lists.newArrayList();
for (FieldInfo fi : getFieldInfos()) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (acceptedFields == null || acceptedFields.apply(fi.getName())) {</dt><dd><p>acceptedFieldInfos.add(convert(fi.getName(), fi.getFieldId(), fi.getFieldType()));</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return new FieldInfos(acceptedFieldInfos.toArray(</p>
<blockquote>
<div><p>new org.apache.lucene.index.FieldInfo[acceptedFieldInfos.size()]));</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
<dl>
<dt>private FieldInfo parseThriftFieldSettings(int fieldId, ThriftFieldConfiguration fieldConfig,</dt><dd><blockquote>
<div><blockquote>
<div><p>Map&lt;Integer, ThriftFieldConfiguration&gt; csfViewFields)</p>
</div></blockquote>
<p>throws SchemaValidationException {</p>
</div></blockquote>
<dl class="simple">
<dt>FieldInfo fieldInfo</dt><dd><p>= new FieldInfo(fieldId, fieldConfig.getFieldName(), new EarlybirdFieldType());</p>
</dd>
</dl>
<p>ThriftFieldSettings fieldSettings = fieldConfig.getSettings();</p>
<p>boolean settingFound = false;</p>
<dl>
<dt>if (fieldSettings.isSetIndexedFieldSettings()) {</dt><dd><dl class="simple">
<dt>if (fieldSettings.isSetCsfFieldSettings() || fieldSettings.isSetCsfViewSettings()) {</dt><dd><dl class="simple">
<dt>throw new SchemaValidationException(“ThriftFieldSettings: Only one of “</dt><dd><ul class="simple">
<li><p>“‘indexedFieldSettings’, ‘csfFieldSettings’, ‘csfViewSettings’ can be set.”);</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>applyIndexedFieldSettings(fieldInfo, fieldSettings.getIndexedFieldSettings());
settingFound = true;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>if (fieldSettings.isSetCsfFieldSettings()) {</dt><dd><dl class="simple">
<dt>if (fieldSettings.isSetIndexedFieldSettings() || fieldSettings.isSetCsfViewSettings()) {</dt><dd><dl class="simple">
<dt>throw new SchemaValidationException(“ThriftFieldSettings: Only one of “</dt><dd><ul class="simple">
<li><p>“‘indexedFieldSettings’, ‘csfFieldSettings’, ‘csfViewSettings’ can be set.”);</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>applyCsfFieldSettings(fieldInfo, fieldSettings.getCsfFieldSettings());
settingFound = true;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>if (fieldSettings.isSetFacetFieldSettings()) {</dt><dd><dl>
<dt>if (!fieldSettings.isSetIndexedFieldSettings() &amp;&amp; !(fieldSettings.isSetCsfFieldSettings()</dt><dd><blockquote>
<div><p>&amp;&amp; fieldSettings.getFacetFieldSettings().isUseCSFForFacetCounting()
&amp;&amp; CAN_FACET_ON_CSF_TYPES.contains(fieldSettings.getCsfFieldSettings().getCsfType()))) {</p>
</div></blockquote>
<dl class="simple">
<dt>throw new SchemaValidationException(“ThriftFieldSettings: ‘facetFieldSettings’ can only be “</dt><dd><ul class="simple">
<li><p>“used in combination with ‘indexedFieldSettings’ or with ‘csfFieldSettings’ “</p></li>
<li><p>“where ‘isUseCSFForFacetCounting’ was set to true and ThriftCSFType is a type that “</p></li>
<li><p>“can be faceted on.”);</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>applyFacetFieldSettings(fieldInfo, fieldSettings.getFacetFieldSettings());
settingFound = true;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>if (fieldSettings.isSetCsfViewSettings()) {</dt><dd><dl class="simple">
<dt>if (fieldSettings.isSetIndexedFieldSettings() || fieldSettings.isSetCsfFieldSettings()) {</dt><dd><dl class="simple">
<dt>throw new SchemaValidationException(“ThriftFieldSettings: Only one of “</dt><dd><ul class="simple">
<li><p>“‘indexedFieldSettings’, ‘csfFieldSettings’, ‘csfViewSettings’ can be set.”);</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>// add this field now, but apply settings later to make sure the base field was added properly
// before
csfViewFields.put(fieldId, fieldConfig);
settingFound = true;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (!settingFound) {</dt><dd><dl class="simple">
<dt>throw new SchemaValidationException(“ThriftFieldSettings: One of ‘indexedFieldSettings’, “</dt><dd><ul class="simple">
<li><p>“‘csfFieldSettings’ or ‘facetFieldSettings’ must be set.”);</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>// search field settings are optional
if (fieldSettings.isSetSearchFieldSettings()) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (!fieldSettings.isSetIndexedFieldSettings()) {</dt><dd><dl class="simple">
<dt>throw new SchemaValidationException(</dt><dd><dl class="simple">
<dt>“ThriftFieldSettings: ‘searchFieldSettings’ can only be “</dt><dd><ul class="simple">
<li><p>“used in combination with ‘indexedFieldSettings’”);</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>applySearchFieldSettings(fieldInfo, fieldSettings.getSearchFieldSettings());</p>
</div></blockquote>
<p>}</p>
<p>return fieldInfo;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void applyCsfFieldSettings(FieldInfo fieldInfo, ThriftCSFFieldSettings settings)</dt><dd><blockquote>
<div><p>throws SchemaValidationException {</p>
</div></blockquote>
<p>// csfType is required - no need to check if it’s set
fieldInfo.getFieldType().setDocValuesType(DocValuesType.NUMERIC);
fieldInfo.getFieldType().setCsfType(settings.getCsfType());</p>
<dl>
<dt>if (settings.isVariableLength()) {</dt><dd><p>fieldInfo.getFieldType().setDocValuesType(DocValuesType.BINARY);
fieldInfo.getFieldType().setCsfVariableLength();</p>
</dd>
<dt>} else {</dt><dd><dl>
<dt>if (settings.isSetFixedLengthSettings()) {</dt><dd><dl class="simple">
<dt>fieldInfo.getFieldType().setCsfFixedLengthSettings(</dt><dd><p>settings.getFixedLengthSettings().getNumValuesPerDoc(),
settings.getFixedLengthSettings().isUpdateable());</p>
</dd>
<dt>if (settings.getFixedLengthSettings().getNumValuesPerDoc() &gt; 1) {</dt><dd><p>fieldInfo.getFieldType().setDocValuesType(DocValuesType.BINARY);</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>throw new SchemaValidationException(</dt><dd><dl class="simple">
<dt>“ThriftCSFFieldSettings: Either variableLength should be set to ‘true’, “</dt><dd><ul class="simple">
<li><p>“or fixedLengthSettings should be set.”);</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>fieldInfo.getFieldType().setCsfLoadIntoRam(settings.isLoadIntoRAM());
if (settings.isSetDefaultValue()) {</p>
<blockquote>
<div><p>fieldInfo.getFieldType().setCsfDefaultValue(settings.getDefaultValue());</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void applyCsfViewFieldSettings(FieldInfo fieldInfo, FieldInfo baseField,</dt><dd><blockquote>
<div><blockquote>
<div><p>ThriftCSFViewSettings settings)</p>
</div></blockquote>
<p>throws SchemaValidationException {</p>
</div></blockquote>
<p>// csfType is required - no need to check if it’s set
fieldInfo.getFieldType().setDocValuesType(DocValuesType.NUMERIC);
fieldInfo.getFieldType().setCsfType(settings.getCsfType());</p>
<dl class="simple">
<dt>fieldInfo.getFieldType().setCsfFixedLengthSettings(1 /* numValuesPerDoc*/,</dt><dd><p>false /* updateable*/);</p>
</dd>
</dl>
<p>fieldInfo.getFieldType().setCsfViewSettings(fieldInfo.getName(), settings, baseField);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void applyFacetFieldSettings(FieldInfo fieldInfo, ThriftFacetFieldSettings settings) {</dt><dd><dl class="simple">
<dt>if (settings.isSetFacetName()) {</dt><dd><p>fieldInfo.getFieldType().setFacetName(settings.getFacetName());</p>
</dd>
<dt>} else {</dt><dd><p>// fall back to field name if no facet name is explicitly provided
fieldInfo.getFieldType().setFacetName(fieldInfo.getName());</p>
</dd>
</dl>
<p>}
fieldInfo.getFieldType().setStoreFacetSkiplist(settings.isStoreSkiplist());
fieldInfo.getFieldType().setStoreFacetOffensiveCounters(settings.isStoreOffensiveCounters());
fieldInfo.getFieldType().setUseCSFForFacetCounting(settings.isUseCSFForFacetCounting());</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void applyIndexedFieldSettings(FieldInfo fieldInfo, ThriftIndexedFieldSettings settings)</dt><dd><blockquote>
<div><p>throws SchemaValidationException {</p>
</div></blockquote>
<p>fieldInfo.getFieldType().setIndexedField(true);
fieldInfo.getFieldType().setStored(settings.isStored());
fieldInfo.getFieldType().setTokenized(settings.isTokenized());
fieldInfo.getFieldType().setStoreTermVectors(settings.isStoreTermVectors());
fieldInfo.getFieldType().setStoreTermVectorOffsets(settings.isStoreTermVectorOffsets());
fieldInfo.getFieldType().setStoreTermVectorPositions(settings.isStoreTermVectorPositions());
fieldInfo.getFieldType().setStoreTermVectorPayloads(settings.isStoreTermVectorPayloads());
fieldInfo.getFieldType().setOmitNorms(settings.isOmitNorms());
fieldInfo.getFieldType().setIndexHFTermPairs(settings.isIndexHighFreqTermPairs());
fieldInfo.getFieldType().setUseTweetSpecificNormalization(</p>
<blockquote>
<div><p>settings.deprecated_performTweetSpecificNormalizations);</p>
</div></blockquote>
<dl>
<dt>if (settings.isSetIndexOptions()) {</dt><dd><dl>
<dt>switch (settings.getIndexOptions()) {</dt><dd><dl>
<dt>case DOCS_ONLY :</dt><dd><p>fieldInfo.getFieldType().setIndexOptions(IndexOptions.DOCS);
break;</p>
</dd>
<dt>case DOCS_AND_FREQS :</dt><dd><p>fieldInfo.getFieldType().setIndexOptions(IndexOptions.DOCS_AND_FREQS);
break;</p>
</dd>
<dt>case DOCS_AND_FREQS_AND_POSITIONS :</dt><dd><p>fieldInfo.getFieldType().setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);
break;</p>
</dd>
<dt>case DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS :</dt><dd><dl class="simple">
<dt>fieldInfo.getFieldType().setIndexOptions(</dt><dd><p>IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS);</p>
</dd>
</dl>
<p>break;</p>
</dd>
<dt>default:</dt><dd><dl class="simple">
<dt>throw new SchemaValidationException(“Unknown value for IndexOptions: “</dt><dd><ul class="simple">
<li><p>settings.getIndexOptions());</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else if (settings.isIndexed()) {</dt><dd><p>// default for backward-compatibility
fieldInfo.getFieldType().setIndexOptions(IndexOptions.DOCS_AND_FREQS_AND_POSITIONS);</p>
</dd>
</dl>
<p>}</p>
<p>fieldInfo.getFieldType().setStorePerPositionPayloads(settings.isStorePerPositionPayloads());
fieldInfo.getFieldType().setDefaultPayloadLength(</p>
<blockquote>
<div><p>settings.getDefaultPerPositionPayloadLength());</p>
</div></blockquote>
<p>fieldInfo.getFieldType().setBecomesImmutable(!settings.isSupportOutOfOrderAppends());
fieldInfo.getFieldType().setSupportOrderedTerms(settings.isSupportOrderedTerms());
fieldInfo.getFieldType().setSupportTermTextLookup(settings.isSupportTermTextLookup());</p>
<dl class="simple">
<dt>if (settings.isSetNumericFieldSettings()) {</dt><dd><dl class="simple">
<dt>fieldInfo.getFieldType().setNumericFieldSettings(</dt><dd><p>new IndexedNumericFieldSettings(settings.getNumericFieldSettings()));</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (settings.isSetTokenStreamSerializer()) {</dt><dd><dl class="simple">
<dt>fieldInfo.getFieldType().setTokenStreamSerializerBuilder(</dt><dd><p>buildTokenStreamSerializerProvider(settings.getTokenStreamSerializer()));</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void applySearchFieldSettings(FieldInfo fieldInfo, ThriftSearchFieldSettings settings)</dt><dd><blockquote>
<div><p>throws SchemaValidationException {</p>
</div></blockquote>
<dl class="simple">
<dt>fieldInfo.getFieldType().setTextSearchableFieldWeight(</dt><dd><p>(float) settings.getTextSearchableFieldWeight());</p>
</dd>
</dl>
<p>fieldInfo.getFieldType().setTextSearchableByDefault(settings.isTextDefaultSearchable());</p>
</dd>
</dl>
<p>}</p>
<p>private void validate(FieldInfo fieldInfo) throws SchemaValidationException {
}</p>
<dl>
<dt>private TokenStreamSerializer.Builder buildTokenStreamSerializerProvider(</dt><dd><blockquote>
<div><p>final ThriftTokenStreamSerializer settings) {</p>
</div></blockquote>
<p>TokenStreamSerializer.Builder builder = TokenStreamSerializer.builder();
for (String serializerName : settings.getAttributeSerializerClassNames()) {</p>
<blockquote>
<div><dl class="simple">
<dt>try {</dt><dd><dl class="simple">
<dt>builder.add((TokenStreamSerializer.AttributeSerializer) Class.forName(serializerName)</dt><dd><p>.newInstance());</p>
</dd>
</dl>
</dd>
<dt>} catch (InstantiationException e) {</dt><dd><dl class="simple">
<dt>throw new RuntimeException(</dt><dd><p>“Unable to instantiate AttributeSerializer for name “ + serializerName);</p>
</dd>
</dl>
</dd>
<dt>} catch (IllegalAccessException e) {</dt><dd><dl class="simple">
<dt>throw new RuntimeException(</dt><dd><p>“Unable to instantiate AttributeSerializer for name “ + serializerName);</p>
</dd>
</dl>
</dd>
<dt>} catch (ClassNotFoundException e) {</dt><dd><dl class="simple">
<dt>throw new RuntimeException(</dt><dd><p>“Unable to instantiate AttributeSerializer for name “ + serializerName);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return builder;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public FacetsConfig getFacetsConfig() {</p>
<blockquote>
<div><p>FacetsConfig facetsConfig = new FacetsConfig();</p>
<dl class="simple">
<dt>for (String facetName<span class="classifier">facetNameToFieldMap.keySet()) {</span></dt><dd><p>// set multiValued = true as default, since we’re using SortedSetDocValues facet, in which,
// there is no difference between multiValued true or false for the real facet, but only the
// checking of the values.
facetsConfig.setMultiValued(facetName, true);</p>
</dd>
</dl>
<p>}</p>
<p>return facetsConfig;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public Analyzer getDefaultAnalyzer(ThriftAnalyzer override) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (override != null) {</dt><dd><p>return analyzerFactory.getAnalyzer(override);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (defaultAnalyzer != null) {</dt><dd><p>return analyzerFactory.getAnalyzer(defaultAnalyzer);</p>
</dd>
</dl>
<p>}</p>
<p>return new SearchWhitespaceAnalyzer();</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public ImmutableCollection&lt;FieldInfo&gt; getFieldInfos() {</p>
<blockquote>
<div><p>return fieldSettingsMapById.values();</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>This is the preferred method to check whether a field configuration is in schema.</p></li>
<li><p>One can also use getFieldInfo and do null checks, but should be careful about excessive</p></li>
<li><p>warning logging resulting from looking up fields not in schema.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
</dl>
<p>&#64;Override
public boolean hasField(int fieldConfigId) {</p>
<blockquote>
<div><p>return fieldSettingsMapById.containsKey(fieldConfigId);</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>This is the preferred method to check whether a field configuration is in schema.</p></li>
<li><p>One can also use getFieldInfo and do null checks, but should be careful about excessive</p></li>
<li><p>warning logging resulting from looking up fields not in schema.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
</dl>
<p>&#64;Override
public boolean hasField(String fieldName) {</p>
<blockquote>
<div><p>return fieldSettingsMapByName.containsKey(fieldName);</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Get FieldInfo for the given field id.</p></li>
<li><p>If the goal is to check whether a field is in the schema, use <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #hasField(int)} instead.</p></li>
<li><p>This method logs a warning whenever it returns null.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
</dl>
<p>&#64;Override
&#64;Nullable
public FieldInfo getFieldInfo(int fieldConfigId) {</p>
<blockquote>
<div><p>return getFieldInfo(fieldConfigId, null);</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private org.apache.lucene.index.FieldInfo convert(String fieldName,</dt><dd><blockquote>
<div><p>int index,
EarlybirdFieldType type) {</p>
</div></blockquote>
<dl class="simple">
<dt>return new org.apache.lucene.index.FieldInfo(</dt><dd><p>fieldName,                          // String name
index,                              // int number
type.storeTermVectors(),            // boolean storeTermVector
type.omitNorms(),                   // boolean omitNorms
type.isStorePerPositionPayloads(),  // boolean storePayloads
type.indexOptions(),                // IndexOptions indexOptions
type.docValuesType(),               // DocValuesType docValues
-1,                                 // long dvGen
Maps.&lt;String, String&gt;newHashMap(),  // Map&lt;String, String&gt; attributes
0,                                  // int pointDataDimensionCount
0,                                  // int pointIndexDimensionCount
0,                                  // int pointNumBytes
false);                             // boolean softDeletesField</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Get FieldInfo for the given field name, or null if the field does not exist.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
</dl>
<p>&#64;Override
&#64;Nullable
public FieldInfo getFieldInfo(String fieldName) {</p>
<blockquote>
<div><p>return fieldSettingsMapByName.get(fieldName);</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public String getFieldName(int fieldConfigId) {</p>
<blockquote>
<div><p>FieldInfo fieldInfo = fieldSettingsMapById.get(fieldConfigId);
return fieldInfo != null ? fieldInfo.getName() : null;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public FieldInfo getFieldInfo(int fieldConfigId, ThriftFieldConfiguration override) {</p>
<blockquote>
<div><p>FieldInfo fieldInfo = fieldSettingsMapById.get(fieldConfigId);
if (fieldInfo == null) {</p>
<blockquote>
<div><p>// This method is used to check the availability of fields by IDs,
// so no warning is logged here (would be too verbose otherwise).
return null;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>if (override != null) {</dt><dd><dl class="simple">
<dt>try {</dt><dd><p>return merge(fieldConfigId, fieldInfo, override);</p>
</dd>
<dt>} catch (SchemaValidationException e) {</dt><dd><p>throw new RuntimeException(e);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>return fieldInfo;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public int getNumFacetFields() {</p>
<blockquote>
<div><p>return numFacetFields;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public FieldInfo getFacetFieldByFacetName(String facetName) {</p>
<blockquote>
<div><p>return facetNameToFieldMap.get(facetName);</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public FieldInfo getFacetFieldByFieldName(String fieldName) {</p>
<blockquote>
<div><p>FieldInfo fieldInfo = getFieldInfo(fieldName);
return fieldInfo != null &amp;&amp; fieldInfo.getFieldType().isFacetField() ? fieldInfo : null;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public Collection&lt;FieldInfo&gt; getFacetFields() {</p>
<blockquote>
<div><p>return facetNameToFieldMap.values();</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public Collection&lt;FieldInfo&gt; getCsfFacetFields() {</p>
<blockquote>
<div><p>return csfFacetFields;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public String getVersionDescription() {</p>
<blockquote>
<div><p>return versionDesc;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public int getMajorVersionNumber() {</p>
<blockquote>
<div><p>return majorVersionNumber;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public int getMinorVersionNumber() {</p>
<blockquote>
<div><p>return minorVersionNumber;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public boolean isVersionOfficial() {</p>
<blockquote>
<div><p>return isVersionOfficial;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Parses a version string like “16: renamed field x into y” into a version number and</p></li>
<li><p>a string description.</p></li>
<li><p>&#64;return a Pair of the version number and the description</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>private static Pair&lt;Integer, String&gt; parseVersionString(String version)</dt><dd><blockquote>
<div><p>throws SchemaValidationException {</p>
</div></blockquote>
<p>Preconditions.checkNotNull(version, “Schema must have a version number and description.”);
int colonIndex = version.indexOf(‘:’);
if (colonIndex == -1) {</p>
<blockquote>
<div><p>throw new SchemaValidationException(“Malformed version string: “ + version);</p>
</div></blockquote>
<p>}
try {</p>
<blockquote>
<div><p>int versionNumber = Integer.parseInt(version.substring(0, colonIndex));
String versionDesc = version.substring(colonIndex + 1);
return Pair.of(versionNumber, versionDesc);</p>
</div></blockquote>
<dl class="simple">
<dt>} catch (Exception e) {</dt><dd><p>throw new SchemaValidationException(“Malformed version string: “ + version, e);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public Map&lt;String, FieldWeightDefault&gt; getFieldWeightMap() {</p>
<blockquote>
<div><p>return fieldWeightMap;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Build the feature maps so that we can use feature name to get the feature configuration.</p></li>
<li><p>&#64;return: an immutable map keyed on fieldName.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>private Pair&lt;ImmutableMap&lt;String, FeatureConfiguration&gt;,</dt><dd><blockquote>
<div><p>ImmutableMap&lt;Integer, FeatureConfiguration&gt;&gt; buildFeatureMaps(
final Map&lt;Integer, ThriftFieldConfiguration&gt; csvViewFields)
throws SchemaValidationException {</p>
</div></blockquote>
<dl>
<dt>final ImmutableMap.Builder&lt;String, FeatureConfiguration&gt; featureConfigMapByNameBuilder =</dt><dd><p>ImmutableMap.builder();</p>
</dd>
<dt>final ImmutableMap.Builder&lt;Integer, FeatureConfiguration&gt; featureConfigMapByIdBuilder =</dt><dd><p>ImmutableMap.builder();</p>
</dd>
<dt>for (final Map.Entry&lt;Integer, ThriftFieldConfiguration&gt; entry<span class="classifier">csvViewFields.entrySet()) {</span></dt><dd><p>ThriftFieldSettings fieldSettings = entry.getValue().getSettings();
FieldInfo fieldInfo = getFieldInfo(entry.getKey());
FieldInfo baseFieldInfo =</p>
<blockquote>
<div><p>getFieldInfo(fieldSettings.getCsfViewSettings().getBaseFieldConfigId());</p>
</div></blockquote>
<dl class="simple">
<dt>if (baseFieldInfo == null) {</dt><dd><dl class="simple">
<dt>throw new SchemaValidationException(“Base field (id=”</dt><dd><ul class="simple">
<li><p>fieldSettings.getCsfViewSettings().getBaseFieldConfigId() + “) not found.”);</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>}
applyCsfViewFieldSettings(fieldInfo, baseFieldInfo, fieldSettings.getCsfViewSettings());</p>
<dl class="simple">
<dt>FeatureConfiguration featureConfig = fieldInfo.getFieldType()</dt><dd><p>.getCsfViewFeatureConfiguration();</p>
</dd>
<dt>if (featureConfig != null) {</dt><dd><p>featureConfigMapByNameBuilder.put(fieldInfo.getName(), featureConfig);
featureConfigMapByIdBuilder.put(fieldInfo.getFieldId(), featureConfig);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>return Pair.of(featureConfigMapByNameBuilder.build(), featureConfigMapByIdBuilder.build());</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public FeatureConfiguration getFeatureConfigurationByName(String featureName) {</p>
<blockquote>
<div><p>return featureConfigMapByName.get(featureName);</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public FeatureConfiguration getFeatureConfigurationById(int featureFieldId) {</p>
<blockquote>
<div><dl class="simple">
<dt>return Preconditions.checkNotNull(featureConfigMapById.get(featureFieldId),</dt><dd><p>“Field ID: “ + featureFieldId);</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>&#64;Override
&#64;Nullable
public ThriftCSFType getCSFFieldType(String fieldName) {</p>
<blockquote>
<div><p>FieldInfo fieldInfo = getFieldInfo(fieldName);
if (fieldInfo == null) {</p>
<blockquote>
<div><p>return null;</p>
</div></blockquote>
<p>}</p>
<p>EarlybirdFieldType fieldType = fieldInfo.getFieldType();
if (fieldType.docValuesType() != org.apache.lucene.index.DocValuesType.NUMERIC) {</p>
<blockquote>
<div><p>return null;</p>
</div></blockquote>
<p>}</p>
<p>return fieldType.getCsfType();</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public ImmutableSchemaInterface getSchemaSnapshot() {</p>
<blockquote>
<div><p>return this;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private FieldInfo merge(int fieldConfigId,</dt><dd><blockquote>
<div><blockquote>
<div><p>FieldInfo fieldInfo,
ThriftFieldConfiguration overrideConfig)</p>
</div></blockquote>
<p>throws SchemaValidationException {</p>
</div></blockquote>
<p>throw new UnsupportedOperationException(“Field override config not supported”);</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public ThriftSearchFeatureSchema getSearchFeatureSchema() {</p>
<blockquote>
<div><p>return searchFeatureSchema;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public ImmutableMap&lt;Integer, FeatureConfiguration&gt; getFeatureIdToFeatureConfig() {</p>
<blockquote>
<div><p>return featureConfigMapById;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public ImmutableMap&lt;String, FeatureConfiguration&gt; getFeatureNameToFeatureConfig() {</p>
<blockquote>
<div><p>return featureConfigMapByName;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private ThriftSearchFeatureSchema createSearchResultFeatureSchema(</dt><dd><blockquote>
<div><p>String featureSchemaVersionPrefix,
Map&lt;String, FieldInfo&gt; allFieldSettings,
Map&lt;String, FeatureConfiguration&gt; featureConfigurations) throws SchemaValidationException {</p>
</div></blockquote>
<dl>
<dt>final ImmutableMap.Builder&lt;Integer, ThriftSearchFeatureSchemaEntry&gt; builder =</dt><dd><p>new ImmutableMap.Builder&lt;&gt;();</p>
</dd>
<dt>for (Map.Entry&lt;String, FieldInfo&gt; field<span class="classifier">allFieldSettings.entrySet()) {</span></dt><dd><p>FeatureConfiguration featureConfig = featureConfigurations.get(field.getKey());
if (featureConfig == null) {</p>
<blockquote>
<div><p>// This is either a not csf related field or a csf field.
continue;</p>
</div></blockquote>
<p>}</p>
<p>// This is a csfView field.
if (featureConfig.getOutputType() == null) {</p>
<blockquote>
<div><p>LOG.info(“Skip unused fieldschemas: {} for search feature schema.”, field.getKey());
continue;</p>
</div></blockquote>
<p>}</p>
<p>ThriftSearchFeatureType featureType = getResultFeatureType(featureConfig.getOutputType());
if (featureType != null) {</p>
<blockquote>
<div><dl class="simple">
<dt>builder.put(</dt><dd><p>field.getValue().getFieldId(),
new ThriftSearchFeatureSchemaEntry(field.getKey(), featureType));</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>LOG.error(“Invalid CSFType encountered for csf field: {}”, field.getKey());</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
Map&lt;Integer, ThriftSearchFeatureSchemaEntry&gt; indexOnlySchemaEntries = builder.build();</p>
<p>// Add earlybird derived features, they are defined in ExternalTweetFeatures and used in the
// scoring function. They are no different from those auto-generated index-based features
// viewed from outside Earlybird.
Map&lt;Integer, ThriftSearchFeatureSchemaEntry&gt; entriesWithEBFeatures =</p>
<blockquote>
<div><dl class="simple">
<dt>appendToFeatureSchema(</dt><dd><p>indexOnlySchemaEntries, ExternalTweetFeature.EARLYBIRD_DERIVED_FEATURES);</p>
</dd>
</dl>
</div></blockquote>
<p>// Add other features needed for tweet ranking from EarlybirdRankingDerivedFeature.
Map&lt;Integer, ThriftSearchFeatureSchemaEntry&gt; allSchemaEntries = appendToFeatureSchema(</p>
<blockquote>
<div><p>entriesWithEBFeatures, ExternalTweetFeature.EARLYBIRD_RANKING_DERIVED_FEATURES);</p>
</div></blockquote>
<p>long schemaEntriesChecksum = getChecksum(allSchemaEntries);
SearchLongGauge.export(“feature_schema_checksum”, new AtomicLong(schemaEntriesChecksum));</p>
<dl class="simple">
<dt>String schemaVersion = String.format(</dt><dd><p>“%s.%d.%d”, featureSchemaVersionPrefix, majorVersionNumber, minorVersionNumber);</p>
</dd>
<dt>ThriftSearchFeatureSchemaSpecifier schemaSpecifier =</dt><dd><p>new ThriftSearchFeatureSchemaSpecifier(schemaVersion, schemaEntriesChecksum);</p>
</dd>
</dl>
<p>ThriftSearchFeatureSchema schema = new ThriftSearchFeatureSchema();
schema.setSchemaSpecifier(schemaSpecifier);
schema.setEntries(allSchemaEntries);</p>
<p>return schema;</p>
</dd>
</dl>
<p>}</p>
<p>// Serializes schemaEntries to a byte array, and computes a CRC32 checksum of the array.
// The serialization needs to be stable: if schemaEntries1.equals(schemaEntries2), we want
// this method to produce the same checksum for schemaEntrie1 and schemaEntrie2, even if
// the checksums are computed in different JVMs, etc.
private static long getChecksum(Map&lt;Integer, ThriftSearchFeatureSchemaEntry&gt; schemaEntries)</p>
<blockquote>
<div><blockquote>
<div><p>throws SchemaValidationException {</p>
</div></blockquote>
<dl class="simple">
<dt>SortedMap&lt;Integer, ThriftSearchFeatureSchemaEntry&gt; sortedSchemaEntries =</dt><dd><p>new TreeMap&lt;Integer, ThriftSearchFeatureSchemaEntry&gt;(schemaEntries);</p>
</dd>
</dl>
<p>CRC32OutputStream crc32OutputStream = new CRC32OutputStream();
ObjectOutputStream objectOutputStream = null;
try {</p>
<blockquote>
<div><p>objectOutputStream = new ObjectOutputStream(crc32OutputStream);
for (Integer fieldId : sortedSchemaEntries.keySet()) {</p>
<blockquote>
<div><p>objectOutputStream.writeObject(fieldId);
ThriftSearchFeatureSchemaEntry schemaEntry = sortedSchemaEntries.get(fieldId);
objectOutputStream.writeObject(schemaEntry.getFeatureName());
objectOutputStream.writeObject(schemaEntry.getFeatureType());</p>
</div></blockquote>
<p>}
objectOutputStream.flush();
return crc32OutputStream.getValue();</p>
</div></blockquote>
<dl>
<dt>} catch (IOException e) {</dt><dd><p>throw new SchemaValidationException(“Could not serialize feature schema entries.”, e);</p>
</dd>
<dt>} finally {</dt><dd><p>Preconditions.checkNotNull(objectOutputStream);
try {</p>
<blockquote>
<div><p>objectOutputStream.close();</p>
</div></blockquote>
<dl class="simple">
<dt>} catch (IOException e) {</dt><dd><p>throw new SchemaValidationException(“Could not close ObjectOutputStream.”, e);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Get the search feature type based on the csf type.</p></li>
<li><p>&#64;param csfType the column stride field type for the data</p></li>
<li><p>&#64;return the corresponding search feature type</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
</dl>
<p>&#64;VisibleForTesting
public static ThriftSearchFeatureType getResultFeatureType(ThriftCSFType csfType) {</p>
<blockquote>
<div><dl>
<dt>switch (csfType) {</dt><dd><p>case INT:
case BYTE:</p>
<blockquote>
<div><p>return ThriftSearchFeatureType.INT32_VALUE;</p>
</div></blockquote>
<dl class="simple">
<dt>case BOOLEAN:</dt><dd><p>return ThriftSearchFeatureType.BOOLEAN_VALUE;</p>
</dd>
</dl>
<p>case FLOAT:
case DOUBLE:</p>
<blockquote>
<div><p>return ThriftSearchFeatureType.DOUBLE_VALUE;</p>
</div></blockquote>
<dl class="simple">
<dt>case LONG:</dt><dd><p>return ThriftSearchFeatureType.LONG_VALUE;</p>
</dd>
<dt>default:</dt><dd><p>return null;</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../_sources/src/java/com/twitter/search/common/schema/ImmutableSchema.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>