<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../" id="documentation_options" src="../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.common.query;</p>
<p>import java.io.IOException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;</p>
<p>import org.apache.lucene.index.FilteredTermsEnum;
import org.apache.lucene.index.IndexReader;
import org.apache.lucene.index.LeafReaderContext;
import org.apache.lucene.index.PostingsEnum;
import org.apache.lucene.index.Term;
import org.apache.lucene.index.TermState;
import org.apache.lucene.index.TermStates;
import org.apache.lucene.index.Terms;
import org.apache.lucene.index.TermsEnum;
import org.apache.lucene.search.BooleanClause.Occur;
import org.apache.lucene.search.BooleanQuery;
import org.apache.lucene.search.BulkScorer;
import org.apache.lucene.search.ConstantScoreQuery;
import org.apache.lucene.search.ConstantScoreScorer;
import org.apache.lucene.search.ConstantScoreWeight;
import org.apache.lucene.search.DocIdSet;
import org.apache.lucene.search.DocIdSetIterator;
import org.apache.lucene.search.IndexSearcher;
import org.apache.lucene.search.MultiTermQuery;
import org.apache.lucene.search.Query;
import org.apache.lucene.search.Scorer;
import org.apache.lucene.search.ScoreMode;
import org.apache.lucene.search.TermQuery;
import org.apache.lucene.search.Weight;
import org.apache.lucene.util.AttributeSource;
import org.apache.lucene.util.BytesRef;
import org.apache.lucene.util.DocIdSetBuilder;</p>
<p>import com.twitter.search.common.schema.base.ImmutableSchemaInterface;
import com.twitter.search.common.schema.base.IndexedNumericFieldSettings;
import com.twitter.search.common.util.analysis.LongTermAttributeImpl;
import com.twitter.search.common.util.analysis.SortableLongTermAttributeImpl;
import com.twitter.search.queryparser.query.QueryParserException;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>An extension of Lucene’s MultiTermQuery which creates a disjunction of</p></li>
<li><p>long ID terms. Lucene tries to rewrite the Query depending on the number</p></li>
<li><p>of clauses to perform as efficiently as possible.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public class IDDisjunctionQuery extends MultiTermQuery {</dt><dd><p>private final List&lt;Long&gt; ids;
private final boolean useOrderPreservingEncoding;</p>
<p>/** Creates a new IDDisjunctionQuery instance. <a href="#id3"><span class="problematic" id="id4">*</span></a>/
public IDDisjunctionQuery(List&lt;Long&gt; ids, String field, ImmutableSchemaInterface schemaSnapshot)</p>
<blockquote>
<div><blockquote>
<div><p>throws QueryParserException {</p>
</div></blockquote>
<p>super(field);
this.ids = ids;</p>
<p>setRewriteMethod(new Rewrite());</p>
<dl class="simple">
<dt>if (!schemaSnapshot.hasField(field)) {</dt><dd><dl class="simple">
<dt>throw new QueryParserException(</dt><dd><p>“Tried to search a field which does not exist in schema: “ + field);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>IndexedNumericFieldSettings numericFieldSettings =</dt><dd><p>schemaSnapshot.getFieldInfo(field).getFieldType().getNumericFieldSettings();</p>
</dd>
<dt>if (numericFieldSettings == null) {</dt><dd><p>throw new QueryParserException(“Requested id field is not numerical: “ + field);</p>
</dd>
</dl>
<p>}</p>
<p>this.useOrderPreservingEncoding = numericFieldSettings.isUseSortableEncoding();</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Work around for an issue where LongTerms are not valid utf8, so calling</p></li>
<li><p>toString on any TermQuery containing a LongTerm may cause exceptions.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>private class Rewrite extends RewriteMethod {</dt><dd><p>&#64;Override
public Query rewrite(IndexReader reader, MultiTermQuery query) throws IOException {</p>
<blockquote>
<div><dl class="simple">
<dt>Query result = new MultiTermQueryConstantScoreWrapper(</dt><dd><p>(IDDisjunctionQuery) query, useOrderPreservingEncoding);</p>
</dd>
</dl>
<p>return result;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
protected TermsEnum getTermsEnum(final Terms terms, AttributeSource atts) throws IOException {</p>
<blockquote>
<div><p>final Iterator&lt;Long&gt; it = this.ids.iterator();
final TermsEnum termsEnum = terms.iterator();</p>
<dl>
<dt>return new FilteredTermsEnum(termsEnum) {</dt><dd><dl class="simple">
<dt>private final BytesRef term = useOrderPreservingEncoding</dt><dd><p>? SortableLongTermAttributeImpl.newBytesRef()
: LongTermAttributeImpl.newBytesRef();</p>
</dd>
<dt>&#64;Override protected AcceptStatus accept(BytesRef term) throws IOException {</dt><dd><p>return AcceptStatus.YES;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>&#64;Override public BytesRef next() throws IOException {</dt><dd><dl>
<dt>while (it.hasNext()) {</dt><dd><p>Long longTerm = it.next();
if (useOrderPreservingEncoding) {</p>
<blockquote>
<div><p>SortableLongTermAttributeImpl.copyLongToBytesRef(term, longTerm);</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>LongTermAttributeImpl.copyLongToBytesRef(term, longTerm);</p>
</dd>
</dl>
<p>}
if (termsEnum.seekExact(term)) {</p>
<blockquote>
<div><p>return term;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>return null;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>};</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public String toString(String field) {</p>
<blockquote>
<div><p>StringBuilder builder = new StringBuilder();
builder.append(“IDDisjunction[“).append(this.field).append(“:”);
for (Long id : this.ids) {</p>
<blockquote>
<div><p>builder.append(id);
builder.append(“,”);</p>
</div></blockquote>
<p>}
builder.setLength(builder.length() - 1);
builder.append(“]”);
return builder.toString();</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private static class TermQueryWithToString extends TermQuery {</dt><dd><p>private final boolean useOrderPreservingEncoding;</p>
<dl class="simple">
<dt>public TermQueryWithToString(Term t, TermStates states, boolean useOrderPreservingEncoding) {</dt><dd><p>super(t, states);
this.useOrderPreservingEncoding = useOrderPreservingEncoding;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public String toString(String field) {</p>
<blockquote>
<div><p>StringBuilder buffer = new StringBuilder();
if (!getTerm().field().equals(field)) {</p>
<blockquote>
<div><p>buffer.append(getTerm().field());
buffer.append(“:”);</p>
</div></blockquote>
<p>}
long longTerm;
BytesRef termBytes = getTerm().bytes();
if (useOrderPreservingEncoding) {</p>
<blockquote>
<div><p>longTerm = SortableLongTermAttributeImpl.copyBytesRefToLong(termBytes);</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>longTerm = LongTermAttributeImpl.copyBytesRefToLong(termBytes);</p>
</dd>
</dl>
<p>}
buffer.append(longTerm);
return buffer.toString();</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>This class provides the functionality behind <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> MultiTermQuery#CONSTANT_SCORE_REWRITE}.</p></li>
<li><p>It tries to rewrite per-segment as a boolean query that returns a constant score and otherwise</p></li>
<li><p>fills a DocIdSet with matches and builds a Scorer on top of this DocIdSet.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>static final class MultiTermQueryConstantScoreWrapper extends Query {</dt><dd><p>// disable the rewrite option which will scan all posting lists sequentially and perform
// the intersection using a temporary DocIdSet. In earlybird this mode is slower than a “normal”
// disjunctive BooleanQuery, due to early termination and the fact that everything is in memory.
private static final int BOOLEAN_REWRITE_TERM_COUNT_THRESHOLD = 3000;</p>
<dl>
<dt>private static class TermAndState {</dt><dd><p>private final BytesRef term;
private final TermState state;
private final int docFreq;
private final long totalTermFreq;</p>
<dl class="simple">
<dt>TermAndState(BytesRef term, TermState state, int docFreq, long totalTermFreq) {</dt><dd><p>this.term = term;
this.state = state;
this.docFreq = docFreq;
this.totalTermFreq = totalTermFreq;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private static class WeightOrDocIdSet {</dt><dd><p>private final Weight weight;
private final DocIdSet docIdSet;</p>
<dl class="simple">
<dt>WeightOrDocIdSet(Weight weight) {</dt><dd><p>this.weight = Objects.requireNonNull(weight);
this.docIdSet = null;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>WeightOrDocIdSet(DocIdSet docIdSet) {</dt><dd><p>this.docIdSet = docIdSet;
this.weight = null;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>protected final IDDisjunctionQuery query;
private final boolean useOrderPreservingEncoding;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Wrap a <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> MultiTermQuery} as a Filter.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>protected MultiTermQueryConstantScoreWrapper(</dt><dd><blockquote>
<div><p>IDDisjunctionQuery query,
boolean useOrderPreservingEncoding) {</p>
</div></blockquote>
<p>this.query = query;
this.useOrderPreservingEncoding = useOrderPreservingEncoding;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public String toString(String field) {</p>
<blockquote>
<div><p>// query.toString should be ok for the filter, too, if the query boost is 1.0f
return query.toString(field);</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public boolean equals(Object obj) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (!(obj instanceof MultiTermQueryConstantScoreWrapper)) {</dt><dd><p>return false;</p>
</dd>
</dl>
<p>}</p>
<p>return query.equals(MultiTermQueryConstantScoreWrapper.class.cast(obj).query);</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public int hashCode() {</p>
<blockquote>
<div><p>return query == null ? 0 : query.hashCode();</p>
</div></blockquote>
<p>}</p>
<p>/** Returns the field name for this query <a href="#id11"><span class="problematic" id="id12">*</span></a>/
public String getField() {</p>
<blockquote>
<div><p>return query.getField();</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>private List&lt;Long&gt; getIDs() {</dt><dd><p>return query.ids;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public Weight createWeight(</p>
<blockquote>
<div><blockquote>
<div><p>final IndexSearcher searcher,
final ScoreMode scoreMode,
final float boost) throws IOException {</p>
</div></blockquote>
<dl>
<dt>return new ConstantScoreWeight(this, boost) {</dt><dd><dl>
<dt>/** Try to collect terms from the given terms enum and return true iff all</dt><dd><ul class="simple">
<li><p>terms could be collected. If <a class="reference external" href="mailto:{&#37;&#52;&#48;code">{<span>&#64;</span>code</a> false} is returned, the enum is</p></li>
<li><p>left positioned on the next term. <a href="#id13"><span class="problematic" id="id14">*</span></a>/</p></li>
</ul>
</dd>
<dt>private boolean collectTerms(LeafReaderContext context,</dt><dd><blockquote>
<div><p>TermsEnum termsEnum,
List&lt;TermAndState&gt; terms) throws IOException {</p>
</div></blockquote>
<dl>
<dt>final int threshold = Math.min(BOOLEAN_REWRITE_TERM_COUNT_THRESHOLD,</dt><dd><p>BooleanQuery.getMaxClauseCount());</p>
</dd>
<dt>for (int i = 0; i &lt; threshold; ++i) {</dt><dd><p>final BytesRef term = termsEnum.next();
if (term == null) {</p>
<blockquote>
<div><p>return true;</p>
</div></blockquote>
<p>}
TermState state = termsEnum.termState();
terms.add(new TermAndState(BytesRef.deepCopyOf(term),</p>
<blockquote>
<div><p>state,
termsEnum.docFreq(),
termsEnum.totalTermFreq()));</p>
</div></blockquote>
</dd>
</dl>
<p>}
return termsEnum.next() == null;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>On the given leaf context, try to either rewrite to a disjunction if</p></li>
<li><p>there are few terms, or build a DocIdSet containing matching docs.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>private WeightOrDocIdSet rewrite(LeafReaderContext context)</dt><dd><blockquote>
<div><p>throws IOException {</p>
</div></blockquote>
<p>final Terms terms = context.reader().terms(query.getField());
if (terms == null) {</p>
<blockquote>
<div><p>// field does not exist
return new WeightOrDocIdSet((DocIdSet) null);</p>
</div></blockquote>
<p>}</p>
<p>final TermsEnum termsEnum = query.getTermsEnum(terms);
assert termsEnum != null;</p>
<p>PostingsEnum docs = null;</p>
<p>final List&lt;TermAndState&gt; collectedTerms = new ArrayList&lt;&gt;();
if (collectTerms(context, termsEnum, collectedTerms)) {</p>
<blockquote>
<div><p>// build a boolean query
BooleanQuery.Builder bqBuilder = new BooleanQuery.Builder();
for (TermAndState t : collectedTerms) {</p>
<blockquote>
<div><p>final TermStates termStates = new TermStates(searcher.getTopReaderContext());
termStates.register(t.state, context.ord, t.docFreq, t.totalTermFreq);
final Term term = new Term(query.getField(), t.term);
bqBuilder.add(</p>
<blockquote>
<div><p>new TermQueryWithToString(term, termStates, useOrderPreservingEncoding),
Occur.SHOULD);</p>
</div></blockquote>
</div></blockquote>
<p>}
Query q = BoostUtils.maybeWrapInBoostQuery(</p>
<blockquote>
<div><p>new ConstantScoreQuery(bqBuilder.build()), score());</p>
</div></blockquote>
<dl class="simple">
<dt>return new WeightOrDocIdSet(</dt><dd><p>searcher.rewrite(q).createWeight(searcher, scoreMode, boost));</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>// Too many terms: go back to the terms we already collected and start building
// the DocIdSet
DocIdSetBuilder builder = new DocIdSetBuilder(context.reader().maxDoc());
if (!collectedTerms.isEmpty()) {</p>
<blockquote>
<div><p>TermsEnum termsEnum2 = terms.iterator();
for (TermAndState t : collectedTerms) {</p>
<blockquote>
<div><p>termsEnum2.seekExact(t.term, t.state);
docs = termsEnum2.postings(docs, PostingsEnum.NONE);
builder.add(docs);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Then keep filling the DocIdSet with remaining terms
do {</p>
<blockquote>
<div><p>docs = termsEnum.postings(docs, PostingsEnum.NONE);
builder.add(docs);</p>
</div></blockquote>
<p>} while (termsEnum.next() != null);</p>
<p>return new WeightOrDocIdSet(builder.build());</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private Scorer scorer(DocIdSet set) throws IOException {</dt><dd><dl class="simple">
<dt>if (set == null) {</dt><dd><p>return null;</p>
</dd>
</dl>
<p>}
final DocIdSetIterator disi = set.iterator();
if (disi == null) {</p>
<blockquote>
<div><p>return null;</p>
</div></blockquote>
<p>}
return new ConstantScoreScorer(this, score(), ScoreMode.COMPLETE_NO_SCORES, disi);</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public BulkScorer bulkScorer(LeafReaderContext context) throws IOException {</p>
<blockquote>
<div><p>final WeightOrDocIdSet weightOrDocIdSet = rewrite(context);
if (weightOrDocIdSet.weight != null) {</p>
<blockquote>
<div><p>return weightOrDocIdSet.weight.bulkScorer(context);</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>final Scorer scorer = scorer(weightOrDocIdSet.docIdSet);
if (scorer == null) {</p>
<blockquote>
<div><p>return null;</p>
</div></blockquote>
<p>}
return new DefaultBulkScorer(scorer);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public Scorer scorer(LeafReaderContext context) throws IOException {</p>
<blockquote>
<div><p>final WeightOrDocIdSet weightOrDocIdSet = rewrite(context);
if (weightOrDocIdSet.weight != null) {</p>
<blockquote>
<div><p>return weightOrDocIdSet.weight.scorer(context);</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>return scorer(weightOrDocIdSet.docIdSet);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public void extractTerms(Set&lt;Term&gt; terms) {</p>
<blockquote>
<div><dl class="simple">
<dt>terms.addAll(getIDs()</dt><dd><p>.stream()
.map(id -&gt; new Term(getField(), LongTermAttributeImpl.copyIntoNewBytesRef(id)))
.collect(Collectors.toSet()));</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public boolean isCacheable(LeafReaderContext ctx) {</p>
<blockquote>
<div><p>return false;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>};</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../_sources/src/java/com/twitter/search/common/query/IDDisjunctionQuery.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>