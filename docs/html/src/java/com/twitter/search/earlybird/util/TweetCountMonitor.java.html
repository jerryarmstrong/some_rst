<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../" id="documentation_options" src="../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.earlybird.util;</p>
<p>import java.io.IOException;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;</p>
<p>import com.google.common.annotations.VisibleForTesting;
import com.google.common.collect.Maps;</p>
<p>import org.apache.commons.lang.mutable.MutableInt;
import org.apache.commons.lang.mutable.MutableLong;
import org.apache.lucene.index.IndexOptions;
import org.apache.lucene.index.PostingsEnum;
import org.apache.lucene.index.Terms;
import org.apache.lucene.index.TermsEnum;
import org.apache.lucene.search.DocIdSetIterator;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;</p>
<p>import com.twitter.common.collections.Pair;
import com.twitter.search.common.concurrent.ScheduledExecutorServiceFactory;
import com.twitter.search.common.metrics.SearchCounter;
import com.twitter.search.common.metrics.SearchLongGauge;
import com.twitter.search.common.metrics.SearchStatsReceiver;
import com.twitter.search.common.metrics.SearchTimerStats;
import com.twitter.search.common.partitioning.base.Segment;
import com.twitter.search.common.schema.base.ImmutableSchemaInterface;
import com.twitter.search.common.schema.base.Schema;
import com.twitter.search.core.earlybird.index.DocIDToTweetIDMapper;
import com.twitter.search.core.earlybird.index.EarlybirdIndexSegmentAtomicReader;
import com.twitter.search.core.earlybird.index.TimeMapper;
import com.twitter.search.earlybird.common.config.EarlybirdConfig;
import com.twitter.search.earlybird.exception.CriticalExceptionHandler;
import com.twitter.search.earlybird.index.EarlybirdSingleSegmentSearcher;
import com.twitter.search.earlybird.partition.SegmentInfo;
import com.twitter.search.earlybird.partition.SegmentManager;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A background task that periodically gets and exports the number of tweets per hour that are</p></li>
<li><p>indexed on this earlybird.</p></li>
<li><p>Specifically used for making sure that we are not missing data for any hours in the search</p></li>
<li><p>archives.</p></li>
<li><p>The task loops though all the segments that are indexed by this earlybird, and for each segment</p></li>
<li><p>looks at all the createdAt dates for all of the documents in that segment.</p></li>
<li></li>
<li><p>Also keeps track off an exposes as a stat the number of hours that do not have any tweets in the</p></li>
<li><p>min/max range of data that IS indexed on this earlybird. i.e if we only have data for</p></li>
<li><p>2006/01/01:02 and 2006/01/01:04, it will consider 2006/01/01:03 as a missing hour.</p></li>
<li><p>Hours before 2006/01/01:02 or after 2006/01/01:04 will not be considered as missing.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public class TweetCountMonitor extends OneTaskScheduledExecutorManager {</dt><dd><p>private static final Logger LOG = LoggerFactory.getLogger(TweetCountMonitor.class);</p>
<p>private static final String THREAD_NAME_FORMAT = “TweetCountMonitor-%d”;
private static final boolean THREAD_IS_DAEMON = true;</p>
<dl class="simple">
<dt>public static final String RUN_INTERVAL_MINUTES_CONFIG_NAME =</dt><dd><p>“tweet_count_monitor_run_interval_minutes”;</p>
</dd>
<dt>public static final String START_CHECK_HOUR_CONFIG_NAME =</dt><dd><p>“tweet_count_monitor_start_check_hour”;</p>
</dd>
<dt>public static final String HOURLY_MIN_COUNT_CONFIG_NAME =</dt><dd><p>“tweet_count_monitor_hourly_min_count”;</p>
</dd>
<dt>public static final String DAILY_MIN_COUNT_CONFIG_NAME =</dt><dd><p>“tweet_count_monitor_daily_min_count”;</p>
</dd>
</dl>
<p>&#64;VisibleForTesting
public static final AtomicInteger INSTANCE_COUNTER = new AtomicInteger(0);</p>
<p>private static final long MILLIS_IN_A_DAY = TimeUnit.DAYS.toMillis(1);</p>
<p>private final SegmentManager segmentManager;</p>
<p>private final SearchStatsReceiver searchStatsReceiver;
private final int instanceCounter;</p>
<p>// The first date in format “YYYYMMDDHH” that we want to check counts for.
private final int startCheckHour;
// The last date in format “YYYYMMDDHH” that we want to check counts for.
private final int endCheckHour;
//Smallest number of docs we expect to have for each day.
private final int dailyMinCount;
// Smallest number of docs we expect to have for each hour.
private final int hourlyMinCount;
// Binary stat, set to 0 when the monitor is running
private final SearchLongGauge isRunningStat;
// How long each iteration takes
private final SearchTimerStats checkTimeStat;</p>
<p>private final Map&lt;String, FieldTermCounter&gt; fieldTermCounters;
private final Map&lt;String, SearchTimerStats&gt; fieldCheckTimeStats;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Create a TweetCountMonitor to monitor all segments in the given segmentManager</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>public TweetCountMonitor(</dt><dd><blockquote>
<div><p>SegmentManager segmentManager,
ScheduledExecutorServiceFactory executorServiceFactory,
long shutdownWaitDuration,
TimeUnit shutdownWaitUnit,
SearchStatsReceiver searchStatsReceiver,
CriticalExceptionHandler criticalExceptionHandler) {</p>
</div></blockquote>
<dl class="simple">
<dt>this(segmentManager,</dt><dd><p>EarlybirdConfig.getInt(START_CHECK_HOUR_CONFIG_NAME, 0),
EarlybirdConfig.getInt(RUN_INTERVAL_MINUTES_CONFIG_NAME, -1),
EarlybirdConfig.getInt(HOURLY_MIN_COUNT_CONFIG_NAME, 0),
EarlybirdConfig.getInt(DAILY_MIN_COUNT_CONFIG_NAME, 0),
executorServiceFactory,
shutdownWaitDuration,
shutdownWaitUnit,
searchStatsReceiver,
criticalExceptionHandler);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>&#64;VisibleForTesting
TweetCountMonitor(</p>
<blockquote>
<div><blockquote>
<div><p>SegmentManager segmentManager,
int startCheckHourFromConfig,
int schedulePeriodMinutes,
int hourlyMinCount,
int dailyMinCount,
ScheduledExecutorServiceFactory executorServiceFactory,
long shutdownWaitDuration,
TimeUnit shutdownWaitUnit,
SearchStatsReceiver searchStatsReceiver,
CriticalExceptionHandler criticalExceptionHandler) {</p>
</div></blockquote>
<dl>
<dt>super(</dt><dd><p>executorServiceFactory,
THREAD_NAME_FORMAT,
THREAD_IS_DAEMON,
PeriodicActionParams.atFixedRate(</p>
<blockquote>
<div><p>schedulePeriodMinutes,
TimeUnit.MINUTES</p>
</div></blockquote>
<p>),
new ShutdownWaitTimeParams(</p>
<blockquote>
<div><p>shutdownWaitDuration,
shutdownWaitUnit</p>
</div></blockquote>
<p>),
searchStatsReceiver,</p>
<blockquote>
<div><p>criticalExceptionHandler);</p>
</div></blockquote>
</dd>
</dl>
<p>this.segmentManager = segmentManager;
this.searchStatsReceiver = searchStatsReceiver;
this.instanceCounter = INSTANCE_COUNTER.incrementAndGet();
this.hourlyMinCount = hourlyMinCount;
this.dailyMinCount = dailyMinCount;</p>
<p>String isRunningStatName = “<a href="#id9"><span class="problematic" id="id10">tweet_count_monitor_is_running_v_</span></a>” + this.instanceCounter;
this.isRunningStat = SearchLongGauge.export(isRunningStatName);
String checkTimeStatName = “<a href="#id11"><span class="problematic" id="id12">tweet_count_monitor_check_time_v_</span></a>” + this.instanceCounter;
this.checkTimeStat = SearchTimerStats.export(checkTimeStatName, TimeUnit.MILLISECONDS, true);</p>
<dl class="simple">
<dt>this.startCheckHour = Math.max(</dt><dd><p>startCheckHourFromConfig,
dateToHourValue(segmentManager.getPartitionConfig().getTierStartDate()));</p>
</dd>
</dl>
<p>this.endCheckHour = dateToHourValue(segmentManager.getPartitionConfig().getTierEndDate());</p>
<p>this.fieldTermCounters = Maps.newHashMap();
this.fieldTermCounters.put(</p>
<blockquote>
<div><p>FieldTermCounter.TWEET_COUNT_KEY,
new FieldTermCounter(</p>
<blockquote>
<div><p>FieldTermCounter.TWEET_COUNT_KEY,
instanceCounter,
startCheckHour,
endCheckHour,
hourlyMinCount,
dailyMinCount));</p>
</div></blockquote>
</div></blockquote>
<p>this.fieldCheckTimeStats = Maps.newHashMap();</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>private int dateToHourValue(Date date) {</dt><dd><p>Calendar cal = Calendar.getInstance(FieldTermCounter.TIME_ZONE);
cal.setTime(date);
return FieldTermCounter.getHourValue(cal);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void updateHourlyCounts() {</dt><dd><p>// Iterate the current index to count all tweets anf field hits.
Map&lt;String, Map&lt;Integer, MutableInt&gt;&gt; newCountMap = getNewTweetCountMap();</p>
<dl>
<dt>for (Map.Entry&lt;String, Map&lt;Integer, MutableInt&gt;&gt; newCounts<span class="classifier">newCountMap.entrySet()) {</span></dt><dd><p>final String fieldName = newCounts.getKey();
FieldTermCounter termCounter = fieldTermCounters.get(fieldName);
if (termCounter == null) {</p>
<blockquote>
<div><dl class="simple">
<dt>termCounter = new FieldTermCounter(</dt><dd><p>fieldName,
instanceCounter,
startCheckHour,
endCheckHour,
hourlyMinCount,
dailyMinCount);</p>
</dd>
</dl>
<p>fieldTermCounters.put(fieldName, termCounter);</p>
</div></blockquote>
<p>}
termCounter.runWithNewCounts(newCounts.getValue());</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Loops through all segments, and all documents in each segment, and for each document</p></li>
<li><p>gets the createdAt timestamp (in seconds) from the TimeMapper.</p></li>
<li><p>Based on that, returns a map with the count of:</p></li>
<li><p>. the number of tweets for each hour</p></li>
<li><p>. the number of tweets corresponding to each field for each hour</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>private Map&lt;String, Map&lt;Integer, MutableInt&gt;&gt; getNewTweetCountMap() {</dt><dd><dl class="simple">
<dt>Iterable&lt;SegmentInfo&gt; segmentInfos = segmentManager.getSegmentInfos(</dt><dd><p>SegmentManager.Filter.Enabled, SegmentManager.Order.NEW_TO_OLD);</p>
</dd>
</dl>
<p>Map&lt;String, Map&lt;Integer, MutableInt&gt;&gt; newCountMap = Maps.newHashMap();</p>
<p>Map&lt;Integer, MutableInt&gt; newCounts = Maps.newHashMap();
newCountMap.put(FieldTermCounter.TWEET_COUNT_KEY, newCounts);</p>
<dl class="simple">
<dt>ImmutableSchemaInterface schemaSnapshot =</dt><dd><p>segmentManager.getEarlybirdIndexConfig().getSchema().getSchemaSnapshot();</p>
</dd>
</dl>
<p>Calendar cal = Calendar.getInstance(FieldTermCounter.TIME_ZONE);
for (SegmentInfo segmentInfo : segmentInfos) {</p>
<blockquote>
<div><dl>
<dt>try {</dt><dd><dl>
<dt>EarlybirdSingleSegmentSearcher searcher = segmentManager.getSearcher(</dt><dd><p>segmentInfo.getTimeSliceID(), schemaSnapshot);</p>
</dd>
<dt>if (searcher != null) {</dt><dd><p>EarlybirdIndexSegmentAtomicReader reader = searcher.getTwitterIndexReader();
TimeMapper timeMapper = reader.getSegmentData().getTimeMapper();
List&lt;Pair&lt;String, Integer&gt;&gt; outsideEndDateRangeDocList = new ArrayList&lt;&gt;();</p>
<p>// Get the number of tweets for each hour.
int docsOutsideEndDateRange = getNewTweetCountsForSegment(</p>
<blockquote>
<div><p>segmentInfo, reader, timeMapper, cal, newCounts);</p>
</div></blockquote>
<dl class="simple">
<dt>if (docsOutsideEndDateRange &gt; 0) {</dt><dd><dl class="simple">
<dt>outsideEndDateRangeDocList.add(new Pair&lt;&gt;(</dt><dd><p>FieldTermCounter.TWEET_COUNT_KEY, docsOutsideEndDateRange));</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>// Get the number of tweets with corresponding field for each hour.
for (Schema.FieldInfo fieldInfo : schemaSnapshot.getFieldInfos()) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (fieldInfo.getFieldType().indexOptions() == IndexOptions.NONE) {</dt><dd><p>continue;</p>
</dd>
</dl>
<p>}</p>
<p>String fieldName = fieldInfo.getName();
docsOutsideEndDateRange = getNewFieldTweetCountsForSegment(</p>
<blockquote>
<div><p>segmentInfo, reader, timeMapper, cal, fieldName, newCountMap);</p>
</div></blockquote>
<dl class="simple">
<dt>if (docsOutsideEndDateRange &gt; 0) {</dt><dd><p>outsideEndDateRangeDocList.add(new Pair&lt;&gt;(fieldName, docsOutsideEndDateRange));</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>LOG.info(“Inspected segment: “ + segmentInfo + “ found “</dt><dd><ul class="simple">
<li><p>outsideEndDateRangeDocList.size()</p></li>
<li><p>“ fields with documents outside of segment end date.”);</p></li>
</ul>
</dd>
<dt>for (Pair&lt;String, Integer&gt; outsideEndRange<span class="classifier">outsideEndDateRangeDocList) {</span></dt><dd><dl class="simple">
<dt>LOG.info(”  outside end date range - segment: “ + segmentInfo.getSegmentName()</dt><dd><ul class="simple">
<li><p>“ field: “ + outsideEndRange.toString());</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} catch (IOException e) {</dt><dd><p>LOG.error(“Exception getting daily tweet counts for timeslice: “ + segmentInfo, e);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return newCountMap;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void incrementNumDocsWithIllegalTimeCounter(String segmentName, String fieldSuffix) {</dt><dd><dl class="simple">
<dt>String statName = String.format(</dt><dd><p>“num_docs_with_illegal_time_for_segment_%s%s_counter”, segmentName, fieldSuffix);</p>
</dd>
</dl>
<p>SearchCounter counter = SearchCounter.export(statName);
counter.increment();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private int getNewTweetCountsForSegment(</dt><dd><blockquote>
<div><p>SegmentInfo segmentInfo,
EarlybirdIndexSegmentAtomicReader reader,
TimeMapper timeMapper,
Calendar cal,
Map&lt;Integer, MutableInt&gt; newTweetCounts) {</p>
</div></blockquote>
<p>DocIDToTweetIDMapper tweetIdMapper = reader.getSegmentData().getDocIDToTweetIDMapper();
long dataEndTimeExclusiveMillis = getDataEndTimeExclusiveMillis(segmentInfo);
int docsOutsideEndDateRange = 0;
int docId = Integer.MIN_VALUE;
while ((docId = tweetIdMapper.getNextDocID(docId)) != DocIDToTweetIDMapper.ID_NOT_FOUND) {</p>
<blockquote>
<div><dl class="simple">
<dt>UpdateCountType updateCountType =</dt><dd><p>updateTweetCount(timeMapper, docId, dataEndTimeExclusiveMillis, cal, newTweetCounts);</p>
</dd>
<dt>if (updateCountType == UpdateCountType.ILLEGAL_TIME) {</dt><dd><p>incrementNumDocsWithIllegalTimeCounter(segmentInfo.getSegmentName(), “”);</p>
</dd>
<dt>} else if (updateCountType == UpdateCountType.OUT_OF_RANGE_TIME) {</dt><dd><p>docsOutsideEndDateRange++;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return docsOutsideEndDateRange;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private int getNewFieldTweetCountsForSegment(</dt><dd><blockquote>
<div><p>SegmentInfo segmentInfo,
EarlybirdIndexSegmentAtomicReader reader,
TimeMapper timeMapper,
Calendar cal,
String field,
Map&lt;String, Map&lt;Integer, MutableInt&gt;&gt; newCountMap) throws IOException {</p>
</div></blockquote>
<p>int docsOutsideEndDateRange = 0;
Map&lt;Integer, MutableInt&gt; fieldTweetCounts =</p>
<blockquote>
<div><p>newCountMap.computeIfAbsent(field, k -&gt; Maps.newHashMap());</p>
</div></blockquote>
<p>Terms terms = reader.terms(field);
if (terms == null) {</p>
<blockquote>
<div><dl class="simple">
<dt>LOG.warn(“Field &lt;” + field + “&gt; is missing terms in segment: “</dt><dd><ul class="simple">
<li><p>segmentInfo.getSegmentName());</p></li>
</ul>
</dd>
</dl>
<p>return 0;</p>
</div></blockquote>
<p>}
long startTimeMillis = System.currentTimeMillis();</p>
<p>long dataEndTimeExclusiveMillis = getDataEndTimeExclusiveMillis(segmentInfo);
for (TermsEnum termsEnum = terms.iterator(); termsEnum.next() != null;) {</p>
<blockquote>
<div><p>DocIdSetIterator docsIterator = termsEnum.postings(null, PostingsEnum.NONE);
for (int docId = docsIterator.nextDoc();</p>
<blockquote>
<div><blockquote>
<div><p>docId != DocIdSetIterator.NO_MORE_DOCS; docId = docsIterator.nextDoc()) {</p>
</div></blockquote>
<dl class="simple">
<dt>UpdateCountType updateCountType = updateTweetCount(</dt><dd><p>timeMapper, docId, dataEndTimeExclusiveMillis, cal, fieldTweetCounts);</p>
</dd>
<dt>if (updateCountType == UpdateCountType.ILLEGAL_TIME) {</dt><dd><dl class="simple">
<dt>incrementNumDocsWithIllegalTimeCounter(</dt><dd><p>segmentInfo.getSegmentName(), “_and_field_” + field);</p>
</dd>
</dl>
</dd>
<dt>} else if (updateCountType == UpdateCountType.OUT_OF_RANGE_TIME) {</dt><dd><p>docsOutsideEndDateRange++;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
updateFieldRunTimeStats(field, System.currentTimeMillis() - startTimeMillis);</p>
<p>return docsOutsideEndDateRange;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private enum UpdateCountType {</dt><dd><p>OK_TIME,
ILLEGAL_TIME,
OUT_OF_RANGE_TIME,</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private static UpdateCountType updateTweetCount(</dt><dd><blockquote>
<div><p>TimeMapper timeMapper,
int docId,
long dataEndTimeExclusiveMillis,
Calendar cal,
Map&lt;Integer, MutableInt&gt; newTweetCounts) {</p>
</div></blockquote>
<p>int timeSecs = timeMapper.getTime(docId);
if (timeSecs == TimeMapper.ILLEGAL_TIME) {</p>
<blockquote>
<div><p>return UpdateCountType.ILLEGAL_TIME;</p>
</div></blockquote>
<p>}
if (dataEndTimeExclusiveMillis == Segment.NO_DATA_END_TIME</p>
<blockquote>
<div><blockquote>
<div><p>|| timeSecs * 1000L &lt; dataEndTimeExclusiveMillis) {</p>
</div></blockquote>
<p>Integer hourlyValue = FieldTermCounter.getHourValue(cal, timeSecs);
MutableInt count = newTweetCounts.get(hourlyValue);
if (count == null) {</p>
<blockquote>
<div><p>count = new MutableInt(0);
newTweetCounts.put(hourlyValue, count);</p>
</div></blockquote>
<p>}
count.increment();
return UpdateCountType.OK_TIME;</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>return UpdateCountType.OUT_OF_RANGE_TIME;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>If a segment has an end date, return the last timestamp (exclusive, and in millis) for which</p></li>
<li><p>we expect it to have data.</p></li>
<li><p>&#64;return Segment.NO_DATA_END_TIME if the segment does not have an end date.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>private long getDataEndTimeExclusiveMillis(SegmentInfo segmentInfo) {</dt><dd><p>long dataEndDate = segmentInfo.getSegment().getDataEndDateInclusiveMillis();
if (dataEndDate == Segment.NO_DATA_END_TIME) {</p>
<blockquote>
<div><p>return Segment.NO_DATA_END_TIME;</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>return dataEndDate + MILLIS_IN_A_DAY;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void updateFieldRunTimeStats(String fieldName, long runTimeMs) {</dt><dd><p>SearchTimerStats timerStats = fieldCheckTimeStats.get(fieldName);
if (timerStats == null) {</p>
<blockquote>
<div><p>final String statName = “<a href="#id13"><span class="problematic" id="id14">tweet_count_monitor_check_time_field_</span></a>” + fieldName;
timerStats = searchStatsReceiver.getTimerStats(</p>
<blockquote>
<div><p>statName, TimeUnit.MILLISECONDS, false, false, false);</p>
</div></blockquote>
<p>fieldCheckTimeStats.put(fieldName, timerStats);</p>
</div></blockquote>
<p>}
timerStats.timerIncrement(runTimeMs);</p>
</dd>
</dl>
<p>}</p>
<p>&#64;VisibleForTesting
String getStatName(String fieldName, Integer date) {</p>
<blockquote>
<div><p>return FieldTermCounter.getStatName(fieldName, instanceCounter, date);</p>
</div></blockquote>
<p>}</p>
<p>&#64;VisibleForTesting
Map&lt;Integer, AtomicInteger&gt; getExportedCounts(String fieldName) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (fieldTermCounters.get(fieldName) == null) {</dt><dd><p>return null;</p>
</dd>
<dt>} else {</dt><dd><p>return fieldTermCounters.get(fieldName).getExportedCounts();</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>&#64;VisibleForTesting
Map&lt;Integer, MutableLong&gt; getDailyCounts(String fieldName) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (fieldTermCounters.get(fieldName) == null) {</dt><dd><p>return null;</p>
</dd>
<dt>} else {</dt><dd><p>return fieldTermCounters.get(fieldName).getDailyCounts();</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>&#64;VisibleForTesting
long getHoursWithNoTweets(String fieldName) {</p>
<blockquote>
<div><p>return fieldTermCounters.get(fieldName).getHoursWithNoTweets();</p>
</div></blockquote>
<p>}</p>
<p>&#64;VisibleForTesting
long getDaysWithNoTweets(String fieldName) {</p>
<blockquote>
<div><p>return fieldTermCounters.get(fieldName).getDaysWithNoTweets();</p>
</div></blockquote>
<p>}</p>
<p>&#64;VisibleForTesting
Map&lt;String, SearchLongGauge&gt; getExportedHourlyCountStats(String fieldName) {</p>
<blockquote>
<div><p>return fieldTermCounters.get(fieldName).getExportedHourlyCountStats();</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
protected void runOneIteration() {</p>
<blockquote>
<div><p>LOG.info(“Starting to get hourly tweet counts”);
final long startTimeMillis = System.currentTimeMillis();</p>
<p>isRunningStat.set(1);
try {</p>
<blockquote>
<div><p>updateHourlyCounts();</p>
</div></blockquote>
<dl>
<dt>} catch (Exception ex) {</dt><dd><p>LOG.error(“Unexpected exception while getting hourly tweet counts”, ex);</p>
</dd>
<dt>} finally {</dt><dd><p>isRunningStat.set(0);</p>
<p>long elapsedTimeMillis = System.currentTimeMillis() - startTimeMillis;
checkTimeStat.timerIncrement(elapsedTimeMillis);
LOG.info(“Done getting daily tweet counts. Hours without tweets: “</p>
<blockquote>
<div><ul class="simple">
<li><p>getHoursWithNoTweets(FieldTermCounter.TWEET_COUNT_KEY));</p></li>
</ul>
</div></blockquote>
<p>LOG.info(“Updating tweet count takes “ + (elapsedTimeMillis / 1000) + “ secs.”);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../_sources/src/java/com/twitter/search/earlybird/util/TweetCountMonitor.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>