<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../" id="documentation_options" src="../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.earlybird_root.filters;</p>
<p>import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;</p>
<p>import javax.inject.Inject;</p>
<p>import com.google.common.annotations.VisibleForTesting;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.util.concurrent.RateLimiterProxy;
import com.google.common.util.concurrent.TwitterRateLimiterProxyFactory;</p>
<p>import org.slf4j.Logger;
import org.slf4j.LoggerFactory;</p>
<p>import com.twitter.finagle.Service;
import com.twitter.finagle.SimpleFilter;
import com.twitter.search.common.metrics.SearchCustomGauge;
import com.twitter.search.common.metrics.SearchLongGauge;
import com.twitter.search.common.metrics.SearchRateCounter;
import com.twitter.search.common.util.FinagleUtil;
import com.twitter.search.earlybird.common.ClientIdUtil;
import com.twitter.search.earlybird.thrift.EarlybirdRequest;
import com.twitter.search.earlybird.thrift.EarlybirdResponse;
import com.twitter.search.earlybird.thrift.EarlybirdResponseCode;
import com.twitter.search.earlybird.thrift.ThriftSearchResults;
import com.twitter.search.earlybird_root.quota.ClientIdQuotaManager;
import com.twitter.search.earlybird_root.quota.QuotaInfo;
import com.twitter.util.Future;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A filter that tracks and limits the per-client request rate. The ID of the client is determined</p></li>
<li><p>by looking at the Finagle client ID and the EarlybirdRequest.clientId field.</p></li>
<li></li>
<li><p>The configuration currently has one config based implementation: see ConfigRepoBasedQuotaManager.</p></li>
<li></li>
<li><p>If a client has a quota set, this filter will rate limit the requests from that client based on</p></li>
<li><p>that quota. Otherwise, the client is assumed to use a “common request pool”, which has its own</p></li>
<li><p>quota. A quota for the common pool must always exist (even if it’s set to 0).</p></li>
<li></li>
<li><p>All rate limiters used in this class are tolerant to bursts. See TwitterRateLimiterFactory for</p></li>
<li><p>more details.</p></li>
<li></li>
<li><p>If a client sends us more requests than its allowed quota, we keep track of the excess traffic</p></li>
<li><p>and export that number in a counter. However, we rate limit the requests from that client only if</p></li>
<li><p>the QuotaInfo returned from ClientIdQuotaManager has the shouldEnforceQuota property set to true.</p></li>
<li></li>
<li><p>If a request is rate limited, the filter will return an EarlybirdResponse with a</p></li>
<li><p>QUOTA_EXCEEDED_ERROR response code.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public class ClientIdQuotaFilter extends SimpleFilter&lt;EarlybirdRequest, EarlybirdResponse&gt; {</dt><dd><dl>
<dt>private static final class ClientQuota {</dt><dd><p>private final QuotaInfo quotaInfo;
private final boolean shouldAllowRequest;
private final ClientIdRequestCounters requestCounters;</p>
<dl>
<dt>private ClientQuota(</dt><dd><blockquote>
<div><p>QuotaInfo quotaInfo,
boolean shouldAllowRequest,
ClientIdRequestCounters requestCounters) {</p>
</div></blockquote>
<p>this.quotaInfo = quotaInfo;
this.shouldAllowRequest = shouldAllowRequest;
this.requestCounters = requestCounters;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private static final class ClientIdRequestCounters {</dt><dd><dl class="simple">
<dt>private static final String REQUESTS_RECEIVED_COUNTER_NAME_PATTERN =</dt><dd><p>“quota_requests_received_for_client_id_%s”;</p>
</dd>
<dt>private static final String THROTTLED_REQUESTS_COUNTER_NAME_PATTERN =</dt><dd><p>“quota_requests_throttled_for_client_id_%s”;</p>
</dd>
<dt>private static final String REQUESTS_ABOVE_QUOTA_COUNTER_NAME_PATTERN =</dt><dd><p>“quota_requests_above_quota_for_client_id_%s”;</p>
</dd>
<dt>private static final String REQUESTS_WITHIN_QUOTA_COUNTER_NAME_PATTERN =</dt><dd><p>“quota_requests_within_quota_for_client_id_%s”;</p>
</dd>
<dt>private static final String PER_CLIENT_QUOTA_GAUGE_NAME_PATTERN =</dt><dd><p>“quota_for_client_id_%s”;</p>
</dd>
</dl>
<p>private final SearchRateCounter throttledRequestsCounter;
private final SearchRateCounter requestsReceivedCounter;
private final SearchRateCounter requestsAboveQuotaCounter;
private final SearchRateCounter requestsWithinQuotaCounter;
private final SearchLongGauge quotaClientGauge;</p>
<dl class="simple">
<dt>private ClientIdRequestCounters(String clientId) {</dt><dd><dl class="simple">
<dt>this.throttledRequestsCounter = SearchRateCounter.export(</dt><dd><p>String.format(THROTTLED_REQUESTS_COUNTER_NAME_PATTERN, clientId));</p>
</dd>
<dt>this.requestsReceivedCounter = SearchRateCounter.export(</dt><dd><p>String.format(REQUESTS_RECEIVED_COUNTER_NAME_PATTERN, clientId), true);</p>
</dd>
<dt>this.quotaClientGauge = SearchLongGauge.export(</dt><dd><p>String.format(PER_CLIENT_QUOTA_GAUGE_NAME_PATTERN, clientId));</p>
</dd>
<dt>this.requestsAboveQuotaCounter = SearchRateCounter.export(</dt><dd><p>String.format(REQUESTS_ABOVE_QUOTA_COUNTER_NAME_PATTERN, clientId));</p>
</dd>
<dt>this.requestsWithinQuotaCounter = SearchRateCounter.export(</dt><dd><p>String.format(REQUESTS_WITHIN_QUOTA_COUNTER_NAME_PATTERN, clientId));</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private static final String REQUESTS_RECEIVED_FOR_EMAIL_COUNTER_NAME_PATTERN =</dt><dd><p>“quota_requests_received_for_email_%s”;</p>
</dd>
</dl>
<p>// We have this aggregate stat only because doing sumany(…) on the
// per-client statistic is too expensive for an alert.
&#64;VisibleForTesting
static final SearchRateCounter TOTAL_REQUESTS_RECEIVED_COUNTER =</p>
<blockquote>
<div><p>SearchRateCounter.export(“total_quota_requests_received”, true);</p>
</div></blockquote>
<p>private static final int DEFAULT_BURST_FACTOR_SECONDS = 60;
private static final String QUOTA_STAT_CACHE_SIZE = “quota_stat_cache_size”;
private static final String MISSING_QUOTA_FOR_CLIENT_ID_COUNTER_NAME_PATTERN =</p>
<blockquote>
<div><p>“quota_requests_with_missing_quota_for_client_id_%s”;</p>
</div></blockquote>
<p>private static final Logger LOG = LoggerFactory.getLogger(ClientIdQuotaFilter.class);</p>
<dl class="simple">
<dt>private final ConcurrentMap&lt;String, RateLimiterProxy&gt; rateLimiterProxiesByClientId =</dt><dd><p>new ConcurrentHashMap&lt;&gt;();</p>
</dd>
</dl>
<p>private final ClientIdQuotaManager quotaManager;
private final TwitterRateLimiterProxyFactory rateLimiterProxyFactory;
private final LoadingCache&lt;String, ClientIdRequestCounters&gt; clientRequestCounters;
private final LoadingCache&lt;String, SearchRateCounter&gt; emailRequestCounters;</p>
<p>/** Creates a new ClientIdQuotaFilter instance. <a href="#id3"><span class="problematic" id="id4">*</span></a>/
&#64;Inject
public ClientIdQuotaFilter(ClientIdQuotaManager quotaManager,</p>
<blockquote>
<div><blockquote>
<div><p>TwitterRateLimiterProxyFactory rateLimiterProxyFactory) {</p>
</div></blockquote>
<p>this.quotaManager = quotaManager;
this.rateLimiterProxyFactory = rateLimiterProxyFactory;</p>
<dl>
<dt>this.clientRequestCounters = CacheBuilder.newBuilder()</dt><dd><dl>
<dt>.build(new CacheLoader&lt;String, ClientIdRequestCounters&gt;() {</dt><dd><p>&#64;Override
public ClientIdRequestCounters load(String clientId) {</p>
<blockquote>
<div><p>return new ClientIdRequestCounters(clientId);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>});</p>
</dd>
<dt>this.emailRequestCounters = CacheBuilder.newBuilder()</dt><dd><dl>
<dt>.build(new CacheLoader&lt;String, SearchRateCounter&gt;() {</dt><dd><p>&#64;Override
public SearchRateCounter load(String email) {</p>
<blockquote>
<div><dl class="simple">
<dt>return SearchRateCounter.export(</dt><dd><p>String.format(REQUESTS_RECEIVED_FOR_EMAIL_COUNTER_NAME_PATTERN, email));</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>});</p>
</dd>
</dl>
<p>SearchCustomGauge.export(QUOTA_STAT_CACHE_SIZE, () -&gt; clientRequestCounters.size());</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public Future&lt;EarlybirdResponse&gt; apply(EarlybirdRequest request,</p>
<blockquote>
<div><blockquote>
<div><p>Service&lt;EarlybirdRequest, EarlybirdResponse&gt; service) {</p>
</div></blockquote>
<p>String finagleClientId = FinagleUtil.getFinagleClientName();
String requestClientId = ClientIdUtil.getClientIdFromRequest(request);
LOG.debug(String.format(“Client id from request or attribution: %s”, requestClientId));</p>
<p>// Multiple client ids may be grouped into a single quota client id, all the
// unknown or unset client ids for example.
String quotaClientId = ClientIdUtil.getQuotaClientId(requestClientId);
LOG.debug(String.format(“Client id used for checking quota: %s”, quotaClientId));</p>
<p>ClientQuota clientQuota = getClientQuota(quotaClientId);
if (!clientQuota.shouldAllowRequest &amp;&amp; clientQuota.quotaInfo.shouldEnforceQuota()) {</p>
<blockquote>
<div><p>clientQuota.requestCounters.throttledRequestsCounter.increment();</p>
<dl class="simple">
<dt>return Future.value(getQuotaExceededResponse(</dt><dd><p>finagleClientId,
clientQuota.quotaInfo.getQuotaClientId(),
clientQuota.quotaInfo.getQuota()));</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>return service.apply(request);</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private ClientQuota getClientQuota(String clientId) {</dt><dd><p>Optional&lt;QuotaInfo&gt; quotaInfoOptional = quotaManager.getQuotaForClient(clientId);
if (!quotaInfoOptional.isPresent()) {</p>
<blockquote>
<div><dl class="simple">
<dt>SearchRateCounter noQuotaFoundForClientCounter = SearchRateCounter.export(</dt><dd><p>String.format(MISSING_QUOTA_FOR_CLIENT_ID_COUNTER_NAME_PATTERN, clientId));</p>
</dd>
</dl>
<p>noQuotaFoundForClientCounter.increment();</p>
</div></blockquote>
<p>}</p>
<p>// If a quota was set for this client, use it. Otherwise, use the common pool’s quota.
// A quota for the common pool must always exist.
QuotaInfo quotaInfo = quotaInfoOptional.orElseGet(quotaManager::getCommonPoolQuota);</p>
<dl class="simple">
<dt>ClientIdRequestCounters requestCounters = clientRequestCounters</dt><dd><p>.getUnchecked(quotaInfo.getQuotaClientId());</p>
</dd>
</dl>
<p>emailRequestCounters.getUnchecked(quotaInfo.getQuotaEmail()).increment();</p>
<p>// Increment a stat for each request the filter receives.
requestCounters.requestsReceivedCounter.increment();</p>
<p>// Also increment the total stat
TOTAL_REQUESTS_RECEIVED_COUNTER.increment();</p>
<p>// If shouldEnforceQuota is false, we already know that the request will be allowed.
// However, we still want to update the rate limiter and the stats.
final boolean requestAllowed;
if (quotaInfo.getQuota() == 0) {</p>
<blockquote>
<div><p>// If the quota for this client is set to 0, then the request should not be allowed.
//
// Do not update the rate limiter’s rate: RateLimiter only accepts positive rates, and in any
// case, we already know that the request should not be allowed.
requestAllowed = false;</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>// The quota is not 0: update the rate limiter with the new quota, and see if the request
// should be allowed.
RateLimiterProxy rateLimiterProxy = getClientRateLimiterProxy(quotaInfo.getQuotaClientId(),</p>
<blockquote>
<div><p>quotaInfo.getQuota());</p>
</div></blockquote>
<p>requestAllowed = rateLimiterProxy.tryAcquire();</p>
</dd>
</dl>
<p>}</p>
<p>// Report the current quota for each client
requestCounters.quotaClientGauge.set(quotaInfo.getQuota());</p>
<p>// Update the corresponding counter, if the request should not be allowed.
if (!requestAllowed) {</p>
<blockquote>
<div><p>requestCounters.requestsAboveQuotaCounter.increment();</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>requestCounters.requestsWithinQuotaCounter.increment();</p>
</dd>
</dl>
<p>}</p>
<p>// Throttle the request only if the quota for this service should be enforced.
return new ClientQuota(quotaInfo, requestAllowed, requestCounters);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private RateLimiterProxy getClientRateLimiterProxy(String clientId, int rate) {</dt><dd><p>// If a RateLimiter for this client doesn’t exist, create one,
// unless another thread beat us to it.
RateLimiterProxy clientRateLimiterProxy = rateLimiterProxiesByClientId.get(clientId);
if (clientRateLimiterProxy == null) {</p>
<blockquote>
<div><dl class="simple">
<dt>clientRateLimiterProxy =</dt><dd><p>rateLimiterProxyFactory.createRateLimiterProxy(rate, DEFAULT_BURST_FACTOR_SECONDS);</p>
</dd>
<dt>RateLimiterProxy existingClientRateLimiterProxy =</dt><dd><p>rateLimiterProxiesByClientId.putIfAbsent(clientId, clientRateLimiterProxy);</p>
</dd>
<dt>if (existingClientRateLimiterProxy != null) {</dt><dd><p>clientRateLimiterProxy = existingClientRateLimiterProxy;</p>
</dd>
</dl>
<p>}
LOG.info(“Using rate limiter with rate {} for clientId {}.”,</p>
<blockquote>
<div><p>clientRateLimiterProxy.getRate(), clientId);</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
<p>// Update the quota, if needed.
if (clientRateLimiterProxy.getRate() != rate) {</p>
<blockquote>
<div><dl class="simple">
<dt>LOG.info(“Updating the rate from {} to {} for clientId {}.”,</dt><dd><p>clientRateLimiterProxy.getRate(), rate, clientId);</p>
</dd>
</dl>
<p>clientRateLimiterProxy.setRate(rate);</p>
</div></blockquote>
<p>}</p>
<p>return clientRateLimiterProxy;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private static EarlybirdResponse getQuotaExceededResponse(</dt><dd><blockquote>
<div><p>String finagleClientId, String quotaClientId, int quota) {</p>
</div></blockquote>
<dl>
<dt>return new EarlybirdResponse(EarlybirdResponseCode.QUOTA_EXCEEDED_ERROR, 0)</dt><dd><p>.setSearchResults(new ThriftSearchResults())
.setDebugString(String.format(</p>
<blockquote>
<div><p>“Client %s (finagle client ID %s) has exceeded its request quota of %d. ”
+ “Please request more quota at go/searchquota.”,
quotaClientId, finagleClientId, quota));</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../_sources/src/java/com/twitter/search/earlybird_root/filters/ClientIdQuotaFilter.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>