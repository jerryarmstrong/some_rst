<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../" id="documentation_options" src="../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.simclusters_v2.summingbird.common</p>
<p>import com.twitter.algebird.DecayedValue
import com.twitter.algebird.Monoid
import com.twitter.algebird.OptionMonoid
import com.twitter.algebird.ScMapMonoid
import com.twitter.algebird_internal.thriftscala.{DecayedValue =&gt; ThriftDecayedValue}
import com.twitter.simclusters_v2.common.SimClustersEmbedding
import com.twitter.simclusters_v2.thriftscala.ClustersWithScores
import com.twitter.simclusters_v2.thriftscala.MultiModelClustersWithScores
import com.twitter.simclusters_v2.thriftscala.MultiModelTopKTweetsWithScores
import com.twitter.simclusters_v2.thriftscala.ModelVersion
import com.twitter.simclusters_v2.thriftscala.MultiModelPersistentSimClustersEmbedding
import com.twitter.simclusters_v2.thriftscala.PersistentSimClustersEmbedding
import com.twitter.simclusters_v2.thriftscala.Scores
import com.twitter.simclusters_v2.thriftscala.SimClustersEmbeddingMetadata
import com.twitter.simclusters_v2.thriftscala.TopKClustersWithScores
import com.twitter.simclusters_v2.thriftscala.TopKTweetsWithScores
import com.twitter.simclusters_v2.thriftscala.{SimClustersEmbedding =&gt; ThriftSimClustersEmbedding}
import com.twitter.snowflake.id.SnowflakeId
import scala.collection.mutable</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Contains various monoids used in the EntityJob</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
</dl>
<p>object Monoids {</p>
<blockquote>
<div><dl>
<dt>class ScoresMonoid(implicit thriftDecayedValueMonoid: ThriftDecayedValueMonoid)</dt><dd><blockquote>
<div><p>extends Monoid[Scores] {</p>
</div></blockquote>
<dl class="simple">
<dt>private val optionalThriftDecayedValueMonoid =</dt><dd><p>new OptionMonoid[ThriftDecayedValue]()</p>
</dd>
</dl>
<p>override val zero: Scores = Scores()</p>
<dl>
<dt>override def plus(x: Scores, y: Scores): Scores = {</dt><dd><dl>
<dt>Scores(</dt><dd><dl class="simple">
<dt>optionalThriftDecayedValueMonoid.plus(</dt><dd><p>x.favClusterNormalized8HrHalfLifeScore,
y.favClusterNormalized8HrHalfLifeScore</p>
</dd>
</dl>
<p>),
optionalThriftDecayedValueMonoid.plus(</p>
<blockquote>
<div><p>x.followClusterNormalized8HrHalfLifeScore,
y.followClusterNormalized8HrHalfLifeScore</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>class ClustersWithScoresMonoid(implicit scoresMonoid: ScoresMonoid)</dt><dd><blockquote>
<div><p>extends Monoid[ClustersWithScores] {</p>
</div></blockquote>
<dl class="simple">
<dt>private val optionMapMonoid =</dt><dd><p>new OptionMonoid[collection.Map[Int, Scores]]()(new ScMapMonoid[Int, Scores]())</p>
</dd>
</dl>
<p>override val zero: ClustersWithScores = ClustersWithScores()</p>
<dl>
<dt>override def plus(x: ClustersWithScores, y: ClustersWithScores): ClustersWithScores = {</dt><dd><dl class="simple">
<dt>ClustersWithScores(</dt><dd><p>optionMapMonoid.plus(x.clustersToScore, y.clustersToScore)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>class MultiModelClustersWithScoresMonoid(implicit scoresMonoid: ScoresMonoid)</dt><dd><blockquote>
<div><p>extends Monoid[MultiModelClustersWithScores] {</p>
</div></blockquote>
<p>override val zero: MultiModelClustersWithScores = MultiModelClustersWithScores()</p>
<dl>
<dt>override def plus(</dt><dd><p>x: MultiModelClustersWithScores,
y: MultiModelClustersWithScores</p>
</dd>
<dt>): MultiModelClustersWithScores = {</dt><dd><p>// We reuse the logic from the Monoid for the Value here
val clustersWithScoreMonoid = Implicits.clustersWithScoreMonoid</p>
<dl class="simple">
<dt>MultiModelClustersWithScores(</dt><dd><dl class="simple">
<dt>MultiModelUtils.mergeTwoMultiModelMaps(</dt><dd><p>x.multiModelClustersWithScores,
y.multiModelClustersWithScores,
clustersWithScoreMonoid))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>class TopKClustersWithScoresMonoid(</dt><dd><p>topK: Int,
threshold: Double</p>
</dd>
<dt>)(</dt><dd><dl class="simple">
<dt>implicit thriftDecayedValueMonoid: ThriftDecayedValueMonoid)</dt><dd><p>extends Monoid[TopKClustersWithScores] {</p>
</dd>
</dl>
<p>override val zero: TopKClustersWithScores = TopKClustersWithScores()</p>
<dl class="simple">
<dt>override def plus(</dt><dd><p>x: TopKClustersWithScores,
y: TopKClustersWithScores</p>
</dd>
</dl>
<p>): TopKClustersWithScores = {</p>
<blockquote>
<div><dl>
<dt>val mergedFavMap = TopKScoresUtils</dt><dd><dl>
<dt>.mergeTwoTopKMapWithDecayedValues(</dt><dd><dl class="simple">
<dt>x.topClustersByFavClusterNormalizedScore</dt><dd><dl class="simple">
<dt>.map(_.mapValues(</dt><dd><p>_.favClusterNormalized8HrHalfLifeScore.getOrElse(thriftDecayedValueMonoid.zero))),</p>
</dd>
</dl>
</dd>
<dt>y.topClustersByFavClusterNormalizedScore</dt><dd><dl class="simple">
<dt>.map(_.mapValues(</dt><dd><p>_.favClusterNormalized8HrHalfLifeScore.getOrElse(thriftDecayedValueMonoid.zero))),</p>
</dd>
</dl>
</dd>
</dl>
<p>topK,
threshold</p>
</dd>
<dt>).map(_.mapValues(decayedValue =&gt;</dt><dd><p>Scores(favClusterNormalized8HrHalfLifeScore = Some(decayedValue))))</p>
</dd>
</dl>
</dd>
<dt>val mergedFollowMap = TopKScoresUtils</dt><dd><dl>
<dt>.mergeTwoTopKMapWithDecayedValues(</dt><dd><dl class="simple">
<dt>x.topClustersByFollowClusterNormalizedScore</dt><dd><dl class="simple">
<dt>.map(_.mapValues(</dt><dd><p>_.followClusterNormalized8HrHalfLifeScore.getOrElse(thriftDecayedValueMonoid.zero))),</p>
</dd>
</dl>
</dd>
<dt>y.topClustersByFollowClusterNormalizedScore</dt><dd><dl class="simple">
<dt>.map(_.mapValues(</dt><dd><p>_.followClusterNormalized8HrHalfLifeScore.getOrElse(thriftDecayedValueMonoid.zero))),</p>
</dd>
</dl>
</dd>
</dl>
<p>topK,
threshold</p>
</dd>
<dt>).map(_.mapValues(decayedValue =&gt;</dt><dd><p>Scores(followClusterNormalized8HrHalfLifeScore = Some(decayedValue))))</p>
</dd>
</dl>
</dd>
<dt>TopKClustersWithScores(</dt><dd><p>mergedFavMap,
mergedFollowMap</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
class TopKTweetsWithScoresMonoid(</p>
<blockquote>
<div><p>topK: Int,
threshold: Double,
tweetAgeThreshold: Long</p>
</div></blockquote>
<dl>
<dt>)(</dt><dd><dl class="simple">
<dt>implicit thriftDecayedValueMonoid: ThriftDecayedValueMonoid)</dt><dd><p>extends Monoid[TopKTweetsWithScores] {</p>
</dd>
</dl>
<p>override val zero: TopKTweetsWithScores = TopKTweetsWithScores()</p>
<dl>
<dt>override def plus(x: TopKTweetsWithScores, y: TopKTweetsWithScores): TopKTweetsWithScores = {</dt><dd><p>val oldestTweetId = SnowflakeId.firstIdFor(System.currentTimeMillis() - tweetAgeThreshold)</p>
<dl>
<dt>val mergedFavMap = TopKScoresUtils</dt><dd><dl>
<dt>.mergeTwoTopKMapWithDecayedValues(</dt><dd><dl class="simple">
<dt>x.topTweetsByFavClusterNormalizedScore</dt><dd><dl class="simple">
<dt>.map(_.mapValues(</dt><dd><p>_.favClusterNormalized8HrHalfLifeScore.getOrElse(thriftDecayedValueMonoid.zero))),</p>
</dd>
</dl>
</dd>
<dt>y.topTweetsByFavClusterNormalizedScore</dt><dd><dl class="simple">
<dt>.map(_.mapValues(</dt><dd><p>_.favClusterNormalized8HrHalfLifeScore.getOrElse(thriftDecayedValueMonoid.zero))),</p>
</dd>
</dl>
</dd>
</dl>
<p>topK,
threshold</p>
</dd>
<dt>).map(_.filter(_._1 &gt;= oldestTweetId).mapValues(decayedValue =&gt;</dt><dd><p>Scores(favClusterNormalized8HrHalfLifeScore = Some(decayedValue))))</p>
</dd>
</dl>
</dd>
</dl>
<p>TopKTweetsWithScores(mergedFavMap, None)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>class MultiModelTopKTweetsWithScoresMonoid(
)(</p>
<blockquote>
<div><dl class="simple">
<dt>implicit thriftDecayedValueMonoid: ThriftDecayedValueMonoid)</dt><dd><p>extends Monoid[MultiModelTopKTweetsWithScores] {</p>
</dd>
</dl>
<p>override val zero: MultiModelTopKTweetsWithScores = MultiModelTopKTweetsWithScores()</p>
<dl>
<dt>override def plus(</dt><dd><p>x: MultiModelTopKTweetsWithScores,
y: MultiModelTopKTweetsWithScores</p>
</dd>
<dt>): MultiModelTopKTweetsWithScores = {</dt><dd><p>// We reuse the logic from the Monoid for the Value here
val topKTweetsWithScoresMonoid = Implicits.topKTweetsWithScoresMonoid</p>
<dl class="simple">
<dt>MultiModelTopKTweetsWithScores(</dt><dd><dl class="simple">
<dt>MultiModelUtils.mergeTwoMultiModelMaps(</dt><dd><p>x.multiModelTopKTweetsWithScores,
y.multiModelTopKTweetsWithScores,
topKTweetsWithScoresMonoid))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Merge two PersistentSimClustersEmbedding. The latest embedding overwrite the old embedding.</p></li>
<li><p>The new count equals to the sum of the count.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
</dl>
<p>class PersistentSimClustersEmbeddingMonoid extends Monoid[PersistentSimClustersEmbedding] {</p>
<blockquote>
<div><dl class="simple">
<dt>override val zero: PersistentSimClustersEmbedding = PersistentSimClustersEmbedding(</dt><dd><p>ThriftSimClustersEmbedding(),
SimClustersEmbeddingMetadata()</p>
</dd>
</dl>
<p>)</p>
<p>private val optionLongMonoid = new OptionMonoid[Long]()</p>
<dl class="simple">
<dt>override def plus(</dt><dd><p>x: PersistentSimClustersEmbedding,
y: PersistentSimClustersEmbedding</p>
</dd>
<dt>): PersistentSimClustersEmbedding = {</dt><dd><dl class="simple">
<dt>val latest =</dt><dd><p>if (x.metadata.updatedAtMs.getOrElse(0L) &gt; y.metadata.updatedAtMs.getOrElse(0L)) x else y</p>
</dd>
<dt>latest.copy(</dt><dd><dl class="simple">
<dt>metadata = latest.metadata.copy(</dt><dd><p>updatedCount = optionLongMonoid.plus(x.metadata.updatedCount, y.metadata.updatedCount)))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>class MultiModelPersistentSimClustersEmbeddingMonoid</dt><dd><blockquote>
<div><p>extends Monoid[MultiModelPersistentSimClustersEmbedding] {</p>
</div></blockquote>
<dl>
<dt>override val zero: MultiModelPersistentSimClustersEmbedding =</dt><dd><p>MultiModelPersistentSimClustersEmbedding(Map[ModelVersion, PersistentSimClustersEmbedding]())</p>
</dd>
<dt>override def plus(</dt><dd><p>x: MultiModelPersistentSimClustersEmbedding,
y: MultiModelPersistentSimClustersEmbedding</p>
</dd>
<dt>): MultiModelPersistentSimClustersEmbedding = {</dt><dd><p>val monoid = Implicits.persistentSimClustersEmbeddingMonoid</p>
<p>// PersistentSimClustersEmbeddings is the only required thrift object so we need to wrap it
// in Some
MultiModelUtils.mergeTwoMultiModelMaps(</p>
<blockquote>
<div><p>Some(x.multiModelPersistentSimClustersEmbedding),
Some(y.multiModelPersistentSimClustersEmbedding),
monoid) match {
// clean up the empty embeddings
case Some(res) =&gt;</p>
<blockquote>
<div><dl>
<dt>MultiModelPersistentSimClustersEmbedding(res.flatMap {</dt><dd><p>// in some cases the list of SimClustersScore is empty, so we want to remove the
// modelVersion from the list of Models for the embedding
case (modelVersion, persistentSimClustersEmbedding) =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>persistentSimClustersEmbedding.embedding.embedding match {</dt><dd><dl class="simple">
<dt>case embedding if embedding.nonEmpty =&gt;</dt><dd><p>Map(modelVersion -&gt; persistentSimClustersEmbedding)</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>None</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>})</p>
</div></blockquote>
<p>case _ =&gt; zero</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Merge two PersistentSimClustersEmbeddings. The embedding with the longest l2 norm overwrites</p></li>
<li><p>the other embedding. The new count equals to the sum of the count.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>class PersistentSimClustersEmbeddingLongestL2NormMonoid</dt><dd><blockquote>
<div><p>extends Monoid[PersistentSimClustersEmbedding] {</p>
</div></blockquote>
<dl class="simple">
<dt>override val zero: PersistentSimClustersEmbedding = PersistentSimClustersEmbedding(</dt><dd><p>ThriftSimClustersEmbedding(),
SimClustersEmbeddingMetadata()</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>override def plus(</dt><dd><p>x: PersistentSimClustersEmbedding,
y: PersistentSimClustersEmbedding</p>
</dd>
<dt>): PersistentSimClustersEmbedding = {</dt><dd><p>if (SimClustersEmbedding(x.embedding).l2norm &gt;= SimClustersEmbedding(y.embedding).l2norm) x
else y</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>class MultiModelPersistentSimClustersEmbeddingLongestL2NormMonoid</dt><dd><blockquote>
<div><p>extends Monoid[MultiModelPersistentSimClustersEmbedding] {</p>
</div></blockquote>
<dl>
<dt>override val zero: MultiModelPersistentSimClustersEmbedding =</dt><dd><p>MultiModelPersistentSimClustersEmbedding(Map[ModelVersion, PersistentSimClustersEmbedding]())</p>
</dd>
<dt>override def plus(</dt><dd><p>x: MultiModelPersistentSimClustersEmbedding,
y: MultiModelPersistentSimClustersEmbedding</p>
</dd>
<dt>): MultiModelPersistentSimClustersEmbedding = {</dt><dd><p>val monoid = Implicits.persistentSimClustersEmbeddingLongestL2NormMonoid</p>
<dl>
<dt>MultiModelUtils.mergeTwoMultiModelMaps(</dt><dd><p>Some(x.multiModelPersistentSimClustersEmbedding),
Some(y.multiModelPersistentSimClustersEmbedding),
monoid) match {
// clean up empty embeddings
case Some(res) =&gt;</p>
<blockquote>
<div><dl>
<dt>MultiModelPersistentSimClustersEmbedding(res.flatMap {</dt><dd><dl>
<dt>case (modelVersion, persistentSimClustersEmbedding) =&gt;</dt><dd><p>// in some cases the list of SimClustersScore is empty, so we want to remove the
// modelVersion from the list of Models for the embedding
persistentSimClustersEmbedding.embedding.embedding match {</p>
<blockquote>
<div><dl class="simple">
<dt>case embedding if embedding.nonEmpty =&gt;</dt><dd><p>Map(modelVersion -&gt; persistentSimClustersEmbedding)</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>None</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>})</p>
</div></blockquote>
<p>case _ =&gt; zero</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>object TopKScoresUtils {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Function for merging TopK scores with decayed values.</p></li>
<li></li>
<li><p>This is for use with topk scores where all scores are updated at the same time (i.e. most</p></li>
<li><p>time-decayed embedding aggregations). Rather than storing individual scores as algebird.DecayedValue</p></li>
<li><p>and replicating time information for every key, we can store a single timestamp for the entire</p></li>
<li><p>embedding and replicate the decay logic when processing each score.</p></li>
<li></li>
<li><p>This should replicate the behaviour of <cite>mergeTwoTopKMapWithDecayedValues</cite></p></li>
<li></li>
<li><p>The logic is:</p></li>
<li><ul>
<li><p>Determine the most recent update and build a DecayedValue for it (decayedValueForLatestTime)</p></li>
</ul>
</li>
<li><ul>
<li><p>For each (cluster, score), decay the score relative to the time of the most-recently updated embedding</p></li>
</ul>
</li>
<li><ul>
<li><p>This is a no-op for scores from the most recently-updated embedding, and will scale scores</p></li>
</ul>
</li>
<li><p>for the older embedding.</p></li>
<li><ul>
<li><p>Drop any (cluster, score) which are below the <cite>threshold</cite> score</p></li>
</ul>
</li>
<li><ul>
<li><p>If both input embeddings contribute a score for the same cluster, keep the one with the largest score (after scaling)</p></li>
</ul>
</li>
<li><ul>
<li><p>Sort (cluster, score) by score and keep the <cite>topK</cite></p></li>
</ul>
</li>
<li></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>def mergeClusterScoresWithUpdateTimes[Key](</dt><dd><p>x: Seq[(Key, Double)],
xUpdatedAtMs: Long,
y: Seq[(Key, Double)],
yUpdatedAtMs: Long,
halfLifeMs: Long,
topK: Int,
threshold: Double</p>
</dd>
<dt>): Seq[(Key, Double)] = {</dt><dd><p>val latestUpdate = math.max(xUpdatedAtMs, yUpdatedAtMs)
val decayedValueForLatestTime = DecayedValue.build(0.0, latestUpdate, halfLifeMs)</p>
<p>val merged = mutable.HashMap[Key, Double]()</p>
<dl>
<dt>x.foreach {</dt><dd><dl>
<dt>case (key, score) =&gt;</dt><dd><dl>
<dt>val decayedScore = Implicits.decayedValueMonoid</dt><dd><dl class="simple">
<dt>.plus(</dt><dd><p>DecayedValue.build(score, xUpdatedAtMs, halfLifeMs),
decayedValueForLatestTime</p>
</dd>
</dl>
<p>).value</p>
</dd>
<dt>if (decayedScore &gt; threshold)</dt><dd><p>merged += key -&gt; decayedScore</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>y.foreach {</dt><dd><dl>
<dt>case (key, score) =&gt;</dt><dd><dl>
<dt>val decayedScore = Implicits.decayedValueMonoid</dt><dd><dl class="simple">
<dt>.plus(</dt><dd><p>DecayedValue.build(score, yUpdatedAtMs, halfLifeMs),
decayedValueForLatestTime</p>
</dd>
</dl>
<p>).value</p>
</dd>
<dt>if (decayedScore &gt; threshold)</dt><dd><dl class="simple">
<dt>merged.get(key) match {</dt><dd><dl class="simple">
<dt>case Some(existingValue) =&gt;</dt><dd><dl class="simple">
<dt>if (decayedScore &gt; existingValue)</dt><dd><p>merged += key -&gt; decayedScore</p>
</dd>
</dl>
</dd>
<dt>case None =&gt;</dt><dd><p>merged += key -&gt; decayedScore</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>merged.toSeq</dt><dd><p>.sortBy(-_._2)
.take(topK)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Function for merging to TopK map with decayed values.</p></li>
<li></li>
<li><p>First of all, all the values will be decayed to the latest scaled timestamp to be comparable.</p></li>
<li></li>
<li><p>If the same key appears at both a and b, the one with larger scaled time (or larger value when</p></li>
<li><p>their scaled times are same) will be taken. The values smaller than the threshold will be dropped.</p></li>
<li></li>
<li><p>After merging, if the size is larger than TopK, only scores with topK largest value will be kept.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>def mergeTwoTopKMapWithDecayedValues[T](</dt><dd><p>a: Option[collection.Map[T, ThriftDecayedValue]],
b: Option[collection.Map[T, ThriftDecayedValue]],
topK: Int,
threshold: Double</p>
</dd>
<dt>)(</dt><dd><p>implicit thriftDecayedValueMonoid: ThriftDecayedValueMonoid</p>
</dd>
</dl>
<p>): Option[collection.Map[T, ThriftDecayedValue]] = {</p>
<blockquote>
<div><dl class="simple">
<dt>if (a.isEmpty || a.exists(_.isEmpty)) {</dt><dd><p>return b</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (b.isEmpty || b.exists(_.isEmpty)) {</dt><dd><p>return a</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val latestScaledTime = (a.get.view ++ b.get.view).map {</dt><dd><dl class="simple">
<dt>case (_, scores) =&gt;</dt><dd><p>scores.scaledTime</p>
</dd>
</dl>
</dd>
</dl>
<p>}.max</p>
<p>val decayedValueWithLatestScaledTime = ThriftDecayedValue(0.0, latestScaledTime)</p>
<p>val merged = mutable.HashMap[T, ThriftDecayedValue]()</p>
<dl>
<dt>a.foreach {</dt><dd><dl>
<dt>_.foreach {</dt><dd><dl>
<dt>case (k, v) =&gt;</dt><dd><p>// decay the value to latest scaled time
val decayedScores = thriftDecayedValueMonoid</p>
<blockquote>
<div><p>.plus(v, decayedValueWithLatestScaledTime)</p>
</div></blockquote>
<p>// only merge if the value is larger than the threshold
if (decayedScores.value &gt; threshold) {</p>
<blockquote>
<div><p>merged += k -&gt; decayedScores</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>b.foreach {</dt><dd><dl>
<dt>_.foreach {</dt><dd><dl>
<dt>case (k, v) =&gt;</dt><dd><dl class="simple">
<dt>val decayedScores = thriftDecayedValueMonoid</dt><dd><p>.plus(v, decayedValueWithLatestScaledTime)</p>
</dd>
</dl>
<p>// only merge if the value is larger than the threshold
if (decayedScores.value &gt; threshold) {</p>
<blockquote>
<div><dl>
<dt>if (!merged.contains(k)) {</dt><dd><p>merged += k -&gt; decayedScores</p>
</dd>
<dt>} else {</dt><dd><p>// only update if the value is larger than the one already merged
if (decayedScores.value &gt; merged(k).value) {</p>
<blockquote>
<div><p>merged.update(k, decayedScores)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// add some buffer size (~ 0.2 * topK) to avoid sorting and taking too frequently
if (merged.size &gt; topK * 1.2) {</p>
<blockquote>
<div><dl class="simple">
<dt>Some(</dt><dd><dl class="simple">
<dt>merged.toSeq</dt><dd><p>.sortBy { case (_, scores) =&gt; scores.value * -1 }
.take(topK)
.toMap</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>Some(merged)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>object MultiModelUtils {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>In order to reduce complexity we use the Monoid for the value to plus two MultiModel maps</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>def mergeTwoMultiModelMaps[T](</dt><dd><p>a: Option[collection.Map[ModelVersion, T]],
b: Option[collection.Map[ModelVersion, T]],
monoid: Monoid[T]</p>
</dd>
<dt>): Option[collection.Map[ModelVersion, T]] = {</dt><dd><dl>
<dt>(a, b) match {</dt><dd><p>case (Some(_), None) =&gt; a
case (None, Some(_)) =&gt; b
case (Some(aa), Some(bb)) =&gt;</p>
<blockquote>
<div><dl>
<dt>val res = ModelVersionProfiles.ModelVersionProfiles.foldLeft(Map[ModelVersion, T]()) {</dt><dd><dl>
<dt>(map, model) =&gt;</dt><dd><dl class="simple">
<dt>map + (model._1 -&gt; monoid.plus(</dt><dd><p>aa.getOrElse(model._1, monoid.zero),
bb.getOrElse(model._1, monoid.zero)</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
</dl>
<p>}
Some(res)</p>
</div></blockquote>
<p>case _ =&gt; None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../_sources/src/scala/com/twitter/simclusters_v2/summingbird/common/Monoids.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>