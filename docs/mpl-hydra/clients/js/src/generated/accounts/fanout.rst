clients/js/src/generated/accounts/fanout.ts
===========================================

Last edited: 2023-06-19 18:36:17

Contents:

.. code-block:: ts

    /**
 * This code was AUTOGENERATED using the kinobi library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun kinobi to update it.
 *
 * @see https://github.com/metaplex-foundation/kinobi
 */

import {
  Account,
  Context,
  Option,
  OptionOrNullable,
  Pda,
  PublicKey,
  RpcAccount,
  RpcGetAccountOptions,
  RpcGetAccountsOptions,
  assertAccountExists,
  deserializeAccount,
  gpaBuilder,
  publicKey as toPublicKey,
} from '@metaplex-foundation/umi';
import {
  Serializer,
  array,
  mapSerializer,
  option,
  publicKey as publicKeySerializer,
  string,
  struct,
  u64,
  u8,
} from '@metaplex-foundation/umi/serializers';
import {
  MembershipModel,
  MembershipModelArgs,
  getMembershipModelSerializer,
} from '../types';

export type Fanout = Account<FanoutAccountData>;

export type FanoutAccountData = {
  discriminator: Array<number>;
  authority: PublicKey;
  name: string;
  accountKey: PublicKey;
  totalShares: bigint;
  totalMembers: bigint;
  totalInflow: bigint;
  lastSnapshotAmount: bigint;
  bumpSeed: number;
  accountOwnerBumpSeed: number;
  totalAvailableShares: bigint;
  membershipModel: MembershipModel;
  membershipMint: Option<PublicKey>;
  totalStakedShares: Option<bigint>;
};

export type FanoutAccountDataArgs = {
  authority: PublicKey;
  name: string;
  accountKey: PublicKey;
  totalShares: number | bigint;
  totalMembers: number | bigint;
  totalInflow: number | bigint;
  lastSnapshotAmount: number | bigint;
  bumpSeed: number;
  accountOwnerBumpSeed: number;
  totalAvailableShares: number | bigint;
  membershipModel: MembershipModelArgs;
  membershipMint: OptionOrNullable<PublicKey>;
  totalStakedShares: OptionOrNullable<number | bigint>;
};

/** @deprecated Use `getFanoutAccountDataSerializer()` without any argument instead. */
export function getFanoutAccountDataSerializer(
  _context: object
): Serializer<FanoutAccountDataArgs, FanoutAccountData>;
export function getFanoutAccountDataSerializer(): Serializer<
  FanoutAccountDataArgs,
  FanoutAccountData
>;
export function getFanoutAccountDataSerializer(
  _context: object = {}
): Serializer<FanoutAccountDataArgs, FanoutAccountData> {
  return mapSerializer<FanoutAccountDataArgs, any, FanoutAccountData>(
    struct<FanoutAccountData>(
      [
        ['discriminator', array(u8(), { size: 8 })],
        ['authority', publicKeySerializer()],
        ['name', string()],
        ['accountKey', publicKeySerializer()],
        ['totalShares', u64()],
        ['totalMembers', u64()],
        ['totalInflow', u64()],
        ['lastSnapshotAmount', u64()],
        ['bumpSeed', u8()],
        ['accountOwnerBumpSeed', u8()],
        ['totalAvailableShares', u64()],
        ['membershipModel', getMembershipModelSerializer()],
        ['membershipMint', option(publicKeySerializer())],
        ['totalStakedShares', option(u64())],
      ],
      { description: 'FanoutAccountData' }
    ),
    (value) => ({
      ...value,
      discriminator: [164, 101, 210, 92, 222, 14, 75, 156],
    })
  ) as Serializer<FanoutAccountDataArgs, FanoutAccountData>;
}

/** @deprecated Use `deserializeFanout(rawAccount)` without any context instead. */
export function deserializeFanout(
  context: object,
  rawAccount: RpcAccount
): Fanout;
export function deserializeFanout(rawAccount: RpcAccount): Fanout;
export function deserializeFanout(
  context: RpcAccount | object,
  rawAccount?: RpcAccount
): Fanout {
  return deserializeAccount(
    rawAccount ?? (context as RpcAccount),
    getFanoutAccountDataSerializer()
  );
}

export async function fetchFanout(
  context: Pick<Context, 'rpc'>,
  publicKey: PublicKey | Pda,
  options?: RpcGetAccountOptions
): Promise<Fanout> {
  const maybeAccount = await context.rpc.getAccount(
    toPublicKey(publicKey, false),
    options
  );
  assertAccountExists(maybeAccount, 'Fanout');
  return deserializeFanout(maybeAccount);
}

export async function safeFetchFanout(
  context: Pick<Context, 'rpc'>,
  publicKey: PublicKey | Pda,
  options?: RpcGetAccountOptions
): Promise<Fanout | null> {
  const maybeAccount = await context.rpc.getAccount(
    toPublicKey(publicKey, false),
    options
  );
  return maybeAccount.exists ? deserializeFanout(maybeAccount) : null;
}

export async function fetchAllFanout(
  context: Pick<Context, 'rpc'>,
  publicKeys: Array<PublicKey | Pda>,
  options?: RpcGetAccountsOptions
): Promise<Fanout[]> {
  const maybeAccounts = await context.rpc.getAccounts(
    publicKeys.map((key) => toPublicKey(key, false)),
    options
  );
  return maybeAccounts.map((maybeAccount) => {
    assertAccountExists(maybeAccount, 'Fanout');
    return deserializeFanout(maybeAccount);
  });
}

export async function safeFetchAllFanout(
  context: Pick<Context, 'rpc'>,
  publicKeys: Array<PublicKey | Pda>,
  options?: RpcGetAccountsOptions
): Promise<Fanout[]> {
  const maybeAccounts = await context.rpc.getAccounts(
    publicKeys.map((key) => toPublicKey(key, false)),
    options
  );
  return maybeAccounts
    .filter((maybeAccount) => maybeAccount.exists)
    .map((maybeAccount) => deserializeFanout(maybeAccount as RpcAccount));
}

export function getFanoutGpaBuilder(
  context: Pick<Context, 'rpc' | 'programs'>
) {
  const programId = context.programs.getPublicKey(
    'mplHydra',
    'hyDQ4Nz1eYyegS6JfenyKwKzYxRsCWCriYSAjtzP4Vg'
  );
  return gpaBuilder(context, programId)
    .registerFields<{
      discriminator: Array<number>;
      authority: PublicKey;
      name: string;
      accountKey: PublicKey;
      totalShares: number | bigint;
      totalMembers: number | bigint;
      totalInflow: number | bigint;
      lastSnapshotAmount: number | bigint;
      bumpSeed: number;
      accountOwnerBumpSeed: number;
      totalAvailableShares: number | bigint;
      membershipModel: MembershipModelArgs;
      membershipMint: OptionOrNullable<PublicKey>;
      totalStakedShares: OptionOrNullable<number | bigint>;
    }>({
      discriminator: [0, array(u8(), { size: 8 })],
      authority: [8, publicKeySerializer()],
      name: [40, string()],
      accountKey: [null, publicKeySerializer()],
      totalShares: [null, u64()],
      totalMembers: [null, u64()],
      totalInflow: [null, u64()],
      lastSnapshotAmount: [null, u64()],
      bumpSeed: [null, u8()],
      accountOwnerBumpSeed: [null, u8()],
      totalAvailableShares: [null, u64()],
      membershipModel: [null, getMembershipModelSerializer()],
      membershipMint: [null, option(publicKeySerializer())],
      totalStakedShares: [null, option(u64())],
    })
    .deserializeUsing<Fanout>((account) => deserializeFanout(account))
    .whereField('discriminator', [164, 101, 210, 92, 222, 14, 75, 156]);
}

export function getFanoutSize(): number {
  return 300;
}

export function findFanoutPda(
  context: Pick<Context, 'eddsa' | 'programs'>,
  seeds: {
    /** The name of the fanout account */
    name: string;
  }
): Pda {
  const programId = context.programs.getPublicKey(
    'mplHydra',
    'hyDQ4Nz1eYyegS6JfenyKwKzYxRsCWCriYSAjtzP4Vg'
  );
  return context.eddsa.findPda(programId, [
    string({ size: 'variable' }).serialize('fanout-config'),
    string({ size: 'variable' }).serialize(seeds.name),
  ]);
}

export async function fetchFanoutFromSeeds(
  context: Pick<Context, 'eddsa' | 'programs' | 'rpc'>,
  seeds: Parameters<typeof findFanoutPda>[1],
  options?: RpcGetAccountOptions
): Promise<Fanout> {
  return fetchFanout(context, findFanoutPda(context, seeds), options);
}

export async function safeFetchFanoutFromSeeds(
  context: Pick<Context, 'eddsa' | 'programs' | 'rpc'>,
  seeds: Parameters<typeof findFanoutPda>[1],
  options?: RpcGetAccountOptions
): Promise<Fanout | null> {
  return safeFetchFanout(context, findFanoutPda(context, seeds), options);
}


