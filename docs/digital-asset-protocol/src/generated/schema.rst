src/generated/schema.rs
=======================

Last edited: 2022-08-04 13:38:52

Contents:

.. code-block:: rs

    //
// This code was generated by a tool.
//
//
//   bebopc version:
//       2.4.2
//
//
//   bebopc source:
//       https://github.com/RainwayApp/bebop
//
//
// Changes to this file may cause incorrect behavior and will be lost if
// the code is regenerated.
//

#![allow(warnings)]

use bebop::FixedSized as _;
use core::convert::TryInto as _;
use std::io::Write as _;

#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum Interface {
    Unknown = 0,
    NFTv1 = 1,
    Nft = 2,
    NFTPrintable = 3,
    NFTGroup = 4,
    FungibleAsset = 5,
    IdentityAsset = 6,
}

impl ::core::convert::TryFrom<u8> for Interface {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u8) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(Interface::Unknown),
            1 => Ok(Interface::NFTv1),
            2 => Ok(Interface::Nft),
            3 => Ok(Interface::NFTPrintable),
            4 => Ok(Interface::NFTGroup),
            5 => Ok(Interface::FungibleAsset),
            6 => Ok(Interface::IdentityAsset),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(
                d.into(),
            )),
        }
    }
}

impl ::core::convert::From<Interface> for u8 {
    fn from(value: Interface) -> Self {
        match value {
            Interface::Unknown => 0,
            Interface::NFTv1 => 1,
            Interface::Nft => 2,
            Interface::NFTPrintable => 3,
            Interface::NFTGroup => 4,
            Interface::FungibleAsset => 5,
            Interface::IdentityAsset => 6,
        }
    }
}

impl ::bebop::SubRecord<'_> for Interface {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u8>());

    #[inline]
    fn serialized_size(&self) -> usize {
        ::std::mem::size_of::<u8>()
    }

    #[inline]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        u8::from(*self)._serialize_chained(dest)
    }

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u8::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for Interface {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
}

#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum ModuleType {
    Invalid = 0,
    Signature = 1,
    Ownership = 2,
    Creators = 3,
    Data = 4,
    Royalty = 5,
    Rights = 6,
    Extension = 7,
    Governance = 8,
}

impl ::core::convert::TryFrom<u8> for ModuleType {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u8) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(ModuleType::Invalid),
            1 => Ok(ModuleType::Signature),
            2 => Ok(ModuleType::Ownership),
            3 => Ok(ModuleType::Creators),
            4 => Ok(ModuleType::Data),
            5 => Ok(ModuleType::Royalty),
            6 => Ok(ModuleType::Rights),
            7 => Ok(ModuleType::Extension),
            8 => Ok(ModuleType::Governance),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(
                d.into(),
            )),
        }
    }
}

impl ::core::convert::From<ModuleType> for u8 {
    fn from(value: ModuleType) -> Self {
        match value {
            ModuleType::Invalid => 0,
            ModuleType::Signature => 1,
            ModuleType::Ownership => 2,
            ModuleType::Creators => 3,
            ModuleType::Data => 4,
            ModuleType::Royalty => 5,
            ModuleType::Rights => 6,
            ModuleType::Extension => 7,
            ModuleType::Governance => 8,
        }
    }
}

impl ::bebop::SubRecord<'_> for ModuleType {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u8>());

    #[inline]
    fn serialized_size(&self) -> usize {
        ::std::mem::size_of::<u8>()
    }

    #[inline]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        u8::from(*self)._serialize_chained(dest)
    }

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u8::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for ModuleType {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
}

#[derive(Clone, Debug, PartialEq)]
pub enum ModuleData<'raw> {
    /// An unknown type which is likely defined in a newer version of the schema.
    Unknown,

    /// Discriminator 1
    CreatorsData {
        creators: ::std::vec::Vec<Creator<'raw>>,
    },

    /// Discriminator 2
    OwnershipData {
        model: OwnershipModel,
        owner: ::bebop::SliceWrapper<'raw, u8>,
    },

    /// Discriminator 3
    RoyaltyData {
        royalty_percent: u8,
        model: RoyaltyModel,
        target: ::std::vec::Vec<RoyaltyTarget<'raw>>,
        locked: bool,
    },

    /// Discriminator 4
    GovernanceData {
        authorities: ::std::vec::Vec<Authority<'raw>>,
    },
}

impl<'raw> ::bebop::SubRecord<'raw> for ModuleData<'raw> {
    const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

    fn serialized_size(&self) -> usize {
        ::bebop::LEN_SIZE
            + 1
            + match self {
                ModuleData::Unknown => 0,
                Self::CreatorsData {
                    creators: ref _creators,
                } => _creators.serialized_size(),
                Self::OwnershipData {
                    model: ref _model,
                    owner: ref _owner,
                } => _model.serialized_size() + _owner.serialized_size(),
                Self::RoyaltyData {
                    royalty_percent: ref _royalty_percent,
                    model: ref _model,
                    target: ref _target,
                    locked: ref _locked,
                } => {
                    _royalty_percent.serialized_size()
                        + _model.serialized_size()
                        + _target.serialized_size()
                        + _locked.serialized_size()
                }
                Self::GovernanceData {
                    authorities: ref _authorities,
                } => _authorities.serialized_size(),
            }
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        let size = self.serialized_size();
        ::bebop::write_len(dest, size - ::bebop::LEN_SIZE - 1)?;
        match self {
            ModuleData::Unknown => {
                return Err(::bebop::SerializeError::CannotSerializeUnknownUnion);
            }
            Self::CreatorsData {
                creators: ref _creators,
            } => {
                1u8._serialize_chained(dest)?;
                _creators._serialize_chained(dest)?;
            }
            Self::OwnershipData {
                model: ref _model,
                owner: ref _owner,
            } => {
                2u8._serialize_chained(dest)?;
                _model._serialize_chained(dest)?;
                _owner._serialize_chained(dest)?;
            }
            Self::RoyaltyData {
                royalty_percent: ref _royalty_percent,
                model: ref _model,
                target: ref _target,
                locked: ref _locked,
            } => {
                3u8._serialize_chained(dest)?;
                _royalty_percent._serialize_chained(dest)?;
                _model._serialize_chained(dest)?;
                _target._serialize_chained(dest)?;
                _locked._serialize_chained(dest)?;
            }
            Self::GovernanceData {
                authorities: ref _authorities,
            } => {
                4u8._serialize_chained(dest)?;
                _authorities._serialize_chained(dest)?;
            }
        }
        Ok(size)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let len = ::bebop::read_len(&raw)? + ::bebop::LEN_SIZE + 1;
        let mut i = ::bebop::LEN_SIZE + 1;
        let de = match raw[::bebop::LEN_SIZE] {
            1 => {
                let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                i += read;

                ModuleData::CreatorsData { creators: v0 }
            }
            2 => {
                let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                i += read;
                let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                i += read;

                ModuleData::OwnershipData {
                    model: v0,
                    owner: v1,
                }
            }
            3 => {
                let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                i += read;
                let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                i += read;
                let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                i += read;
                let (read, v3) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                i += read;

                ModuleData::RoyaltyData {
                    royalty_percent: v0,
                    model: v1,
                    target: v2,
                    locked: v3,
                }
            }
            4 => {
                let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                i += read;

                ModuleData::GovernanceData { authorities: v0 }
            }
            _ => {
                i = len;
                ModuleData::Unknown
            }
        };
        if !cfg!(feature = "unchecked") && i != len {
            debug_assert!(i > len);
            Err(::bebop::DeserializeError::CorruptFrame)
        } else {
            Ok((i, de))
        }
    }
}

impl<'raw> ::bebop::Record<'raw> for ModuleData<'raw> {}

#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum Encoding {
    Invalid = 0,
    Borsh = 1,
    Bincode = 2,
}

impl ::core::convert::TryFrom<u8> for Encoding {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u8) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(Encoding::Invalid),
            1 => Ok(Encoding::Borsh),
            2 => Ok(Encoding::Bincode),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(
                d.into(),
            )),
        }
    }
}

impl ::core::convert::From<Encoding> for u8 {
    fn from(value: Encoding) -> Self {
        match value {
            Encoding::Invalid => 0,
            Encoding::Borsh => 1,
            Encoding::Bincode => 2,
        }
    }
}

impl ::bebop::SubRecord<'_> for Encoding {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u8>());

    #[inline]
    fn serialized_size(&self) -> usize {
        ::std::mem::size_of::<u8>()
    }

    #[inline]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        u8::from(*self)._serialize_chained(dest)
    }

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u8::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for Encoding {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
}

#[derive(Clone, Debug, PartialEq)]
pub enum DataItemValue<'raw> {
    /// An unknown type which is likely defined in a newer version of the schema.
    Unknown,

    /// Discriminator 1
    String {
        /// Field 1
        value: ::core::option::Option<&'raw str>,
    },

    /// Discriminator 2
    Int {
        /// Field 1
        value: ::core::option::Option<i32>,
    },

    /// Discriminator 3
    BigInt {
        /// Field 1
        value: ::core::option::Option<i64>,
    },

    /// Discriminator 4
    Bytes {
        encoding: Encoding,
        raw: ::bebop::SliceWrapper<'raw, u8>,
    },
}

impl<'raw> ::bebop::SubRecord<'raw> for DataItemValue<'raw> {
    const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

    fn serialized_size(&self) -> usize {
        ::bebop::LEN_SIZE
            + 1
            + match self {
                DataItemValue::Unknown => 0,
                Self::String { value: ref _value } => {
                    ::bebop::LEN_SIZE
                        + 1
                        + _value
                            .as_ref()
                            .map(|v| v.serialized_size() + 1)
                            .unwrap_or(0)
                }
                Self::Int { value: ref _value } => {
                    ::bebop::LEN_SIZE
                        + 1
                        + _value
                            .as_ref()
                            .map(|v| v.serialized_size() + 1)
                            .unwrap_or(0)
                }
                Self::BigInt { value: ref _value } => {
                    ::bebop::LEN_SIZE
                        + 1
                        + _value
                            .as_ref()
                            .map(|v| v.serialized_size() + 1)
                            .unwrap_or(0)
                }
                Self::Bytes {
                    encoding: ref _encoding,
                    raw: ref _raw,
                } => _encoding.serialized_size() + _raw.serialized_size(),
            }
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        let size = self.serialized_size();
        ::bebop::write_len(dest, size - ::bebop::LEN_SIZE - 1)?;
        match self {
            DataItemValue::Unknown => {
                return Err(::bebop::SerializeError::CannotSerializeUnknownUnion);
            }
            Self::String { value: ref _value } => {
                1u8._serialize_chained(dest)?;
                ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                if let Some(ref v) = _value {
                    1u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                0u8._serialize_chained(dest)?;
            }
            Self::Int { value: ref _value } => {
                2u8._serialize_chained(dest)?;
                ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                if let Some(ref v) = _value {
                    1u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                0u8._serialize_chained(dest)?;
            }
            Self::BigInt { value: ref _value } => {
                3u8._serialize_chained(dest)?;
                ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                if let Some(ref v) = _value {
                    1u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                0u8._serialize_chained(dest)?;
            }
            Self::Bytes {
                encoding: ref _encoding,
                raw: ref _raw,
            } => {
                4u8._serialize_chained(dest)?;
                _encoding._serialize_chained(dest)?;
                _raw._serialize_chained(dest)?;
            }
        }
        Ok(size)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let len = ::bebop::read_len(&raw)? + ::bebop::LEN_SIZE + 1;
        let mut i = ::bebop::LEN_SIZE + 1;
        let de = match raw[::bebop::LEN_SIZE] {
            1 => {
                let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                i += ::bebop::LEN_SIZE;

                #[cfg(not(feature = "unchecked"))]
                if len == 0 {
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                if raw.len() < len {
                    return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                }

                let mut _value = None;

                #[cfg(not(feature = "unchecked"))]
                let mut last = 0;

                while i < len {
                    let di = raw[i];

                    #[cfg(not(feature = "unchecked"))]
                    if di != 0 {
                        if di < last {
                            return Err(::bebop::DeserializeError::CorruptFrame);
                        }
                        last = di;
                    }

                    i += 1;
                    match di {
                        0 => {
                            break;
                        }
                        1 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _value.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _value = Some(value)
                        }
                        _ => {
                            i = len;
                            break;
                        }
                    }
                }

                if i != len {
                    debug_assert!(i > len);
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                DataItemValue::String { value: _value }
            }
            2 => {
                let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                i += ::bebop::LEN_SIZE;

                #[cfg(not(feature = "unchecked"))]
                if len == 0 {
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                if raw.len() < len {
                    return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                }

                let mut _value = None;

                #[cfg(not(feature = "unchecked"))]
                let mut last = 0;

                while i < len {
                    let di = raw[i];

                    #[cfg(not(feature = "unchecked"))]
                    if di != 0 {
                        if di < last {
                            return Err(::bebop::DeserializeError::CorruptFrame);
                        }
                        last = di;
                    }

                    i += 1;
                    match di {
                        0 => {
                            break;
                        }
                        1 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _value.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _value = Some(value)
                        }
                        _ => {
                            i = len;
                            break;
                        }
                    }
                }

                if i != len {
                    debug_assert!(i > len);
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                DataItemValue::Int { value: _value }
            }
            3 => {
                let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                i += ::bebop::LEN_SIZE;

                #[cfg(not(feature = "unchecked"))]
                if len == 0 {
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                if raw.len() < len {
                    return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                }

                let mut _value = None;

                #[cfg(not(feature = "unchecked"))]
                let mut last = 0;

                while i < len {
                    let di = raw[i];

                    #[cfg(not(feature = "unchecked"))]
                    if di != 0 {
                        if di < last {
                            return Err(::bebop::DeserializeError::CorruptFrame);
                        }
                        last = di;
                    }

                    i += 1;
                    match di {
                        0 => {
                            break;
                        }
                        1 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _value.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _value = Some(value)
                        }
                        _ => {
                            i = len;
                            break;
                        }
                    }
                }

                if i != len {
                    debug_assert!(i > len);
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                DataItemValue::BigInt { value: _value }
            }
            4 => {
                let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                i += read;
                let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                i += read;

                DataItemValue::Bytes {
                    encoding: v0,
                    raw: v1,
                }
            }
            _ => {
                i = len;
                DataItemValue::Unknown
            }
        };
        if !cfg!(feature = "unchecked") && i != len {
            debug_assert!(i > len);
            Err(::bebop::DeserializeError::CorruptFrame)
        } else {
            Ok((i, de))
        }
    }
}

impl<'raw> ::bebop::Record<'raw> for DataItemValue<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct DataItem<'raw> {
    pub key: &'raw str,
    pub value: DataItemValue<'raw>,
}

impl<'raw> ::bebop::SubRecord<'raw> for DataItem<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <&'raw str>::MIN_SERIALIZED_SIZE + <DataItemValue<'raw>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.key.serialized_size() + self.value.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(self.key._serialize_chained(dest)? + self.value._serialize_chained(dest)?)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self { key: v0, value: v1 }))
    }
}

impl<'raw> ::bebop::Record<'raw> for DataItem<'raw> {}

#[derive(Clone, Debug, PartialEq, Default)]
pub struct Blob<'raw> {
    /// Field 1
    pub module_id: ::core::option::Option<u8>,
    /// Field 2
    pub structured_module: ::core::option::Option<ModuleData<'raw>>,
    /// Field 3
    pub data_module: ::core::option::Option<::std::vec::Vec<DataItem<'raw>>>,
}

impl<'raw> ::bebop::SubRecord<'raw> for Blob<'raw> {
    const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

    #[inline]
    fn serialized_size(&self) -> usize {
        ::bebop::LEN_SIZE
            + 1
            + self
                .module_id
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
            + self
                .structured_module
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
            + self
                .data_module
                .as_ref()
                .map(|v| v.serialized_size() + 1)
                .unwrap_or(0)
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        let size = self.serialized_size();
        ::bebop::write_len(dest, size - ::bebop::LEN_SIZE)?;
        if let Some(ref v) = self.module_id {
            1u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.structured_module {
            2u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        if let Some(ref v) = self.data_module {
            3u8._serialize_chained(dest)?;
            v._serialize_chained(dest)?;
        }
        0u8._serialize_chained(dest)?;
        Ok(size)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        let len = ::bebop::read_len(&raw[i..])? + ::bebop::LEN_SIZE;
        i += ::bebop::LEN_SIZE;

        #[cfg(not(feature = "unchecked"))]
        if len == 0 {
            return Err(::bebop::DeserializeError::CorruptFrame);
        }

        if raw.len() < len {
            return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
        }

        let mut _module_id = None;
        let mut _structured_module = None;
        let mut _data_module = None;

        #[cfg(not(feature = "unchecked"))]
        let mut last = 0;

        while i < len {
            let di = raw[i];

            #[cfg(not(feature = "unchecked"))]
            if di != 0 {
                if di < last {
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }
                last = di;
            }

            i += 1;
            match di {
                0 => {
                    break;
                }
                1 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _module_id.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _module_id = Some(value)
                }
                2 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _structured_module.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _structured_module = Some(value)
                }
                3 => {
                    #[cfg(not(feature = "unchecked"))]
                    if _data_module.is_some() {
                        return Err(::bebop::DeserializeError::DuplicateMessageField);
                    }
                    let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    _data_module = Some(value)
                }
                _ => {
                    i = len;
                    break;
                }
            }
        }

        if i != len {
            debug_assert!(i > len);
            return Err(::bebop::DeserializeError::CorruptFrame);
        }

        Ok((
            i,
            Self {
                module_id: _module_id,
                structured_module: _structured_module,
                data_module: _data_module,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for Blob<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct BlobContainer<'raw> {
    pub blobs: ::std::vec::Vec<Blob<'raw>>,
}

impl<'raw> ::bebop::SubRecord<'raw> for BlobContainer<'raw> {
    const MIN_SERIALIZED_SIZE: usize = <::std::vec::Vec<Blob<'raw>>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.blobs.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(self.blobs._serialize_chained(dest)?)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((i, Self { blobs: v0 }))
    }
}

impl<'raw> ::bebop::Record<'raw> for BlobContainer<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct Authority<'raw> {
    pub scopes: ::std::vec::Vec<&'raw str>,
    pub address: ::bebop::SliceWrapper<'raw, u8>,
}

impl<'raw> ::bebop::SubRecord<'raw> for Authority<'raw> {
    const MIN_SERIALIZED_SIZE: usize = <::std::vec::Vec<&'raw str>>::MIN_SERIALIZED_SIZE
        + <::bebop::SliceWrapper<'raw, u8>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.scopes.serialized_size() + self.address.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(self.scopes._serialize_chained(dest)? + self.address._serialize_chained(dest)?)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                scopes: v0,
                address: v1,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for Authority<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct Action<'raw> {
    pub standard: Interface,
    pub data: ActionData<'raw>,
}

impl<'raw> ::bebop::SubRecord<'raw> for Action<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <Interface>::MIN_SERIALIZED_SIZE + <ActionData<'raw>>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.standard.serialized_size() + self.data.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(self.standard._serialize_chained(dest)? + self.data._serialize_chained(dest)?)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                standard: v0,
                data: v1,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for Action<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub enum ActionData<'raw> {
    /// An unknown type which is likely defined in a newer version of the schema.
    Unknown,

    /// Discriminator 1
    CreateIdentityV1 {
        /// Field 1
        uri: ::core::option::Option<&'raw str>,
    },

    /// Discriminator 2
    CreateAssetV1 {
        /// Field 1
        uri: ::core::option::Option<&'raw str>,
        /// Field 2
        ownership_model: ::core::option::Option<OwnershipModel>,
        /// Field 3
        royalty_model: ::core::option::Option<RoyaltyModel>,
        /// Field 4
        royalty_target: ::core::option::Option<RoyaltyTarget<'raw>>,
        /// Field 5
        data_schema: ::core::option::Option<JsonDataSchema>,
        /// Field 6
        creator_shares: ::core::option::Option<::bebop::SliceWrapper<'raw, u8>>,
        /// Field 7
        authorities: ::core::option::Option<::std::vec::Vec<Authority<'raw>>>,
    },

    /// Discriminator 3
    UpdateAssetV1 {
        /// Field 1
        msg: ::core::option::Option<&'raw str>,
    },
}

impl<'raw> ::bebop::SubRecord<'raw> for ActionData<'raw> {
    const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

    fn serialized_size(&self) -> usize {
        ::bebop::LEN_SIZE
            + 1
            + match self {
                ActionData::Unknown => 0,
                Self::CreateIdentityV1 { uri: ref _uri } => {
                    ::bebop::LEN_SIZE
                        + 1
                        + _uri.as_ref().map(|v| v.serialized_size() + 1).unwrap_or(0)
                }
                Self::CreateAssetV1 {
                    uri: ref _uri,
                    ownership_model: ref _ownership_model,
                    royalty_model: ref _royalty_model,
                    royalty_target: ref _royalty_target,
                    data_schema: ref _data_schema,
                    creator_shares: ref _creator_shares,
                    authorities: ref _authorities,
                } => {
                    ::bebop::LEN_SIZE
                        + 1
                        + _uri.as_ref().map(|v| v.serialized_size() + 1).unwrap_or(0)
                        + _ownership_model
                            .as_ref()
                            .map(|v| v.serialized_size() + 1)
                            .unwrap_or(0)
                        + _royalty_model
                            .as_ref()
                            .map(|v| v.serialized_size() + 1)
                            .unwrap_or(0)
                        + _royalty_target
                            .as_ref()
                            .map(|v| v.serialized_size() + 1)
                            .unwrap_or(0)
                        + _data_schema
                            .as_ref()
                            .map(|v| v.serialized_size() + 1)
                            .unwrap_or(0)
                        + _creator_shares
                            .as_ref()
                            .map(|v| v.serialized_size() + 1)
                            .unwrap_or(0)
                        + _authorities
                            .as_ref()
                            .map(|v| v.serialized_size() + 1)
                            .unwrap_or(0)
                }
                Self::UpdateAssetV1 { msg: ref _msg } => {
                    ::bebop::LEN_SIZE
                        + 1
                        + _msg.as_ref().map(|v| v.serialized_size() + 1).unwrap_or(0)
                }
            }
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        let size = self.serialized_size();
        ::bebop::write_len(dest, size - ::bebop::LEN_SIZE - 1)?;
        match self {
            ActionData::Unknown => {
                return Err(::bebop::SerializeError::CannotSerializeUnknownUnion);
            }
            Self::CreateIdentityV1 { uri: ref _uri } => {
                1u8._serialize_chained(dest)?;
                ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                if let Some(ref v) = _uri {
                    1u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                0u8._serialize_chained(dest)?;
            }
            Self::CreateAssetV1 {
                uri: ref _uri,
                ownership_model: ref _ownership_model,
                royalty_model: ref _royalty_model,
                royalty_target: ref _royalty_target,
                data_schema: ref _data_schema,
                creator_shares: ref _creator_shares,
                authorities: ref _authorities,
            } => {
                2u8._serialize_chained(dest)?;
                ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                if let Some(ref v) = _uri {
                    1u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                if let Some(ref v) = _ownership_model {
                    2u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                if let Some(ref v) = _royalty_model {
                    3u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                if let Some(ref v) = _royalty_target {
                    4u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                if let Some(ref v) = _data_schema {
                    5u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                if let Some(ref v) = _creator_shares {
                    6u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                if let Some(ref v) = _authorities {
                    7u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                0u8._serialize_chained(dest)?;
            }
            Self::UpdateAssetV1 { msg: ref _msg } => {
                3u8._serialize_chained(dest)?;
                ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                if let Some(ref v) = _msg {
                    1u8._serialize_chained(dest)?;
                    v._serialize_chained(dest)?;
                }
                0u8._serialize_chained(dest)?;
            }
        }
        Ok(size)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let len = ::bebop::read_len(&raw)? + ::bebop::LEN_SIZE + 1;
        let mut i = ::bebop::LEN_SIZE + 1;
        let de = match raw[::bebop::LEN_SIZE] {
            1 => {
                let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                i += ::bebop::LEN_SIZE;

                #[cfg(not(feature = "unchecked"))]
                if len == 0 {
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                if raw.len() < len {
                    return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                }

                let mut _uri = None;

                #[cfg(not(feature = "unchecked"))]
                let mut last = 0;

                while i < len {
                    let di = raw[i];

                    #[cfg(not(feature = "unchecked"))]
                    if di != 0 {
                        if di < last {
                            return Err(::bebop::DeserializeError::CorruptFrame);
                        }
                        last = di;
                    }

                    i += 1;
                    match di {
                        0 => {
                            break;
                        }
                        1 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _uri.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _uri = Some(value)
                        }
                        _ => {
                            i = len;
                            break;
                        }
                    }
                }

                if i != len {
                    debug_assert!(i > len);
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                ActionData::CreateIdentityV1 { uri: _uri }
            }
            2 => {
                let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                i += ::bebop::LEN_SIZE;

                #[cfg(not(feature = "unchecked"))]
                if len == 0 {
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                if raw.len() < len {
                    return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                }

                let mut _uri = None;
                let mut _ownership_model = None;
                let mut _royalty_model = None;
                let mut _royalty_target = None;
                let mut _data_schema = None;
                let mut _creator_shares = None;
                let mut _authorities = None;

                #[cfg(not(feature = "unchecked"))]
                let mut last = 0;

                while i < len {
                    let di = raw[i];

                    #[cfg(not(feature = "unchecked"))]
                    if di != 0 {
                        if di < last {
                            return Err(::bebop::DeserializeError::CorruptFrame);
                        }
                        last = di;
                    }

                    i += 1;
                    match di {
                        0 => {
                            break;
                        }
                        1 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _uri.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _uri = Some(value)
                        }
                        2 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _ownership_model.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _ownership_model = Some(value)
                        }
                        3 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _royalty_model.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _royalty_model = Some(value)
                        }
                        4 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _royalty_target.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _royalty_target = Some(value)
                        }
                        5 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _data_schema.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _data_schema = Some(value)
                        }
                        6 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _creator_shares.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _creator_shares = Some(value)
                        }
                        7 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _authorities.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _authorities = Some(value)
                        }
                        _ => {
                            i = len;
                            break;
                        }
                    }
                }

                if i != len {
                    debug_assert!(i > len);
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                ActionData::CreateAssetV1 {
                    uri: _uri,
                    ownership_model: _ownership_model,
                    royalty_model: _royalty_model,
                    royalty_target: _royalty_target,
                    data_schema: _data_schema,
                    creator_shares: _creator_shares,
                    authorities: _authorities,
                }
            }
            3 => {
                let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                i += ::bebop::LEN_SIZE;

                #[cfg(not(feature = "unchecked"))]
                if len == 0 {
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                if raw.len() < len {
                    return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                }

                let mut _msg = None;

                #[cfg(not(feature = "unchecked"))]
                let mut last = 0;

                while i < len {
                    let di = raw[i];

                    #[cfg(not(feature = "unchecked"))]
                    if di != 0 {
                        if di < last {
                            return Err(::bebop::DeserializeError::CorruptFrame);
                        }
                        last = di;
                    }

                    i += 1;
                    match di {
                        0 => {
                            break;
                        }
                        1 => {
                            #[cfg(not(feature = "unchecked"))]
                            if _msg.is_some() {
                                return Err(::bebop::DeserializeError::DuplicateMessageField);
                            }
                            let (read, value) =
                                ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                            i += read;
                            _msg = Some(value)
                        }
                        _ => {
                            i = len;
                            break;
                        }
                    }
                }

                if i != len {
                    debug_assert!(i > len);
                    return Err(::bebop::DeserializeError::CorruptFrame);
                }

                ActionData::UpdateAssetV1 { msg: _msg }
            }
            _ => {
                i = len;
                ActionData::Unknown
            }
        };
        if !cfg!(feature = "unchecked") && i != len {
            debug_assert!(i > len);
            Err(::bebop::DeserializeError::CorruptFrame)
        } else {
            Ok((i, de))
        }
    }
}

impl<'raw> ::bebop::Record<'raw> for ActionData<'raw> {}

pub const MAX_MODULES: i32 = 10;

#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum OwnershipModel {
    Invalid = 0,
    Single = 1,
    Token = 2,
}

impl ::core::convert::TryFrom<u8> for OwnershipModel {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u8) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(OwnershipModel::Invalid),
            1 => Ok(OwnershipModel::Single),
            2 => Ok(OwnershipModel::Token),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(
                d.into(),
            )),
        }
    }
}

impl ::core::convert::From<OwnershipModel> for u8 {
    fn from(value: OwnershipModel) -> Self {
        match value {
            OwnershipModel::Invalid => 0,
            OwnershipModel::Single => 1,
            OwnershipModel::Token => 2,
        }
    }
}

impl ::bebop::SubRecord<'_> for OwnershipModel {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u8>());

    #[inline]
    fn serialized_size(&self) -> usize {
        ::std::mem::size_of::<u8>()
    }

    #[inline]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        u8::from(*self)._serialize_chained(dest)
    }

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u8::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for OwnershipModel {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
}

#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum RoyaltyModel {
    Invalid = 0,
    Address = 1,
    Fanout = 2,
    Creators = 3,
}

impl ::core::convert::TryFrom<u8> for RoyaltyModel {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u8) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(RoyaltyModel::Invalid),
            1 => Ok(RoyaltyModel::Address),
            2 => Ok(RoyaltyModel::Fanout),
            3 => Ok(RoyaltyModel::Creators),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(
                d.into(),
            )),
        }
    }
}

impl ::core::convert::From<RoyaltyModel> for u8 {
    fn from(value: RoyaltyModel) -> Self {
        match value {
            RoyaltyModel::Invalid => 0,
            RoyaltyModel::Address => 1,
            RoyaltyModel::Fanout => 2,
            RoyaltyModel::Creators => 3,
        }
    }
}

impl ::bebop::SubRecord<'_> for RoyaltyModel {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u8>());

    #[inline]
    fn serialized_size(&self) -> usize {
        ::std::mem::size_of::<u8>()
    }

    #[inline]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        u8::from(*self)._serialize_chained(dest)
    }

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u8::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for RoyaltyModel {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
}

#[derive(Clone, Debug, PartialEq)]
pub struct RoyaltyTarget<'raw> {
    pub address: ::bebop::SliceWrapper<'raw, u8>,
    pub share: u8,
}

impl<'raw> ::bebop::SubRecord<'raw> for RoyaltyTarget<'raw> {
    const MIN_SERIALIZED_SIZE: usize =
        <::bebop::SliceWrapper<'raw, u8>>::MIN_SERIALIZED_SIZE + <u8>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.address.serialized_size() + self.share.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(self.address._serialize_chained(dest)? + self.share._serialize_chained(dest)?)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                address: v0,
                share: v1,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for RoyaltyTarget<'raw> {}

#[derive(Clone, Debug, PartialEq)]
pub struct Creator<'raw> {
    pub address: ::bebop::SliceWrapper<'raw, u8>,
    pub share: u8,
    pub verified: bool,
}

impl<'raw> ::bebop::SubRecord<'raw> for Creator<'raw> {
    const MIN_SERIALIZED_SIZE: usize = <::bebop::SliceWrapper<'raw, u8>>::MIN_SERIALIZED_SIZE
        + <u8>::MIN_SERIALIZED_SIZE
        + <bool>::MIN_SERIALIZED_SIZE;

    #[inline]
    fn serialized_size(&self) -> usize {
        self.address.serialized_size()
            + self.share.serialized_size()
            + self.verified.serialized_size()
    }

    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        Ok(self.address._serialize_chained(dest)?
            + self.share._serialize_chained(dest)?
            + self.verified._serialize_chained(dest)?)
    }

    fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
        let mut i = 0;
        if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
            let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
            return Err(::bebop::DeserializeError::MoreDataExpected(missing));
        }

        let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;
        let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
        i += read;

        Ok((
            i,
            Self {
                address: v0,
                share: v1,
                verified: v2,
            },
        ))
    }
}

impl<'raw> ::bebop::Record<'raw> for Creator<'raw> {}

#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum Lifecycle {
    Invalid = 0,
    Create = 1,
    Transfer = 2,
    Destroy = 3,
    Update = 4,
    Freeze = 5,
    Thaw = 6,
    Split = 7,
    Combine = 8,
    SupplyIncrease = 9,
    SupplyDecrease = 10,
    ActivateExtension = 11,
    DeactivateExtension = 12,
}

impl ::core::convert::TryFrom<u8> for Lifecycle {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u8) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(Lifecycle::Invalid),
            1 => Ok(Lifecycle::Create),
            2 => Ok(Lifecycle::Transfer),
            3 => Ok(Lifecycle::Destroy),
            4 => Ok(Lifecycle::Update),
            5 => Ok(Lifecycle::Freeze),
            6 => Ok(Lifecycle::Thaw),
            7 => Ok(Lifecycle::Split),
            8 => Ok(Lifecycle::Combine),
            9 => Ok(Lifecycle::SupplyIncrease),
            10 => Ok(Lifecycle::SupplyDecrease),
            11 => Ok(Lifecycle::ActivateExtension),
            12 => Ok(Lifecycle::DeactivateExtension),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(
                d.into(),
            )),
        }
    }
}

impl ::core::convert::From<Lifecycle> for u8 {
    fn from(value: Lifecycle) -> Self {
        match value {
            Lifecycle::Invalid => 0,
            Lifecycle::Create => 1,
            Lifecycle::Transfer => 2,
            Lifecycle::Destroy => 3,
            Lifecycle::Update => 4,
            Lifecycle::Freeze => 5,
            Lifecycle::Thaw => 6,
            Lifecycle::Split => 7,
            Lifecycle::Combine => 8,
            Lifecycle::SupplyIncrease => 9,
            Lifecycle::SupplyDecrease => 10,
            Lifecycle::ActivateExtension => 11,
            Lifecycle::DeactivateExtension => 12,
        }
    }
}

impl ::bebop::SubRecord<'_> for Lifecycle {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u8>());

    #[inline]
    fn serialized_size(&self) -> usize {
        ::std::mem::size_of::<u8>()
    }

    #[inline]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        u8::from(*self)._serialize_chained(dest)
    }

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u8::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for Lifecycle {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
}

#[repr(u8)]
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum JsonDataSchema {
    Invalid = 0,
    Core = 1,
    MultiMedia = 2,
    SimpleImage = 3,
    SimpleAudio = 4,
    Simple3D = 5,
    SimpleText = 6,
    MusicRecording = 7,
}

impl ::core::convert::TryFrom<u8> for JsonDataSchema {
    type Error = ::bebop::DeserializeError;

    fn try_from(value: u8) -> ::bebop::DeResult<Self> {
        match value {
            0 => Ok(JsonDataSchema::Invalid),
            1 => Ok(JsonDataSchema::Core),
            2 => Ok(JsonDataSchema::MultiMedia),
            3 => Ok(JsonDataSchema::SimpleImage),
            4 => Ok(JsonDataSchema::SimpleAudio),
            5 => Ok(JsonDataSchema::Simple3D),
            6 => Ok(JsonDataSchema::SimpleText),
            7 => Ok(JsonDataSchema::MusicRecording),
            d => Err(::bebop::DeserializeError::InvalidEnumDiscriminator(
                d.into(),
            )),
        }
    }
}

impl ::core::convert::From<JsonDataSchema> for u8 {
    fn from(value: JsonDataSchema) -> Self {
        match value {
            JsonDataSchema::Invalid => 0,
            JsonDataSchema::Core => 1,
            JsonDataSchema::MultiMedia => 2,
            JsonDataSchema::SimpleImage => 3,
            JsonDataSchema::SimpleAudio => 4,
            JsonDataSchema::Simple3D => 5,
            JsonDataSchema::SimpleText => 6,
            JsonDataSchema::MusicRecording => 7,
        }
    }
}

impl ::bebop::SubRecord<'_> for JsonDataSchema {
    const MIN_SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
    const EXACT_SERIALIZED_SIZE: Option<usize> = Some(::std::mem::size_of::<u8>());

    #[inline]
    fn serialized_size(&self) -> usize {
        ::std::mem::size_of::<u8>()
    }

    #[inline]
    fn _serialize_chained<W: ::std::io::Write>(&self, dest: &mut W) -> ::bebop::SeResult<usize> {
        u8::from(*self)._serialize_chained(dest)
    }

    #[inline]
    fn _deserialize_chained(raw: &[u8]) -> ::bebop::DeResult<(usize, Self)> {
        let (n, v) = u8::_deserialize_chained(raw)?;
        Ok((n, v.try_into()?))
    }
}

impl ::bebop::FixedSized for JsonDataSchema {
    const SERIALIZED_SIZE: usize = ::std::mem::size_of::<u8>();
}

#[cfg(feature = "bebop-owned-all")]
pub mod owned {
    #![allow(warnings)]

    use bebop::FixedSized as _;
    use core::convert::TryInto as _;
    use std::io::Write as _;

    pub use super::Interface;

    pub use super::ModuleType;

    #[derive(Clone, Debug, PartialEq)]
    pub enum ModuleData {
        /// An unknown type which is likely defined in a newer version of the schema.
        Unknown,

        /// Discriminator 1
        CreatorsData { creators: ::std::vec::Vec<Creator> },

        /// Discriminator 2
        OwnershipData {
            model: OwnershipModel,
            owner: ::std::vec::Vec<u8>,
        },

        /// Discriminator 3
        RoyaltyData {
            royalty_percent: u8,
            model: RoyaltyModel,
            target: ::std::vec::Vec<RoyaltyTarget>,
            locked: bool,
        },

        /// Discriminator 4
        GovernanceData {
            authorities: ::std::vec::Vec<Authority>,
        },
    }

    impl<'raw> ::core::convert::From<super::ModuleData<'raw>> for ModuleData {
        fn from(value: super::ModuleData) -> Self {
            match value {
                super::ModuleData::Unknown => Self::Unknown,
                super::ModuleData::CreatorsData {
                    creators: _creators,
                } => Self::CreatorsData {
                    creators: _creators.into_iter().map(|value| value.into()).collect(),
                },
                super::ModuleData::OwnershipData {
                    model: _model,
                    owner: _owner,
                } => Self::OwnershipData {
                    model: _model,
                    owner: _owner.iter().map(|value| value).collect(),
                },
                super::ModuleData::RoyaltyData {
                    royalty_percent: _royalty_percent,
                    model: _model,
                    target: _target,
                    locked: _locked,
                } => Self::RoyaltyData {
                    royalty_percent: _royalty_percent,
                    model: _model,
                    target: _target.into_iter().map(|value| value.into()).collect(),
                    locked: _locked,
                },
                super::ModuleData::GovernanceData {
                    authorities: _authorities,
                } => Self::GovernanceData {
                    authorities: _authorities.into_iter().map(|value| value.into()).collect(),
                },
            }
        }
    }
    impl<'raw> ::bebop::SubRecord<'raw> for ModuleData {
        const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

        fn serialized_size(&self) -> usize {
            ::bebop::LEN_SIZE
                + 1
                + match self {
                    ModuleData::Unknown => 0,
                    Self::CreatorsData {
                        creators: ref _creators,
                    } => _creators.serialized_size(),
                    Self::OwnershipData {
                        model: ref _model,
                        owner: ref _owner,
                    } => _model.serialized_size() + _owner.serialized_size(),
                    Self::RoyaltyData {
                        royalty_percent: ref _royalty_percent,
                        model: ref _model,
                        target: ref _target,
                        locked: ref _locked,
                    } => {
                        _royalty_percent.serialized_size()
                            + _model.serialized_size()
                            + _target.serialized_size()
                            + _locked.serialized_size()
                    }
                    Self::GovernanceData {
                        authorities: ref _authorities,
                    } => _authorities.serialized_size(),
                }
        }

        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            let size = self.serialized_size();
            ::bebop::write_len(dest, size - ::bebop::LEN_SIZE - 1)?;
            match self {
                ModuleData::Unknown => {
                    return Err(::bebop::SerializeError::CannotSerializeUnknownUnion);
                }
                Self::CreatorsData {
                    creators: ref _creators,
                } => {
                    1u8._serialize_chained(dest)?;
                    _creators._serialize_chained(dest)?;
                }
                Self::OwnershipData {
                    model: ref _model,
                    owner: ref _owner,
                } => {
                    2u8._serialize_chained(dest)?;
                    _model._serialize_chained(dest)?;
                    _owner._serialize_chained(dest)?;
                }
                Self::RoyaltyData {
                    royalty_percent: ref _royalty_percent,
                    model: ref _model,
                    target: ref _target,
                    locked: ref _locked,
                } => {
                    3u8._serialize_chained(dest)?;
                    _royalty_percent._serialize_chained(dest)?;
                    _model._serialize_chained(dest)?;
                    _target._serialize_chained(dest)?;
                    _locked._serialize_chained(dest)?;
                }
                Self::GovernanceData {
                    authorities: ref _authorities,
                } => {
                    4u8._serialize_chained(dest)?;
                    _authorities._serialize_chained(dest)?;
                }
            }
            Ok(size)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let len = ::bebop::read_len(&raw)? + ::bebop::LEN_SIZE + 1;
            let mut i = ::bebop::LEN_SIZE + 1;
            let de = match raw[::bebop::LEN_SIZE] {
                1 => {
                    let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;

                    ModuleData::CreatorsData { creators: v0 }
                }
                2 => {
                    let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;

                    ModuleData::OwnershipData {
                        model: v0,
                        owner: v1,
                    }
                }
                3 => {
                    let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    let (read, v3) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;

                    ModuleData::RoyaltyData {
                        royalty_percent: v0,
                        model: v1,
                        target: v2,
                        locked: v3,
                    }
                }
                4 => {
                    let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;

                    ModuleData::GovernanceData { authorities: v0 }
                }
                _ => {
                    i = len;
                    ModuleData::Unknown
                }
            };
            if !cfg!(feature = "unchecked") && i != len {
                debug_assert!(i > len);
                Err(::bebop::DeserializeError::CorruptFrame)
            } else {
                Ok((i, de))
            }
        }
    }

    impl<'raw> ::bebop::Record<'raw> for ModuleData {}

    pub use super::Encoding;

    #[derive(Clone, Debug, PartialEq)]
    pub enum DataItemValue {
        /// An unknown type which is likely defined in a newer version of the schema.
        Unknown,

        /// Discriminator 1
        String {
            /// Field 1
            value: ::core::option::Option<String>,
        },

        /// Discriminator 2
        Int {
            /// Field 1
            value: ::core::option::Option<i32>,
        },

        /// Discriminator 3
        BigInt {
            /// Field 1
            value: ::core::option::Option<i64>,
        },

        /// Discriminator 4
        Bytes {
            encoding: Encoding,
            raw: ::std::vec::Vec<u8>,
        },
    }

    impl<'raw> ::core::convert::From<super::DataItemValue<'raw>> for DataItemValue {
        fn from(value: super::DataItemValue) -> Self {
            match value {
                super::DataItemValue::Unknown => Self::Unknown,
                super::DataItemValue::String { value: _value } => Self::String {
                    value: _value.map(|value| value.into()),
                },
                super::DataItemValue::Int { value: _value } => Self::Int { value: _value },
                super::DataItemValue::BigInt { value: _value } => Self::BigInt { value: _value },
                super::DataItemValue::Bytes {
                    encoding: _encoding,
                    raw: _raw,
                } => Self::Bytes {
                    encoding: _encoding,
                    raw: _raw.iter().map(|value| value).collect(),
                },
            }
        }
    }
    impl<'raw> ::bebop::SubRecord<'raw> for DataItemValue {
        const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

        fn serialized_size(&self) -> usize {
            ::bebop::LEN_SIZE
                + 1
                + match self {
                    DataItemValue::Unknown => 0,
                    Self::String { value: ref _value } => {
                        ::bebop::LEN_SIZE
                            + 1
                            + _value
                                .as_ref()
                                .map(|v| v.serialized_size() + 1)
                                .unwrap_or(0)
                    }
                    Self::Int { value: ref _value } => {
                        ::bebop::LEN_SIZE
                            + 1
                            + _value
                                .as_ref()
                                .map(|v| v.serialized_size() + 1)
                                .unwrap_or(0)
                    }
                    Self::BigInt { value: ref _value } => {
                        ::bebop::LEN_SIZE
                            + 1
                            + _value
                                .as_ref()
                                .map(|v| v.serialized_size() + 1)
                                .unwrap_or(0)
                    }
                    Self::Bytes {
                        encoding: ref _encoding,
                        raw: ref _raw,
                    } => _encoding.serialized_size() + _raw.serialized_size(),
                }
        }

        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            let size = self.serialized_size();
            ::bebop::write_len(dest, size - ::bebop::LEN_SIZE - 1)?;
            match self {
                DataItemValue::Unknown => {
                    return Err(::bebop::SerializeError::CannotSerializeUnknownUnion);
                }
                Self::String { value: ref _value } => {
                    1u8._serialize_chained(dest)?;
                    ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                    if let Some(ref v) = _value {
                        1u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    0u8._serialize_chained(dest)?;
                }
                Self::Int { value: ref _value } => {
                    2u8._serialize_chained(dest)?;
                    ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                    if let Some(ref v) = _value {
                        1u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    0u8._serialize_chained(dest)?;
                }
                Self::BigInt { value: ref _value } => {
                    3u8._serialize_chained(dest)?;
                    ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                    if let Some(ref v) = _value {
                        1u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    0u8._serialize_chained(dest)?;
                }
                Self::Bytes {
                    encoding: ref _encoding,
                    raw: ref _raw,
                } => {
                    4u8._serialize_chained(dest)?;
                    _encoding._serialize_chained(dest)?;
                    _raw._serialize_chained(dest)?;
                }
            }
            Ok(size)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let len = ::bebop::read_len(&raw)? + ::bebop::LEN_SIZE + 1;
            let mut i = ::bebop::LEN_SIZE + 1;
            let de = match raw[::bebop::LEN_SIZE] {
                1 => {
                    let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                    i += ::bebop::LEN_SIZE;

                    #[cfg(not(feature = "unchecked"))]
                    if len == 0 {
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    if raw.len() < len {
                        return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                    }

                    let mut _value = None;

                    #[cfg(not(feature = "unchecked"))]
                    let mut last = 0;

                    while i < len {
                        let di = raw[i];

                        #[cfg(not(feature = "unchecked"))]
                        if di != 0 {
                            if di < last {
                                return Err(::bebop::DeserializeError::CorruptFrame);
                            }
                            last = di;
                        }

                        i += 1;
                        match di {
                            0 => {
                                break;
                            }
                            1 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _value.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _value = Some(value)
                            }
                            _ => {
                                i = len;
                                break;
                            }
                        }
                    }

                    if i != len {
                        debug_assert!(i > len);
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    DataItemValue::String { value: _value }
                }
                2 => {
                    let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                    i += ::bebop::LEN_SIZE;

                    #[cfg(not(feature = "unchecked"))]
                    if len == 0 {
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    if raw.len() < len {
                        return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                    }

                    let mut _value = None;

                    #[cfg(not(feature = "unchecked"))]
                    let mut last = 0;

                    while i < len {
                        let di = raw[i];

                        #[cfg(not(feature = "unchecked"))]
                        if di != 0 {
                            if di < last {
                                return Err(::bebop::DeserializeError::CorruptFrame);
                            }
                            last = di;
                        }

                        i += 1;
                        match di {
                            0 => {
                                break;
                            }
                            1 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _value.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _value = Some(value)
                            }
                            _ => {
                                i = len;
                                break;
                            }
                        }
                    }

                    if i != len {
                        debug_assert!(i > len);
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    DataItemValue::Int { value: _value }
                }
                3 => {
                    let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                    i += ::bebop::LEN_SIZE;

                    #[cfg(not(feature = "unchecked"))]
                    if len == 0 {
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    if raw.len() < len {
                        return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                    }

                    let mut _value = None;

                    #[cfg(not(feature = "unchecked"))]
                    let mut last = 0;

                    while i < len {
                        let di = raw[i];

                        #[cfg(not(feature = "unchecked"))]
                        if di != 0 {
                            if di < last {
                                return Err(::bebop::DeserializeError::CorruptFrame);
                            }
                            last = di;
                        }

                        i += 1;
                        match di {
                            0 => {
                                break;
                            }
                            1 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _value.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _value = Some(value)
                            }
                            _ => {
                                i = len;
                                break;
                            }
                        }
                    }

                    if i != len {
                        debug_assert!(i > len);
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    DataItemValue::BigInt { value: _value }
                }
                4 => {
                    let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;
                    let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                    i += read;

                    DataItemValue::Bytes {
                        encoding: v0,
                        raw: v1,
                    }
                }
                _ => {
                    i = len;
                    DataItemValue::Unknown
                }
            };
            if !cfg!(feature = "unchecked") && i != len {
                debug_assert!(i > len);
                Err(::bebop::DeserializeError::CorruptFrame)
            } else {
                Ok((i, de))
            }
        }
    }

    impl<'raw> ::bebop::Record<'raw> for DataItemValue {}

    #[derive(Clone, Debug, PartialEq)]
    pub struct DataItem {
        pub key: String,
        pub value: DataItemValue,
    }

    impl<'raw> ::core::convert::From<super::DataItem<'raw>> for DataItem {
        fn from(value: super::DataItem) -> Self {
            Self {
                key: value.key.into(),
                value: value.value.into(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for DataItem {
        const MIN_SERIALIZED_SIZE: usize =
            <String>::MIN_SERIALIZED_SIZE + <DataItemValue>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.key.serialized_size() + self.value.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            Ok(self.key._serialize_chained(dest)? + self.value._serialize_chained(dest)?)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((i, Self { key: v0, value: v1 }))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for DataItem {}

    #[derive(Clone, Debug, PartialEq, Default)]
    pub struct Blob {
        /// Field 1
        pub module_id: ::core::option::Option<u8>,
        /// Field 2
        pub structured_module: ::core::option::Option<ModuleData>,
        /// Field 3
        pub data_module: ::core::option::Option<::std::vec::Vec<DataItem>>,
    }

    impl<'raw> ::core::convert::From<super::Blob<'raw>> for Blob {
        fn from(value: super::Blob) -> Self {
            Self {
                module_id: value.module_id,
                structured_module: value.structured_module.map(|value| value.into()),
                data_module: value
                    .data_module
                    .map(|value| value.into_iter().map(|value| value.into()).collect()),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for Blob {
        const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

        #[inline]
        fn serialized_size(&self) -> usize {
            ::bebop::LEN_SIZE
                + 1
                + self
                    .module_id
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
                + self
                    .structured_module
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
                + self
                    .data_module
                    .as_ref()
                    .map(|v| v.serialized_size() + 1)
                    .unwrap_or(0)
        }

        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            let size = self.serialized_size();
            ::bebop::write_len(dest, size - ::bebop::LEN_SIZE)?;
            if let Some(ref v) = self.module_id {
                1u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.structured_module {
                2u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            if let Some(ref v) = self.data_module {
                3u8._serialize_chained(dest)?;
                v._serialize_chained(dest)?;
            }
            0u8._serialize_chained(dest)?;
            Ok(size)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            let len = ::bebop::read_len(&raw[i..])? + ::bebop::LEN_SIZE;
            i += ::bebop::LEN_SIZE;

            #[cfg(not(feature = "unchecked"))]
            if len == 0 {
                return Err(::bebop::DeserializeError::CorruptFrame);
            }

            if raw.len() < len {
                return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
            }

            let mut _module_id = None;
            let mut _structured_module = None;
            let mut _data_module = None;

            #[cfg(not(feature = "unchecked"))]
            let mut last = 0;

            while i < len {
                let di = raw[i];

                #[cfg(not(feature = "unchecked"))]
                if di != 0 {
                    if di < last {
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }
                    last = di;
                }

                i += 1;
                match di {
                    0 => {
                        break;
                    }
                    1 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _module_id.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _module_id = Some(value)
                    }
                    2 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _structured_module.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _structured_module = Some(value)
                    }
                    3 => {
                        #[cfg(not(feature = "unchecked"))]
                        if _data_module.is_some() {
                            return Err(::bebop::DeserializeError::DuplicateMessageField);
                        }
                        let (read, value) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                        i += read;
                        _data_module = Some(value)
                    }
                    _ => {
                        i = len;
                        break;
                    }
                }
            }

            if i != len {
                debug_assert!(i > len);
                return Err(::bebop::DeserializeError::CorruptFrame);
            }

            Ok((
                i,
                Self {
                    module_id: _module_id,
                    structured_module: _structured_module,
                    data_module: _data_module,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for Blob {}

    #[derive(Clone, Debug, PartialEq)]
    pub struct BlobContainer {
        pub blobs: ::std::vec::Vec<Blob>,
    }

    impl<'raw> ::core::convert::From<super::BlobContainer<'raw>> for BlobContainer {
        fn from(value: super::BlobContainer) -> Self {
            Self {
                blobs: value.blobs.into_iter().map(|value| value.into()).collect(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for BlobContainer {
        const MIN_SERIALIZED_SIZE: usize = <::std::vec::Vec<Blob>>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.blobs.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            Ok(self.blobs._serialize_chained(dest)?)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((i, Self { blobs: v0 }))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for BlobContainer {}

    #[derive(Clone, Debug, PartialEq)]
    pub struct Authority {
        pub scopes: ::std::vec::Vec<String>,
        pub address: ::std::vec::Vec<u8>,
    }

    impl<'raw> ::core::convert::From<super::Authority<'raw>> for Authority {
        fn from(value: super::Authority) -> Self {
            Self {
                scopes: value.scopes.into_iter().map(|value| value.into()).collect(),
                address: value.address.iter().map(|value| value).collect(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for Authority {
        const MIN_SERIALIZED_SIZE: usize = <::std::vec::Vec<String>>::MIN_SERIALIZED_SIZE
            + <::std::vec::Vec<u8>>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.scopes.serialized_size() + self.address.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            Ok(self.scopes._serialize_chained(dest)? + self.address._serialize_chained(dest)?)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    scopes: v0,
                    address: v1,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for Authority {}

    #[derive(Clone, Debug, PartialEq)]
    pub struct Action {
        pub standard: Interface,
        pub data: ActionData,
    }

    impl<'raw> ::core::convert::From<super::Action<'raw>> for Action {
        fn from(value: super::Action) -> Self {
            Self {
                standard: value.standard,
                data: value.data.into(),
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for Action {
        const MIN_SERIALIZED_SIZE: usize =
            <Interface>::MIN_SERIALIZED_SIZE + <ActionData>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.standard.serialized_size() + self.data.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            Ok(self.standard._serialize_chained(dest)? + self.data._serialize_chained(dest)?)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    standard: v0,
                    data: v1,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for Action {}

    #[derive(Clone, Debug, PartialEq)]
    pub enum ActionData {
        /// An unknown type which is likely defined in a newer version of the schema.
        Unknown,

        /// Discriminator 1
        CreateIdentityV1 {
            /// Field 1
            uri: ::core::option::Option<String>,
        },

        /// Discriminator 2
        CreateAssetV1 {
            /// Field 1
            uri: ::core::option::Option<String>,
            /// Field 2
            ownership_model: ::core::option::Option<OwnershipModel>,
            /// Field 3
            royalty_model: ::core::option::Option<RoyaltyModel>,
            /// Field 4
            royalty_target: ::core::option::Option<RoyaltyTarget>,
            /// Field 5
            data_schema: ::core::option::Option<JsonDataSchema>,
            /// Field 6
            creator_shares: ::core::option::Option<::std::vec::Vec<u8>>,
            /// Field 7
            authorities: ::core::option::Option<::std::vec::Vec<Authority>>,
        },

        /// Discriminator 3
        UpdateAssetV1 {
            /// Field 1
            msg: ::core::option::Option<String>,
        },
    }

    impl<'raw> ::core::convert::From<super::ActionData<'raw>> for ActionData {
        fn from(value: super::ActionData) -> Self {
            match value {
                super::ActionData::Unknown => Self::Unknown,
                super::ActionData::CreateIdentityV1 { uri: _uri } => Self::CreateIdentityV1 {
                    uri: _uri.map(|value| value.into()),
                },
                super::ActionData::CreateAssetV1 {
                    uri: _uri,
                    ownership_model: _ownership_model,
                    royalty_model: _royalty_model,
                    royalty_target: _royalty_target,
                    data_schema: _data_schema,
                    creator_shares: _creator_shares,
                    authorities: _authorities,
                } => Self::CreateAssetV1 {
                    uri: _uri.map(|value| value.into()),
                    ownership_model: _ownership_model,
                    royalty_model: _royalty_model,
                    royalty_target: _royalty_target.map(|value| value.into()),
                    data_schema: _data_schema,
                    creator_shares: _creator_shares
                        .map(|value| value.iter().map(|value| value).collect()),
                    authorities: _authorities
                        .map(|value| value.into_iter().map(|value| value.into()).collect()),
                },
                super::ActionData::UpdateAssetV1 { msg: _msg } => Self::UpdateAssetV1 {
                    msg: _msg.map(|value| value.into()),
                },
            }
        }
    }
    impl<'raw> ::bebop::SubRecord<'raw> for ActionData {
        const MIN_SERIALIZED_SIZE: usize = ::bebop::LEN_SIZE + 1;

        fn serialized_size(&self) -> usize {
            ::bebop::LEN_SIZE
                + 1
                + match self {
                    ActionData::Unknown => 0,
                    Self::CreateIdentityV1 { uri: ref _uri } => {
                        ::bebop::LEN_SIZE
                            + 1
                            + _uri.as_ref().map(|v| v.serialized_size() + 1).unwrap_or(0)
                    }
                    Self::CreateAssetV1 {
                        uri: ref _uri,
                        ownership_model: ref _ownership_model,
                        royalty_model: ref _royalty_model,
                        royalty_target: ref _royalty_target,
                        data_schema: ref _data_schema,
                        creator_shares: ref _creator_shares,
                        authorities: ref _authorities,
                    } => {
                        ::bebop::LEN_SIZE
                            + 1
                            + _uri.as_ref().map(|v| v.serialized_size() + 1).unwrap_or(0)
                            + _ownership_model
                                .as_ref()
                                .map(|v| v.serialized_size() + 1)
                                .unwrap_or(0)
                            + _royalty_model
                                .as_ref()
                                .map(|v| v.serialized_size() + 1)
                                .unwrap_or(0)
                            + _royalty_target
                                .as_ref()
                                .map(|v| v.serialized_size() + 1)
                                .unwrap_or(0)
                            + _data_schema
                                .as_ref()
                                .map(|v| v.serialized_size() + 1)
                                .unwrap_or(0)
                            + _creator_shares
                                .as_ref()
                                .map(|v| v.serialized_size() + 1)
                                .unwrap_or(0)
                            + _authorities
                                .as_ref()
                                .map(|v| v.serialized_size() + 1)
                                .unwrap_or(0)
                    }
                    Self::UpdateAssetV1 { msg: ref _msg } => {
                        ::bebop::LEN_SIZE
                            + 1
                            + _msg.as_ref().map(|v| v.serialized_size() + 1).unwrap_or(0)
                    }
                }
        }

        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            let size = self.serialized_size();
            ::bebop::write_len(dest, size - ::bebop::LEN_SIZE - 1)?;
            match self {
                ActionData::Unknown => {
                    return Err(::bebop::SerializeError::CannotSerializeUnknownUnion);
                }
                Self::CreateIdentityV1 { uri: ref _uri } => {
                    1u8._serialize_chained(dest)?;
                    ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                    if let Some(ref v) = _uri {
                        1u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    0u8._serialize_chained(dest)?;
                }
                Self::CreateAssetV1 {
                    uri: ref _uri,
                    ownership_model: ref _ownership_model,
                    royalty_model: ref _royalty_model,
                    royalty_target: ref _royalty_target,
                    data_schema: ref _data_schema,
                    creator_shares: ref _creator_shares,
                    authorities: ref _authorities,
                } => {
                    2u8._serialize_chained(dest)?;
                    ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                    if let Some(ref v) = _uri {
                        1u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    if let Some(ref v) = _ownership_model {
                        2u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    if let Some(ref v) = _royalty_model {
                        3u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    if let Some(ref v) = _royalty_target {
                        4u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    if let Some(ref v) = _data_schema {
                        5u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    if let Some(ref v) = _creator_shares {
                        6u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    if let Some(ref v) = _authorities {
                        7u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    0u8._serialize_chained(dest)?;
                }
                Self::UpdateAssetV1 { msg: ref _msg } => {
                    3u8._serialize_chained(dest)?;
                    ::bebop::write_len(dest, size - ::bebop::LEN_SIZE * 2 - 1)?;
                    if let Some(ref v) = _msg {
                        1u8._serialize_chained(dest)?;
                        v._serialize_chained(dest)?;
                    }
                    0u8._serialize_chained(dest)?;
                }
            }
            Ok(size)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let len = ::bebop::read_len(&raw)? + ::bebop::LEN_SIZE + 1;
            let mut i = ::bebop::LEN_SIZE + 1;
            let de = match raw[::bebop::LEN_SIZE] {
                1 => {
                    let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                    i += ::bebop::LEN_SIZE;

                    #[cfg(not(feature = "unchecked"))]
                    if len == 0 {
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    if raw.len() < len {
                        return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                    }

                    let mut _uri = None;

                    #[cfg(not(feature = "unchecked"))]
                    let mut last = 0;

                    while i < len {
                        let di = raw[i];

                        #[cfg(not(feature = "unchecked"))]
                        if di != 0 {
                            if di < last {
                                return Err(::bebop::DeserializeError::CorruptFrame);
                            }
                            last = di;
                        }

                        i += 1;
                        match di {
                            0 => {
                                break;
                            }
                            1 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _uri.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _uri = Some(value)
                            }
                            _ => {
                                i = len;
                                break;
                            }
                        }
                    }

                    if i != len {
                        debug_assert!(i > len);
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    ActionData::CreateIdentityV1 { uri: _uri }
                }
                2 => {
                    let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                    i += ::bebop::LEN_SIZE;

                    #[cfg(not(feature = "unchecked"))]
                    if len == 0 {
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    if raw.len() < len {
                        return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                    }

                    let mut _uri = None;
                    let mut _ownership_model = None;
                    let mut _royalty_model = None;
                    let mut _royalty_target = None;
                    let mut _data_schema = None;
                    let mut _creator_shares = None;
                    let mut _authorities = None;

                    #[cfg(not(feature = "unchecked"))]
                    let mut last = 0;

                    while i < len {
                        let di = raw[i];

                        #[cfg(not(feature = "unchecked"))]
                        if di != 0 {
                            if di < last {
                                return Err(::bebop::DeserializeError::CorruptFrame);
                            }
                            last = di;
                        }

                        i += 1;
                        match di {
                            0 => {
                                break;
                            }
                            1 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _uri.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _uri = Some(value)
                            }
                            2 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _ownership_model.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _ownership_model = Some(value)
                            }
                            3 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _royalty_model.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _royalty_model = Some(value)
                            }
                            4 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _royalty_target.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _royalty_target = Some(value)
                            }
                            5 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _data_schema.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _data_schema = Some(value)
                            }
                            6 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _creator_shares.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _creator_shares = Some(value)
                            }
                            7 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _authorities.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _authorities = Some(value)
                            }
                            _ => {
                                i = len;
                                break;
                            }
                        }
                    }

                    if i != len {
                        debug_assert!(i > len);
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    ActionData::CreateAssetV1 {
                        uri: _uri,
                        ownership_model: _ownership_model,
                        royalty_model: _royalty_model,
                        royalty_target: _royalty_target,
                        data_schema: _data_schema,
                        creator_shares: _creator_shares,
                        authorities: _authorities,
                    }
                }
                3 => {
                    let len = ::bebop::read_len(&raw[i..])? + i + ::bebop::LEN_SIZE;
                    i += ::bebop::LEN_SIZE;

                    #[cfg(not(feature = "unchecked"))]
                    if len == 0 {
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    if raw.len() < len {
                        return Err(::bebop::DeserializeError::MoreDataExpected(len - raw.len()));
                    }

                    let mut _msg = None;

                    #[cfg(not(feature = "unchecked"))]
                    let mut last = 0;

                    while i < len {
                        let di = raw[i];

                        #[cfg(not(feature = "unchecked"))]
                        if di != 0 {
                            if di < last {
                                return Err(::bebop::DeserializeError::CorruptFrame);
                            }
                            last = di;
                        }

                        i += 1;
                        match di {
                            0 => {
                                break;
                            }
                            1 => {
                                #[cfg(not(feature = "unchecked"))]
                                if _msg.is_some() {
                                    return Err(::bebop::DeserializeError::DuplicateMessageField);
                                }
                                let (read, value) =
                                    ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
                                i += read;
                                _msg = Some(value)
                            }
                            _ => {
                                i = len;
                                break;
                            }
                        }
                    }

                    if i != len {
                        debug_assert!(i > len);
                        return Err(::bebop::DeserializeError::CorruptFrame);
                    }

                    ActionData::UpdateAssetV1 { msg: _msg }
                }
                _ => {
                    i = len;
                    ActionData::Unknown
                }
            };
            if !cfg!(feature = "unchecked") && i != len {
                debug_assert!(i > len);
                Err(::bebop::DeserializeError::CorruptFrame)
            } else {
                Ok((i, de))
            }
        }
    }

    impl<'raw> ::bebop::Record<'raw> for ActionData {}

    pub use super::MAX_MODULES;

    pub use super::OwnershipModel;

    pub use super::RoyaltyModel;

    #[derive(Clone, Debug, PartialEq)]
    pub struct RoyaltyTarget {
        pub address: ::std::vec::Vec<u8>,
        pub share: u8,
    }

    impl<'raw> ::core::convert::From<super::RoyaltyTarget<'raw>> for RoyaltyTarget {
        fn from(value: super::RoyaltyTarget) -> Self {
            Self {
                address: value.address.iter().map(|value| value).collect(),
                share: value.share,
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for RoyaltyTarget {
        const MIN_SERIALIZED_SIZE: usize =
            <::std::vec::Vec<u8>>::MIN_SERIALIZED_SIZE + <u8>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.address.serialized_size() + self.share.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            Ok(self.address._serialize_chained(dest)? + self.share._serialize_chained(dest)?)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    address: v0,
                    share: v1,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for RoyaltyTarget {}

    #[derive(Clone, Debug, PartialEq)]
    pub struct Creator {
        pub address: ::std::vec::Vec<u8>,
        pub share: u8,
        pub verified: bool,
    }

    impl<'raw> ::core::convert::From<super::Creator<'raw>> for Creator {
        fn from(value: super::Creator) -> Self {
            Self {
                address: value.address.iter().map(|value| value).collect(),
                share: value.share,
                verified: value.verified,
            }
        }
    }

    impl<'raw> ::bebop::SubRecord<'raw> for Creator {
        const MIN_SERIALIZED_SIZE: usize = <::std::vec::Vec<u8>>::MIN_SERIALIZED_SIZE
            + <u8>::MIN_SERIALIZED_SIZE
            + <bool>::MIN_SERIALIZED_SIZE;

        #[inline]
        fn serialized_size(&self) -> usize {
            self.address.serialized_size()
                + self.share.serialized_size()
                + self.verified.serialized_size()
        }

        fn _serialize_chained<W: ::std::io::Write>(
            &self,
            dest: &mut W,
        ) -> ::bebop::SeResult<usize> {
            Ok(self.address._serialize_chained(dest)?
                + self.share._serialize_chained(dest)?
                + self.verified._serialize_chained(dest)?)
        }

        fn _deserialize_chained(raw: &'raw [u8]) -> ::bebop::DeResult<(usize, Self)> {
            let mut i = 0;
            if raw.len() - i < Self::MIN_SERIALIZED_SIZE {
                let missing = Self::MIN_SERIALIZED_SIZE - (raw.len() - i);
                return Err(::bebop::DeserializeError::MoreDataExpected(missing));
            }

            let (read, v0) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v1) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;
            let (read, v2) = ::bebop::SubRecord::_deserialize_chained(&raw[i..])?;
            i += read;

            Ok((
                i,
                Self {
                    address: v0,
                    share: v1,
                    verified: v2,
                },
            ))
        }
    }

    impl<'raw> ::bebop::Record<'raw> for Creator {}

    pub use super::Lifecycle;

    pub use super::JsonDataSchema;
}


