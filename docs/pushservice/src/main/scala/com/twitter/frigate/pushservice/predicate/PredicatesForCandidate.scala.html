<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.frigate.pushservice.predicate</p>
<p>import com.twitter.finagle.stats.StatsReceiver
import com.twitter.frigate.common.base._
import com.twitter.frigate.common.candidate.MaxTweetAge
import com.twitter.frigate.common.candidate.TargetABDecider
import com.twitter.frigate.common.predicate.tweet.TweetAuthorPredicates
import com.twitter.frigate.common.predicate._
import com.twitter.frigate.common.rec_types.RecTypes
import com.twitter.frigate.common.util.SnowflakeUtils
import com.twitter.frigate.pushservice.model.PushTypes.PushCandidate
import com.twitter.frigate.pushservice.params.PushFeatureSwitchParams
import com.twitter.frigate.pushservice.params.PushParams
import com.twitter.frigate.pushservice.util.CandidateUtil
import com.twitter.frigate.thriftscala.ChannelName
import com.twitter.frigate.thriftscala.CommonRecommendationType
import com.twitter.gizmoduck.thriftscala.User
import com.twitter.gizmoduck.thriftscala.UserType
import com.twitter.hermit.predicate.NamedPredicate
import com.twitter.hermit.predicate.Predicate
import com.twitter.hermit.predicate.gizmoduck._
import com.twitter.hermit.predicate.socialgraph.Edge
import com.twitter.hermit.predicate.socialgraph.MultiEdge
import com.twitter.hermit.predicate.socialgraph.RelationEdge
import com.twitter.hermit.predicate.socialgraph.SocialGraphPredicate
import com.twitter.service.metastore.gen.thriftscala.Location
import com.twitter.socialgraph.thriftscala.RelationshipType
import com.twitter.stitch.tweetypie.TweetyPie.TweetyPieResult
import com.twitter.storehaus.ReadableStore
import com.twitter.timelines.configapi.Param
import com.twitter.util.Duration
import com.twitter.util.Future</p>
<p>object PredicatesForCandidate {</p>
<blockquote>
<div><dl>
<dt>def oldTweetRecsPredicate(implicit stats: StatsReceiver): Predicate[</dt><dd><dl class="simple">
<dt>TweetCandidate with RecommendationType with TargetInfo[</dt><dd><p>TargetUser with TargetABDecider with MaxTweetAge</p>
</dd>
</dl>
<p>]</p>
</dd>
<dt>] = {</dt><dd><p>val name = “old_tweet”
Predicate</p>
<blockquote>
<div><dl>
<dt>.from[TweetCandidate with RecommendationType with TargetInfo[</dt><dd><p>TargetUser with TargetABDecider with MaxTweetAge</p>
</dd>
<dt>]] { candidate =&gt;</dt><dd><dl>
<dt>{</dt><dd><p>val crt = candidate.commonRecType
val defaultAge = if (RecTypes.mrModelingBasedTypes.contains(crt)) {</p>
<blockquote>
<div><p>candidate.target.params(PushFeatureSwitchParams.ModelingBasedCandidateMaxTweetAgeParam)</p>
</div></blockquote>
<dl class="simple">
<dt>} else if (RecTypes.GeoPopTweetTypes.contains(crt)) {</dt><dd><p>candidate.target.params(PushFeatureSwitchParams.GeoPopTweetMaxAgeInHours)</p>
</dd>
<dt>} else if (RecTypes.simclusterBasedTweets.contains(crt)) {</dt><dd><dl class="simple">
<dt>candidate.target.params(</dt><dd><p>PushFeatureSwitchParams.SimclusterBasedCandidateMaxTweetAgeParam)</p>
</dd>
</dl>
</dd>
<dt>} else if (RecTypes.detopicTypes.contains(crt)) {</dt><dd><p>candidate.target.params(PushFeatureSwitchParams.DetopicBasedCandidateMaxTweetAgeParam)</p>
</dd>
<dt>} else if (RecTypes.f1FirstDegreeTypes.contains(crt)) {</dt><dd><p>candidate.target.params(PushFeatureSwitchParams.F1CandidateMaxTweetAgeParam)</p>
</dd>
<dt>} else if (crt == CommonRecommendationType.ExploreVideoTweet) {</dt><dd><p>candidate.target.params(PushFeatureSwitchParams.ExploreVideoTweetAgeParam)</p>
</dd>
<dt>} else</dt><dd><p>candidate.target.params(PushFeatureSwitchParams.MaxTweetAgeParam)</p>
</dd>
</dl>
<p>SnowflakeUtils.isRecent(candidate.tweetId, defaultAge)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.withStats(stats.scope(name))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def tweetIsNotAreply(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[TweetCandidate with TweetDetails] = {</dt><dd><p>val name = “tweet_candidate_not_a_reply”
Predicate</p>
<blockquote>
<div><dl>
<dt>.from[TweetCandidate with TweetDetails] { c =&gt;</dt><dd><dl class="simple">
<dt>c.isReply match {</dt><dd><p>case Some(true) =&gt; false
case _ =&gt; true</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.withStats(stats.scope(name))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Check if tweet contains any optouted free form interests.</p></li>
<li><p>Currently, we use it for media categories and semantic core</p></li>
<li><p>&#64;param stats</p></li>
<li><p>&#64;return</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>def noOptoutFreeFormInterestPredicate(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate] = {</dt><dd><p>val name = “free_form_interest_opt_out”
val tweetMediaAnnotationFeature =</p>
<blockquote>
<div><p>“tweet.mediaunderstanding.tweet_annotations.safe_category_probabilities”</p>
</div></blockquote>
<dl class="simple">
<dt>val tweetSemanticCoreFeature =</dt><dd><p>“tweet.core.tweet.semantic_core_annotations”</p>
</dd>
</dl>
<p>val scopedStatsReceiver = stats.scope(s”predicate_$name”)
val withOptOutFreeFormInterestsCounter = stats.counter(“with_optout_interests”)
val withoutOptOutInterestsCounter = stats.counter(“without_optout_interests”)
val withOptOutFreeFormInterestsFromMediaAnnotationCounter =</p>
<blockquote>
<div><p>stats.counter(“with_optout_interests_from_media_annotation”)</p>
</div></blockquote>
<dl>
<dt>val withOptOutFreeFormInterestsFromSemanticCoreCounter =</dt><dd><p>stats.counter(“with_optout_interests_from_semantic_core”)</p>
</dd>
<dt>Predicate</dt><dd><dl>
<dt>.fromAsync { candidate: PushCandidate =&gt;</dt><dd><dl>
<dt>val tweetSemanticCoreEntityIds = candidate.sparseBinaryFeatures</dt><dd><dl class="simple">
<dt>.getOrElse(tweetSemanticCoreFeature, Set.empty[String]).map { id =&gt;</dt><dd><p>id.split(‘.’)(2)</p>
</dd>
</dl>
<p>}.toSet</p>
</dd>
<dt>val tweetMediaAnnotationIds = candidate.sparseContinuousFeatures</dt><dd><p>.getOrElse(tweetMediaAnnotationFeature, Map.empty[String, Double]).keys.toSet</p>
</dd>
<dt>candidate.target.optOutFreeFormUserInterests.map {</dt><dd><dl>
<dt>case optOutUserInterests: Seq[String] =&gt;</dt><dd><p>withOptOutFreeFormInterestsCounter.incr()
val optOutUserInterestsSet = optOutUserInterests.toSet
val mediaAnnoIntersect = optOutUserInterestsSet.intersect(tweetMediaAnnotationIds)
val semanticCoreIntersect = optOutUserInterestsSet.intersect(tweetSemanticCoreEntityIds)
if (!mediaAnnoIntersect.isEmpty) {</p>
<blockquote>
<div><p>withOptOutFreeFormInterestsFromMediaAnnotationCounter.incr()</p>
</div></blockquote>
<p>}
if (!semanticCoreIntersect.isEmpty) {</p>
<blockquote>
<div><p>withOptOutFreeFormInterestsFromSemanticCoreCounter.incr()</p>
</div></blockquote>
<p>}
semanticCoreIntersect.isEmpty &amp;&amp; mediaAnnoIntersect.isEmpty</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>withoutOptOutInterestsCounter.incr()
true</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.withStats(scopedStatsReceiver)
.withName(name)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def tweetCandidateWithLessThan2SocialContextsIsAReply(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[TweetCandidate with TweetDetails with SocialContextActions] = {</dt><dd><p>val name = “tweet_candidate_with_less_than_2_social_contexts_is_not_a_reply”
Predicate</p>
<blockquote>
<div><dl>
<dt>.from[TweetCandidate with TweetDetails with SocialContextActions] { cand =&gt;</dt><dd><dl class="simple">
<dt>cand.isReply match {</dt><dd><p>case Some(true) if cand.socialContextTweetIds.size &lt; 2 =&gt; false
case _ =&gt; true</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.withStats(stats.scope(name))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def f1CandidateIsNotAReply(implicit stats: StatsReceiver): NamedPredicate[F1Candidate] = {</dt><dd><p>val name = “f1_candidate_is_not_a_reply”
Predicate</p>
<blockquote>
<div><dl>
<dt>.from[F1Candidate] { candidate =&gt;</dt><dd><dl class="simple">
<dt>candidate.isReply match {</dt><dd><p>case Some(true) =&gt; false
case _ =&gt; true</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.withStats(stats.scope(name))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def outOfNetworkTweetCandidateEnabledCrTag(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[OutOfNetworkTweetCandidate with TargetInfo[TargetUser with TargetABDecider]] = {</dt><dd><p>val name = “out_of_network_tweet_candidate_enabled_crtag”
val scopedStats = stats.scope(name)
Predicate</p>
<blockquote>
<div><dl>
<dt>.from[OutOfNetworkTweetCandidate with TargetInfo[TargetUser with TargetABDecider]] { cand =&gt;</dt><dd><dl class="simple">
<dt>val disabledCrTag = cand.target</dt><dd><p>.params(PushFeatureSwitchParams.OONCandidatesDisabledCrTagParam)</p>
</dd>
<dt>val candGeneratedByDisabledSignal = cand.tagsCR.exists { tagsCR =&gt;</dt><dd><p>val tagsCRSet = tagsCR.map(_.toString).toSet
tagsCRSet.nonEmpty &amp;&amp; tagsCRSet.subsetOf(disabledCrTag.toSet)</p>
</dd>
</dl>
<p>}
if (candGeneratedByDisabledSignal) {</p>
<blockquote>
<div><p>cand.tagsCR.getOrElse(Nil).foreach(tag =&gt; scopedStats.counter(tag.toString).incr())
false</p>
</div></blockquote>
<p>} else true</p>
</dd>
</dl>
<p>}
.withStats(scopedStats)
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def outOfNetworkTweetCandidateEnabledCrtGroup(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[OutOfNetworkTweetCandidate with TargetInfo[TargetUser with TargetABDecider]] = {</dt><dd><p>val name = “out_of_network_tweet_candidate_enabled_crt_group”
val scopedStats = stats.scope(name)
Predicate</p>
<blockquote>
<div><dl>
<dt>.from[OutOfNetworkTweetCandidate with TargetInfo[TargetUser with TargetABDecider]] { cand =&gt;</dt><dd><dl class="simple">
<dt>val disabledCrtGroup = cand.target</dt><dd><p>.params(PushFeatureSwitchParams.OONCandidatesDisabledCrtGroupParam)</p>
</dd>
</dl>
<p>val crtGroup = CandidateUtil.getCrtGroup(cand.commonRecType)
val candGeneratedByDisabledCrt = disabledCrtGroup.contains(crtGroup)
if (candGeneratedByDisabledCrt) {</p>
<blockquote>
<div><p>scopedStats.counter(”<a href="#id15"><span class="problematic" id="id16">filter_</span></a>” + crtGroup.toString).incr()
false</p>
</div></blockquote>
<p>} else true</p>
</dd>
</dl>
<p>}
.withStats(scopedStats)
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def outOfNetworkTweetCandidateIsNotAReply(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[OutOfNetworkTweetCandidate] = {</dt><dd><p>val name = “out_of_network_tweet_candidate_is_not_a_reply”
Predicate</p>
<blockquote>
<div><dl>
<dt>.from[OutOfNetworkTweetCandidate] { cand =&gt;</dt><dd><dl class="simple">
<dt>cand.isReply match {</dt><dd><p>case Some(true) =&gt; false
case _ =&gt; true</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.withStats(stats.scope(name))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def recommendedTweetIsAuthoredBySelf(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate] =</dt><dd><dl>
<dt>Predicate</dt><dd><dl>
<dt>.from[PushCandidate] {</dt><dd><dl>
<dt>case tweetCandidate: PushCandidate with TweetDetails =&gt;</dt><dd><dl class="simple">
<dt>tweetCandidate.authorId match {</dt><dd><p>case Some(authorId) =&gt; authorId != tweetCandidate.target.targetId
case None =&gt; true</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>true</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.withStats(statsReceiver.scope(“predicate_self_author”))
.withName(“self_author”)</p>
</dd>
</dl>
</dd>
<dt>def authorInSocialContext(implicit statsReceiver: StatsReceiver): NamedPredicate[PushCandidate] =</dt><dd><dl>
<dt>Predicate</dt><dd><dl>
<dt>.from[PushCandidate] {</dt><dd><dl>
<dt>case tweetCandidate: PushCandidate with TweetDetails with SocialContextActions =&gt;</dt><dd><dl>
<dt>tweetCandidate.authorId match {</dt><dd><dl class="simple">
<dt>case Some(authorId) =&gt;</dt><dd><p>!tweetCandidate.socialContextUserIds.contains(authorId)</p>
</dd>
</dl>
<p>case None =&gt; true</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>case _ =&gt; true</p>
</dd>
</dl>
<p>}
.withStats(statsReceiver.scope(“predicate_author_social_context”))
.withName(“author_social_context”)</p>
</dd>
</dl>
</dd>
<dt>def selfInSocialContext(implicit statsReceiver: StatsReceiver): NamedPredicate[PushCandidate] = {</dt><dd><p>val name = “self_social_context”
Predicate</p>
<blockquote>
<div><dl class="simple">
<dt>.from[PushCandidate] {</dt><dd><dl class="simple">
<dt>case candidate: PushCandidate with SocialContextActions =&gt;</dt><dd><p>!candidate.socialContextUserIds.contains(candidate.target.targetId)</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>true</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.withStats(statsReceiver.scope(s”${name}_predicate”))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def minSocialContext(</dt><dd><p>threshold: Int</p>
</dd>
<dt>)(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate with SocialContextActions] = {</dt><dd><dl>
<dt>Predicate</dt><dd><dl class="simple">
<dt>.from { candidate: PushCandidate with SocialContextActions =&gt;</dt><dd><p>candidate.socialContextUserIds.size &gt;= threshold</p>
</dd>
</dl>
<p>}
.withStats(statsReceiver.scope(“predicate_min_social_context”))
.withName(“min_social_context”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def anyWithheldContent(</dt><dd><p>userStore: ReadableStore[Long, User],
userCountryStore: ReadableStore[Long, Location]</p>
</dd>
<dt>)(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): Predicate[TargetRecUser] =</dt><dd><dl class="simple">
<dt>GizmoduckUserPredicate.withheldContentPredicate(</dt><dd><p>userStore = userStore,
userCountryStore = userCountryStore,
statsReceiver = statsReceiver,
checkAllCountries = true</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>def targetUserExists(implicit statsReceiver: StatsReceiver): NamedPredicate[PushCandidate] = {</dt><dd><dl class="simple">
<dt>TargetUserPredicates</dt><dd><p>.targetUserExists()(statsReceiver)
.flatContraMap { candidate: PushCandidate =&gt; Future.value(candidate.target) }
.withName(“target_user_exists”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def secondaryDormantAccountPredicate(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate] = {</dt><dd><p>val name = “secondary_dormant_account”
TargetUserPredicates</p>
<blockquote>
<div><p>.secondaryDormantAccountPredicate()(statsReceiver)
.on { candidate: PushCandidate =&gt; candidate.target }
.withStats(statsReceiver.scope(s”predicate_$name”))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def socialContextBeingFollowed(</dt><dd><p>edgeStore: ReadableStore[RelationEdge, Boolean]</p>
</dd>
<dt>)(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate with SocialContextActions] =</dt><dd><dl>
<dt>SocialGraphPredicate</dt><dd><p>.allRelationEdgesExist(edgeStore, RelationshipType.Following)
.on { candidate: PushCandidate with SocialContextActions =&gt;</p>
<blockquote>
<div><p>candidate.socialContextUserIds.map { u =&gt; Edge(candidate.target.targetId, u) }</p>
</div></blockquote>
<p>}
.withStats(statsReceiver.scope(“predicate_social_context_being_followed”))
.withName(“social_context_being_followed”)</p>
</dd>
</dl>
</dd>
<dt>private def edgeFromCandidate(candidate: PushCandidate with TweetAuthor): Option[Edge] = {</dt><dd><p>candidate.authorId map { authorId =&gt; Edge(candidate.target.targetId, authorId) }</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def authorNotBeingDeviceFollowed(</dt><dd><p>edgeStore: ReadableStore[RelationEdge, Boolean]</p>
</dd>
<dt>)(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate with TweetAuthor] = {</dt><dd><dl>
<dt>SocialGraphPredicate</dt><dd><p>.relationExists(edgeStore, RelationshipType.DeviceFollowing)
.optionalOn(</p>
<blockquote>
<div><p>edgeFromCandidate,
missingResult = false</p>
</div></blockquote>
<p>)
.flip
.withStats(statsReceiver.scope(“predicate_author_not_device_followed”))
.withName(“author_not_device_followed”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def authorBeingFollowed(</dt><dd><p>edgeStore: ReadableStore[RelationEdge, Boolean]</p>
</dd>
<dt>)(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate with TweetAuthor] = {</dt><dd><dl>
<dt>SocialGraphPredicate</dt><dd><p>.relationExists(edgeStore, RelationshipType.Following)
.optionalOn(</p>
<blockquote>
<div><p>edgeFromCandidate,
missingResult = false</p>
</div></blockquote>
<p>)
.withStats(statsReceiver.scope(“predicate_author_being_followed”))
.withName(“author_being_followed”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def authorNotBeingFollowed(</dt><dd><p>edgeStore: ReadableStore[RelationEdge, Boolean]</p>
</dd>
<dt>)(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate with TweetAuthor] = {</dt><dd><dl>
<dt>SocialGraphPredicate</dt><dd><p>.relationExists(edgeStore, RelationshipType.Following)
.optionalOn(</p>
<blockquote>
<div><p>edgeFromCandidate,
missingResult = false</p>
</div></blockquote>
<p>)
.flip
.withStats(statsReceiver.scope(“predicate_author_not_being_followed”))
.withName(“author_not_being_followed”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def recommendedTweetAuthorAcceptableToTargetUser(</dt><dd><p>edgeStore: ReadableStore[RelationEdge, Boolean]</p>
</dd>
<dt>)(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate with TweetAuthor] = {</dt><dd><p>val name = “recommended_tweet_author_acceptable_to_target_user”
SocialGraphPredicate</p>
<blockquote>
<div><dl>
<dt>.anyRelationExists(</dt><dd><p>edgeStore,
Set(</p>
<blockquote>
<div><p>RelationshipType.Blocking,
RelationshipType.BlockedBy,
RelationshipType.HideRecommendations,
RelationshipType.Muting</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)
.flip
.optionalOn(</p>
<blockquote>
<div><p>edgeFromCandidate,
missingResult = false</p>
</div></blockquote>
<p>)
.withStats(statsReceiver.scope(s”predicate_$name”))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def relationNotExistsPredicate(</dt><dd><p>edgeStore: ReadableStore[RelationEdge, Boolean],
relations: Set[RelationshipType]</p>
</dd>
<dt>): Predicate[(Long, Iterable[Long])] =</dt><dd><dl>
<dt>SocialGraphPredicate</dt><dd><dl class="simple">
<dt>.anyRelationExistsForMultiEdge(</dt><dd><p>edgeStore,
relations</p>
</dd>
</dl>
<p>)
.flip
.on {</p>
<blockquote>
<div><dl class="simple">
<dt>case (targetUserId, userIds) =&gt;</dt><dd><p>MultiEdge(targetUserId, userIds.toSet)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
<dt>def blocking(edgeStore: ReadableStore[RelationEdge, Boolean]): Predicate[(Long, Iterable[Long])] =</dt><dd><dl class="simple">
<dt>relationNotExistsPredicate(</dt><dd><p>edgeStore,
Set(RelationshipType.BlockedBy, RelationshipType.Blocking)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>def blockingOrMuting(</dt><dd><p>edgeStore: ReadableStore[RelationEdge, Boolean]</p>
</dd>
<dt>): Predicate[(Long, Iterable[Long])] =</dt><dd><dl class="simple">
<dt>relationNotExistsPredicate(</dt><dd><p>edgeStore,
Set(RelationshipType.BlockedBy, RelationshipType.Blocking, RelationshipType.Muting)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>def socialContextNotRetweetFollowing(</dt><dd><p>edgeStore: ReadableStore[RelationEdge, Boolean]</p>
</dd>
<dt>)(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate with SocialContextActions] = {</dt><dd><p>val name = “social_context_not_retweet_following”
relationNotExistsPredicate(edgeStore, Set(RelationshipType.NotRetweetFollowing))</p>
<blockquote>
<div><dl>
<dt>.optionalOn[PushCandidate with SocialContextActions](</dt><dd><dl>
<dt>{</dt><dd><dl>
<dt>case candidate: PushCandidate with SocialContextActions</dt><dd><blockquote>
<div><p>if RecTypes.isTweetRetweetType(candidate.commonRecType) =&gt;</p>
</div></blockquote>
<p>Some((candidate.target.targetId, candidate.socialContextUserIds))</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>None</p>
</dd>
</dl>
</dd>
</dl>
<p>},
missingResult = true</p>
</dd>
</dl>
<p>)
.withStats(statsReceiver.scope(s”predicate_$name”))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def socialContextBlockingOrMuting(</dt><dd><p>edgeStore: ReadableStore[RelationEdge, Boolean]</p>
</dd>
<dt>)(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate with SocialContextActions] =</dt><dd><dl>
<dt>blockingOrMuting(edgeStore)</dt><dd><dl class="simple">
<dt>.on { candidate: PushCandidate with SocialContextActions =&gt;</dt><dd><p>(candidate.target.targetId, candidate.socialContextUserIds)</p>
</dd>
</dl>
<p>}
.withStats(statsReceiver.scope(“predicate_social_context_blocking_or_muting”))
.withName(“social_context_blocking_or_muting”)</p>
</dd>
</dl>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Use hyrated Tweet object for F1 Protected experiment for checking null cast as Tweetypie hydration</p></li>
<li><p>fails for protected Authors without passing in Target id. We do this specifically for</p></li>
<li><p>F1 Protected Tweet Experiment in Earlybird Adaptor.</p></li>
<li><p>For rest of the traffic refer to existing Nullcast Predicate</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>def nullCastF1ProtectedExperientPredicate(</dt><dd><p>tweetypieStore: ReadableStore[Long, TweetyPieResult]</p>
</dd>
<dt>)(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate with TweetCandidate with TweetDetails] = {</dt><dd><p>val name = “f1_exempted_null_cast_tweet”
val f1NullCastCheckCounter = statsReceiver.scope(name).counter(“f1_null_cast_check”)
Predicate</p>
<blockquote>
<div><dl>
<dt>.fromAsync { tweetCandidate: PushCandidate with TweetCandidate with TweetDetails =&gt;</dt><dd><dl>
<dt>if (RecTypes.f1FirstDegreeTypes(tweetCandidate.commonRecType) &amp;&amp; tweetCandidate.target</dt><dd><blockquote>
<div><p>.params(PushFeatureSwitchParams.EnableF1FromProtectedTweetAuthors)) {</p>
</div></blockquote>
<p>f1NullCastCheckCounter.incr()
tweetCandidate.tweet match {</p>
<blockquote>
<div><dl class="simple">
<dt>case Some(tweetObj) =&gt;</dt><dd><p>baseNullCastTweet().apply(Seq(TweetyPieResult(tweetObj, None, None))).map(_.head)</p>
</dd>
</dl>
<p>case _ =&gt; Future.False</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>nullCastTweet(tweetypieStore).apply(Seq(tweetCandidate)).map(_.head)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.withStats(statsReceiver.scope(s”predicate_$name”))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def baseNullCastTweet(): Predicate[TweetyPieResult] =</dt><dd><p>Predicate.from { t: TweetyPieResult =&gt; !t.tweet.coreData.exists { cd =&gt; cd.nullcast } }</p>
</dd>
<dt>def nullCastTweet(</dt><dd><p>tweetyPieStore: ReadableStore[Long, TweetyPieResult]</p>
</dd>
<dt>)(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate with TweetCandidate] = {</dt><dd><p>val name = “null_cast_tweet”
baseNullCastTweet()</p>
<blockquote>
<div><dl>
<dt>.flatOptionContraMap[PushCandidate with TweetCandidate](</dt><dd><dl class="simple">
<dt>f = (tweetCandidate: PushCandidate</dt><dd><p>with TweetCandidate) =&gt; tweetyPieStore.get(tweetCandidate.tweetId),</p>
</dd>
</dl>
<p>missingResult = false</p>
</dd>
</dl>
<p>)
.withStats(statsReceiver.scope(s”predicate_$name”))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Use the predicate except fn is true.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>def exceptedPredicate[T &lt;: PushCandidate](</dt><dd><p>name: String,
fn: T =&gt; Future[Boolean],
predicate: Predicate[T]</p>
</dd>
<dt>)(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[T] = {</dt><dd><dl class="simple">
<dt>Predicate</dt><dd><p>.fromAsync { e: T =&gt; fn(e) }
.or(predicate)
.withStats(statsReceiver.scope(name))
.withName(name)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li></li>
<li><p>&#64;param edgeStore [[ReadableStore[RelationEdge, Boolean]]]</p></li>
<li><p>&#64;return - allow only out-network tweets if in-network tweets are disabled</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>def disableInNetworkTweetPredicate(</dt><dd><p>edgeStore: ReadableStore[RelationEdge, Boolean]</p>
</dd>
<dt>)(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate with TweetAuthor] = {</dt><dd><p>val name = “disable_in_network_tweet”
Predicate</p>
<blockquote>
<div><dl>
<dt>.fromAsync { candidate: PushCandidate with TweetAuthor =&gt;</dt><dd><dl class="simple">
<dt>if (candidate.target.params(PushParams.DisableInNetworkTweetCandidatesParam)) {</dt><dd><dl class="simple">
<dt>authorNotBeingFollowed(edgeStore)</dt><dd><p>.apply(Seq(candidate))
.map(_.head)</p>
</dd>
</dl>
</dd>
</dl>
<p>} else Future.True</p>
</dd>
</dl>
<p>}.withStats(statsReceiver.scope(name))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li></li>
<li><p>&#64;param edgeStore [[ReadableStore[RelationEdge, Boolean]]]</p></li>
<li><p>&#64;return - allow only in-network tweets if out-network tweets are disabled</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>def disableOutNetworkTweetPredicate(</dt><dd><p>edgeStore: ReadableStore[RelationEdge, Boolean]</p>
</dd>
<dt>)(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate with TweetAuthor] = {</dt><dd><p>val name = “disable_out_network_tweet”
Predicate</p>
<blockquote>
<div><dl>
<dt>.fromAsync { candidate: PushCandidate with TweetAuthor =&gt;</dt><dd><dl class="simple">
<dt>if (candidate.target.params(PushFeatureSwitchParams.DisableOutNetworkTweetCandidatesFS)) {</dt><dd><dl class="simple">
<dt>authorBeingFollowed(edgeStore)</dt><dd><p>.apply(Seq(candidate))
.map(_.head)</p>
</dd>
</dl>
</dd>
</dl>
<p>} else Future.True</p>
</dd>
</dl>
<p>}.withStats(statsReceiver.scope(name))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def alwaysTruePredicate: NamedPredicate[PushCandidate] = {</dt><dd><dl class="simple">
<dt>Predicate</dt><dd><p>.all[PushCandidate]
.withName(“predicate_AlwaysTrue”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def alwaysTruePushCandidatePredicate: NamedPredicate[PushCandidate] = {</dt><dd><dl class="simple">
<dt>Predicate</dt><dd><p>.all[PushCandidate]
.withName(“predicate_AlwaysTrue”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def alwaysFalsePredicate(implicit statsReceiver: StatsReceiver): NamedPredicate[PushCandidate] = {</dt><dd><p>val name = “predicate_AlwaysFalse”
val scopedStatsReceiver = statsReceiver.scope(name)
Predicate</p>
<blockquote>
<div><p>.from { candidate: PushCandidate =&gt; false }
.withStats(scopedStatsReceiver)
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def accountCountryPredicate(</dt><dd><p>allowedCountries: Set[String]</p>
</dd>
<dt>)(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate] = {</dt><dd><p>val name = “AccountCountryPredicate”
val stats = statsReceiver.scope(name)
AccountCountryPredicate(allowedCountries)</p>
<blockquote>
<div><p>.on { candidate: PushCandidate =&gt; candidate.target }
.withStats(stats)
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def paramPredicate[T &lt;: PushCandidate](</dt><dd><p>param: Param[Boolean]</p>
</dd>
<dt>)(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[T] = {</dt><dd><p>val name = param.getClass.getSimpleName.stripSuffix(“$”)
TargetPredicates</p>
<blockquote>
<div><p>.paramPredicate(param)
.on { candidate: PushCandidate =&gt; candidate.target }
.withStats(statsReceiver.scope(s”param_${name}_controlled_predicate”))
.withName(s”param_${name}_controlled_predicate”)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def isDeviceEligibleForNewsOrSports(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate] = {</dt><dd><p>val name = “is_device_eligible_for_news_or_sports”
val scopedStatsReceiver = stats.scope(s”predicate_$name”)
Predicate</p>
<blockquote>
<div><dl class="simple">
<dt>.fromAsync { candidate: PushCandidate =&gt;</dt><dd><p>candidate.target.deviceInfo.map(_.exists(_.isNewsEligible))</p>
</dd>
</dl>
<p>}
.withStats(scopedStatsReceiver)
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def isDeviceEligibleForCreatorPush(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate] = {</dt><dd><p>val name = “is_device_eligible_for_creator_push”
val scopedStatsReceiver = stats.scope(s”predicate_$name”)
Predicate</p>
<blockquote>
<div><dl class="simple">
<dt>.fromAsync { candidate: PushCandidate =&gt;</dt><dd><dl class="simple">
<dt>candidate.target.deviceInfo.map(_.exists(settings =&gt;</dt><dd><p>settings.isNewsEligible || settings.isRecommendationsEligible))</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.withStats(scopedStatsReceiver)
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Like [[TargetUserPredicates.homeTimelineFatigue()]] but for candidate.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>def htlFatiguePredicate(</dt><dd><p>fatigueDuration: Param[Duration]</p>
</dd>
<dt>)(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate] = {</dt><dd><p>val name = “htl_fatigue”
Predicate</p>
<blockquote>
<div><dl>
<dt>.fromAsync { candidate: PushCandidate =&gt;</dt><dd><p>val _fatigueDuration = candidate.target.params(fatigueDuration)
TargetUserPredicates</p>
<blockquote>
<div><dl class="simple">
<dt>.homeTimelineFatigue(</dt><dd><p>fatigueDuration = _fatigueDuration</p>
</dd>
</dl>
<p>).apply(Seq(candidate.target)).map(_.head)</p>
</div></blockquote>
</dd>
</dl>
<p>}
.withStats(statsReceiver.scope(name))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def mrWebHoldbackPredicate(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate] = {</dt><dd><p>val name = “mr_web_holdback_for_candidate”
val scopedStats = stats.scope(name)
PredicatesForCandidate.exludeCrtFromPushHoldback</p>
<blockquote>
<div><dl class="simple">
<dt>.or(</dt><dd><dl class="simple">
<dt>TargetPredicates</dt><dd><p>.webNotifsHoldback()
.on { candidate: PushCandidate =&gt; candidate.target }</p>
</dd>
</dl>
</dd>
</dl>
<p>)
.withStats(scopedStats)
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<p>def candidateEnabledForEmailPredicate(
)(</p>
<blockquote>
<div><p>implicit stats: StatsReceiver</p>
</div></blockquote>
<dl>
<dt>): NamedPredicate[PushCandidate] = {</dt><dd><p>val name = “candidates_enabled_for_email”
Predicate</p>
<blockquote>
<div><dl>
<dt>.from { candidate: PushCandidate =&gt;</dt><dd><dl class="simple">
<dt>if (candidate.target.isEmailUser)</dt><dd><p>candidate.isInstanceOf[TweetCandidate with TweetAuthor with RecommendationType]</p>
</dd>
</dl>
<p>else true</p>
</dd>
</dl>
<p>}
.withStats(stats.scope(name))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def protectedTweetF1ExemptPredicate[</dt><dd><p>T &lt;: TargetUser with TargetABDecider,
Cand &lt;: TweetCandidate with TweetAuthorDetails with TargetInfo[T]</p>
</dd>
<dt>](</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[</dt><dd><dl class="simple">
<dt>TweetCandidate with TweetAuthorDetails with TargetInfo[</dt><dd><p>TargetUser with TargetABDecider</p>
</dd>
</dl>
<p>]</p>
</dd>
<dt>] = {</dt><dd><p>val name = “f1_exempt_tweet_author_protected”
val skipForProtectedAuthorScope = stats.scope(name).scope(“skip_protected_author_for_f1”)
val authorIsProtectedCounter = skipForProtectedAuthorScope.counter(“author_protected_true”)
val authorIsNotProtectedCounter = skipForProtectedAuthorScope.counter(“author_protected_false”)
val authorNotFoundCounter = stats.scope(name).counter(“author_not_found”)
Predicate</p>
<blockquote>
<div><dl>
<dt>.fromAsync[TweetCandidate with TweetAuthorDetails with TargetInfo[</dt><dd><p>TargetUser with TargetABDecider</p>
</dd>
<dt>]] {</dt><dd><dl>
<dt>case candidate: F1Candidate</dt><dd><blockquote>
<div><p>if candidate.target.params(PushFeatureSwitchParams.EnableF1FromProtectedTweetAuthors) =&gt;</p>
</div></blockquote>
<dl>
<dt>candidate.tweetAuthor.foreach {</dt><dd><dl>
<dt>case Some(author) =&gt;</dt><dd><dl class="simple">
<dt>if (GizmoduckUserPredicate.isProtected(author)) {</dt><dd><p>authorIsProtectedCounter.incr()</p>
</dd>
</dl>
<p>} else authorIsNotProtectedCounter.incr()</p>
</dd>
</dl>
<p>case _ =&gt; authorNotFoundCounter.incr()</p>
</dd>
</dl>
<p>}
Future.True</p>
</dd>
<dt>case cand =&gt;</dt><dd><p>TweetAuthorPredicates.recTweetAuthorProtected.apply(Seq(cand)).map(_.head)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.withStats(stats.scope(name))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>filter a notification if user has already received ANY prior notification about the space id</p></li>
<li><p>&#64;param stats</p></li>
<li><p>&#64;return</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>def duplicateSpacesPredicate(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[Space with PushCandidate] = {</dt><dd><p>val name = “duplicate_spaces_predicate”
Predicate</p>
<blockquote>
<div><dl>
<dt>.fromAsync { c: Space with PushCandidate =&gt;</dt><dd><dl class="simple">
<dt>c.target.pushRecItems.map { pushRecItems =&gt;</dt><dd><p>!pushRecItems.spaceIds.contains(c.spaceId)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.withStats(stats.scope(name))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<p>def filterOONCandidatePredicate(
)(</p>
<blockquote>
<div><p>implicit stats: StatsReceiver</p>
</div></blockquote>
<dl>
<dt>): NamedPredicate[PushCandidate] = {</dt><dd><p>val name = “filter_oon_candidate”</p>
<dl>
<dt>Predicate</dt><dd><dl>
<dt>.fromAsync[PushCandidate] { cand =&gt;</dt><dd><p>val crt = cand.commonRecType
val isOONCandidate =</p>
<blockquote>
<div><dl class="simple">
<dt>RecTypes.isOutOfNetworkTweetRecType(crt) || RecTypes.outOfNetworkTopicTweetTypes</dt><dd><p>.contains(crt) || RecTypes.isOutOfNetworkSpaceType(crt) || RecTypes.userTypes.contains(
crt)</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>if (isOONCandidate) {</dt><dd><dl>
<dt>cand.target.notificationsFromOnlyPeopleIFollow.map { inNetworkOnly =&gt;</dt><dd><dl class="simple">
<dt>if (inNetworkOnly) {</dt><dd><p>stats.scope(name, crt.toString).counter(“inNetworkOnlyOn”).incr()</p>
</dd>
<dt>} else {</dt><dd><p>stats.scope(name, crt.toString).counter(“inNetworkOnlyOff”).incr()</p>
</dd>
</dl>
<p>}
!(inNetworkOnly &amp;&amp; cand.target.params(</p>
<blockquote>
<div><p>PushFeatureSwitchParams.EnableOONFilteringBasedOnUserSettings))</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>} else Future.True</p>
</dd>
</dl>
<p>}
.withStats(stats.scope(name))
.withName(name)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def exludeCrtFromPushHoldback(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate] = Predicate</dt><dd><dl>
<dt>.from { candidate: PushCandidate =&gt;</dt><dd><p>val crtName = candidate.commonRecType.name
val target = candidate.target
target</p>
<blockquote>
<div><p>.params(PushFeatureSwitchParams.CommonRecommendationTypeDenyListPushHoldbacks)
.exists(crtName.equalsIgnoreCase)</p>
</div></blockquote>
</dd>
</dl>
<p>}
.withStats(stats.scope(“exclude_crt_from_push_holdbacks”))</p>
</dd>
<dt>def enableSendHandlerCandidates(implicit stats: StatsReceiver): NamedPredicate[PushCandidate] = {</dt><dd><p>val name = “sendhandler_enable_push_recommendations”
PredicatesForCandidate.exludeCrtFromPushHoldback</p>
<blockquote>
<div><dl class="simple">
<dt>.or(PredicatesForCandidate.paramPredicate(</dt><dd><p>PushFeatureSwitchParams.EnablePushRecommendationsParam))</p>
</dd>
</dl>
<p>.withStats(stats.scope(name))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def openAppExperimentUserCandidateAllowList(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate] = {</dt><dd><p>val name = “open_app_experiment_user_candidate_allow_list”
Predicate</p>
<blockquote>
<div><dl>
<dt>.fromAsync { candidate: PushCandidate =&gt;</dt><dd><p>val target = candidate.target
Future.join(target.isOpenAppExperimentUser, target.targetUser).map {</p>
<blockquote>
<div><dl>
<dt>case (isOpenAppUser, targetUser) =&gt;</dt><dd><dl>
<dt>val shouldLimitOpenAppCrts =</dt><dd><p>isOpenAppUser || targetUser.exists(_.userType == UserType.Soft)</p>
</dd>
<dt>if (shouldLimitOpenAppCrts) {</dt><dd><dl class="simple">
<dt>val listOfAllowedCrt = target</dt><dd><p>.params(PushFeatureSwitchParams.ListOfCrtsForOpenApp)
.flatMap(CommonRecommendationType.valueOf)</p>
</dd>
</dl>
<p>listOfAllowedCrt.contains(candidate.commonRecType)</p>
</dd>
</dl>
<p>} else true</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}.withStats(stats.scope(name))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def isTargetBlueVerified(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate] = {</dt><dd><p>val name = “is_target_already_blue_verified”
Predicate</p>
<blockquote>
<div><dl class="simple">
<dt>.fromAsync { candidate: PushCandidate =&gt;</dt><dd><p>val target = candidate.target
target.isBlueVerified.map(_.getOrElse(false))</p>
</dd>
</dl>
<p>}.withStats(stats.scope(name))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def isTargetLegacyVerified(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate] = {</dt><dd><p>val name = “is_target_already_legacy_verified”
Predicate</p>
<blockquote>
<div><dl class="simple">
<dt>.fromAsync { candidate: PushCandidate =&gt;</dt><dd><p>val target = candidate.target
target.isVerified.map(_.getOrElse(false))</p>
</dd>
</dl>
<p>}.withStats(stats.scope(name))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def isTargetSuperFollowCreator(implicit stats: StatsReceiver): NamedPredicate[PushCandidate] = {</dt><dd><p>val name = “is_target_already_super_follow_creator”
Predicate</p>
<blockquote>
<div><dl>
<dt>.fromAsync { candidate: PushCandidate =&gt;</dt><dd><p>val target = candidate.target
target.isSuperFollowCreator.map(</p>
<blockquote>
<div><p>_.getOrElse(false)</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}.withStats(stats.scope(name))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def isChannelValidPredicate(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate] = {</dt><dd><p>val name = “is_channel_valid”
val scopedStatsReceiver = stats.scope(s”predicate_$name”)
Predicate</p>
<blockquote>
<div><dl class="simple">
<dt>.fromAsync { candidate: PushCandidate =&gt;</dt><dd><dl class="simple">
<dt>candidate</dt><dd><dl class="simple">
<dt>.getChannels().map(channels =&gt;</dt><dd><p>!(channels.toSet.size == 1 &amp;&amp; channels.head == ChannelName.None))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}
.withStats(scopedStatsReceiver)
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/pushservice/src/main/scala/com/twitter/frigate/pushservice/predicate/PredicatesForCandidate.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>