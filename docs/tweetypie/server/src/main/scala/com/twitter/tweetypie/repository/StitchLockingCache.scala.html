<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie.repository</p>
<p>import com.twitter.servo.cache.{CachedValueStatus =&gt; Status, LockingCache =&gt; KVLockingCache, _}
import com.twitter.servo.repository.{CachedResult =&gt; Result}
import com.twitter.stitch.MapGroup
import com.twitter.stitch.Group
import com.twitter.stitch.Stitch
import com.twitter.util.Future
import com.twitter.util.Return
import com.twitter.util.Throw
import com.twitter.util.Time
import com.twitter.util.Try</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Adapts a key-value locking cache to Arrow and</p></li>
<li><p>normalizes the results to <cite>CachedResult</cite>.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>trait StitchLockingCache[K, V] {</dt><dd><p>val get: K =&gt; Stitch[Result[K, V]]
val lockAndSet: (K, StitchLockingCache.Val[V]) =&gt; Stitch[Unit]
val delete: K =&gt; Stitch[Boolean]</p>
</dd>
</dl>
<p>}</p>
<p>object StitchLockingCache {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Value intended to be written back to cache using lockAndSet.</p></li>
<li></li>
<li><p>Note that only a subset of CachedValueStatus values are eligible for writing:</p></li>
<li><p>Found, NotFound, and Deleted</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
</dl>
<p>sealed trait Val[+V]
object Val {</p>
<blockquote>
<div><p>case class Found[V](value: V) extends Val[V]
case object NotFound extends Val[Nothing]
case object Deleted extends Val[Nothing]</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A Group for batching get requests to a [[KVLockingCache]].</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>private case class GetGroup[K, V](cache: KVLockingCache[K, Cached[V]], override val maxSize: Int)</dt><dd><blockquote>
<div><p>extends MapGroup[K, Result[K, V]] {</p>
</div></blockquote>
<dl>
<dt>private[this] def cachedToResult(key: K, cached: Cached[V]): Try[Result[K, V]] =</dt><dd><dl>
<dt>cached.status match {</dt><dd><p>case Status.NotFound =&gt; Return(Result.CachedNotFound(key, cached.cachedAt))
case Status.Deleted =&gt; Return(Result.CachedDeleted(key, cached.cachedAt))
case Status.SerializationFailed =&gt; Return(Result.SerializationFailed(key))
case Status.DeserializationFailed =&gt; Return(Result.DeserializationFailed(key))
case Status.Evicted =&gt; Return(Result.NotFound(key))
case Status.DoNotCache =&gt; Return(Result.DoNotCache(key, cached.doNotCacheUntil))
case Status.Found =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>cached.value match {</dt><dd><p>case None =&gt; Return(Result.NotFound(key))
case Some(value) =&gt; Return(Result.CachedFound(key, value, cached.cachedAt))</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>case _ =&gt; Throw(new UnsupportedOperationException)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override protected def run(keys: Seq[K]): Future[K =&gt; Try[Result[K, V]]] =</dt><dd><dl>
<dt>cache.get(keys).map { (result: KeyValueResult[K, Cached[V]]) =&gt; key =&gt;</dt><dd><dl>
<dt>result.found.get(key) match {</dt><dd><p>case Some(cached) =&gt; cachedToResult(key, cached)
case None =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>result.failed.get(key) match {</dt><dd><p>case Some(t) =&gt; Return(Result.Failed(key, t))
case None =&gt; Return(Result.NotFound(key))</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Used in the implementation of LockAndSetGroup. This is just a</p></li>
<li><p>glorified tuple with special equality semantics where calls with</p></li>
<li><p>the same key will compare equal.  MapGroup will use this as a key</p></li>
<li><p>in a Map, which will prevent duplicate lockAndSet calls with the</p></li>
<li><p>same key. We donâ€™t care which one we use</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>private class LockAndSetCall[K, V](val key: K, val value: V) {</dt><dd><dl>
<dt>override def equals(other: Any): Boolean =</dt><dd><dl class="simple">
<dt>other match {</dt><dd><p>case call: LockAndSetCall[_, _] =&gt; call.key == key
case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>override def hashCode(): Int = key.hashCode</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A Group for <cite>lockAndSet</cite> calls to a [[KVLockingCache]]. This is</p></li>
<li><p>necessary to avoid writing back a key multiple times if it is</p></li>
<li><p>appears more than once in a batch. LockAndSetCall considers two</p></li>
<li><p>calls equal even if the values differ because multiple lockAndSet</p></li>
<li><p>calls for the same key will eventually result in only one being</p></li>
<li><p>chosen by the cache anyway, and this avoids conflicting</p></li>
<li><p>lockAndSet calls.</p></li>
<li></li>
<li><p>For example, consider a tweet that mentions &#64;jack twice</p></li>
<li><p>when &#64;jack is not in cache. That will result in two queries to</p></li>
<li><p>load &#64;jack, which will be deduped by the Group when the repo is</p></li>
<li><p>called. Despite the fact that it is loaded only once, each of the</p></li>
<li><p>two loads is oblivious to the other, so each of them attempts to</p></li>
<li><p>write the value back to cache, resulting in two <cite>lockAndSet</cite></p></li>
<li><p>calls for &#64;jack, so we have to dedupe them again.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>private case class LockAndSetGroup[K, V](</dt><dd><p>cache: KVLockingCache[K, V],
picker: KVLockingCache.Picker[V])</p>
<blockquote>
<div><p>extends MapGroup[LockAndSetCall[K, V], Option[V]] {</p>
</div></blockquote>
<dl>
<dt>override def run(</dt><dd><p>calls: Seq[LockAndSetCall[K, V]]</p>
</dd>
<dt>): Future[LockAndSetCall[K, V] =&gt; Try[Option[V]]] =</dt><dd><dl>
<dt>Future</dt><dd><dl>
<dt>.collect {</dt><dd><dl>
<dt>calls.map { call =&gt;</dt><dd><p>// This is masked to prevent interrupts to the overall
// request from interrupting writes back to cache.
cache</p>
<blockquote>
<div><p>.lockAndSet(call.key, KVLockingCache.PickingHandler(call.value, picker))
.masked
.liftToTry</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.map(responses =&gt; calls.zip(responses).toMap)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def apply[K, V](</dt><dd><p>underlying: KVLockingCache[K, Cached[V]],
picker: KVLockingCache.Picker[Cached[V]],
maxRequestSize: Int = Int.MaxValue</p>
</dd>
<dt>): StitchLockingCache[K, V] =</dt><dd><dl>
<dt>new StitchLockingCache[K, V] {</dt><dd><dl>
<dt>override val get: K =&gt; Stitch[Result[K, V]] = {</dt><dd><p>val group: Group[K, Result[K, V]] = GetGroup(underlying, maxRequestSize)</p>
<p>(key: K) =&gt; Stitch.call(key, group)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val lockAndSet: (K, Val[V]) =&gt; Stitch[Unit] = {</dt><dd><p>val group = LockAndSetGroup(underlying, picker)</p>
<dl>
<dt>(key: K, value: Val[V]) =&gt; {</dt><dd><p>val now = Time.now
val cached: Cached[V] =</p>
<blockquote>
<div><dl class="simple">
<dt>value match {</dt><dd><p>case Val.Found(v) =&gt; Cached[V](Some(v), Status.Found, now, Some(now))
case Val.NotFound =&gt; Cached[V](None, Status.NotFound, now, Some(now))
case Val.Deleted =&gt; Cached[V](None, Status.Deleted, now, Some(now))</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>Stitch.call(new LockAndSetCall(key, cached), group).unit</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override val delete: K =&gt; Stitch[Boolean] =</dt><dd><p>(key: K) =&gt; Stitch.callFuture(underlying.delete(key))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/tweetypie/server/src/main/scala/com/twitter/tweetypie/repository/StitchLockingCache.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>