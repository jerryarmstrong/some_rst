<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../../" id="documentation_options" src="../../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie
package service
package observer</p>
<p>import com.twitter.snowflake.id.SnowflakeId
import com.twitter.tweetypie.additionalfields.AdditionalFields
import com.twitter.tweetypie.media.MediaKeyClassifier
import com.twitter.tweetypie.thriftscala._
import com.twitter.tweetypie.tweettext.TweetText.codePointLength
import com.twitter.conversions.DurationOps._</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Observer can be used for storing</p></li>
<li><ul>
<li><p>one-off handler specific metrics with minor logic</p></li>
</ul>
</li>
<li><ul>
<li><p>reusable Tweetypie service metrics for multiple handlers</p></li>
</ul>
</li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
</dl>
<p>private[service] object Observer {</p>
<blockquote>
<div><dl class="simple">
<dt>val successStatusStates: Set[StatusState] = Set(</dt><dd><p>StatusState.Found,
StatusState.NotFound,
StatusState.DeactivatedUser,
StatusState.SuspendedUser,
StatusState.ProtectedUser,
StatusState.ReportedTweet,
StatusState.UnsupportedClient,
StatusState.Drop,
StatusState.Suppress,
StatusState.Deleted,
StatusState.BounceDeleted</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>def observeStatusStates(statsReceiver: StatsReceiver): Effect[StatusState] = {</dt><dd><p>val stats = statsReceiver.scope(“status_state”)
val total = statsReceiver.counter(“status_results”)</p>
<p>val foundCounter = stats.counter(“found”)
val notFoundCounter = stats.counter(“not_found”)
val partialCounter = stats.counter(“partial”)
val timedOutCounter = stats.counter(“timed_out”)
val failedCounter = stats.counter(“failed”)
val deactivatedCounter = stats.counter(“deactivated”)
val suspendedCounter = stats.counter(“suspended”)
val protectedCounter = stats.counter(“protected”)
val reportedCounter = stats.counter(“reported”)
val overCapacityCounter = stats.counter(“over_capacity”)
val unsupportedClientCounter = stats.counter(“unsupported_client”)
val dropCounter = stats.counter(“drop”)
val suppressCounter = stats.counter(“suppress”)
val deletedCounter = stats.counter(“deleted”)
val bounceDeletedCounter = stats.counter(“bounce_deleted”)</p>
<dl>
<dt>Effect { st =&gt;</dt><dd><p>total.incr()
st match {</p>
<blockquote>
<div><p>case StatusState.Found =&gt; foundCounter.incr()
case StatusState.NotFound =&gt; notFoundCounter.incr()
case StatusState.Partial =&gt; partialCounter.incr()
case StatusState.TimedOut =&gt; timedOutCounter.incr()
case StatusState.Failed =&gt; failedCounter.incr()
case StatusState.DeactivatedUser =&gt; deactivatedCounter.incr()
case StatusState.SuspendedUser =&gt; suspendedCounter.incr()
case StatusState.ProtectedUser =&gt; protectedCounter.incr()
case StatusState.ReportedTweet =&gt; reportedCounter.incr()
case StatusState.OverCapacity =&gt; overCapacityCounter.incr()
case StatusState.UnsupportedClient =&gt; unsupportedClientCounter.incr()
case StatusState.Drop =&gt; dropCounter.incr()
case StatusState.Suppress =&gt; suppressCounter.incr()
case StatusState.Deleted =&gt; deletedCounter.incr()
case StatusState.BounceDeleted =&gt; bounceDeletedCounter.incr()
case _ =&gt;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def observeSetFieldsRequest(stats: StatsReceiver): Effect[SetAdditionalFieldsRequest] =</dt><dd><dl>
<dt>Effect { request =&gt;</dt><dd><p>val tweet = request.additionalFields
AdditionalFields.nonEmptyAdditionalFieldIds(tweet).foreach { id =&gt;</p>
<blockquote>
<div><p>val fieldScope = “field_%d”.format(id)
val fieldCounter = stats.counter(fieldScope)
val sizeStats = stats.stat(fieldScope)</p>
<dl class="simple">
<dt>tweet.getFieldBlob(id).foreach { blob =&gt;</dt><dd><p>fieldCounter.incr()
sizeStats.add(blob.content.length)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>def observeSetRetweetVisibilityRequest(</dt><dd><p>stats: StatsReceiver</p>
</dd>
<dt>): Effect[SetRetweetVisibilityRequest] = {</dt><dd><p>val setInvisibleCounter = stats.counter(“set_invisible”)
val setVisibleCounter = stats.counter(“set_visible”)</p>
<dl class="simple">
<dt>Effect { request =&gt;</dt><dd><p>if (request.visible) setVisibleCounter.incr() else setInvisibleCounter.incr()</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def observeDeleteFieldsRequest(stats: StatsReceiver): Effect[DeleteAdditionalFieldsRequest] = {</dt><dd><p>val requestSizeStat = stats.stat(“request_size”)</p>
<dl>
<dt>Effect { request =&gt;</dt><dd><p>requestSizeStat.add(request.tweetIds.size)</p>
<dl class="simple">
<dt>request.fieldIds.foreach { id =&gt;</dt><dd><p>val fieldScope = “field_%d”.format(id)
val fieldCounter = stats.counter(fieldScope)
fieldCounter.incr()</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def observeDeleteTweetsRequest(stats: StatsReceiver): Effect[DeleteTweetsRequest] = {</dt><dd><p>val requestSizeStat = stats.stat(“request_size”)
val userErasureTweetsStat = stats.counter(“user_erasure_tweets”)
val isBounceDeleteStat = stats.counter(“is_bounce_delete_tweets”)</p>
<dl>
<dt>Effect {</dt><dd><dl>
<dt>case DeleteTweetsRequest(tweetIds, _, _, _, isUserErasure, _, isBounceDelete, _, _) =&gt;</dt><dd><p>requestSizeStat.add(tweetIds.size)
if (isUserErasure) {</p>
<blockquote>
<div><p>userErasureTweetsStat.incr(tweetIds.size)</p>
</div></blockquote>
<p>}
if (isBounceDelete) {</p>
<blockquote>
<div><p>isBounceDeleteStat.incr(tweetIds.size)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def observeRetweetRequest(stats: StatsReceiver): Effect[RetweetRequest] = {</dt><dd><p>val optionsScope = stats.scope(“options”)
val narrowcastCounter = optionsScope.counter(“narrowcast”)
val nullcastCounter = optionsScope.counter(“nullcast”)
val darkCounter = optionsScope.counter(“dark”)
val successOnDupCounter = optionsScope.counter(“success_on_dup”)</p>
<dl class="simple">
<dt>Effect { request =&gt;</dt><dd><p>if (request.narrowcast.nonEmpty) narrowcastCounter.incr()
if (request.nullcast) nullcastCounter.incr()
if (request.dark) darkCounter.incr()
if (request.returnSuccessOnDuplicate) successOnDupCounter.incr()</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def observeScrubGeo(stats: StatsReceiver): Effect[GeoScrub] = {</dt><dd><p>val optionsScope = stats.scope(“options”)
val hosebirdEnqueueCounter = optionsScope.counter(“hosebird_enqueue”)
val requestSizeStat = stats.stat(“request_size”)</p>
<dl class="simple">
<dt>Effect { request =&gt;</dt><dd><p>requestSizeStat.add(request.statusIds.size)
if (request.hosebirdEnqueue) hosebirdEnqueueCounter.incr()</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def observeEventOrRetry(stats: StatsReceiver, isRetry: Boolean): Unit = {</dt><dd><p>val statName = if (isRetry) “retry” else “event”
stats.counter(statName).incr()</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def observeAsyncInsertRequest(stats: StatsReceiver): Effect[AsyncInsertRequest] = {</dt><dd><p>val insertScope = stats.scope(“insert”)
val ageStat = insertScope.stat(“age”)
Effect { request =&gt;</p>
<blockquote>
<div><p>observeEventOrRetry(insertScope, request.retryAction.isDefined)
ageStat.add(SnowflakeId.timeFromId(request.tweet.id).untilNow.inMillis)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def observeAsyncSetAdditionalFieldsRequest(</dt><dd><p>stats: StatsReceiver</p>
</dd>
<dt>): Effect[AsyncSetAdditionalFieldsRequest] = {</dt><dd><p>val setAdditionalFieldsScope = stats.scope(“set_additional_fields”)
Effect { request =&gt;</p>
<blockquote>
<div><p>observeEventOrRetry(setAdditionalFieldsScope, request.retryAction.isDefined)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def observeAsyncSetRetweetVisibilityRequest(</dt><dd><p>stats: StatsReceiver</p>
</dd>
<dt>): Effect[AsyncSetRetweetVisibilityRequest] = {</dt><dd><p>val setRetweetVisibilityScope = stats.scope(“set_retweet_visibility”)</p>
<dl class="simple">
<dt>Effect { request =&gt;</dt><dd><p>observeEventOrRetry(setRetweetVisibilityScope, request.retryAction.isDefined)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def observeAsyncUndeleteTweetRequest(stats: StatsReceiver): Effect[AsyncUndeleteTweetRequest] = {</dt><dd><p>val undeleteTweetScope = stats.scope(“undelete_tweet”)
Effect { request =&gt; observeEventOrRetry(undeleteTweetScope, request.retryAction.isDefined) }</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def observeAsyncDeleteTweetRequest(stats: StatsReceiver): Effect[AsyncDeleteRequest] = {</dt><dd><p>val deleteTweetScope = stats.scope(“delete_tweet”)
Effect { request =&gt; observeEventOrRetry(deleteTweetScope, request.retryAction.isDefined) }</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def observeAsyncDeleteAdditionalFieldsRequest(</dt><dd><p>stats: StatsReceiver</p>
</dd>
<dt>): Effect[AsyncDeleteAdditionalFieldsRequest] = {</dt><dd><p>val deleteAdditionalFieldsScope = stats.scope(“delete_additional_fields”)
Effect { request =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>observeEventOrRetry(</dt><dd><p>deleteAdditionalFieldsScope,
request.retryAction.isDefined</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def observeAsyncTakedownRequest(stats: StatsReceiver): Effect[AsyncTakedownRequest] = {</dt><dd><p>val takedownScope = stats.scope(“takedown”)
Effect { request =&gt; observeEventOrRetry(takedownScope, request.retryAction.isDefined) }</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def observeAsyncUpdatePossiblySensitiveTweetRequest(</dt><dd><p>stats: StatsReceiver</p>
</dd>
<dt>): Effect[AsyncUpdatePossiblySensitiveTweetRequest] = {</dt><dd><p>val updatePossiblySensitiveTweetScope = stats.scope(“update_possibly_sensitive_tweet”)
Effect { request =&gt;</p>
<blockquote>
<div><p>observeEventOrRetry(updatePossiblySensitiveTweetScope, request.action.isDefined)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def observeReplicatedInsertTweetRequest(stats: StatsReceiver): Effect[Tweet] = {</dt><dd><p>val ageStat = stats.stat(“age”) // in milliseconds
Effect { request =&gt; ageStat.add(SnowflakeId.timeFromId(request.id).untilNow.inMillis) }</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def camelToUnderscore(str: String): String = {</dt><dd><p>val bldr = new StringBuilder
str.foldLeft(false) { (prevWasLowercase, c) =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>if (prevWasLowercase &amp;&amp; c.isUpper) {</dt><dd><p>bldr += ‘_’</p>
</dd>
</dl>
<p>}
bldr += c.toLower
c.isLower</p>
</div></blockquote>
<p>}
bldr.result</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def observeAdditionalFields(stats: StatsReceiver): Effect[Tweet] = {</dt><dd><p>val additionalScope = stats.scope(“additional_fields”)</p>
<dl class="simple">
<dt>Effect { tweet =&gt;</dt><dd><dl class="simple">
<dt>for (fieldId &lt;- AdditionalFields.nonEmptyAdditionalFieldIds(tweet))</dt><dd><p>additionalScope.counter(fieldId.toString).incr()</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>We count how many tweets have each of these attributes so that we</p></li>
<li><p>can observe general trends, as well as for tracking down the</p></li>
<li><p>cause of behavior changes, like increased calls to certain</p></li>
<li><p>services.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>def countTweetAttributes(stats: StatsReceiver, byClient: Boolean): Effect[Tweet] = {</dt><dd><p>val ageStat = stats.stat(“age”)
val tweetCounter = stats.counter(“tweets”)
val retweetCounter = stats.counter(“retweets”)
val repliesCounter = stats.counter(“replies”)
val inReplyToTweetCounter = stats.counter(“in_reply_to_tweet”)
val selfRepliesCounter = stats.counter(“self_replies”)
val directedAtCounter = stats.counter(“directed_at”)
val mentionsCounter = stats.counter(“mentions”)
val mentionsStat = stats.stat(“mentions”)
val urlsCounter = stats.counter(“urls”)
val urlsStat = stats.stat(“urls”)
val hashtagsCounter = stats.counter(“hashtags”)
val hashtagsStat = stats.stat(“hashtags”)
val mediaCounter = stats.counter(“media”)
val mediaStat = stats.stat(“media”)
val photosCounter = stats.counter(“media”, “photos”)
val gifsCounter = stats.counter(“media”, “animated_gifs”)
val videosCounter = stats.counter(“media”, “videos”)
val cardsCounter = stats.counter(“cards”)
val card2Counter = stats.counter(“card2”)
val geoCoordsCounter = stats.counter(“geo_coordinates”)
val placeCounter = stats.counter(“place”)
val quotedTweetCounter = stats.counter(“quoted_tweet”)
val selfRetweetCounter = stats.counter(“self_retweet”)
val languageScope = stats.scope(“language”)
val textLengthStat = stats.stat(“text_length”)
val selfThreadCounter = stats.counter(“self_thread”)
val communitiesTweetCounter = stats.counter(“communities”)</p>
<dl>
<dt>observeAdditionalFields(stats).also {</dt><dd><dl>
<dt>Effect[Tweet] { tweet =&gt;</dt><dd><dl class="simple">
<dt>def coreDataField[T](f: TweetCoreData =&gt; T): Option[T] =</dt><dd><p>tweet.coreData.map(f)</p>
</dd>
<dt>def coreDataOptionField[T](f: TweetCoreData =&gt; Option[T]) =</dt><dd><p>coreDataField(f).flatten</p>
</dd>
<dt>(SnowflakeId.isSnowflakeId(tweet.id) match {</dt><dd><p>case true =&gt; Some(SnowflakeId.timeFromId(tweet.id))
case false =&gt; coreDataField(_.createdAtSecs.seconds.afterEpoch)</p>
</dd>
</dl>
<p>}).foreach { createdAt =&gt; ageStat.add(createdAt.untilNow.inSeconds) }</p>
<dl>
<dt>if (!byClient) {</dt><dd><p>val mentions = getMentions(tweet)
val urls = getUrls(tweet)
val hashtags = getHashtags(tweet)
val media = getMedia(tweet)
val mediaKeys = media.flatMap(_.mediaKey)
val share = coreDataOptionField(_.share)
val selfThreadMetadata = getSelfThreadMetadata(tweet)
val communities = getCommunities(tweet)</p>
<p>tweetCounter.incr()
if (share.isDefined) retweetCounter.incr()
if (coreDataOptionField(_.directedAtUser).isDefined) directedAtCounter.incr()</p>
<dl>
<dt>coreDataOptionField(_.reply).foreach { reply =&gt;</dt><dd><p>repliesCounter.incr()
if (reply.inReplyToStatusId.nonEmpty) {</p>
<blockquote>
<div><p>// repliesCounter counts all Tweets with a Reply struct,
// but that includes both directed-at Tweets and
// conversational replies. Only conversational replies
// have inReplyToStatusId present, so this counter lets
// us split apart those two cases.
inReplyToTweetCounter.incr()</p>
</div></blockquote>
<p>}</p>
<p>// Not all Tweet objects have CoreData yet isSelfReply() requires it.  Thus, this
// invocation is guarded by the <cite>coreDataOptionField(_.reply)</cite> above.
if (isSelfReply(tweet)) selfRepliesCounter.incr()</p>
</dd>
</dl>
<p>}</p>
<p>if (mentions.nonEmpty) mentionsCounter.incr()
if (urls.nonEmpty) urlsCounter.incr()
if (hashtags.nonEmpty) hashtagsCounter.incr()
if (media.nonEmpty) mediaCounter.incr()
if (selfThreadMetadata.nonEmpty) selfThreadCounter.incr()
if (communities.nonEmpty) communitiesTweetCounter.incr()</p>
<p>mentionsStat.add(mentions.size)
urlsStat.add(urls.size)
hashtagsStat.add(hashtags.size)
mediaStat.add(media.size)</p>
<p>if (mediaKeys.exists(MediaKeyClassifier.isImage(_))) photosCounter.incr()
if (mediaKeys.exists(MediaKeyClassifier.isGif(_))) gifsCounter.incr()
if (mediaKeys.exists(MediaKeyClassifier.isVideo(_))) videosCounter.incr()</p>
<p>if (tweet.cards.exists(_.nonEmpty)) cardsCounter.incr()
if (tweet.card2.nonEmpty) card2Counter.incr()
if (coreDataOptionField(_.coordinates).nonEmpty) geoCoordsCounter.incr()
if (TweetLenses.place.get(tweet).nonEmpty) placeCounter.incr()
if (TweetLenses.quotedTweet.get(tweet).nonEmpty) quotedTweetCounter.incr()
if (share.exists(_.sourceUserId == getUserId(tweet))) selfRetweetCounter.incr()</p>
<dl class="simple">
<dt>tweet.language</dt><dd><p>.map(_.language)
.foreach(lang =&gt; languageScope.counter(lang).incr())</p>
</dd>
</dl>
<p>coreDataField(_.text).foreach(text =&gt; textLengthStat.add(codePointLength(text)))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../../_sources/tweetypie/server/src/main/scala/com/twitter/tweetypie/service/observer/Observer.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>