<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie
package config</p>
<p>import com.twitter.servo.util.FutureArrow
import com.twitter.servo.util.RetryHandler
import com.twitter.servo.util.Scribe
import com.twitter.tweetypie.backends.LimiterService.Feature.MediaTagCreate
import com.twitter.tweetypie.backends.LimiterService.Feature.Updates
import com.twitter.tweetypie.client_id.ClientIdHelper
import com.twitter.tweetypie.handler.TweetBuilder
import com.twitter.tweetypie.repository.TweetKeyFactory
import com.twitter.tweetypie.store._
import com.twitter.tweetypie.tflock.TFlockIndexer
import com.twitter.tweetypie.thriftscala._
import com.twitter.tweetypie.util.RetryPolicyBuilder
import com.twitter.util.Timer</p>
<dl>
<dt>object TweetStores {</dt><dd><dl class="simple">
<dt>def apply(</dt><dd><p>settings: TweetServiceSettings,
statsReceiver: StatsReceiver,
timer: Timer,
deciderGates: TweetypieDeciderGates,
tweetKeyFactory: TweetKeyFactory,
clients: BackendClients,
caches: Caches,
asyncBuilder: ServiceInvocationBuilder,
hasMedia: Tweet =&gt; Boolean,
clientIdHelper: ClientIdHelper,</p>
</dd>
</dl>
<p>): TotalTweetStore = {</p>
<blockquote>
<div><dl>
<dt>val deferredrpcRetryPolicy =</dt><dd><p>// retry all application exceptions for now.  however, in the future, deferredrpc
// may throw a backpressure exception that should not be retried.
RetryPolicyBuilder.anyFailure(settings.deferredrpcBackoffs)</p>
</dd>
<dt>val asyncWriteRetryPolicy =</dt><dd><p>// currently retries all failures with the same back-off times.  might need
// to update to handle backpressure exceptions differently.
RetryPolicyBuilder.anyFailure(settings.asyncWriteRetryBackoffs)</p>
</dd>
<dt>val replicatedEventRetryPolicy =</dt><dd><p>RetryPolicyBuilder.anyFailure(settings.replicatedEventCacheBackoffs)</p>
</dd>
<dt>val logLensStore =</dt><dd><dl class="simple">
<dt>LogLensStore(</dt><dd><p>tweetCreationsLogger = Logger(“com.twitter.tweetypie.store.TweetCreations”),
tweetDeletionsLogger = Logger(“com.twitter.tweetypie.store.TweetDeletions”),
tweetUndeletionsLogger = Logger(“com.twitter.tweetypie.store.TweetUndeletions”),
tweetUpdatesLogger = Logger(“com.twitter.tweetypie.store.TweetUpdates”),
clientIdHelper = clientIdHelper,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>val tweetStoreStats = statsReceiver.scope(“tweet_store”)</p>
<p>val tweetStatsStore = TweetStatsStore(tweetStoreStats.scope(“stats”))</p>
<dl>
<dt>val asyncRetryConfig =</dt><dd><dl class="simple">
<dt>new TweetStore.AsyncRetry(</dt><dd><p>asyncWriteRetryPolicy,
deferredrpcRetryPolicy,
timer,
clients.asyncRetryTweetService,
Scribe(FailedAsyncWrite, “tweetypie_failed_async_writes”)</p>
</dd>
</dl>
<p>)(_, _)</p>
</dd>
<dt>val manhattanStore = {</dt><dd><p>val scopedStats = tweetStoreStats.scope(“base”)
ManhattanTweetStore(clients.tweetStorageClient)</p>
<blockquote>
<div><p>.tracked(scopedStats)
.asyncRetry(asyncRetryConfig(scopedStats, ManhattanTweetStore.Action))</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val cachingTweetStore = {</dt><dd><p>val cacheStats = tweetStoreStats.scope(“caching”)
CachingTweetStore(</p>
<blockquote>
<div><p>tweetKeyFactory = tweetKeyFactory,
tweetCache = caches.tweetCache,
stats = cacheStats</p>
</div></blockquote>
<dl class="simple">
<dt>).tracked(cacheStats)</dt><dd><p>.asyncRetry(asyncRetryConfig(cacheStats, CachingTweetStore.Action))
.replicatedRetry(RetryHandler.failuresOnly(replicatedEventRetryPolicy, timer, cacheStats))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val indexingStore = {</dt><dd><p>val indexingStats = tweetStoreStats.scope(“indexing”)
TweetIndexingStore(</p>
<blockquote>
<div><dl class="simple">
<dt>new TFlockIndexer(</dt><dd><p>tflock = clients.tflockWriteClient,
hasMedia = hasMedia,
backgroundIndexingPriority = settings.backgroundIndexingPriority,
stats = indexingStats</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl class="simple">
<dt>).tracked(indexingStats)</dt><dd><p>.asyncRetry(asyncRetryConfig(indexingStats, TweetIndexingStore.Action))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val timelineUpdatingStore = {</dt><dd><p>val tlsScope = tweetStoreStats.scope(“timeline_updating”)
TlsTimelineUpdatingStore(</p>
<blockquote>
<div><p>processEvent2 = clients.timelineService.processEvent2,
hasMedia = hasMedia,
stats = tlsScope</p>
</div></blockquote>
<dl class="simple">
<dt>).tracked(tlsScope)</dt><dd><p>.asyncRetry(asyncRetryConfig(tlsScope, TlsTimelineUpdatingStore.Action))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val guanoServiceStore = {</dt><dd><p>val guanoStats = tweetStoreStats.scope(“guano”)
GuanoServiceStore(clients.guano, guanoStats)</p>
<blockquote>
<div><p>.tracked(guanoStats)
.asyncRetry(asyncRetryConfig(guanoStats, GuanoServiceStore.Action))</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val mediaServiceStore = {</dt><dd><p>val mediaStats = tweetStoreStats.scope(“media”)
MediaServiceStore(clients.mediaClient.deleteMedia, clients.mediaClient.undeleteMedia)</p>
<blockquote>
<div><p>.tracked(mediaStats)
.asyncRetry(asyncRetryConfig(mediaStats, MediaServiceStore.Action))</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val userCountsUpdatingStore = {</dt><dd><p>val userCountsStats = tweetStoreStats.scope(“user_counts”)
GizmoduckUserCountsUpdatingStore(clients.gizmoduck.incrCount, hasMedia)</p>
<blockquote>
<div><p>.tracked(userCountsStats)
.ignoreFailures</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val tweetCountsUpdatingStore = {</dt><dd><p>val cacheScope = statsReceiver.scope(“tweet_counts_cache”)
val tweetCountsStats = tweetStoreStats.scope(“tweet_counts”)</p>
<dl>
<dt>val memcacheCountsStore = {</dt><dd><dl class="simple">
<dt>val lockingCacheCountsStore =</dt><dd><p>CachedCountsStore.fromLockingCache(caches.tweetCountsCache)</p>
</dd>
<dt>new AggregatingCachedCountsStore(</dt><dd><p>lockingCacheCountsStore,
timer,
settings.aggregatedTweetCountsFlushInterval,
settings.maxAggregatedCountsSize,
cacheScope</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>TweetCountsCacheUpdatingStore(memcacheCountsStore)</dt><dd><p>.tracked(tweetCountsStats)
.ignoreFailures</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val replicatingStore = {</dt><dd><p>val replicateStats = tweetStoreStats.scope(“replicate_out”)
ReplicatingTweetStore(</p>
<blockquote>
<div><p>clients.replicationClient</p>
</div></blockquote>
<dl class="simple">
<dt>).tracked(replicateStats)</dt><dd><p>.retry(RetryHandler.failuresOnly(deferredrpcRetryPolicy, timer, replicateStats))
.asyncRetry(asyncRetryConfig(replicateStats, ReplicatingTweetStore.Action))
.enabledBy(Gate.const(settings.enableReplication))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val scribeMediaTagStore =</dt><dd><dl class="simple">
<dt>ScribeMediaTagStore()</dt><dd><p>.tracked(tweetStoreStats.scope(“scribe_media_tag_store”))</p>
</dd>
</dl>
</dd>
<dt>val limiterStore =</dt><dd><dl class="simple">
<dt>LimiterStore(</dt><dd><p>clients.limiterService.incrementByOne(Updates),
clients.limiterService.increment(MediaTagCreate)</p>
</dd>
</dl>
<p>).tracked(tweetStoreStats.scope(“limiter_store”))</p>
</dd>
<dt>val geoSearchRequestIDStore = {</dt><dd><p>val statsScope = tweetStoreStats.scope(“geo_search_request_id”)
GeoSearchRequestIDStore(FutureArrow(clients.geoRelevance.reportConversion _))</p>
<blockquote>
<div><p>.tracked(statsScope)
.asyncRetry(asyncRetryConfig(statsScope, GeoSearchRequestIDStore.Action))</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val userGeotagUpdateStore = {</dt><dd><p>val geotagScope = tweetStoreStats.scope(“gizmoduck_user_geotag_updating”)
GizmoduckUserGeotagUpdateStore(</p>
<blockquote>
<div><p>clients.gizmoduck.modifyAndGet,
geotagScope</p>
</div></blockquote>
<dl class="simple">
<dt>).tracked(geotagScope)</dt><dd><p>.asyncRetry(asyncRetryConfig(geotagScope, GizmoduckUserGeotagUpdateStore.Action))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val fanoutServiceStore = {</dt><dd><p>val fanoutStats = tweetStoreStats.scope(“fanout_service_delivery”)
FanoutServiceStore(clients.fanoutServiceClient, fanoutStats)</p>
<blockquote>
<div><p>.tracked(fanoutStats)
.asyncRetry(asyncRetryConfig(fanoutStats, FanoutServiceStore.Action))</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A store that converts Tweetypie TweetEvents to EventBus TweetEvents and sends each event to</p></li>
<li><p>the underlying FutureEffect[eventbus.TweetEvent]</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>val eventBusEnqueueStore = {</dt><dd><p>val enqueueStats = tweetStoreStats.scope(“event_bus_enqueueing”)
val enqueueEffect = FutureEffect[TweetEvent](clients.tweetEventsPublisher.publish)</p>
<dl class="simple">
<dt>TweetEventBusStore(</dt><dd><p>enqueueEffect</p>
</dd>
<dt>).tracked(enqueueStats)</dt><dd><p>.asyncRetry(asyncRetryConfig(enqueueStats, AsyncWriteAction.EventBusEnqueue))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val retweetArchivalEnqueueStore = {</dt><dd><p>val enqueueStats = tweetStoreStats.scope(“retweet_archival_enqueueing”)
val enqueueEffect = FutureEffect(clients.retweetArchivalEventPublisher.publish)</p>
<dl class="simple">
<dt>RetweetArchivalEnqueueStore(enqueueEffect)</dt><dd><p>.tracked(enqueueStats)
.asyncRetry(asyncRetryConfig(enqueueStats, AsyncWriteAction.RetweetArchivalEnqueue))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val asyncEnqueueStore = {</dt><dd><p>val asyncEnqueueStats = tweetStoreStats.scope(“async_enqueueing”)
AsyncEnqueueStore(</p>
<blockquote>
<div><p>asyncBuilder.asyncVia(clients.asyncTweetService).service,
TweetBuilder.scrubUserInAsyncInserts,
TweetBuilder.scrubSourceTweetInAsyncInserts,
TweetBuilder.scrubSourceUserInAsyncInserts</p>
</div></blockquote>
<dl class="simple">
<dt>).tracked(asyncEnqueueStats)</dt><dd><p>.retry(RetryHandler.failuresOnly(deferredrpcRetryPolicy, timer, asyncEnqueueStats))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val insertTweetStore =</dt><dd><dl class="simple">
<dt>InsertTweet.Store(</dt><dd><p>logLensStore = logLensStore,
manhattanStore = manhattanStore,
tweetStatsStore = tweetStatsStore,
cachingTweetStore = cachingTweetStore,
limiterStore = limiterStore,
asyncEnqueueStore = asyncEnqueueStore,
userCountsUpdatingStore = userCountsUpdatingStore,
tweetCountsUpdatingStore = tweetCountsUpdatingStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val asyncInsertStore =</dt><dd><dl class="simple">
<dt>AsyncInsertTweet.Store(</dt><dd><p>replicatingStore = replicatingStore,
indexingStore = indexingStore,
tweetCountsUpdatingStore = tweetCountsUpdatingStore,
timelineUpdatingStore = timelineUpdatingStore,
eventBusEnqueueStore = eventBusEnqueueStore,
fanoutServiceStore = fanoutServiceStore,
scribeMediaTagStore = scribeMediaTagStore,
userGeotagUpdateStore = userGeotagUpdateStore,
geoSearchRequestIDStore = geoSearchRequestIDStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val replicatedInsertTweetStore =</dt><dd><dl class="simple">
<dt>ReplicatedInsertTweet.Store(</dt><dd><p>cachingTweetStore = cachingTweetStore,
tweetCountsUpdatingStore = tweetCountsUpdatingStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val deleteTweetStore =</dt><dd><dl class="simple">
<dt>DeleteTweet.Store(</dt><dd><p>cachingTweetStore = cachingTweetStore,
asyncEnqueueStore = asyncEnqueueStore,
userCountsUpdatingStore = userCountsUpdatingStore,
tweetCountsUpdatingStore = tweetCountsUpdatingStore,
logLensStore = logLensStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val asyncDeleteTweetStore =</dt><dd><dl class="simple">
<dt>AsyncDeleteTweet.Store(</dt><dd><p>manhattanStore = manhattanStore,
cachingTweetStore = cachingTweetStore,
replicatingStore = replicatingStore,
indexingStore = indexingStore,
eventBusEnqueueStore = eventBusEnqueueStore,
timelineUpdatingStore = timelineUpdatingStore,
tweetCountsUpdatingStore = tweetCountsUpdatingStore,
guanoServiceStore = guanoServiceStore,
mediaServiceStore = mediaServiceStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val replicatedDeleteTweetStore =</dt><dd><dl class="simple">
<dt>ReplicatedDeleteTweet.Store(</dt><dd><p>cachingTweetStore = cachingTweetStore,
tweetCountsUpdatingStore = tweetCountsUpdatingStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val incrBookmarkCountStore =</dt><dd><dl class="simple">
<dt>IncrBookmarkCount.Store(</dt><dd><p>asyncEnqueueStore = asyncEnqueueStore,
replicatingStore = replicatingStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val asyncIncrBookmarkCountStore =</dt><dd><dl class="simple">
<dt>AsyncIncrBookmarkCount.Store(</dt><dd><p>tweetCountsUpdatingStore = tweetCountsUpdatingStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val replicatedIncrBookmarkCountStore =</dt><dd><dl class="simple">
<dt>ReplicatedIncrBookmarkCount.Store(</dt><dd><p>tweetCountsUpdatingStore = tweetCountsUpdatingStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val incrFavCountStore =</dt><dd><dl class="simple">
<dt>IncrFavCount.Store(</dt><dd><p>asyncEnqueueStore = asyncEnqueueStore,
replicatingStore = replicatingStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val asyncIncrFavCountStore =</dt><dd><dl class="simple">
<dt>AsyncIncrFavCount.Store(</dt><dd><p>tweetCountsUpdatingStore = tweetCountsUpdatingStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val replicatedIncrFavCountStore =</dt><dd><dl class="simple">
<dt>ReplicatedIncrFavCount.Store(</dt><dd><p>tweetCountsUpdatingStore = tweetCountsUpdatingStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val scrubGeoStore =</dt><dd><dl class="simple">
<dt>ScrubGeo.Store(</dt><dd><p>logLensStore = logLensStore,
manhattanStore = manhattanStore,
cachingTweetStore = cachingTweetStore,
eventBusEnqueueStore = eventBusEnqueueStore,
replicatingStore = replicatingStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val replicatedScrubGeoStore =</dt><dd><dl class="simple">
<dt>ReplicatedScrubGeo.Store(</dt><dd><p>cachingTweetStore = cachingTweetStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val takedownStore =</dt><dd><dl class="simple">
<dt>Takedown.Store(</dt><dd><p>logLensStore = logLensStore,
manhattanStore = manhattanStore,
cachingTweetStore = cachingTweetStore,
asyncEnqueueStore = asyncEnqueueStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val asyncTakedownStore =</dt><dd><dl class="simple">
<dt>AsyncTakedown.Store(</dt><dd><p>replicatingStore = replicatingStore,
guanoStore = guanoServiceStore,
eventBusEnqueueStore = eventBusEnqueueStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val replicatedTakedownStore =</dt><dd><dl class="simple">
<dt>ReplicatedTakedown.Store(</dt><dd><p>cachingTweetStore = cachingTweetStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val updatePossiblySensitiveTweetStore =</dt><dd><dl class="simple">
<dt>UpdatePossiblySensitiveTweet.Store(</dt><dd><p>manhattanStore = manhattanStore,
cachingTweetStore = cachingTweetStore,
logLensStore = logLensStore,
asyncEnqueueStore = asyncEnqueueStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val asyncUpdatePossiblySensitiveTweetStore =</dt><dd><dl class="simple">
<dt>AsyncUpdatePossiblySensitiveTweet.Store(</dt><dd><p>manhattanStore = manhattanStore,
cachingTweetStore = cachingTweetStore,
replicatingStore = replicatingStore,
guanoStore = guanoServiceStore,
eventBusStore = eventBusEnqueueStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val replicatedUpdatePossiblySensitiveTweetStore =</dt><dd><dl class="simple">
<dt>ReplicatedUpdatePossiblySensitiveTweet.Store(</dt><dd><p>cachingTweetStore = cachingTweetStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val setAdditionalFieldsStore =</dt><dd><dl class="simple">
<dt>SetAdditionalFields.Store(</dt><dd><p>manhattanStore = manhattanStore,
cachingTweetStore = cachingTweetStore,
asyncEnqueueStore = asyncEnqueueStore,
logLensStore = logLensStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val asyncSetAdditionalFieldsStore =</dt><dd><dl class="simple">
<dt>AsyncSetAdditionalFields.Store(</dt><dd><p>replicatingStore = replicatingStore,
eventBusEnqueueStore = eventBusEnqueueStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val replicatedSetAdditionalFieldsStore =</dt><dd><dl class="simple">
<dt>ReplicatedSetAdditionalFields.Store(</dt><dd><p>cachingTweetStore = cachingTweetStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val setRetweetVisibilityStore =</dt><dd><p>SetRetweetVisibility.Store(asyncEnqueueStore = asyncEnqueueStore)</p>
</dd>
<dt>val asyncSetRetweetVisibilityStore =</dt><dd><dl class="simple">
<dt>AsyncSetRetweetVisibility.Store(</dt><dd><p>tweetIndexingStore = indexingStore,
tweetCountsCacheUpdatingStore = tweetCountsUpdatingStore,
replicatingTweetStore = replicatingStore,
retweetArchivalEnqueueStore = retweetArchivalEnqueueStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val replicatedSetRetweetVisibilityStore =</dt><dd><dl class="simple">
<dt>ReplicatedSetRetweetVisibility.Store(</dt><dd><p>tweetCountsCacheUpdatingStore = tweetCountsUpdatingStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val deleteAdditionalFieldsStore =</dt><dd><dl class="simple">
<dt>DeleteAdditionalFields.Store(</dt><dd><p>cachingTweetStore = cachingTweetStore,
asyncEnqueueStore = asyncEnqueueStore,
logLensStore = logLensStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val asyncDeleteAdditionalFieldsStore =</dt><dd><dl class="simple">
<dt>AsyncDeleteAdditionalFields.Store(</dt><dd><p>manhattanStore = manhattanStore,
cachingTweetStore = cachingTweetStore,
replicatingStore = replicatingStore,
eventBusEnqueueStore = eventBusEnqueueStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val replicatedDeleteAdditionalFieldsStore =</dt><dd><dl class="simple">
<dt>ReplicatedDeleteAdditionalFields.Store(</dt><dd><p>cachingTweetStore = cachingTweetStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/*</dt><dd><ul class="simple">
<li><p>This composed store handles all synchronous side effects of an undelete</p></li>
<li><p>but does not execute the undeletion.</p></li>
<li></li>
<li><p>This store is executed after the actual undelete request succeeds.</p></li>
<li><p>The undeletion request is initiated by Undelete.apply()</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>val undeleteTweetStore =</dt><dd><dl class="simple">
<dt>UndeleteTweet.Store(</dt><dd><p>logLensStore = logLensStore,
cachingTweetStore = cachingTweetStore,
tweetCountsUpdatingStore = tweetCountsUpdatingStore,
asyncEnqueueStore = asyncEnqueueStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val asyncUndeleteTweetStore =</dt><dd><dl class="simple">
<dt>AsyncUndeleteTweet.Store(</dt><dd><p>cachingTweetStore = cachingTweetStore,
eventBusEnqueueStore = eventBusEnqueueStore,
indexingStore = indexingStore,
replicatingStore = replicatingStore,
mediaServiceStore = mediaServiceStore,
timelineUpdatingStore = timelineUpdatingStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val replicatedUndeleteTweetStore =</dt><dd><dl class="simple">
<dt>ReplicatedUndeleteTweet.Store(</dt><dd><p>cachingTweetStore = cachingTweetStore,
tweetCountsUpdatingStore = tweetCountsUpdatingStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val flushStore =</dt><dd><dl class="simple">
<dt>Flush.Store(</dt><dd><p>cachingTweetStore = cachingTweetStore,
tweetCountsUpdatingStore = tweetCountsUpdatingStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val scrubGeoUpdateUserTimestampStore =</dt><dd><dl class="simple">
<dt>ScrubGeoUpdateUserTimestamp.Store(</dt><dd><p>cache = caches.geoScrubCache,
setInManhattan = clients.geoScrubEventStore.setGeoScrubTimestamp,
geotagUpdateStore = userGeotagUpdateStore,
tweetEventBusStore = eventBusEnqueueStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val quotedTweetDeleteStore =</dt><dd><dl class="simple">
<dt>QuotedTweetDelete.Store(</dt><dd><p>eventBusEnqueueStore = eventBusEnqueueStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val quotedTweetTakedownStore =</dt><dd><dl class="simple">
<dt>QuotedTweetTakedown.Store(</dt><dd><p>eventBusEnqueueStore = eventBusEnqueueStore</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>new TotalTweetStore {</dt><dd><dl class="simple">
<dt>val asyncDeleteAdditionalFields: FutureEffect[AsyncDeleteAdditionalFields.Event] =</dt><dd><p>asyncDeleteAdditionalFieldsStore.asyncDeleteAdditionalFields</p>
</dd>
<dt>val asyncDeleteTweet: FutureEffect[AsyncDeleteTweet.Event] =</dt><dd><p>asyncDeleteTweetStore.asyncDeleteTweet</p>
</dd>
<dt>val asyncIncrBookmarkCount: FutureEffect[AsyncIncrBookmarkCount.Event] =</dt><dd><p>asyncIncrBookmarkCountStore.asyncIncrBookmarkCount</p>
</dd>
<dt>val asyncIncrFavCount: FutureEffect[AsyncIncrFavCount.Event] =</dt><dd><p>asyncIncrFavCountStore.asyncIncrFavCount</p>
</dd>
</dl>
<p>val asyncInsertTweet: FutureEffect[AsyncInsertTweet.Event] = asyncInsertStore.asyncInsertTweet
val asyncSetAdditionalFields: FutureEffect[AsyncSetAdditionalFields.Event] =</p>
<blockquote>
<div><p>asyncSetAdditionalFieldsStore.asyncSetAdditionalFields</p>
</div></blockquote>
<dl class="simple">
<dt>val asyncSetRetweetVisibility: FutureEffect[AsyncSetRetweetVisibility.Event] =</dt><dd><p>asyncSetRetweetVisibilityStore.asyncSetRetweetVisibility</p>
</dd>
</dl>
<p>val asyncTakedown: FutureEffect[AsyncTakedown.Event] = asyncTakedownStore.asyncTakedown
val asyncUndeleteTweet: FutureEffect[AsyncUndeleteTweet.Event] =</p>
<blockquote>
<div><p>asyncUndeleteTweetStore.asyncUndeleteTweet</p>
</div></blockquote>
<dl class="simple">
<dt>val asyncUpdatePossiblySensitiveTweet: FutureEffect[AsyncUpdatePossiblySensitiveTweet.Event] =</dt><dd><p>asyncUpdatePossiblySensitiveTweetStore.asyncUpdatePossiblySensitiveTweet</p>
</dd>
<dt>val deleteAdditionalFields: FutureEffect[DeleteAdditionalFields.Event] =</dt><dd><p>deleteAdditionalFieldsStore.deleteAdditionalFields</p>
</dd>
</dl>
<p>val deleteTweet: FutureEffect[DeleteTweet.Event] = deleteTweetStore.deleteTweet
val flush: FutureEffect[Flush.Event] = flushStore.flush
val incrBookmarkCount: FutureEffect[IncrBookmarkCount.Event] =</p>
<blockquote>
<div><p>incrBookmarkCountStore.incrBookmarkCount</p>
</div></blockquote>
<p>val incrFavCount: FutureEffect[IncrFavCount.Event] = incrFavCountStore.incrFavCount
val insertTweet: FutureEffect[InsertTweet.Event] = insertTweetStore.insertTweet
val quotedTweetDelete: FutureEffect[QuotedTweetDelete.Event] =</p>
<blockquote>
<div><p>quotedTweetDeleteStore.quotedTweetDelete</p>
</div></blockquote>
<dl class="simple">
<dt>val quotedTweetTakedown: FutureEffect[QuotedTweetTakedown.Event] =</dt><dd><p>quotedTweetTakedownStore.quotedTweetTakedown</p>
</dd>
<dt>val replicatedDeleteAdditionalFields: FutureEffect[ReplicatedDeleteAdditionalFields.Event] =</dt><dd><p>replicatedDeleteAdditionalFieldsStore.replicatedDeleteAdditionalFields</p>
</dd>
<dt>val replicatedDeleteTweet: FutureEffect[ReplicatedDeleteTweet.Event] =</dt><dd><p>replicatedDeleteTweetStore.replicatedDeleteTweet</p>
</dd>
<dt>val replicatedIncrBookmarkCount: FutureEffect[ReplicatedIncrBookmarkCount.Event] =</dt><dd><p>replicatedIncrBookmarkCountStore.replicatedIncrBookmarkCount</p>
</dd>
<dt>val replicatedIncrFavCount: FutureEffect[ReplicatedIncrFavCount.Event] =</dt><dd><p>replicatedIncrFavCountStore.replicatedIncrFavCount</p>
</dd>
<dt>val replicatedInsertTweet: FutureEffect[ReplicatedInsertTweet.Event] =</dt><dd><p>replicatedInsertTweetStore.replicatedInsertTweet</p>
</dd>
<dt>val replicatedScrubGeo: FutureEffect[ReplicatedScrubGeo.Event] =</dt><dd><p>replicatedScrubGeoStore.replicatedScrubGeo</p>
</dd>
<dt>val replicatedSetAdditionalFields: FutureEffect[ReplicatedSetAdditionalFields.Event] =</dt><dd><p>replicatedSetAdditionalFieldsStore.replicatedSetAdditionalFields</p>
</dd>
<dt>val replicatedSetRetweetVisibility: FutureEffect[ReplicatedSetRetweetVisibility.Event] =</dt><dd><p>replicatedSetRetweetVisibilityStore.replicatedSetRetweetVisibility</p>
</dd>
<dt>val replicatedTakedown: FutureEffect[ReplicatedTakedown.Event] =</dt><dd><p>replicatedTakedownStore.replicatedTakedown</p>
</dd>
<dt>val replicatedUndeleteTweet: FutureEffect[ReplicatedUndeleteTweet.Event] =</dt><dd><p>replicatedUndeleteTweetStore.replicatedUndeleteTweet</p>
</dd>
<dt>val replicatedUpdatePossiblySensitiveTweet: FutureEffect[</dt><dd><p>ReplicatedUpdatePossiblySensitiveTweet.Event</p>
</dd>
<dt>] =</dt><dd><p>replicatedUpdatePossiblySensitiveTweetStore.replicatedUpdatePossiblySensitiveTweet</p>
</dd>
<dt>val retryAsyncDeleteAdditionalFields: FutureEffect[</dt><dd><p>TweetStoreRetryEvent[AsyncDeleteAdditionalFields.Event]</p>
</dd>
<dt>] =</dt><dd><p>asyncDeleteAdditionalFieldsStore.retryAsyncDeleteAdditionalFields</p>
</dd>
<dt>val retryAsyncDeleteTweet: FutureEffect[TweetStoreRetryEvent[AsyncDeleteTweet.Event]] =</dt><dd><p>asyncDeleteTweetStore.retryAsyncDeleteTweet</p>
</dd>
<dt>val retryAsyncInsertTweet: FutureEffect[TweetStoreRetryEvent[AsyncInsertTweet.Event]] =</dt><dd><p>asyncInsertStore.retryAsyncInsertTweet</p>
</dd>
<dt>val retryAsyncSetAdditionalFields: FutureEffect[</dt><dd><p>TweetStoreRetryEvent[AsyncSetAdditionalFields.Event]</p>
</dd>
<dt>] =</dt><dd><p>asyncSetAdditionalFieldsStore.retryAsyncSetAdditionalFields</p>
</dd>
<dt>val retryAsyncSetRetweetVisibility: FutureEffect[</dt><dd><p>TweetStoreRetryEvent[AsyncSetRetweetVisibility.Event]</p>
</dd>
<dt>] =</dt><dd><p>asyncSetRetweetVisibilityStore.retryAsyncSetRetweetVisibility</p>
</dd>
<dt>val retryAsyncTakedown: FutureEffect[TweetStoreRetryEvent[AsyncTakedown.Event]] =</dt><dd><p>asyncTakedownStore.retryAsyncTakedown</p>
</dd>
<dt>val retryAsyncUndeleteTweet: FutureEffect[TweetStoreRetryEvent[AsyncUndeleteTweet.Event]] =</dt><dd><p>asyncUndeleteTweetStore.retryAsyncUndeleteTweet</p>
</dd>
<dt>val retryAsyncUpdatePossiblySensitiveTweet: FutureEffect[</dt><dd><p>TweetStoreRetryEvent[AsyncUpdatePossiblySensitiveTweet.Event]</p>
</dd>
<dt>] =</dt><dd><p>asyncUpdatePossiblySensitiveTweetStore.retryAsyncUpdatePossiblySensitiveTweet</p>
</dd>
</dl>
<p>val scrubGeo: FutureEffect[ScrubGeo.Event] = scrubGeoStore.scrubGeo
val setAdditionalFields: FutureEffect[SetAdditionalFields.Event] =</p>
<blockquote>
<div><p>setAdditionalFieldsStore.setAdditionalFields</p>
</div></blockquote>
<dl class="simple">
<dt>val setRetweetVisibility: FutureEffect[SetRetweetVisibility.Event] =</dt><dd><p>setRetweetVisibilityStore.setRetweetVisibility</p>
</dd>
</dl>
<p>val takedown: FutureEffect[Takedown.Event] = takedownStore.takedown
val undeleteTweet: FutureEffect[UndeleteTweet.Event] = undeleteTweetStore.undeleteTweet
val updatePossiblySensitiveTweet: FutureEffect[UpdatePossiblySensitiveTweet.Event] =</p>
<blockquote>
<div><p>updatePossiblySensitiveTweetStore.updatePossiblySensitiveTweet</p>
</div></blockquote>
<dl class="simple">
<dt>val scrubGeoUpdateUserTimestamp: FutureEffect[ScrubGeoUpdateUserTimestamp.Event] =</dt><dd><p>scrubGeoUpdateUserTimestampStore.scrubGeoUpdateUserTimestamp</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/tweetypie/server/src/main/scala/com/twitter/tweetypie/config/TweetStores.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>