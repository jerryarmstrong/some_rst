<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie
package handler</p>
<p>import com.twitter.expandodo.thriftscala.Card2RequestOptions
import com.twitter.featureswitches.v2.FeatureSwitchResults
import com.twitter.gizmoduck.util.UserUtil
import com.twitter.stitch.Stitch
import com.twitter.tweetypie.core.TweetCreateFailure
import com.twitter.tweetypie.repository.Card2Repository
import com.twitter.tweetypie.repository.StratoPromotedTweetRepository
import com.twitter.tweetypie.repository.StratoSubscriptionVerificationRepository
import com.twitter.tweetypie.repository.TweetQuery
import com.twitter.tweetypie.repository.TweetRepository
import com.twitter.tweetypie.repository.UrlCard2Key
import com.twitter.tweetypie.thriftscala.EditControl
import com.twitter.tweetypie.thriftscala.EditOptions
import com.twitter.tweetypie.thriftscala.TweetCreateState
import com.twitter.tweetypie.util.EditControlUtil._
import com.twitter.tweetypie.thriftscala.CardReference
import com.twitter.tweetypie.thriftscala.EditControlInitial
import com.twitter.tweetypie.thriftscala.PostTweetRequest
import com.twitter.tweetypie.util.CommunityAnnotation
import com.twitter.tweetypie.util.EditControlUtil
import com.twitter.util.Future</p>
<dl>
<dt>object EditControlBuilder {</dt><dd><p>type Type = Request =&gt; Future[Option[EditControl]]</p>
<p>val editTweetCountStat = “edit_tweet_count”
val editControlQueryOptions = TweetQuery.Options(</p>
<blockquote>
<div><p>TweetQuery.Include(Set(Tweet.CoreDataField.id, Tweet.EditControlField.id))</p>
</div></blockquote>
<p>)
val TweetEditCreationEnabledKey = “tweet_edit_creation_enabled”
val TweetEditCreationEnabledForTwitterBlueKey = “tweet_edit_creation_enabled_for_twitter_blue”</p>
<dl class="simple">
<dt>val pollCardNames: Set[String] = Set(</dt><dd><p>“poll2choice_text_only”,
“poll3choice_text_only”,
“poll4choice_text_only”,
“poll2choice_image”,
“poll3choice_image”,
“poll4choice_image”,
“poll2choice_video”,
“poll3choice_video”,
“poll4choice_video”,</p>
</dd>
</dl>
<p>)</p>
<p>/** Used just for checking card name for poll check in case cards platform key not provided. <a href="#id1"><span class="problematic" id="id2">*</span></a>/
val defaultCardsPlatformKey = “iPhone-13”</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Do we assume a Tweet has a poll (which makes it not editable) when it has a card</p></li>
<li><p>that could be a poll, and it cannot be resolved at create.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
</dl>
<p>val isPollCardAssumption = true</p>
<p>val tweetEditSubscriptionResource = “feature/tweet_edit”</p>
<p>val log: Logger = Logger(getClass)</p>
<dl>
<dt>case class Request(</dt><dd><p>postTweetRequest: PostTweetRequest,
tweet: Tweet,
matchedResults: Option[FeatureSwitchResults]) {
def editOptions: Option[EditOptions] = postTweetRequest.editOptions</p>
<p>def authorId: UserId = postTweetRequest.userId</p>
<p>def createdAt: Time = Time.fromMilliseconds(tweet.coreData.get.createdAtSecs * 1000L)</p>
<p>def tweetId: TweetId = tweet.id</p>
<dl class="simple">
<dt>def cardReference: Option[CardReference] =</dt><dd><p>postTweetRequest.additionalFields.flatMap(_.cardReference)</p>
</dd>
<dt>def cardsPlatformKey: Option[String] =</dt><dd><p>postTweetRequest.hydrationOptions.flatMap(_.cardsPlatformKey)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def apply(</dt><dd><p>tweetRepo: TweetRepository.Type,
card2Repo: Card2Repository.Type,
promotedTweetRepo: StratoPromotedTweetRepository.Type,
subscriptionVerificationRepo: StratoSubscriptionVerificationRepository.Type,
disablePromotedTweetEdit: Gate[Unit],
checkTwitterBlueSubscription: Gate[Unit],
setEditWindowToSixtyMinutes: Gate[Unit],
stats: StatsReceiver</p>
</dd>
</dl>
<p>): Type = {</p>
<blockquote>
<div><p>// Nullcast tweets not allowed, except if the tweet has a community annotation
def isNullcastedButNotCommunityTweet(request: Request): Boolean = {</p>
<blockquote>
<div><p>val isNullcasted: Boolean = request.tweet.coreData.get.nullcast</p>
<dl class="simple">
<dt>val communityIds: Option[Seq[CommunityId]] =</dt><dd><dl class="simple">
<dt>request.postTweetRequest.additionalFields</dt><dd><p>.flatMap(CommunityAnnotation.additionalFieldsToCommunityIDs)</p>
</dd>
</dl>
</dd>
</dl>
<p>isNullcasted &amp;&amp; !(communityIds.exists(_.nonEmpty))</p>
</div></blockquote>
<p>}</p>
<p>def isSuperFollow(tweet: Tweet): Boolean = tweet.exclusiveTweetControl.isDefined</p>
<p>def isCollabTweet(tweet: Tweet): Boolean = tweet.collabControl.isDefined</p>
<dl class="simple">
<dt>def isReplyToTweet(tweet: Tweet): Boolean =</dt><dd><p>getReply(tweet).flatMap(_.inReplyToStatusId).isDefined</p>
</dd>
</dl>
<p>// When card is tombstone, tweet is not considered a poll, and therefore can be edit eligible.
val cardReferenceUriIsTombstone = stats.counter(“edit_control_builder_card_tombstoned”)
// We check whether tweets are polls since these are not edit eligible.
// If we are not sure due to lookup failure, we take an <cite>isPollCardAssumption</cite>.
def isPoll(</p>
<blockquote>
<div><p>card2Repo: Card2Repository.Type,
cardReference: CardReference,
cardsPlatformKey: String,</p>
</div></blockquote>
<dl>
<dt>): Stitch[Boolean] = {</dt><dd><dl>
<dt>if (cardReference.cardUri == “tombstone://card”) {</dt><dd><p>cardReferenceUriIsTombstone.incr()
Stitch.value(false)</p>
</dd>
<dt>} else {</dt><dd><p>val key = UrlCard2Key(cardReference.cardUri)
// <cite>allowNonTcoUrls = true</cite> This allows us to check if non-tco urls (e.g. apple.com) have a card
// at this point in tweet builder urls can be in their original form and not tcoified.
val options = Card2RequestOptions(</p>
<blockquote>
<div><p>platformKey = cardsPlatformKey,
allowNonTcoUrls = true</p>
</div></blockquote>
<p>)
card2Repo(key, options)</p>
<blockquote>
<div><p>.map(card2 =&gt; pollCardNames.contains(card2.name))</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def isFeatureSwitchEnabled(matchedResults: Option[FeatureSwitchResults], key: String): Boolean =</dt><dd><p>matchedResults.flatMap(_.getBoolean(key, shouldLogImpression = false)).contains(true)</p>
</dd>
<dt>def wrapInitial(initial: EditControlInitial): Option[EditControl.Initial] =</dt><dd><p>Some(EditControl.Initial(initial = initial))</p>
</dd>
</dl>
<p>// Checks for validity of an edit are implemented as procedures
// that throw an error in case a check fails. This composes way better than
// returning a Try/Future/Stitch because:
// 1. We do not need to decide which of the aforementioned containers to use.
// 2. The checks as below compose with callbacks in all the aforementioned containers.</p>
<p>val editRequestOutsideOfAllowlist = stats.counter(“edit_control_builder_rejected”, “allowlist”)</p>
<p>// This method uses two feature switches:
// - TweetEditCreationEnabledKey authorizes the user to edit tweets directly
// - TweetEditCreationEnabledForTwitterBlueKey authorizes the user to edit tweets if they have
//     a Twitter Blue subscription
//
// Test users are always authorized to edit tweets.
def checkUserEligibility(</p>
<blockquote>
<div><p>authorId: UserId,
matchedResults: Option[FeatureSwitchResults]</p>
</div></blockquote>
<dl>
<dt>): Stitch[Unit] = {</dt><dd><p>val isTestUser = UserUtil.isTestUserId(authorId)
val authorizedWithoutTwitterBlue =</p>
<blockquote>
<div><p>isFeatureSwitchEnabled(matchedResults, TweetEditCreationEnabledKey)</p>
</div></blockquote>
<dl>
<dt>if (isTestUser || authorizedWithoutTwitterBlue) {</dt><dd><p>// If the editing user is a test user or is authorized by the non-Twitter Blue feature
// switch, allow editing.
Stitch.Done</p>
</dd>
<dt>} else {</dt><dd><p>// Otherwise, check if they’re authorized by the Twitter Blue feature switch and if they’re
// subscribed to Twitter Blue.
val authorizedWithTwitterBlue: Stitch[Boolean] =</p>
<blockquote>
<div><dl class="simple">
<dt>if (checkTwitterBlueSubscription() &amp;&amp;</dt><dd><p>isFeatureSwitchEnabled(matchedResults, TweetEditCreationEnabledForTwitterBlueKey)) {
subscriptionVerificationRepo(authorId, tweetEditSubscriptionResource)</p>
</dd>
</dl>
<p>} else Stitch.value(false)</p>
</div></blockquote>
<dl>
<dt>authorizedWithTwitterBlue.flatMap { authorized =&gt;</dt><dd><dl class="simple">
<dt>if (!authorized) {</dt><dd><p>log.error(s”User ${authorId} unauthorized to edit”)
editRequestOutsideOfAllowlist.incr()
Stitch.exception(TweetCreateFailure.State(TweetCreateState.EditTweetUserNotAuthorized))</p>
</dd>
</dl>
<p>} else Stitch.Done</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>val editRequestByNonAuthor = stats.counter(“edit_control_builder_rejected”, “not_author”)
def checkAuthor(</p>
<blockquote>
<div><p>authorId: UserId,
previousTweetAuthorId: UserId</p>
</div></blockquote>
<dl>
<dt>): Unit = {</dt><dd><dl class="simple">
<dt>if (authorId != previousTweetAuthorId) {</dt><dd><p>editRequestByNonAuthor.incr()
throw TweetCreateFailure.State(TweetCreateState.EditTweetUserNotAuthor)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>val tweetEditForStaleTweet = stats.counter(“edit_control_builder_rejected”, “stale”)
def checkLatestEdit(</p>
<blockquote>
<div><p>previousTweetId: TweetId,
initial: EditControlInitial,</p>
</div></blockquote>
<dl>
<dt>): Unit = {</dt><dd><dl class="simple">
<dt>if (previousTweetId != initial.editTweetIds.last) {</dt><dd><p>tweetEditForStaleTweet.incr()
throw TweetCreateFailure.State(TweetCreateState.EditTweetNotLatestVersion)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>val tweetEditForLimitReached = stats.counter(“edit_control_builder_rejected”, “edits_limit”)
def checkEditsRemaining(initial: EditControlInitial): Unit = {</p>
<blockquote>
<div><dl>
<dt>initial.editsRemaining match {</dt><dd><p>case Some(number) if number &gt; 0 =&gt; // OK
case _ =&gt;</p>
<blockquote>
<div><p>tweetEditForLimitReached.incr()
throw TweetCreateFailure.State(TweetCreateState.EditCountLimitReached)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>val editTweetExpired = stats.counter(“edit_control_builder_rejected”, “expired”)
val editTweetExpiredNoEditControl =</p>
<blockquote>
<div><p>stats.counter(“edit_control_builder_rejected”, “expired”, “no_edit_control”)</p>
</div></blockquote>
<dl>
<dt>def checkEditTimeWindow(initial: EditControlInitial): Unit = {</dt><dd><dl>
<dt>initial.editableUntilMsecs match {</dt><dd><p>case Some(millis) if Time.now &lt; Time.fromMilliseconds(millis) =&gt; // OK
case Some(_) =&gt;</p>
<blockquote>
<div><p>editTweetExpired.incr()
throw TweetCreateFailure.State(TweetCreateState.EditTimeLimitReached)</p>
</div></blockquote>
<dl>
<dt>case editable =&gt;</dt><dd><p>editTweetExpired.incr()
if (editable.isEmpty) {</p>
<blockquote>
<div><p>editTweetExpiredNoEditControl.incr()</p>
</div></blockquote>
<p>}
throw TweetCreateFailure.State(TweetCreateState.EditTimeLimitReached)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>val tweetEditNotEligible = stats.counter(“edit_control_builder_rejected”, “not_eligible”)
def checkIsEditEligible(initial: EditControlInitial): Unit = {</p>
<blockquote>
<div><dl>
<dt>initial.isEditEligible match {</dt><dd><p>case Some(true) =&gt; // OK
case _ =&gt;</p>
<blockquote>
<div><p>tweetEditNotEligible.incr()
throw TweetCreateFailure.State(TweetCreateState.NotEligibleForEdit)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>val editControlInitialMissing =</dt><dd><p>stats.counter(“edit_control_builder_rejected”, “initial_missing”)</p>
</dd>
<dt>def findEditControlInitial(previousTweet: Tweet): EditControlInitial = {</dt><dd><dl>
<dt>previousTweet.editControl match {</dt><dd><p>case Some(EditControl.Initial(initial)) =&gt; initial
case Some(EditControl.Edit(edit)) =&gt;</p>
<blockquote>
<div><dl>
<dt>edit.editControlInitial.getOrElse {</dt><dd><p>editControlInitialMissing.incr()
throw new IllegalStateException(</p>
<blockquote>
<div><p>“Encountered edit tweet with missing editControlInitial.”)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>case _ =&gt;</dt><dd><p>throw TweetCreateFailure.State(TweetCreateState.EditTimeLimitReached)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>val editPromotedTweet = stats.counter(“tweet_edit_for_promoted_tweet”)
def checkPromotedTweet(</p>
<blockquote>
<div><p>previousTweetId: TweetId,
promotedTweetRepo: StratoPromotedTweetRepository.Type,
disablePromotedTweetEdit: Gate[Unit]</p>
</div></blockquote>
<dl>
<dt>): Stitch[Unit] = {</dt><dd><dl>
<dt>if (disablePromotedTweetEdit()) {</dt><dd><dl class="simple">
<dt>promotedTweetRepo(previousTweetId).flatMap {</dt><dd><dl class="simple">
<dt>case false =&gt;</dt><dd><p>Stitch.Done</p>
</dd>
<dt>case true =&gt;</dt><dd><p>editPromotedTweet.incr()
Stitch.exception(TweetCreateFailure.State(TweetCreateState.EditTweetUserNotAuthorized))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>Stitch.Done</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// Each time edit is made, count how many versions a tweet already has.
// Value should be always between 1 and 4.
val editTweetCount = 0</p>
<blockquote>
<div><p>.to(EditControlUtil.maxTweetEditsAllowed)
.map(i =&gt; i -&gt; stats.counter(“edit_control_builder_edits_count”, i.toString))
.toMap</p>
</div></blockquote>
<p>// Overall counter and failures of card resolution for poll lookups. Needed because polls are not editable.
val pollCardResolutionTotal = stats.counter(“edit_control_builder_card_resolution”, “total”)
val pollCardResolutionFailure =</p>
<blockquote>
<div><p>stats.counter(“edit_control_builder_card_resolution”, “failures”)</p>
</div></blockquote>
<p>// Edit of initial tweet requested, and all edit checks successful.
val initialEditTweet = stats.counter(“edit_control_builder_initial_edit”)
request =&gt;</p>
<blockquote>
<div><dl>
<dt>Stitch.run {</dt><dd><dl>
<dt>request.editOptions match {</dt><dd><dl>
<dt>case None =&gt;</dt><dd><dl>
<dt>val editControl =</dt><dd><dl>
<dt>makeEditControlInitial(</dt><dd><p>tweetId = request.tweetId,
createdAt = request.createdAt,
setEditWindowToSixtyMinutes = setEditWindowToSixtyMinutes</p>
</dd>
<dt>).initial.copy(</dt><dd><dl class="simple">
<dt>isEditEligible = Some(</dt><dd><dl class="simple">
<dt>!isNullcastedButNotCommunityTweet(request)</dt><dd><p>&amp;&amp; !isSuperFollow(request.tweet)
&amp;&amp; !isCollabTweet(request.tweet)
&amp;&amp; !isReplyToTweet(request.tweet)</p>
</dd>
</dl>
</dd>
</dl>
<p>),</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>(editControl.isEditEligible, request.cardReference) match {</dt><dd><dl>
<dt>case (Some(true), Some(reference)) =&gt;</dt><dd><p>pollCardResolutionTotal.incr()
isPoll(</p>
<blockquote>
<div><p>card2Repo = card2Repo,
cardReference = reference,
cardsPlatformKey = request.cardsPlatformKey.getOrElse(defaultCardsPlatformKey),</p>
</div></blockquote>
<dl>
<dt>).rescue {</dt><dd><blockquote>
<div><p>// Revert to the assumed value if card cannot be resolved.
case _ =&gt;</p>
<blockquote>
<div><p>pollCardResolutionFailure.incr()
Stitch.value(isPollCardAssumption)</p>
</div></blockquote>
</div></blockquote>
<p>}
.map { tweetIsAPoll =&gt;</p>
<blockquote>
<div><p>wrapInitial(editControl.copy(isEditEligible = Some(!tweetIsAPoll)))</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>case _ =&gt; Stitch.value(wrapInitial(editControl))</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>case Some(editOptions) =&gt;</dt><dd><dl>
<dt>for {</dt><dd><dl>
<dt>(previousTweet, _, _) &lt;- Stitch.join(</dt><dd><p>tweetRepo(editOptions.previousTweetId, editControlQueryOptions),
checkPromotedTweet(</p>
<blockquote>
<div><p>editOptions.previousTweetId,
promotedTweetRepo,
disablePromotedTweetEdit),</p>
</div></blockquote>
<dl class="simple">
<dt>checkUserEligibility(</dt><dd><p>authorId = request.authorId,
matchedResults = request.matchedResults)</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
<dt>} yield {</dt><dd><p>val initial = findEditControlInitial(previousTweet)
checkAuthor(</p>
<blockquote>
<div><p>authorId = request.authorId,
previousTweetAuthorId = getUserId(previousTweet))</p>
</div></blockquote>
<dl class="simple">
<dt>editTweetCount</dt><dd><p>.get(initial.editTweetIds.size)
.orElse(editTweetCount.get(EditControlUtil.maxTweetEditsAllowed))
.foreach(counter =&gt; counter.incr())</p>
</dd>
</dl>
<p>checkLatestEdit(previousTweet.id, initial)
checkEditsRemaining(initial)
checkEditTimeWindow(initial)
checkIsEditEligible(initial)
if (initial.editTweetIds == Seq(previousTweet.id)) {</p>
<blockquote>
<div><p>initialEditTweet.incr()</p>
</div></blockquote>
<p>}
Some(editControlEdit(initialTweetId = initial.editTweetIds.head))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/tweetypie/server/src/main/scala/com/twitter/tweetypie/handler/EditControlBuilder.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>