<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>docs/src/theme/SearchBar/lib/DocSearch.js &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="docs-src-theme-searchbar-lib-docsearch-js">
<h1>docs/src/theme/SearchBar/lib/DocSearch.js<a class="headerlink" href="#docs-src-theme-searchbar-lib-docsearch-js" title="Permalink to this heading">¶</a></h1>
<p>Last edited: 2022-07-07 18:10:20</p>
<p>Contents:</p>
<div class="highlight-js notranslate"><div class="highlight"><pre><span></span><span class="k">import</span><span class="w"> </span><span class="nx">Hogan</span><span class="w"> </span><span class="kr">from</span><span class="w"> </span><span class="s2">&quot;hogan.js&quot;</span><span class="p">;</span>
</pre></div>
</div>
<p>import LunrSearchAdapter from “./lunar-search”;
import autocomplete from “autocomplete.js”;
import templates from “./templates”;
import utils from “./utils”;
import $ from “autocomplete.js/zepto”;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Adds an autocomplete dropdown to an input field</p></li>
<li><p>&#64;function DocSearch</p></li>
<li><p>&#64;param  {Object} options.searchDocs Search Documents</p></li>
<li><p>&#64;param  {Object} options.searchIndex Lune searchIndexes</p></li>
<li><p>&#64;param  {string} options.inputSelector  CSS selector that targets the input</p></li>
<li><p>value.</p></li>
<li><p>&#64;param  {Object} [options.autocompleteOptions] Options to pass to the underlying autocomplete instance</p></li>
<li><p>&#64;return {Object}</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>class DocSearch {</dt><dd><dl>
<dt>constructor({</dt><dd><p>searchDocs,
searchIndex,
inputSelector,
debug = false,
queryDataCallback = null,
autocompleteOptions = {</p>
<blockquote>
<div><p>debug: false,
hint: false,
autoselect: true</p>
</div></blockquote>
<p>},
transformData = false,
queryHook = false,
handleSelected = false,
enhancedSearchInput = false,
layout = “collumns”</p>
</dd>
<dt>}) {</dt><dd><p>this.input = DocSearch.getInputFromSelector(inputSelector);
this.queryDataCallback = queryDataCallback || null;
const autocompleteOptionsDebug =</p>
<blockquote>
<div><dl class="simple">
<dt>autocompleteOptions &amp;&amp; autocompleteOptions.debug</dt><dd><p>? autocompleteOptions.debug
: false;</p>
</dd>
</dl>
</div></blockquote>
<p>// eslint-disable-next-line no-param-reassign
autocompleteOptions.debug = debug || autocompleteOptionsDebug;
this.autocompleteOptions = autocompleteOptions;
this.autocompleteOptions.cssClasses =</p>
<blockquote>
<div><p>this.autocompleteOptions.cssClasses || {};</p>
</div></blockquote>
<dl class="simple">
<dt>this.autocompleteOptions.cssClasses.prefix =</dt><dd><p>this.autocompleteOptions.cssClasses.prefix || “ds”;</p>
</dd>
<dt>const inputAriaLabel =</dt><dd><p>this.input &amp;&amp;
typeof this.input.attr === “function” &amp;&amp;
this.input.attr(“aria-label”);</p>
</dd>
<dt>this.autocompleteOptions.ariaLabel =</dt><dd><p>this.autocompleteOptions.ariaLabel || inputAriaLabel || “search input”;</p>
</dd>
</dl>
<p>this.isSimpleLayout = layout === “simple”;</p>
<p>this.client = new LunrSearchAdapter(searchDocs, searchIndex);</p>
<dl class="simple">
<dt>if (enhancedSearchInput) {</dt><dd><p>this.input = DocSearch.injectSearchBox(this.input);</p>
</dd>
</dl>
<p>}
this.autocomplete = autocomplete(this.input, autocompleteOptions, [</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>source: this.getAutocompleteSource(transformData, queryHook),
templates: {</p>
<blockquote>
<div><p>suggestion: DocSearch.getSuggestionTemplate(this.isSimpleLayout),
footer: templates.footer,
empty: DocSearch.getEmptyTemplate()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>]);</p>
<p>const customHandleSelected = handleSelected;
this.handleSelected = customHandleSelected || this.handleSelected;</p>
<p>// We prevent default link clicking if a custom handleSelected is defined
if (customHandleSelected) {</p>
<blockquote>
<div><dl class="simple">
<dt>$(“.algolia-autocomplete”).on(“click”, “.ds-suggestions a”, event =&gt; {</dt><dd><p>event.preventDefault();</p>
</dd>
</dl>
<p>});</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>this.autocomplete.on(</dt><dd><p>“autocomplete:selected”,
this.handleSelected.bind(null, this.autocomplete.autocomplete)</p>
</dd>
</dl>
<p>);</p>
<dl class="simple">
<dt>this.autocomplete.on(</dt><dd><p>“autocomplete:shown”,
this.handleShown.bind(null, this.input)</p>
</dd>
</dl>
<p>);</p>
<dl class="simple">
<dt>if (enhancedSearchInput) {</dt><dd><p>DocSearch.bindSearchBoxEvent();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>static injectSearchBox(input) {</dt><dd><p>input.before(templates.searchBox);
const newInput = input</p>
<blockquote>
<div><p>.prev()
.prev()
.find(“input”);</p>
</div></blockquote>
<p>input.remove();
return newInput;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>static bindSearchBoxEvent() {</dt><dd><dl class="simple">
<dt>$(‘.searchbox [type=”reset”]’).on(“click”, function () {</dt><dd><p>$(“input#docsearch”).focus();
$(this).addClass(“hide”);
autocomplete.autocomplete.setVal(“”);</p>
</dd>
</dl>
<p>});</p>
<dl>
<dt>$(“input#docsearch”).on(“keyup”, () =&gt; {</dt><dd><p>const searchbox = document.querySelector(“input#docsearch”);
const reset = document.querySelector(‘.searchbox [type=”reset”]’);
reset.className = “searchbox__reset”;
if (searchbox.value.length === 0) {</p>
<blockquote>
<div><p>reset.className += “ hide”;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>});</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the matching input from a CSS selector, null if none matches</p></li>
<li><p>&#64;function getInputFromSelector</p></li>
<li><p>&#64;param  {string} selector CSS selector that matches the search</p></li>
<li><p>input of the page</p></li>
<li><p>&#64;returns {void}</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>static getInputFromSelector(selector) {</dt><dd><p>const input = $(selector).filter(“input”);
return input.length ? $(input[0]) : null;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the <cite>source</cite> method to be passed to autocomplete.js. It will query</p></li>
<li><p>the Algolia index and call the callbacks with the formatted hits.</p></li>
<li><p>&#64;function getAutocompleteSource</p></li>
<li><p>&#64;param  {function} transformData An optional function to transform the hits</p></li>
<li><p>&#64;param {function} queryHook An optional function to transform the query</p></li>
<li><p>&#64;returns {function} Method to be passed as the <cite>source</cite> option of</p></li>
<li><p>autocomplete</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>getAutocompleteSource(transformData, queryHook) {</dt><dd><dl>
<dt>return (query, callback) =&gt; {</dt><dd><dl class="simple">
<dt>if (queryHook) {</dt><dd><p>// eslint-disable-next-line no-param-reassign
query = queryHook(query) || query;</p>
</dd>
</dl>
<p>}
this.client.search(query).then(hits =&gt; {</p>
<blockquote>
<div><dl class="simple">
<dt>if (</dt><dd><p>this.queryDataCallback &amp;&amp;
typeof this.queryDataCallback == “function”</p>
</dd>
<dt>) {</dt><dd><p>this.queryDataCallback(hits);</p>
</dd>
</dl>
<p>}
if (transformData) {</p>
<blockquote>
<div><p>hits = transformData(hits) || hits;</p>
</div></blockquote>
<p>}
callback(DocSearch.formatHits(hits));</p>
</div></blockquote>
<p>});</p>
</dd>
</dl>
<p>};</p>
</dd>
</dl>
<p>}</p>
<p>// Given a list of hits returned by the API, will reformat them to be used in
// a Hogan template
static formatHits(receivedHits) {</p>
<blockquote>
<div><p>const clonedHits = utils.deepClone(receivedHits);
const hits = clonedHits.map(hit =&gt; {</p>
<blockquote>
<div><dl>
<dt>if (hit._highlightResult) {</dt><dd><p>// eslint-disable-next-line no-param-reassign
hit._highlightResult = utils.mergeKeyWithParent(</p>
<blockquote>
<div><p>hit._highlightResult,
“hierarchy”</p>
</div></blockquote>
<p>);</p>
</dd>
</dl>
<p>}
return utils.mergeKeyWithParent(hit, “hierarchy”);</p>
</div></blockquote>
<p>});</p>
<p>// Group hits by category / subcategory
let groupedHits = utils.groupBy(hits, “lvl0”);
$.each(groupedHits, (level, collection) =&gt; {</p>
<blockquote>
<div><p>const groupedHitsByLvl1 = utils.groupBy(collection, “lvl1”);
const flattenedHits = utils.flattenAndFlagFirst(</p>
<blockquote>
<div><p>groupedHitsByLvl1,
“isSubCategoryHeader”</p>
</div></blockquote>
<p>);
groupedHits[level] = flattenedHits;</p>
</div></blockquote>
<p>});
groupedHits = utils.flattenAndFlagFirst(groupedHits, “isCategoryHeader”);</p>
<p>// Translate hits into smaller objects to be send to the template
return groupedHits.map(hit =&gt; {</p>
<blockquote>
<div><p>const url = DocSearch.formatURL(hit);
const category = utils.getHighlightedValue(hit, “lvl0”);
const subcategory = utils.getHighlightedValue(hit, “lvl1”) || category;
const displayTitle = utils</p>
<blockquote>
<div><dl class="simple">
<dt>.compact([</dt><dd><p>utils.getHighlightedValue(hit, “lvl2”) || subcategory,
utils.getHighlightedValue(hit, “lvl3”),
utils.getHighlightedValue(hit, “lvl4”),
utils.getHighlightedValue(hit, “lvl5”),
utils.getHighlightedValue(hit, “lvl6”)</p>
</dd>
</dl>
<p>])
.join(</p>
<blockquote>
<div><p>‘&lt;span class=”aa-suggestion-title-separator” aria-hidden=”true”&gt; › &lt;/span&gt;’</p>
</div></blockquote>
<p>);</p>
</div></blockquote>
<p>const text = utils.getSnippetedValue(hit, “content”);
const isTextOrSubcategoryNonEmpty =</p>
<blockquote>
<div><p>(subcategory &amp;&amp; subcategory !== “”) ||
(displayTitle &amp;&amp; displayTitle !== “”);</p>
</div></blockquote>
<dl class="simple">
<dt>const isLvl1EmptyOrDuplicate =</dt><dd><p>!subcategory || subcategory === “” || subcategory === category;</p>
</dd>
<dt>const isLvl2 =</dt><dd><p>displayTitle &amp;&amp; displayTitle !== “” &amp;&amp; displayTitle !== subcategory;</p>
</dd>
<dt>const isLvl1 =</dt><dd><p>!isLvl2 &amp;&amp;
(subcategory &amp;&amp; subcategory !== “” &amp;&amp; subcategory !== category);</p>
</dd>
</dl>
<p>const isLvl0 = !isLvl1 &amp;&amp; !isLvl2;</p>
<dl class="simple">
<dt>return {</dt><dd><p>isLvl0,
isLvl1,
isLvl2,
isLvl1EmptyOrDuplicate,
isCategoryHeader: hit.isCategoryHeader,
isSubCategoryHeader: hit.isSubCategoryHeader,
isTextOrSubcategoryNonEmpty,
category,
subcategory,
title: displayTitle,
text,
url</p>
</dd>
</dl>
<p>};</p>
</div></blockquote>
<p>});</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>static formatURL(hit) {</dt><dd><p>const { url, anchor } = hit;
if (url) {</p>
<blockquote>
<div><p>const containsAnchor = url.indexOf(“#”) !== -1;
if (containsAnchor) return url;
else if (anchor) return <cite>${hit.url}#${hit.anchor}</cite>;
return url;</p>
</div></blockquote>
<p>} else if (anchor) return <cite>#${hit.anchor}</cite>;
/* eslint-disable <em>/
console.warn(“no anchor nor url for : “, JSON.stringify(hit));
/</em> eslint-enable <a href="#id7"><span class="problematic" id="id8">*</span></a>/
return null;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>static getEmptyTemplate() {</dt><dd><p>return args =&gt; Hogan.compile(templates.empty).render(args);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>static getSuggestionTemplate(isSimpleLayout) {</dt><dd><dl class="simple">
<dt>const stringTemplate = isSimpleLayout</dt><dd><p>? templates.suggestionSimple
: templates.suggestion;</p>
</dd>
</dl>
<p>const template = Hogan.compile(stringTemplate);
return suggestion =&gt; template.render(suggestion);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>handleSelected(input, event, suggestion, datasetNumber, context = {}) {</dt><dd><p>// Do nothing if click on the suggestion, as it’s already a &lt;a href&gt;, the
// browser will take care of it. This allow Ctrl-Clicking on results and not
// having the main window being redirected as well
if (context.selectionMethod === “click”) {</p>
<blockquote>
<div><p>return;</p>
</div></blockquote>
<p>}</p>
<p>input.setVal(“”);
window.location.assign(suggestion.url);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>handleShown(input) {</dt><dd><p>const middleOfInput = input.offset().left + input.width() / 2;
let middleOfWindow = $(document).width() / 2;</p>
<dl class="simple">
<dt>if (isNaN(middleOfWindow)) {</dt><dd><p>middleOfWindow = 900;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>const alignClass =</dt><dd><dl class="simple">
<dt>middleOfInput - middleOfWindow &gt;= 0</dt><dd><p>? “algolia-autocomplete-right”
: “algolia-autocomplete-left”;</p>
</dd>
</dl>
</dd>
<dt>const otherAlignClass =</dt><dd><dl class="simple">
<dt>middleOfInput - middleOfWindow &lt; 0</dt><dd><p>? “algolia-autocomplete-right”
: “algolia-autocomplete-left”;</p>
</dd>
</dl>
</dd>
</dl>
<p>const autocompleteWrapper = $(“.algolia-autocomplete”);
if (!autocompleteWrapper.hasClass(alignClass)) {</p>
<blockquote>
<div><p>autocompleteWrapper.addClass(alignClass);</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if (autocompleteWrapper.hasClass(otherAlignClass)) {</dt><dd><p>autocompleteWrapper.removeClass(otherAlignClass);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>export default DocSearch;</p>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../_sources/src/theme/SearchBar/lib/DocSearch.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>