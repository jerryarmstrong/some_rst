<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>docs/src/implemented-proposals/abi-management.md &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="docs-src-implemented-proposals-abi-management-md">
<h1>docs/src/implemented-proposals/abi-management.md<a class="headerlink" href="#docs-src-implemented-proposals-abi-management-md" title="Permalink to this heading">¶</a></h1>
<p>Last edited: 2023-08-11 21:38:33</p>
<p>Contents:</p>
<div class="highlight-md notranslate"><div class="highlight"><pre><span></span>---
</pre></div>
</div>
<p>title: Solana ABI management process
—</p>
<p>This document proposes the Solana ABI management process. The ABI management
process is an engineering practice and a supporting technical framework to avoid
introducing unintended incompatible ABI changes.</p>
<p># Problem</p>
<p>The Solana ABI (binary interface to the cluster) is currently only defined
implicitly by the implementation and requires a very careful eye to notice
breaking changes. This makes it extremely difficult to upgrade the software
on an existing cluster without rebooting the ledger.</p>
<p># Requirements and objectives</p>
<ul class="simple">
<li><p>Unintended ABI changes can be detected as CI failures mechanically.</p></li>
<li><p>Newer implementation must be able to process the oldest data (since genesis)
once we go mainnet.</p></li>
<li><p>The objective of this proposal is to protect the ABI while sustaining rather
rapid development by opting for a mechanical process rather than a very long
human-driven auditing process.</p></li>
<li><p>Once signed cryptographically, data blob must be identical, so no
in-place data format update is possible regardless of inbound and outbound of
the online system. Also, considering the sheer volume of transactions we’re
aiming to handle, retrospective in-place update is undesirable at best.</p></li>
</ul>
<p># Solution</p>
<p>Instead of natural human’s eye due-diligence, which should be assumed to fail
regularly, we need a systematic assurance of not breaking the cluster when
changing the source code.</p>
<p>For that purpose, we introduce a mechanism of marking every ABI-related things
in source code (<cite>struct`s, `enum`s) with the new `#[frozen_abi]</cite> attribute. This
takes hard-coded digest value derived from types of its fields via
<cite>ser::Serialize</cite>. And the attribute automatically generates a unit test to try
to detect any unsanctioned changes to the marked ABI-related things.</p>
<p>However, the detection cannot be complete; no matter how hard we statically
analyze the source code, it’s still possible to break ABI. For example, this
includes not-<cite>derive`d hand-written `ser::Serialize</cite>, underlying library’s
implementation changes (for example <cite>bincode</cite>), CPU architecture differences.
The detection of these possible ABI incompatibilities is out-of-scope for this
ABI management.</p>
<p># Definitions</p>
<p>ABI item/type: various types to be used for serialization, which collectively
comprises the whole ABI for any system components. For example, those types
include <a href="#id1"><span class="problematic" id="id2">`</span></a>struct`s and <a href="#id3"><span class="problematic" id="id4">`</span></a>enum`s.</p>
<p>ABI item digest: Some fixed hash derived from type information of ABI item’s
fields.</p>
<p># Example</p>
<p><a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a>patch
+#[frozen_abi(digest=”eXSMM7b89VY72V…”)]</p>
<blockquote>
<div><p>#[derive(Serialize, Default, Deserialize, Debug, PartialEq, Eq, Clone)]
pub struct Vote {</p>
<blockquote>
<div><p>/// A stack of votes starting with the oldest vote
pub slots: Vec&lt;Slot&gt;,
/// signature of the bank’s state at the last slot
pub hash: Hash,</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p><a href="#id9"><span class="problematic" id="id10">``</span></a><a href="#id11"><span class="problematic" id="id12">`</span></a></p>
<p># Developer’s workflow</p>
<p>To know the digest for new ABI items, developers can add <cite>frozen_abi</cite> with a
random digest value and run the unit tests and replace it with the correct
digest from the assertion test error message.</p>
<p>Run unit tests using the following command to generate digest values:
<code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">SOLANA_ABI_DUMP_DIR=.</span> <span class="pre">cargo</span> <span class="pre">+nightly</span> <span class="pre">test</span> <span class="pre">abi</span>
<span class="pre">`</span></code></p>
<p>In general, once we add <cite>frozen_abi</cite> and its change is published in the stable
release channel, its digest should never change. If such a change is needed, we
should opt for defining a new <cite>struct</cite> like <cite>FooV1</cite>. And special release flow
like hard forks should be approached.</p>
<p># Implementation remarks</p>
<p>We use some degree of macro machinery to automatically generate unit tests
and calculate a digest from ABI items. This is doable by clever use of
<cite>serde::Serialize</cite> (<cite>[1]</cite>) and <cite>any::type_name</cite> (<cite>[2]</cite>). For a precedent for similar
implementation, <cite>ink</cite> from the Parity Technologies <cite>[3]</cite> could be informational.</p>
<p># Implementation details</p>
<p>The implementation’s goal is to detect unintended ABI changes automatically as
much as possible. To that end, the digest of structural ABI information is
calculated with best-effort accuracy and stability.</p>
<p>When the ABI digest check is run, it dynamically computes an ABI digest by
recursively digesting the ABI of fields of the ABI item, by re-using the
<cite>serde</cite>’s serialization functionality, proc macro and generic specialization.
And then, the check <cite>assert!`s that its finalized digest value is identical as
what is specified in the `frozen_abi</cite> attribute.</p>
<p>To realize that, it creates an example instance of the type and a custom
<cite>Serializer</cite> instance for <cite>serde</cite> to recursively traverse its fields as if
serializing the example for real. This traversing must be done via <cite>serde</cite> to
really capture what kinds of data actually would be serialized by <cite>serde</cite>, even
considering custom non-<cite>derive`d `Serialize</cite> trait implementations.</p>
<p># The ABI digesting process</p>
<p>This part is a bit complex. There is three inter-depending parts: <cite>AbiExample</cite>,
<cite>AbiDigester</cite> and <cite>AbiEnumVisitor</cite>.</p>
<p>First, the generated test creates an example instance of the digested type with
a trait called <cite>AbiExample</cite>, which should be implemented for all of digested
types like the <cite>Serialize</cite> and return <cite>Self</cite> like the <cite>Default</cite> trait. Usually,
it’s provided via generic trait specialization for most of common types. Also
it is possible to <cite>derive</cite> for <cite>struct</cite> and <cite>enum</cite> and can be hand-written if
needed.</p>
<p>The custom <cite>Serializer</cite> is called <cite>AbiDigester</cite>. And when it’s called by <cite>serde</cite>
to serialize some data, it recursively collects ABI information as much as
possible. <cite>AbiDigester</cite>’s internal state for the ABI digest is updated
differentially depending on the type of data. This logic is specifically
redirected via with a trait called <cite>AbiEnumVisitor</cite> for each <cite>enum</cite> type. As the
name suggests, there is no need to implement <cite>AbiEnumVisitor</cite> for other types.</p>
<p>To summarize this interplay, <cite>serde</cite> handles the recursive serialization control
flow in tandem with <cite>AbiDigester</cite>. The initial entry point in tests and child
<cite>AbiDigester`s use `AbiExample</cite> recursively to create an example object
hierarchal graph. And <cite>AbiDigester</cite> uses <cite>AbiEnumVisitor</cite> to inquiry the actual
ABI information using the constructed sample.</p>
<p><cite>Default</cite> isn’t enough for <cite>AbiExample</cite>. Various collection’s <cite>::default()</cite> is
empty, yet, we want to digest them with actual items. And, ABI digesting can’t
be realized only with <cite>AbiEnumVisitor</cite>. <cite>AbiExample</cite> is required because an
actual instance of type is needed to actually traverse the data via <cite>serde</cite>.</p>
<p>On the other hand, ABI digesting can’t be done only with <cite>AbiExample</cite>, either.
<cite>AbiEnumVisitor</cite> is required because all variants of an <cite>enum</cite> cannot be
traversed just with a single variant of it as a ABI example.</p>
<p>Digestable information:</p>
<ul class="simple">
<li><p>rust’s type name</p></li>
<li><p><cite>serde</cite>’s data type name</p></li>
<li><p>all fields in <cite>struct</cite></p></li>
<li><p>all variants in <cite>enum</cite></p></li>
<li><p><cite>struct</cite>: normal(<cite>struct {…}</cite>) and tuple-style (<cite>struct(…)</cite>)</p></li>
<li><p><cite>enum</cite>: normal variants and <cite>struct</cite>- and <cite>tuple</cite>- styles.</p></li>
<li><p>attributes: <cite>serde(serialize_with=…)</cite> and <cite>serde(skip)</cite></p></li>
</ul>
<p>Not digestable information:</p>
<ul class="simple">
<li><p>Any custom serialize code path not touched by the sample provided by
<cite>AbiExample</cite>. (technically not possible)</p></li>
<li><p>generics (must be a concrete type; use <cite>frozen_abi</cite> on concrete type
aliases)</p></li>
</ul>
<p># References</p>
<ol class="arabic simple">
<li><p>[(De)Serialization with type info · Issue #1095 · serde-rs/serde](<a class="reference external" href="https://github.com/serde-rs/serde/issues/1095#issuecomment-345483479">https://github.com/serde-rs/serde/issues/1095#issuecomment-345483479</a>)</p></li>
<li><p>[<cite>std::any::type_name</cite> - Rust](<a class="reference external" href="https://doc.rust-lang.org/std/any/fn.type_name.html">https://doc.rust-lang.org/std/any/fn.type_name.html</a>)</p></li>
<li><p>[Parity’s ink to write smart contracts](<a class="reference external" href="https://github.com/paritytech/ink">https://github.com/paritytech/ink</a>)</p></li>
</ol>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../_sources/src/implemented-proposals/abi-management.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>