<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>docs/src/implemented-proposals/validator-timestamp-oracle.md &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="docs-src-implemented-proposals-validator-timestamp-oracle-md">
<h1>docs/src/implemented-proposals/validator-timestamp-oracle.md<a class="headerlink" href="#docs-src-implemented-proposals-validator-timestamp-oracle-md" title="Permalink to this heading">¶</a></h1>
<p>Last edited: 2023-08-11 21:38:33</p>
<p>Contents:</p>
<div class="highlight-md notranslate"><div class="highlight"><pre><span></span>---
</pre></div>
</div>
<p>title: Validator Timestamp Oracle
—</p>
<p>Third-party users of Solana sometimes need to know the real-world time a block
was produced, generally to meet compliance requirements for external auditors or
law enforcement. This proposal describes a validator timestamp oracle that
would allow a Solana cluster to satisfy this need.</p>
<p>The general outline of the proposed implementation is as follows:</p>
<ul class="simple">
<li><p>At regular intervals, each validator records its observed time for a known slot
on-chain (via a Timestamp added to a slot Vote)</p></li>
<li><p>A client can request a block time for a rooted block using the <cite>getBlockTime</cite>
RPC method. When a client requests a timestamp for block N:</p>
<ol class="arabic simple">
<li><p>A validator determines a “cluster” timestamp for a recent timestamped slot
before block N by observing all the timestamped Vote instructions recorded on
the ledger that reference that slot, and determining the stake-weighted mean
timestamp.</p></li>
<li><p>This recent mean timestamp is then used to calculate the timestamp of
block N using the cluster’s established slot duration</p></li>
</ol>
</li>
</ul>
<p>Requirements:</p>
<ul class="simple">
<li><p>Any validator replaying the ledger in the future must come up with the same
time for every block since genesis</p></li>
<li><p>Estimated block times should not drift more than an hour or so before resolving
to real-world (oracle) data</p></li>
<li><p>The block times are not controlled by a single centralized oracle, but
ideally based on a function that uses inputs from all validators</p></li>
<li><p>Each validator must maintain a timestamp oracle</p></li>
</ul>
<p>The same implementation can provide a timestamp estimate for a not-yet-rooted
block. However, because the most recent timestamped slot may or may not be
rooted yet, this timestamp would be unstable (potentially failing requirement
1). Initial implementation will target rooted blocks, but if there is a use case
for recent-block timestamping, it will be trivial to add the RPC apis in the
future.</p>
<p>## Recording Time</p>
<p>At regular intervals as it is voting on a particular slot, each validator
records its observed time by including a timestamp in its Vote instruction
submission. The corresponding slot for the timestamp is the newest Slot in the
Vote vector (<cite>Vote::slots.iter().max()</cite>). It is signed by the validator’s
identity keypair as a usual Vote. In order to enable this reporting, the Vote
struct needs to be extended to include a timestamp field, <cite>timestamp: Option&lt;UnixTimestamp&gt;</cite>, which will be set to <cite>None</cite> in most Votes.</p>
<p>As of <a class="reference external" href="https://github.com/solana-labs/solana/pull/10630">https://github.com/solana-labs/solana/pull/10630</a>, validators submit a
timestamp every vote. This enables implementation of a block time caching
service that allows nodes to calculate the estimated timestamp immediately after
the block is rooted, and cache that value in Blockstore. This provides
persistent data and quick queries, while still meeting requirement 1) above.</p>
<p>### Vote Accounts</p>
<p>A validator’s vote account will hold its most recent slot-timestamp in VoteState.</p>
<p>### Vote Program</p>
<p>The on-chain Vote program needs to be extended to process a timestamp sent with
a Vote instruction from validators. In addition to its current process_vote
functionality (including loading the correct Vote account and verifying that the
transaction signer is the expected validator), this process needs to compare the
timestamp and corresponding slot to the currently stored values to verify that
they are both monotonically increasing, and store the new slot and timestamp in
the account.</p>
<p>## Calculating Stake-Weighted Mean Timestamp</p>
<p>In order to calculate the estimated timestamp for a particular block, a
validator first needs to identify the most recently timestamped slot:</p>
<p><code class="docutils literal notranslate"><span class="pre">`text</span>
<span class="pre">let</span> <span class="pre">timestamp_slot</span> <span class="pre">=</span> <span class="pre">floor(current_slot</span> <span class="pre">/</span> <span class="pre">timestamp_interval);</span>
<span class="pre">`</span></code></p>
<p>Then the validator needs to gather all Vote WithTimestamp transactions from the
ledger that reference that slot, using <cite>Blockstore::get_slot_entries()</cite>. As these
transactions could have taken some time to reach and be processed by the leader,
the validator needs to scan several completed blocks after the timestamp_slot to
get a reasonable set of Timestamps. The exact number of slots will need to be
tuned: More slots will enable greater cluster participation and more timestamp
datapoints; fewer slots will speed how long timestamp filtering takes.</p>
<p>From this collection of transactions, the validator calculates the
stake-weighted mean timestamp, cross-referencing the epoch stakes from
<cite>staking_utils::staked_nodes_at_epoch()</cite>.</p>
<p>Any validator replaying the ledger should derive the same stake-weighted mean
timestamp by processing the Timestamp transactions from the same number of
slots.</p>
<p>## Calculating Estimated Time for a Particular Block</p>
<p>Once the mean timestamp for a known slot is calculated, it is trivial to
calculate the estimated timestamp for subsequent block N:</p>
<p><code class="docutils literal notranslate"><span class="pre">`text</span>
<span class="pre">let</span> <span class="pre">block_n_timestamp</span> <span class="pre">=</span> <span class="pre">mean_timestamp</span> <span class="pre">+</span> <span class="pre">(block_n_slot_offset</span> <span class="pre">*</span> <span class="pre">slot_duration);</span>
<span class="pre">`</span></code></p>
<p>where <cite>block_n_slot_offset</cite> is the difference between the slot of block N and
the timestamp_slot, and <cite>slot_duration</cite> is derived from the cluster’s
<cite>slots_per_year</cite> stored in each Bank</p>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../_sources/src/implemented-proposals/validator-timestamp-oracle.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>