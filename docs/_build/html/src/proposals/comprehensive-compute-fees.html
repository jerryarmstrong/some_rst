<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>docs/src/proposals/comprehensive-compute-fees.md &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="docs-src-proposals-comprehensive-compute-fees-md">
<h1>docs/src/proposals/comprehensive-compute-fees.md<a class="headerlink" href="#docs-src-proposals-comprehensive-compute-fees-md" title="Permalink to this heading">¶</a></h1>
<p>Last edited: 2023-08-11 21:38:33</p>
<p>Contents:</p>
<div class="highlight-md notranslate"><div class="highlight"><pre><span></span>---
</pre></div>
</div>
<p>title: Comprehensive Compute Fees
—</p>
<p>## Motivation</p>
<p>The current fee structure lacks a comprehensive account of the work required by
a validator to process a transaction.  The fee structure is only based on the
number of signatures in a transaction but is meant to account for the work that
the validator must perform to validate each transaction.  The validator performs
a lot more user-defined work than just signature verification.  Processing a
transaction typically includes signature verifications, account locking, account
loading, and instruction processing.</p>
<p>## Proposed Solution</p>
<p>The following solution does not specify what native token costs are to be
associated with the new fee structure.  Instead, it sets the criteria and
provides the knobs that a cost model can use to determine those costs.</p>
<p>### Fee</p>
<p>The goal of the fees is to cover the computation cost of processing a
transaction.  Each of the fee categories below will be represented as a compute
unit cost that, when added together, encompasses the entire cost of processing
the transaction.  By calculating the total cost of the transaction, the runtime
can charge a more representative fee and make better transaction scheduling
decisions.</p>
<p>A fee could be calculated based on:</p>
<ol class="arabic">
<li><p>Number of signatures
- Fixed rate per signature</p></li>
<li><p>Number of write locks
- Fixed rate per writable account</p></li>
<li><p>Data byte cost
- Fixed rate per byte of the sum of the length all a transactions instruction</p>
<blockquote>
<div><p>datas</p>
</div></blockquote>
</li>
<li><p>Account sizes
- Account sizes can’t be known up-front but can account for a considerable</p>
<blockquote>
<div><p>amount of the load the transaction incurs on the network.  The payer will
be charged for a maximum account size (10m) upfront and refunded the
difference after the actual account sizes are known.</p>
</div></blockquote>
</li>
<li><p>Compute budget
- Each transaction will be given a default transaction-wide compute budget of</p>
<blockquote>
<div><p>200k units with the option of requesting a larger budget via a compute
budget instruction up to a maximum of 1m units.  This budget is used to
limit the time it takes to process a transaction.  The compute budget
portion of the fee will be charged up-front based on the default or
requested amount.  After processing, the actual number of units consumed
will be known, and the payer will be refunded the difference, so the payer
only pays for what they used.  Builtin programs will have a fixed cost
while SBF program’s cost will be measured at runtime.</p>
</div></blockquote>
</li>
<li><p>Precompiled programs
- Precompiled programs are performing compute-intensive operations.  The work</p>
<blockquote>
<div><p>incurred by a precompiled program is predictable based on the instruction’s
data array.  Therefore a cost will be assigned per precompiled program
based on the parsing of instruction data.  Because precompiled programs are
processed outside of the bank, their compute cost will not be reflected in
the compute budget and will not be used in transaction scheduling
decisions. The methods used to determine the fixed cost of the components
above are described in
[#19627](<a class="reference external" href="https://github.com/solana-labs/solana/issues/19627">https://github.com/solana-labs/solana/issues/19627</a>)</p>
</div></blockquote>
</li>
</ol>
<p>### Cost model</p>
<p>The cost model is used to assess what load a transaction will incur during
in-slot processing and then make decisions on how to best schedule transaction
into batches.</p>
<p>The cost model’s criteria are identical to the fee’s criteria except for
signatures and precompiled programs.  These two costs are incurred before a
transaction is scheduled and therefore do not affect how long a transaction
takes within a slot to process.</p>
<p>### Cache account sizes and use them instead of the max</p>
<p><a class="reference external" href="https://github.com/solana-labs/solana/issues/20511">https://github.com/solana-labs/solana/issues/20511</a></p>
<p>### Requestable compute budget caps and heap sizes</p>
<p>The precompiled
[ComputeBudget](<a class="reference external" href="https://github.com/solana-labs/solana/blob/00929f836348d76cb3503d0ba5f76f0d275bcc66/sdk/src/compute_budget.rs#L34">https://github.com/solana-labs/solana/blob/00929f836348d76cb3503d0ba5f76f0d275bcc66/sdk/src/compute_budget.rs#L34</a>)
program can be used to request higher transaction-wide compute budget caps and
program heap sizes.  The requested increases will be reflected in the
transaction’s fee.</p>
<p>### Fees for precompiled program failures</p>
<p><a class="reference external" href="https://github.com/solana-labs/solana/issues/20481">https://github.com/solana-labs/solana/issues/20481</a></p>
<p>### Rate governing</p>
<p>Current rate governing needs to be re-assessed.  Fees are being rate
governed down to their minimums because the number of signatures in each slot is
far lower than the “target” signatures per slot.</p>
<p>Instead of using the number of signatures to rate govern, the cost model will
feed back information based on the batch/queue load it is seeing.  The fees will
sit at a target rate and only increase if the load goes above a specified but to
be determined threshold.  The governing will be applied across all the fee
criteria.</p>
<p>### Deterministic fees</p>
<p>Solana’s fees are currently deterministic based on a given blockhash.  This
determinism is a nice feature that simplifies client interactions.  An example
is when draining an account that is also the payer, the transaction issuer can
pre-compute the fee and then set the entire remaining balance to be transferred
out without worrying that the fee will change leaving a very small amount
remaining in the account.  Another example is for offline signing, the payer
signer can guarantee what fee that will be charged for the transaction based on
the nonce’s blockhash.</p>
<p>Determinism is achieved in two ways:
- blockhash queue contains a list of recent (&lt;=~2min) blockhashes and a</p>
<blockquote>
<div><p><cite>lamports_per_signature</cite> value.  The blockhash queue is one of the snapshot’s
serialized members and thus bank hash depends on it.</p>
</div></blockquote>
<ul class="simple">
<li><p>Nonce accounts used for offline signing contain a <cite>lamports_per_signature</cite>
value in its account data</p></li>
</ul>
<p>In both cases, when a transaction is assessed a fee, the
<cite>lamports_per_signature</cite> to use is looked up (either in the queue or in the
nonce account’s data) using the transaction’s blockhash.</p>
<p>This currently comes with the following challenges:
- Exposing the <cite>FeeCalculator</cite> object to the clients (holds the</p>
<blockquote>
<div><p><cite>lamports_per_signature</cite>) makes it hard to evolve the fee criteria due to
backward-compatibility.  This issue is being solved by deprecating the
<cite>FeeCalculator</cite> object and instead the new apis take a message and return a
fee.</p>
</div></blockquote>
<ul class="simple">
<li><p>Blockhash queue entries contain the fee criteria specifics and are part of the
bankhash so evolving the fees over time involves more work/risk</p></li>
<li><p>Nonce accounts store the fee criteria directly in their account data so
evolving the fees over time requires changes to nonce account data and data
size.</p></li>
</ul>
<p>Two solutions to the latter two challenges
- Get rid of the concept of deterministic fees.  Clients ask via RPC to</p>
<blockquote>
<div><p>calculate the current fee estimate and the actual fee is assessed when the
transaction is processed.  Fee changes will be governed and change slowly
based on network load so the fee differences will be small within the 2min
window.  Nonce accounts no longer store the fee criteria but instead a fee
cap.  If the assessed fee at the time of processing exceeds the cap then the
transaction fails.  This solution removes fee criteria entirely from the
blockhash queue and nonce accounts and removes the need for either of those to
evolve if there is a need for fee criteria to evolve.</p>
</div></blockquote>
<ul class="simple">
<li><p>Retain the concept of deterministic fees.  Clients ask via RPC to calculate
the current fee and pass in a blockhash that fee will be associated with.
Blockhash queue and nonce accounts switch to a versioned but internal “Fee”
object (similar to “FeeCalculator”).  Each time there is a need for fees to
evolve the fee object will add a new version and new blockhash queue entries
and new nonce accounts will use the new version.</p></li>
</ul>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../_sources/src/proposals/comprehensive-compute-fees.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>