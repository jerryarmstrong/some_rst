<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>docs/src/proposals/optimistic_confirmation.md &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="docs-src-proposals-optimistic-confirmation-md">
<h1>docs/src/proposals/optimistic_confirmation.md<a class="headerlink" href="#docs-src-proposals-optimistic-confirmation-md" title="Permalink to this heading">¶</a></h1>
<p>Last edited: 2023-08-11 21:38:33</p>
<p>Contents:</p>
<div class="highlight-md notranslate"><div class="highlight"><pre><span></span>---
</pre></div>
</div>
<p>title: Optimistic Confirmation
—</p>
<p>## Primitives</p>
<p><cite>vote(X, S)</cite> - Votes will be augmented with a “reference” slot, <cite>X</cite>
which is the <strong>latest</strong> ancestor of this fork that this validator voted on
with a proof of switching. As long as the validator makes consecutive votes
that are all descended from each other, the same <cite>X</cite> should be used for all
those votes. When the validator makes a vote for a slot <cite>s</cite> that is not
descended from the previous, <cite>X</cite> will be set to the new slot <cite>s</cite>. All votes
will then be of the form <cite>vote(X, S)</cite>, where <cite>S</cite> is the sorted list of slots
<cite>(s, s.lockout)</cite> being voted for.</p>
<p>Given a vote <cite>vote(X, S)</cite>, let <cite>S.last == vote.last</cite> be the last slot in <cite>S</cite>.</p>
<p>Now we define some “Optimistic Slashing” slashing conditions. The intuition
for these is described below:</p>
<ul class="simple">
<li><p><cite>Intuition</cite>: If a validator submits <cite>vote(X, S)</cite>, the same validator
should not have voted on a different fork that “overlaps” this fork.
More concretely, this validator should not have cast another vote
<cite>vote(X’, S’)</cite> where the range <cite>[X, S.last]</cite> overlaps the range
<cite>[X’, S’.last]</cite>, <cite>X != X’</cite>, as shown below:</p></li>
</ul>
<dl>
<dt><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>text</dt><dd><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div></div></blockquote>
<p>+———+       +——–+
|         |       |        |
|         +——-+        |
|                          |
|                          |
|                          |</p>
</div></blockquote>
<p>+—+—+                      |
|       |                      |</p>
</div></blockquote>
<dl>
<dt>X   |       |                      |</dt><dd><blockquote>
<div><div class="line-block">
<div class="line">|                      |</div>
</div>
<dl>
<dt>+—+—+                      |</dt><dd><div class="line-block">
<div class="line-block">
<div class="line"><a href="#id5"><span class="problematic" id="id6">|</span></a></div>
</div>
<div class="line">+—+—+</div>
<div class="line">|       |</div>
<div class="line">|       |  X’</div>
<div class="line">|       |</div>
<div class="line">+—+—+</div>
<div class="line-block">
<div class="line"><a href="#id7"><span class="problematic" id="id8">|</span></a></div>
<div class="line"><a href="#id9"><span class="problematic" id="id10">|</span></a></div>
<div class="line"><a href="#id11"><span class="problematic" id="id12">|</span></a></div>
<div class="line"><a href="#id13"><span class="problematic" id="id14">|</span></a></div>
</div>
<div class="line">+—+—+</div>
<div class="line">|       |</div>
<div class="line">|       |  S’.last</div>
<div class="line">|       |</div>
<div class="line">+——-+</div>
<div class="line"><br /></div>
</div>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>s  |       |</dt><dd><div class="line-block">
<div class="line"><a href="#id15"><span class="problematic" id="id16">|</span></a></div>
</div>
<table class="docutils align-default">
<tbody>
</tbody>
</table>
<blockquote>
<div><div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>S.last |       |</dt><dd><div class="line-block">
<div class="line"><a href="#id17"><span class="problematic" id="id18">|</span></a></div>
</div>
<table class="docutils align-default">
<tbody>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
<p><a href="#id19"><span class="problematic" id="id20">``</span></a><a href="#id21"><span class="problematic" id="id22">`</span></a></p>
<p>(Example of slashable votes vote(X’, S’) and vote(X, S))</p>
<p>In the diagram above, note that the vote for <cite>S.last</cite> must have been sent after
the vote for <cite>S’.last</cite> (due to lockouts, the higher vote must have been sent
later). Thus, the sequence of votes must have been: <cite>X … S’.last … S.last</cite>.
This means after the vote on <cite>S’.last</cite>, the validator must have switched back
to the other fork at some slot <cite>s &gt; S’.last &gt; X</cite>. Thus, the vote for <cite>S.last</cite>
should have used <cite>s</cite> as the “reference” point, not <cite>X</cite>, because that was the
last “switch” on the fork.</p>
<p>To enforce this, we define the “Optimistic Slashing” slashing conditions. Given
any two distinct votes <cite>vote(X, S)`and `vote(X’, S’)</cite> by the same validator,
the votes must satisfy:</p>
<ul class="simple">
<li><p><cite>X &lt;= S.last</cite>, <cite>X’ &lt;= S’.last</cite></p></li>
<li><p>All <cite>s</cite> in <cite>S</cite> are ancestors/descendants of one another,
all <cite>s’</cite> in <cite>S’</cite> are ancsestors/descendants of one another,</p></li>
<li></li>
<li><p><cite>X == X’</cite> implies <cite>S</cite> is parent of <cite>S’</cite> or <cite>S’</cite> is a parent of <cite>S</cite></p></li>
<li><p><cite>X’ &gt; X</cite> implies <cite>X’ &gt; S.last</cite> and <cite>S’.last &gt; S.last</cite>
and for all <cite>s</cite> in <cite>S</cite>, <cite>s + lockout(s) &lt; X’</cite></p></li>
<li><p><cite>X &gt; X’</cite> implies <cite>X &gt; S’.last</cite> and <cite>S.last &gt; S’.last</cite>
and for all <cite>s</cite> in <cite>S’</cite>, <cite>s + lockout(s) &lt; X</cite></p></li>
</ul>
<p>(The last two rules imply the ranges cannot overlap):
Otherwise the validator is slashed.</p>
<p><cite>Range(vote)</cite> - Given a vote <cite>v = vote(X, S)</cite>, define <cite>Range(v)</cite> to be the range
of slots <cite>[X, S.last]</cite>.</p>
<p><cite>SP(old_vote, new_vote)</cite> - This is the “Switching Proof” for <cite>old_vote</cite>, the
validator’s latest vote. Such a proof is necessary anytime a validator switches
their “reference” slot (see vote section above). The switching proof includes
a reference to <cite>old_vote</cite>, so that there’s a record of what the “range” of that
<cite>old_vote</cite> was (to make other conflicting switches in this range slashable).
Such a switch must still respect lockouts.</p>
<p>A switching proof shows that <cite>&gt; 1/3</cite> of the network is locked out at slot
<cite>old_vote.last</cite>.</p>
<p>The proof is a list of elements <cite>(validator_id, validator_vote(X, S))</cite>, where:</p>
<ol class="arabic simple">
<li><p>The sum of the stakes of all the validator id’s <cite>&gt; 1/3</cite></p></li>
<li><p>For each <cite>(validator_id, validator_vote(X, S))</cite>, there exists some slot <cite>s</cite>
in <cite>S</cite> where:
_ a.`s` is not a common ancestor of both <cite>validator_vote.last</cite> and
<cite>old_vote.last</cite> and <cite>new_vote.last</cite>.
_ b. <cite>s</cite> is not a descendant of <cite>validator_vote.last</cite>. * c. <cite>s + s.lockout() &gt;= old_vote.last</cite> (implies validator is still locked
out on slot <cite>s</cite> at slot <cite>old_vote.last</cite>).</p></li>
</ol>
<p>Switching forks without a valid switching proof is slashable.</p>
<p>## Definitions:</p>
<p>Optimistic Confirmation - A block <cite>B</cite> is then said to have achieved
“optimistic confirmation” if <cite>&gt;2/3</cite> of stake have voted with votes <cite>v</cite>
where <cite>Range(v)</cite> for each such <cite>v</cite> includes <cite>B.slot</cite>.</p>
<p>Finalized - A block <cite>B</cite> is said to be finalized if at least one
correct validator has rooted <cite>B</cite> or a descendant of <cite>B</cite>.</p>
<p>Reverted - A block <cite>B</cite> is said to be reverted if another block <cite>B’</cite> that
is not a parent or descendant of <cite>B</cite> was finalized.</p>
<p>## Guarantees:</p>
<p>A block <cite>B</cite> that has reached optimistic confirmation will not be reverted
unless at least one validator is slashed.</p>
<p>## Proof:</p>
<p>Assume for the sake of contradiction, a block <cite>B</cite> has achieved
<cite>optimistic confirmation</cite> at some slot <cite>B + n</cite> for some <cite>n</cite>, and:</p>
<ul class="simple">
<li><p>Another block <cite>B’</cite> that is not a parent or descendant of <cite>B</cite>
was finalized.</p></li>
<li><p>No validators violated any slashing conditions.</p></li>
</ul>
<p>By the definition of <cite>optimistic confirmation</cite>, this means <cite>&gt; 2/3</cite> of validators
have each shown some vote <cite>v</cite> of the form <cite>Vote(X, S)</cite> where <cite>X &lt;= B &lt;= v.last</cite>.
Call this set of validators the <cite>Optimistic Validators</cite>.</p>
<p>Now given a validator <cite>v</cite> in <cite>Optimistic Validators</cite>, given two votes made by
<cite>v</cite>, <cite>Vote(X, S)</cite> and <cite>Vote(X’, S’)</cite> where <cite>X &lt;= B &lt;= S.last</cite>, and
<cite>X’ &lt;= B &lt;= S’.last</cite>, then <cite>X == X’</cite> otherwise an “Optimistic Slashing” condition
is violated (the “ranges” of each vote would overlap at <cite>B</cite>).</p>
<p>Thus define the <cite>Optimistic Votes</cite> to be the set of votes made by
<cite>Optimistic Validators</cite>, where for each optimistic validator <cite>v</cite>, the vote made
by <cite>v</cite> included in the set is the <cite>maximal</cite> vote <cite>Vote(X, S)</cite> with the
greatest <cite>S.last</cite> out of any votes made by <cite>v</cite> that satisfy <cite>X &lt;= B &lt;= S.last</cite>.
Because we know from above <cite>X</cite> for all such votes made by <cite>v</cite> is unique, we know
there is such a unique <cite>maximal</cite> vote.</p>
<p>### Lemma 1:</p>
<p><cite>Claim:</cite> Given a vote <cite>Vote(X, S)</cite> made by a validator <cite>V</cite> in the
<cite>Optimistic Validators</cite> set, and <cite>S</cite> contains a vote for a slot <cite>s</cite>
for which:</p>
<ul class="simple">
<li><p><cite>s + s.lockout &gt; B</cite>,</p></li>
<li><p><cite>s</cite> is not an ancestor or descendant of <cite>B</cite>,</p></li>
</ul>
<p>then <cite>X &gt; B</cite>.</p>
<dl>
<dt><a href="#id23"><span class="problematic" id="id24">``</span></a><a href="#id25"><span class="problematic" id="id26">`</span></a>text</dt><dd><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div><blockquote>
<div></div></blockquote>
<p>+———+       +——–+
|         |       |        |
|         +——-+        |
|                          |
|                          |
|                          |
|                      +—+—+
|                      |       |
|                      |       |  X’
|                      |       |
|                      +—+—+
|                          |
|                          |
|                      +—+—+
|                      |       |
|                      |       |  B (Optimistically Confirmed)
|                      |       |
|                      +—+—+
|                          |
|                          |
|                          |
|                      +—+—+
|                      |       |
|                      |       |  S’.last
|                      |       |
|                      +——-+
|</p>
</div></blockquote>
</div></blockquote>
<dl>
<dt>X  |       |</dt><dd><div class="line-block">
<div class="line"><a href="#id27"><span class="problematic" id="id28">|</span></a></div>
</div>
<table class="docutils align-default">
<tbody>
</tbody>
</table>
<blockquote>
<div><div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>S.last  |       |</dt><dd><div class="line-block">
<div class="line"><a href="#id29"><span class="problematic" id="id30">|</span></a></div>
</div>
<table class="docutils align-default">
<tbody>
</tbody>
</table>
<blockquote>
<div><div class="line-block">
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
<div class="line"><br /></div>
</div>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>s + s.lockout |       |</dt><dd><table class="docutils align-default">
<tbody>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
<p><a href="#id31"><span class="problematic" id="id32">``</span></a><a href="#id33"><span class="problematic" id="id34">`</span></a></p>
<p><cite>Proof</cite>: Assume for the sake of contradiction a validator <cite>V</cite> from the
“Optimistic Validators” set made such a vote <cite>Vote(X, S)</cite> where <cite>S</cite> contains
a vote for a slot <cite>s</cite> not an ancestor or descendant of <cite>B</cite>, where
<cite>s + s.lockout &gt; B</cite>, but <cite>X &lt;= B</cite>.</p>
<p>Let <cite>Vote(X’, S’)</cite> be the vote in <cite>Optimistic Votes</cite> set made by validator <cite>V</cite>.
By definition of that set (all votes optimistically confirmed <cite>B</cite>),
<cite>X’ &lt;= B &lt;= S’.last</cite> (see diagram above).</p>
<p>This implies that because it’s assumed above <cite>X &lt;= B</cite>, then <cite>X &lt;= S’.last</cite>,
so by the slashing rules, either <cite>X == X’</cite> or <cite>X &lt; X’</cite> (otherwise would
overlap the range <cite>(X’, S’.last)</cite>).</p>
<p><cite>Case X == X’</cite>:</p>
<p>Consider <cite>s</cite>. We know <cite>s != X</cite> because it is assumed <cite>s</cite> is not an ancestor
or descendant of <cite>B</cite>, and <cite>X</cite> is an ancestor of <cite>B</cite>. Because <cite>S’.last</cite> is a
descendant of <cite>B</cite>, this means <cite>s</cite> is also not an ancestor or descendant of
<cite>S’.last</cite>. Then because <cite>S.last</cite> is descended from <cite>s</cite>, then <cite>S’.last</cite> cannot
be an ancestor or descendant of <cite>S.last</cite> either. This implies <cite>X != X’</cite> by the
“Optimistic Slashing” rules.</p>
<p><cite>Case X &lt; X’</cite>:</p>
<p>Intuitively, this implies that <cite>Vote(X, S)</cite> was made “before” <cite>Vote(X’, S’)</cite>.</p>
<p>From the assumption above, <cite>s + s.lockout &gt; B &gt; X’</cite>. Because <cite>s</cite> is not an
ancestor of <cite>X’</cite>, lockouts would have been violated when this validator
first attempted to submit a switching vote to <cite>X’</cite> with some vote of the
form <cite>Vote(X’, S’’)</cite>.</p>
<p>Since none of these cases are valid, the assumption must have been invalid,
and the claim is proven.</p>
<p>### Lemma 2:</p>
<p>Recall <cite>B’</cite> was the block finalized on a different fork than
“optimistically” confirmed” block <cite>B</cite>.</p>
<p><cite>Claim</cite>: For any vote <cite>Vote(X, S)</cite> in the <cite>Optimistic Votes</cite> set, it must be
true that <cite>B’ &gt; X</cite></p>
<dl>
<dt><a href="#id35"><span class="problematic" id="id36">``</span></a><a href="#id37"><span class="problematic" id="id38">`</span></a>text</dt><dd><blockquote>
<div><blockquote>
<div><blockquote>
<div></div></blockquote>
<p>+——–+       +———+
|        |       |         |
|        +——-+         |
|                          |
|                          |
|                          |
|                      +—+—+
|                      |       |
|                      |       |  X
|                      |       |
|                      +—+—+
|                          |
|                          |
|                      +—+—+
|                      |       |
|                      |       |  B (Optimistically Confirmed)
|                      |       |
|                      +—+—+
|                          |
|                          |
|                          |
|                      +—+—+
|                      |       |
|                      |       |  S.last
|                      |       |
|                      +——-+
|</p>
</div></blockquote>
</div></blockquote>
<dl>
<dt>B’(Finalized)  |       |</dt><dd><div class="line-block">
<div class="line"><a href="#id39"><span class="problematic" id="id40">|</span></a></div>
</div>
<table class="docutils align-default">
<tbody>
</tbody>
</table>
</dd>
</dl>
</dd>
</dl>
<p><a href="#id41"><span class="problematic" id="id42">``</span></a><a href="#id43"><span class="problematic" id="id44">`</span></a></p>
<p><cite>Proof</cite>: Let <cite>Vote(X, S)</cite> be a vote in the <cite>Optimistic Votes</cite> set. Then by
definition, given the “optimistcally confirmed” block <cite>B</cite>, <cite>X &lt;= B &lt;= S.last</cite>.</p>
<p>Because <cite>X</cite> is a parent of <cite>B</cite>, and <cite>B’</cite> is not a parent or ancestor of <cite>B</cite>,
then:</p>
<ul class="simple">
<li><p><cite>B’ != X</cite></p></li>
<li><p><cite>B’</cite> is not a parent of <cite>X</cite></p></li>
</ul>
<p>Now consider if <cite>B’</cite> &lt; <cite>X</cite>:</p>
<p><cite>Case B’ &lt; X</cite>: We wll show this is a violation of lockouts.
From above, we know <cite>B’</cite> is not a parent of <cite>X</cite>. Then because <cite>B’</cite> was rooted,
and <cite>B’</cite> is not a parent of <cite>X</cite>, then the validator should not have been able
to vote on the higher slot <cite>X</cite> that does not descend from <cite>B’</cite>.</p>
<p>### Proof of Safety:</p>
<p>We now aim to show at least one of the validators in the
<cite>Optimistic Validators</cite> set violated a slashing rule.</p>
<p>First note that in order for <cite>B’</cite> to have been rooted, there must have been
<cite>&gt; 2/3</cite> stake that voted on <cite>B’</cite> or a descendant of <cite>B’</cite>. Given that the
<cite>Optimistic Validator</cite> set also contains <cite>&gt; 2/3</cite> of the staked validators,
it follows that <cite>&gt; 1/3</cite> of the staked validators:</p>
<ul class="simple">
<li><p>Rooted <cite>B’</cite> or a descendant of <cite>B’</cite></p></li>
<li><p>Also submitted a vote <cite>v</cite> of the form <cite>Vote(X, S)</cite> where <cite>X &lt;= B &lt;= v.last</cite>.</p></li>
</ul>
<p>Let the <cite>Delinquent</cite> set be the set of validators that meet the above
criteria.</p>
<p>By definition, in order to root <cite>B’</cite>, each validator <cite>V</cite> in <cite>Delinquent</cite>
must have each made some “switching vote” of the form <cite>Vote(X_v, S_v)</cite> where:</p>
<ul class="simple">
<li><p><cite>S_v.last &gt; B’</cite></p></li>
<li><p><cite>S_v.last</cite> is a descendant of <cite>B’</cite>, so it can’t be a descendant of <cite>B</cite></p></li>
<li><p>Because <cite>S_v.last</cite> is not a descendant of <cite>B</cite>, then <cite>X_v</cite> cannot be a
descendant or ancestor of <cite>B</cite>.</p></li>
</ul>
<p>By definition, this delinquent validator <cite>V</cite> also made some vote <cite>Vote(X, S)</cite>
in the <cite>Optimistic Votes</cite> where by definition of that set (optimistically
confirmed <cite>B</cite>), we know <cite>S.last &gt;= B &gt;= X</cite>.</p>
<p>By <cite>Lemma 2</cite> we know <cite>B’ &gt; X</cite>, and from above <cite>S_v.last &gt; B’</cite>, so then
<cite>S_v.last &gt; X</cite>. Because <cite>X_v != X</cite> (cannot be a descendant or ancestor of
<cite>B</cite> from above), then by the slashing rules then, we know <cite>X_v &gt; S.last</cite>.
From above, <cite>S.last &gt;= B &gt;= X</cite> so for all such “switching votes”, <cite>X_v &gt; B</cite>.</p>
<p>Now ordering all these “switching votes” in time, let <cite>V</cite> to be the validator
in <cite>Optimistic Validators</cite> that first submitted such a “swtching vote”
<cite>Vote(X’, S’)</cite>, where <cite>X’ &gt; B</cite>. We know that such a validator exists because
we know from above that all delinquent validators must have submitted such
a vote, and the delinquent validators are a subset of the
<cite>Optimistic Validators</cite>.</p>
<p>Let <cite>Vote(X, S)</cite> be the unique vote in <cite>Optimistic Votes</cite> made by
validator <cite>V</cite> (maximizing <cite>S.last</cite>).</p>
<p>Given <cite>Vote(X, S)</cite> because <cite>X’ &gt; B &gt;= X</cite>, then <cite>X’ &gt; X</cite>, so
by the “Optimistic Slashing” rules, <cite>X’ &gt; S.last</cite>.</p>
<p>In order to perform such a “switching vote” to <cite>X’</cite>, a switching proof
<cite>SP(Vote(X, S), Vote(X’, S’))</cite> must show <cite>&gt; 1/3</cite> of stake being locked
out at this validator’s latest vote, <cite>S.last</cite>. Combine this <cite>&gt;1/3</cite> with the
fact that the set of validators in the <cite>Optimistic Voters</cite> set consists of
<cite>&gt; 2/3</cite> of the stake, implies at least one optimistic validator <cite>W</cite> from the
<cite>Optimistic Voters</cite> set must have submitted a vote (recall the definition of
a switching proof),`Vote(X_w, S_w)` that was included in validator <cite>V</cite>’s
switching proof for slot <cite>X’</cite>, where <cite>S_w</cite> contains a slot <cite>s</cite> such that:</p>
<ul class="simple">
<li><p><cite>s</cite> is not a common ancestor of <cite>S.last</cite> and <cite>X’</cite></p></li>
<li><p><cite>s</cite> is not a descendant of <cite>S.last</cite>.</p></li>
<li><p><cite>s’ + s’.lockout &gt; S.last</cite></p></li>
</ul>
<p>Because <cite>B</cite> is an ancestor of <cite>S.last</cite>, it is also true then:</p>
<ul class="simple">
<li><p><cite>s</cite> is not a common ancestor of <cite>B</cite> and <cite>X’</cite></p></li>
<li><p><cite>s’ + s’.lockout &gt; B</cite></p></li>
</ul>
<p>which was included in <cite>V</cite>’s switching proof.</p>
<p>Now because <cite>W</cite> is also a member of <cite>Optimistic Voters</cite>, then by the <cite>Lemma 1</cite>
above, given a vote by <cite>W</cite>, <cite>Vote(X_w, S_w)</cite>, where <cite>S_w</cite> contains a vote for
a slot <cite>s</cite> where <cite>s + s.lockout &gt; B</cite>, and <cite>s</cite> is not an ancestor of <cite>B</cite>, then
<cite>X_w &gt; B</cite>.</p>
<p>Because validator <cite>V</cite> included vote <cite>Vote(X_w, S_w)</cite> in its proof of switching
for slot <cite>X’</cite>, then his implies validator <cite>V’</cite> submitted vote <cite>Vote(X_w, S_w)</cite>
<strong>before</strong> validator <cite>V</cite> submitted its switching vote for slot <cite>X’</cite>,
<cite>Vote(X’, S’)</cite>.</p>
<p>But this is a contradiction because we chose <cite>Vote(X’, S’)</cite> to be the first vote
made by any validator in the <cite>Optimistic Voters</cite> set where <cite>X’ &gt; B</cite> and <cite>X’</cite> is
not a descendant of <cite>B</cite>.</p>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../_sources/src/proposals/optimistic_confirmation.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>