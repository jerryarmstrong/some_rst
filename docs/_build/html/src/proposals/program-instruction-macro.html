<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>docs/src/proposals/program-instruction-macro.md &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="docs-src-proposals-program-instruction-macro-md">
<h1>docs/src/proposals/program-instruction-macro.md<a class="headerlink" href="#docs-src-proposals-program-instruction-macro-md" title="Permalink to this heading">¶</a></h1>
<p>Last edited: 2023-08-11 21:38:33</p>
<p>Contents:</p>
<div class="highlight-md notranslate"><div class="highlight"><pre><span></span><span class="gh"># Program Instruction Macro</span>
</pre></div>
</div>
<p>## Problem</p>
<p>Currently, inspecting an on-chain transaction requires depending on a
client-side, language-specific decoding library to parse the instruction. If
rpc methods could return decoded instruction details, these custom solutions
would be unnecessary.</p>
<p>We can deserialize instruction data using a program’s Instruction enum, but
decoding the account-key list into human-readable identifiers requires manual
parsing. Our current Instruction enums have that account information, but only
in variant docs.</p>
<p>Similarly, we have instruction constructor functions that duplicate nearly all
the information in the enum, but we can’t generate that constructor from the
enum definition because the list of account references is in code comments.</p>
<p>Also, Instruction docs can vary between implementations, as there is no
mechanism to ensure consistency.</p>
<p>## Proposed Solution</p>
<p>Move the data from code comments to attributes, such that the constructors
can be generated, and include all the documentation from the enum definition.</p>
<p>Here is an example of an Instruction enum using the new accounts format:</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>rust,ignore
#[instructions(test_program::id())]
pub enum TestInstruction {</p>
<blockquote>
<div><p>/// Transfer lamports
#[accounts(</p>
<blockquote>
<div><p>from_account(SIGNER, WRITABLE, desc = “Funding account”),
to_account(WRITABLE, desc = “Recipient account”),</p>
</div></blockquote>
<p>)]
Transfer {</p>
<blockquote>
<div><p>lamports: u64,</p>
</div></blockquote>
<p>},</p>
<p>/// Provide M of N required signatures
#[accounts(</p>
<blockquote>
<div><p>data_account(WRITABLE, desc = “Data account”),
signers(SIGNER, multiple, desc = “Signer”),</p>
</div></blockquote>
<p>)]
Multisig,</p>
<p>/// Consumes a stored nonce, replacing it with a successor
#[accounts(</p>
<blockquote>
<div><p>nonce_account(SIGNER, WRITABLE, desc = “Nonce account”),
recent_blockhashes_sysvar(desc = “RecentBlockhashes sysvar”),
nonce_authority(SIGNER, optional, desc = “Nonce authority”),</p>
</div></blockquote>
<p>)]
AdvanceNonceAccount,</p>
</div></blockquote>
<section id="id5">
<h2>}<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h2>
<p>An example of the generated TestInstruction with docs:</p>
<p><a href="#id6"><span class="problematic" id="id7">``</span></a><a href="#id8"><span class="problematic" id="id9">`</span></a>rust,ignore
pub enum TestInstruction {</p>
<blockquote>
<div><p>/// Transfer lamports
///
/// * Accounts expected by this instruction:
///   0. <cite>[WRITABLE, SIGNER]</cite> Funding account
///   1. <cite>[WRITABLE]</cite> Recipient account
Transfer {</p>
<blockquote>
<div><p>lamports: u64,</p>
</div></blockquote>
<p>},</p>
<p>/// Provide M of N required signatures
///
/// * Accounts expected by this instruction:
///   0. <cite>[WRITABLE]</cite> Data account
///   * (Multiple) <cite>[SIGNER]</cite> Signers
Multisig,</p>
<p>/// Consumes a stored nonce, replacing it with a successor
///
/// * Accounts expected by this instruction:
///   0. <cite>[WRITABLE, SIGNER]</cite> Nonce account
///   1. <cite>[]</cite> RecentBlockhashes sysvar
///   2. (Optional) <cite>[SIGNER]</cite> Nonce authority
AdvanceNonceAccount,</p>
</div></blockquote>
</section>
<section id="id10">
<h2>}<a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h2>
<p>Generated constructors:</p>
<p><a href="#id11"><span class="problematic" id="id12">``</span></a><cite>rust,ignore
/// Transfer lamports
///
/// * `from_account</cite> - <cite>[WRITABLE, SIGNER]</cite> Funding account
/// * <cite>to_account</cite> - <cite>[WRITABLE]</cite> Recipient account
pub fn transfer(from_account: Pubkey, to_account: Pubkey, lamports: u64) -&gt; Instruction {</p>
<blockquote>
<div><dl class="simple">
<dt>let account_metas = vec![</dt><dd><p>AccountMeta::new(from_pubkey, true),
AccountMeta::new(to_pubkey, false),</p>
</dd>
</dl>
<p>];
Instruction::new_with_bincode(</p>
<blockquote>
<div><p>test_program::id(),
&amp;SystemInstruction::Transfer { lamports },
account_metas,</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>}</p>
<p>/// Provide M of N required signatures
///
/// * <cite>data_account</cite> - <cite>[WRITABLE]</cite> Data account
/// * <cite>signers</cite> - (Multiple) <cite>[SIGNER]</cite> Signers
pub fn multisig(data_account: Pubkey, signers: &amp;[Pubkey]) -&gt; Instruction {</p>
<blockquote>
<div><dl class="simple">
<dt>let mut account_metas = vec![</dt><dd><p>AccountMeta::new(nonce_pubkey, false),</p>
</dd>
</dl>
<p>];
for pubkey in signers.iter() {</p>
<blockquote>
<div><p>account_metas.push(AccountMeta::new_readonly(pubkey, true));</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>Instruction::new_with_bincode(</dt><dd><p>test_program::id(),
&amp;TestInstruction::Multisig,
account_metas,</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>}</p>
<p>/// Consumes a stored nonce, replacing it with a successor
///
/// * nonce_account - <cite>[WRITABLE, SIGNER]</cite> Nonce account
/// * recent_blockhashes_sysvar - <cite>[]</cite> RecentBlockhashes sysvar
/// * nonce_authority - (Optional) <cite>[SIGNER]</cite> Nonce authority
pub fn advance_nonce_account(</p>
<blockquote>
<div><p>nonce_account: Pubkey,
recent_blockhashes_sysvar: Pubkey,
nonce_authority: Option&lt;Pubkey&gt;,</p>
</div></blockquote>
<dl>
<dt>) -&gt; Instruction {</dt><dd><dl class="simple">
<dt>let mut account_metas = vec![</dt><dd><p>AccountMeta::new(nonce_account, false),
AccountMeta::new_readonly(recent_blockhashes_sysvar, false),</p>
</dd>
</dl>
<p>];
if let Some(pubkey) = authorized_pubkey {</p>
<blockquote>
<div><p>account_metas.push(AccountMeta::new_readonly*nonce_authority, true));</p>
</div></blockquote>
<p>}
Instruction::new_with_bincode(</p>
<blockquote>
<div><p>test_program::id(),
&amp;TestInstruction::AdvanceNonceAccount,
account_metas,</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>
<p><a href="#id13"><span class="problematic" id="id14">``</span></a><a href="#id15"><span class="problematic" id="id16">`</span></a></p>
<p>Generated TestInstructionVerbose enum:</p>
<p><a href="#id17"><span class="problematic" id="id18">``</span></a><a href="#id19"><span class="problematic" id="id20">`</span></a>rust,ignore
#[derive(Serialize, Deserialize, Debug, Clone, PartialEq)]
pub enum TestInstruction {</p>
<blockquote>
<div><p>/// Transfer lamports
Transfer {</p>
<blockquote>
<div><p>/// Funding account
funding_account: u8</p>
<p>/// Recipient account
recipient_account: u8</p>
<p>lamports: u64,</p>
</div></blockquote>
<p>},</p>
<p>/// Provide M of N required signatures
Multisig {</p>
<blockquote>
<div><p>data_account: u8,
signers: Vec&lt;u8&gt;,</p>
</div></blockquote>
<p>},</p>
<p>/// Consumes a stored nonce, replacing it with a successor
AdvanceNonceAccount {</p>
<blockquote>
<div><p>nonce_account: u8,
recent_blockhashes_sysvar: u8,
nonce_authority: Option&lt;u8&gt;,</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl TestInstructionVerbose {</dt><dd><dl>
<dt>pub fn from_instruction(instruction: TestInstruction, account_keys: Vec&lt;u8&gt;) -&gt; Self {</dt><dd><dl>
<dt>match instruction {</dt><dd><dl class="simple">
<dt>TestInstruction::Transfer { lamports } =&gt; TestInstructionVerbose::Transfer {</dt><dd><p>funding_account: account_keys[0],
recipient_account: account_keys[1],
lamports,</p>
</dd>
</dl>
<p>}
TestInstruction::Multisig =&gt; TestInstructionVerbose::Multisig {</p>
<blockquote>
<div><p>data_account: account_keys[0],
signers: account_keys[1..],</p>
</div></blockquote>
<p>}
TestInstruction::AdvanceNonceAccount =&gt; TestInstructionVerbose::AdvanceNonceAccount {</p>
<blockquote>
<div><p>nonce_account: account_keys[0],
recent_blockhashes_sysvar: account_keys[1],
nonce_authority: &amp;account_keys.get(2),</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p><a href="#id21"><span class="problematic" id="id22">``</span></a><a href="#id23"><span class="problematic" id="id24">`</span></a></p>
<p>## Considerations</p>
<ol class="arabic simple">
<li><p><strong>Named fields</strong> - Since the resulting Verbose enum constructs variants with
named fields, any unnamed fields in the original Instruction variant will need
to have names generated. As such, it would be considerably more straightforward
if all Instruction enum fields are converted to named types, instead of unnamed
tuples. This seems worth doing anyway, adding more precision to the variants and
enabling real documentation (so developers don’t have to do
[this](<a class="reference external" href="https://github.com/solana-labs/solana/blob/3aab13a1679ba2b7846d9ba39b04a52f2017d3e0/sdk/src/system_instruction.rs#L140">https://github.com/solana-labs/solana/blob/3aab13a1679ba2b7846d9ba39b04a52f2017d3e0/sdk/src/system_instruction.rs#L140</a>)
This will cause a little churn in our current code base, but not a lot.</p></li>
<li><p><strong>Variable account lists</strong> - This approach offers a couple options for
variable account lists. First, optional accounts may be added and tagged with
the <cite>optional</cite> keyword. However, currently only one optional account is
supported per instruction. Additional data will need to be added to the
instruction to support multiples, enabling identification of which accounts are
present when some but not all are included. Second, accounts that share the same
features may be added as a set, tagged with the <cite>multiple</cite> keyword. Like
optional accounts, only one multiple account set is supported per instruction
(and optional and multiple may not coexist). More complex instructions that
cannot be accommodated by <cite>optional</cite> or <cite>multiple</cite>, requiring logic to figure
out account order/representation, should probably be made into separate
instructions.</p></li>
</ol>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../_sources/src/proposals/program-instruction-macro.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>