<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../" id="documentation_options" src="../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.earlybird.common.userupdates;</p>
<p>import java.util.Iterator;
import java.util.concurrent.atomic.AtomicReference;
import java.util.function.Predicate;</p>
<p>import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;</p>
<p>import org.slf4j.Logger;
import org.slf4j.LoggerFactory;</p>
<p>import com.twitter.search.common.metrics.SearchLongGauge;
import com.twitter.search.common.metrics.SearchRateCounter;
import com.twitter.search.common.util.hash.GeneralLongHashFunction;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Table containing metadata about users, like NSFW or Antisocial status.</p></li>
<li><p>Used for result filtering.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public class UserTable {</dt><dd><p>private static final Logger LOG = LoggerFactory.getLogger(UserTable.class);</p>
<p>&#64;VisibleForTesting // Not final for testing.
protected static long userUpdateTableMaxCapacity = 1L &lt;&lt; 30;</p>
<p>private static final int DEFAULT_INITIAL_CAPACITY = 1024;
private static final int BYTE_WIDTH = 8;</p>
<p>private static final String USER_TABLE_CAPACITY = “user_table_capacity”;
private static final String USER_TABLE_SIZE = “user_table_size”;
private static final String</p>
<blockquote>
<div><p>USER_NUM_USERS_WITH_NO_BITS_SET = “user_table_users_with_no_bits_set”;</p>
</div></blockquote>
<p>private static final String USER_TABLE_ANTISOCIAL_USERS = “user_table_antisocial_users”;
private static final String USER_TABLE_OFFENSIVE_USERS = “user_table_offensive_users”;
private static final String USER_TABLE_NSFW_USERS = “user_table_nsfw_users”;
private static final String USER_TABLE_IS_PROTECTED_USERS = “user_table_is_protected_users”;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>number of users filtered</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>private static final SearchRateCounter USER_TABLE_USERS_FILTERED_COUNTER =</dt><dd><p>new SearchRateCounter(“user_table_users_filtered”);</p>
</dd>
</dl>
<p>private SearchLongGauge userTableCapacity;
private SearchLongGauge userTableSize;
private SearchLongGauge userTableNumUsersWithNoBitsSet;
private SearchLongGauge userTableAntisocialUsers;
private SearchLongGauge userTableOffensiveUsers;
private SearchLongGauge userTableNsfwUsers;
private SearchLongGauge userTableIsProtectedUsers;</p>
<p>private final Predicate&lt;Long&gt; userIdFilter;
private long lastRecordTimestamp;</p>
<dl>
<dt>private static final class HashTable {</dt><dd><p>private int numUsersInTable;
private int numUsersWithNoBitsSet;
// size 8 array contains the number of users who have the bit set at the index (0-7) position
// e.g. setBitCounts[0] stores the number of users who have the 0 bit set in their bytes
private long[] setBitCounts;</p>
<p>private final long[] hash;
private final byte[] bits;</p>
<p>private final int hashMask;</p>
<dl class="simple">
<dt>HashTable(int size) {</dt><dd><p>this.hash = new long[size];
this.bits = new byte[size];
this.hashMask = size - 1;
this.numUsersInTable = 0;
this.setBitCounts = new long[BYTE_WIDTH];</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>protected int hashSize() {</dt><dd><p>return hash.length;</p>
</dd>
</dl>
<p>}</p>
<p>// If we want to decrease the number of users in the table, we can delete as many users
// as this table returns, by calling filterTableAndCountValidItems.
public void setCountOfNumUsersWithNoBitsSet() {</p>
<blockquote>
<div><p>int count = 0;
for (int i = 0; i &lt; hash.length; i++) {</p>
<blockquote>
<div><dl class="simple">
<dt>if ((hash[i] &gt; 0) &amp;&amp; (bits[i] == 0)) {</dt><dd><p>count++;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>numUsersWithNoBitsSet = count;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>public void setSetBitCounts() {</dt><dd><p>long[] counts = new long[BYTE_WIDTH];
for (int i = 0; i &lt; hash.length; i++) {</p>
<blockquote>
<div><dl>
<dt>if (hash[i] &gt; 0) {</dt><dd><p>int tempBits = bits[i] &amp; 0xff;
int curBitPos = 0;
while (tempBits != 0) {</p>
<blockquote>
<div><dl class="simple">
<dt>if ((tempBits &amp; 1) != 0) {</dt><dd><p>counts[curBitPos]++;</p>
</dd>
</dl>
<p>}
tempBits = tempBits &gt;&gt;&gt; 1;
curBitPos++;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
setBitCounts = counts;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>public static final int ANTISOCIAL_BIT = 1;
public static final int OFFENSIVE_BIT = 1 &lt;&lt; 1;
public static final int NSFW_BIT = 1 &lt;&lt; 2;
public static final int IS_PROTECTED_BIT = 1 &lt;&lt; 3;</p>
<dl class="simple">
<dt>public long getLastRecordTimestamp() {</dt><dd><p>return this.lastRecordTimestamp;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setLastRecordTimestamp(long lastRecordTimestamp) {</dt><dd><p>this.lastRecordTimestamp = lastRecordTimestamp;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setOffensive(long userID, boolean offensive) {</dt><dd><p>set(userID, OFFENSIVE_BIT, offensive);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setAntisocial(long userID, boolean antisocial) {</dt><dd><p>set(userID, ANTISOCIAL_BIT, antisocial);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setNSFW(long userID, boolean nsfw) {</dt><dd><p>set(userID, NSFW_BIT, nsfw);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setIsProtected(long userID, boolean isProtected) {</dt><dd><p>set(userID, IS_PROTECTED_BIT, isProtected);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Adds the given user update to this table.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>public boolean indexUserUpdate(UserUpdatesChecker checker, UserUpdate userUpdate) {</dt><dd><dl class="simple">
<dt>if (checker.skipUserUpdate(userUpdate)) {</dt><dd><p>return false;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>switch (userUpdate.updateType) {</dt><dd><dl class="simple">
<dt>case ANTISOCIAL:</dt><dd><p>setAntisocial(userUpdate.twitterUserID, userUpdate.updateValue != 0);
break;</p>
</dd>
<dt>case NSFW:</dt><dd><p>setNSFW(userUpdate.twitterUserID, userUpdate.updateValue != 0);
break;</p>
</dd>
<dt>case OFFENSIVE:</dt><dd><p>setOffensive(userUpdate.twitterUserID, userUpdate.updateValue != 0);
break;</p>
</dd>
<dt>case PROTECTED:</dt><dd><p>setIsProtected(userUpdate.twitterUserID, userUpdate.updateValue != 0);
break;</p>
</dd>
<dt>default:</dt><dd><p>return false;</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>return true;</p>
</dd>
</dl>
<p>}</p>
<p>private final AtomicReference&lt;HashTable&gt; hashTable = new AtomicReference&lt;&gt;();</p>
<dl class="simple">
<dt>private int hashCode(long userID) {</dt><dd><p>return (int) GeneralLongHashFunction.hash(userID);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns an iterator for user IDs that have at least one of the bits set.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>public Iterator&lt;Long&gt; getFlaggedUserIdIterator() {</dt><dd><p>HashTable table = hashTable.get();</p>
<p>final long[] currUserIdTable = table.hash;
final byte[] currBitsTable = table.bits;
return new Iterator&lt;Long&gt;() {</p>
<blockquote>
<div><p>private int index = findNext(0);</p>
<dl>
<dt>private int findNext(int index) {</dt><dd><p>int startingIndex = index;
while (startingIndex &lt; currUserIdTable.length) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (currUserIdTable[startingIndex] != 0 &amp;&amp; currBitsTable[startingIndex] != 0) {</dt><dd><p>break;</p>
</dd>
</dl>
<p>}
++startingIndex;</p>
</div></blockquote>
<p>}
return startingIndex;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public boolean hasNext() {</p>
<blockquote>
<div><p>return index &lt; currUserIdTable.length;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public Long next() {</p>
<blockquote>
<div><p>Long r = currUserIdTable[index];
index = findNext(index + 1);
return r;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public void remove() {</p>
<blockquote>
<div><p>throw new UnsupportedOperationException();</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>};</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Constructs an UserUpdatesTable with an given HashTable instance.</p></li>
<li><p>Use &lt;code&gt;useIdFilter&lt;/code&gt; as a Predicate that returns true for the elements</p></li>
<li><p>needed to be kept in the table.</p></li>
<li><p>Use shouldRehash to force a rehasing on the given HashTable.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>private UserTable(HashTable hashTable, Predicate&lt;Long&gt; userIdFilter,</dt><dd><blockquote>
<div><p>boolean shouldRehash) {</p>
</div></blockquote>
<p>Preconditions.checkNotNull(userIdFilter);</p>
<p>this.hashTable.set(hashTable);
this.userIdFilter = userIdFilter;</p>
<p>exportUserUpdatesTableStats();</p>
<dl>
<dt>LOG.info(“User table num users: {}. Users with no bits set: {}. “</dt><dd><blockquote>
<div><ul class="simple">
<li><p>“Antisocial users: {}. Offensive users: {}. Nsfw users: {}. IsProtected users: {}.”,</p></li>
</ul>
</div></blockquote>
<p>this.getNumUsersInTable(),
this.getNumUsersWithNoBitsSet(),
this.getSetBitCount(ANTISOCIAL_BIT),
this.getSetBitCount(OFFENSIVE_BIT),
this.getSetBitCount(NSFW_BIT),
this.getSetBitCount(IS_PROTECTED_BIT));</p>
</dd>
<dt>if (shouldRehash) {</dt><dd><p>int filteredTableSize = filterTableAndCountValidItems();
// Having exactly 100% usage can impact lookup. Maintain the table at under 50% usage.
int newTableCapacity = computeDesiredHashTableCapacity(filteredTableSize * 2);</p>
<p>rehash(newTableCapacity);</p>
<dl>
<dt>LOG.info(“User table num users after rehash: {}. Users with no bits set: {}. “</dt><dd><blockquote>
<div><ul class="simple">
<li><p>“Antisocial users: {}. Offensive users: {}. Nsfw users: {}. IsProtected users: {}.”,</p></li>
</ul>
</div></blockquote>
<p>this.getNumUsersInTable(),
this.getNumUsersWithNoBitsSet(),
this.getSetBitCount(ANTISOCIAL_BIT),
this.getSetBitCount(OFFENSIVE_BIT),
this.getSetBitCount(NSFW_BIT),
this.getSetBitCount(IS_PROTECTED_BIT));</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private UserTable(int initialSize, Predicate&lt;Long&gt; userIdFilter) {</dt><dd><p>this(new HashTable(computeDesiredHashTableCapacity(initialSize)), userIdFilter, false);</p>
</dd>
</dl>
<p>}</p>
<p>&#64;VisibleForTesting
public UserTable(int initialSize) {</p>
<blockquote>
<div><p>this(initialSize, userId -&gt; true);</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>public static UserTable</dt><dd><p>newTableWithDefaultCapacityAndPredicate(Predicate&lt;Long&gt; userIdFilter) {</p>
<p>return new UserTable(DEFAULT_INITIAL_CAPACITY, userIdFilter);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public static UserTable newTableNonFilteredWithDefaultCapacity() {</dt><dd><p>return newTableWithDefaultCapacityAndPredicate(userId -&gt; true);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void exportUserUpdatesTableStats() {</dt><dd><p>userTableSize = SearchLongGauge.export(USER_TABLE_SIZE);
userTableCapacity = SearchLongGauge.export(USER_TABLE_CAPACITY);
userTableNumUsersWithNoBitsSet = SearchLongGauge.export(</p>
<blockquote>
<div><p>USER_NUM_USERS_WITH_NO_BITS_SET</p>
</div></blockquote>
<p>);
userTableAntisocialUsers = SearchLongGauge.export(USER_TABLE_ANTISOCIAL_USERS);
userTableOffensiveUsers = SearchLongGauge.export(USER_TABLE_OFFENSIVE_USERS);
userTableNsfwUsers = SearchLongGauge.export(USER_TABLE_NSFW_USERS);
userTableIsProtectedUsers = SearchLongGauge.export(USER_TABLE_IS_PROTECTED_USERS);</p>
<dl>
<dt>LOG.info(</dt><dd><dl class="simple">
<dt>“Exporting stats for user table. Starting with numUsersInTable={}, usersWithZeroBits={}, “</dt><dd><ul class="simple">
<li><p>“antisocialUsers={}, offensiveUsers={}, nsfwUsers={}, isProtectedUsers={}.”,</p></li>
</ul>
</dd>
</dl>
<p>getNumUsersInTable(),
getNumUsersWithNoBitsSet(),
getSetBitCount(ANTISOCIAL_BIT),
getSetBitCount(OFFENSIVE_BIT),
getSetBitCount(NSFW_BIT),
getSetBitCount(IS_PROTECTED_BIT));</p>
</dd>
</dl>
<p>updateStats();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private void updateStats() {</dt><dd><p>HashTable table = this.hashTable.get();
userTableSize.set(table.numUsersInTable);
userTableNumUsersWithNoBitsSet.set(table.numUsersWithNoBitsSet);
userTableCapacity.set(table.hashSize());
userTableAntisocialUsers.set(getSetBitCount(ANTISOCIAL_BIT));
userTableOffensiveUsers.set(getSetBitCount(OFFENSIVE_BIT));
userTableNsfwUsers.set(getSetBitCount(NSFW_BIT));
userTableIsProtectedUsers.set(getSetBitCount(IS_PROTECTED_BIT));</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Computes the size of the hashtable as the first power of two greater than or equal to initialSize</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>private static int computeDesiredHashTableCapacity(int initialSize) {</dt><dd><p>long powerOfTwoSize = 2;
while (initialSize &gt; powerOfTwoSize) {</p>
<blockquote>
<div><p>powerOfTwoSize <a href="#id13"><span class="problematic" id="id14">*</span></a>= 2;</p>
</div></blockquote>
<p>}
if (powerOfTwoSize &gt; Integer.MAX_VALUE) {</p>
<blockquote>
<div><p>LOG.error(“Error: powerOfTwoSize overflowed Integer.MAX_VALUE! Initial size: “ + initialSize);
powerOfTwoSize = 1 &lt;&lt; 30;  // max power of 2</p>
</div></blockquote>
<p>}</p>
<p>return (int) powerOfTwoSize;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public int getNumUsersInTable() {</dt><dd><p>return hashTable.get().numUsersInTable;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Get the number of users who have the bit set at the <cite>userStateBit</cite> position</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>public long getSetBitCount(int userStateBit) {</dt><dd><p>int bit = userStateBit;
int bitPosition = 0;
while (bit != 0 &amp;&amp; (bit &amp; 1) == 0) {</p>
<blockquote>
<div><p>bit = bit &gt;&gt;&gt; 1;
bitPosition++;</p>
</div></blockquote>
<p>}
return hashTable.get().setBitCounts[bitPosition];</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Predicate&lt;Long&gt; getUserIdFilter() {</dt><dd><p>return userIdFilter::test;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Updates a user flag in this table.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>public final void set(long userID, int bit, boolean value) {</dt><dd><p>// if userID is filtered return immediately
if (!shouldKeepUser(userID)) {</p>
<blockquote>
<div><p>USER_TABLE_USERS_FILTERED_COUNTER.increment();
return;</p>
</div></blockquote>
<p>}</p>
<p>HashTable table = this.hashTable.get();</p>
<p>int hashPos = findHashPosition(table, userID);
long item = table.hash[hashPos];
byte bits = 0;
int bitsDiff = 0;</p>
<dl>
<dt>if (item != 0) {</dt><dd><p>byte bitsOriginally = bits = table.bits[hashPos];
if (value) {</p>
<blockquote>
<div><p>bits <a href="#id19"><span class="problematic" id="id20">|</span></a>= bit;</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>// AND’ing with the inverse map clears the desired bit, but
// doesn’t change any of the other bits
bits &amp;= ~bit;</p>
</dd>
</dl>
<p>}</p>
<p>// Find the changed bits after the above operation, it is possible that no bit is changed if
// the input ‘bit’ is already set/unset in the table.
// Since bitwise operators cannot be directly applied on Byte, Byte is promoted into int to
// apply the operators. When that happens, if the most significant bit of the Byte is set,
// the promoted int has all significant bits set to 1. 0xff bitmask is applied here to make
// sure only the last 8 bits are considered.
bitsDiff = (bitsOriginally &amp; 0xff) ^ (bits &amp; 0xff);</p>
<dl class="simple">
<dt>if (bitsOriginally &gt; 0 &amp;&amp; bits == 0) {</dt><dd><p>table.numUsersWithNoBitsSet++;</p>
</dd>
<dt>} else if (bitsOriginally == 0 &amp;&amp; bits &gt; 0) {</dt><dd><p>table.numUsersWithNoBitsSet–;</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>if (!value) {</dt><dd><p>// no need to add this user, since all bits would be false anyway
return;</p>
</dd>
</dl>
<p>}</p>
<p>// New user string.
if (table.numUsersInTable + 1 &gt;= (table.hashSize() &gt;&gt; 1)</p>
<blockquote>
<div><blockquote>
<div><p>&amp;&amp; table.hashSize() != userUpdateTableMaxCapacity) {</p>
</div></blockquote>
<dl>
<dt>if (2L * (long) table.hashSize() &lt; userUpdateTableMaxCapacity) {</dt><dd><p>rehash(2 * table.hashSize());
table = this.hashTable.get();</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>if (table.hashSize() &lt; (int) userUpdateTableMaxCapacity) {</dt><dd><p>rehash((int) userUpdateTableMaxCapacity);
table = this.hashTable.get();
LOG.warn(“User update table size reached Integer.MAX_VALUE, performance will degrade.”);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// Must repeat this operation with the resized hashTable.
hashPos = findHashPosition(table, userID);</p>
</div></blockquote>
<p>}</p>
<p>item = userID;
bits <a href="#id21"><span class="problematic" id="id22">|</span></a>= bit;
bitsDiff = bit &amp; 0xff;</p>
<p>table.numUsersInTable++;</p>
</dd>
</dl>
<p>}</p>
<p>table.hash[hashPos] = item;
table.bits[hashPos] = bits;</p>
<p>// update setBitCounts for the changed bits after applying the input ‘bit’
int curBitsDiffPos = 0;
while (bitsDiff != 0) {</p>
<blockquote>
<div><dl>
<dt>if ((bitsDiff &amp; 1) != 0) {</dt><dd><dl class="simple">
<dt>if (value) {</dt><dd><p>table.setBitCounts[curBitsDiffPos]++;</p>
</dd>
<dt>} else {</dt><dd><p>table.setBitCounts[curBitsDiffPos]–;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
bitsDiff = bitsDiff &gt;&gt;&gt; 1;
curBitsDiffPos++;</p>
</div></blockquote>
<p>}</p>
<p>updateStats();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public final boolean isSet(long userID, int bits) {</dt><dd><p>HashTable table = hashTable.get();
int hashPos = findHashPosition(table, userID);
return table.hash[hashPos] != 0 &amp;&amp; (table.bits[hashPos] &amp; bits) != 0;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns true when userIdFilter condition is being met.</p></li>
<li><p>If filter is not present returns true</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>private boolean shouldKeepUser(long userID) {</dt><dd><p>return userIdFilter.test(userID);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private int findHashPosition(final HashTable table, final long userID) {</dt><dd><p>int code = hashCode(userID);
int hashPos = code &amp; table.hashMask;</p>
<p>// Locate user in hash
long item = table.hash[hashPos];</p>
<dl>
<dt>if (item != 0 &amp;&amp; item != userID) {</dt><dd><p>// Conflict: keep searching different locations in
// the hash table.
final int inc = ((code &gt;&gt; 8) + code) | 1;
do {</p>
<blockquote>
<div><p>code += inc;
hashPos = code &amp; table.hashMask;
item = table.hash[hashPos];</p>
</div></blockquote>
<p>} while (item != 0 &amp;&amp; item != userID);</p>
</dd>
</dl>
<p>}</p>
<p>return hashPos;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Applies the filtering predicate and returns the size of the filtered table.</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
<dt>private synchronized int filterTableAndCountValidItems() {</dt><dd><p>final HashTable oldTable = this.hashTable.get();
int newSize = 0;</p>
<p>int clearNoItemSet = 0;
int clearNoBitsSet = 0;
int clearDontKeepUser = 0;</p>
<dl>
<dt>for (int i = 0; i &lt; oldTable.hashSize(); i++) {</dt><dd><p>final long item = oldTable.hash[i]; // this is the userID
final byte bits = oldTable.bits[i];</p>
<p>boolean clearSlot = false;
if (item == 0) {</p>
<blockquote>
<div><p>clearSlot = true;
clearNoItemSet++;</p>
</div></blockquote>
<dl class="simple">
<dt>} else if (bits == 0) {</dt><dd><p>clearSlot = true;
clearNoBitsSet++;</p>
</dd>
<dt>} else if (!shouldKeepUser(item)) {</dt><dd><p>clearSlot = true;
clearDontKeepUser++;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (clearSlot) {</dt><dd><p>oldTable.hash[i] = 0;
oldTable.bits[i] = 0;</p>
</dd>
<dt>} else {</dt><dd><p>newSize += 1;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>oldTable.setCountOfNumUsersWithNoBitsSet();
oldTable.setSetBitCounts();</p>
<dl class="simple">
<dt>LOG.info(“Done filtering table: clearNoItemSet={}, clearNoBitsSet={}, clearDontKeepUser={}”,</dt><dd><p>clearNoItemSet, clearNoBitsSet, clearDontKeepUser);</p>
</dd>
</dl>
<p>return newSize;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Called when hash is too small (&gt; 50% occupied)</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
<dt>private void rehash(final int newSize) {</dt><dd><p>final HashTable oldTable = this.hashTable.get();
final HashTable newTable = new HashTable(newSize);</p>
<p>final int newMask = newTable.hashMask;
final long[] newHash = newTable.hash;
final byte[] newBits = newTable.bits;</p>
<dl>
<dt>for (int i = 0; i &lt; oldTable.hashSize(); i++) {</dt><dd><p>final long item = oldTable.hash[i];
final byte bits = oldTable.bits[i];
if (item != 0 &amp;&amp; bits != 0) {</p>
<blockquote>
<div><p>int code = hashCode(item);</p>
<p>int hashPos = code &amp; newMask;
assert hashPos &gt;= 0;
if (newHash[hashPos] != 0) {</p>
<blockquote>
<div><p>final int inc = ((code &gt;&gt; 8) + code) | 1;
do {</p>
<blockquote>
<div><p>code += inc;
hashPos = code &amp; newMask;</p>
</div></blockquote>
<p>} while (newHash[hashPos] != 0);</p>
</div></blockquote>
<p>}
newHash[hashPos] = item;
newBits[hashPos] = bits;
newTable.numUsersInTable++;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>newTable.setCountOfNumUsersWithNoBitsSet();
newTable.setSetBitCounts();
this.hashTable.set(newTable);</p>
<p>updateStats();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setTable(UserTable newTable) {</dt><dd><p>hashTable.set(newTable.hashTable.get());
updateStats();</p>
</dd>
</dl>
<p>}</p>
<p>&#64;VisibleForTesting
protected int getHashTableCapacity() {</p>
<blockquote>
<div><p>return hashTable.get().hashSize();</p>
</div></blockquote>
<p>}</p>
<p>&#64;VisibleForTesting
protected int getNumUsersWithNoBitsSet() {</p>
<blockquote>
<div><p>return hashTable.get().numUsersWithNoBitsSet;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../_sources/src/java/com/twitter/search/earlybird/common/userupdates/UserTable.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>