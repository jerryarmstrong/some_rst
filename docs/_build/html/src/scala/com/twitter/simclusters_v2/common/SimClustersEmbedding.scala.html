<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../" id="documentation_options" src="../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.simclusters_v2.common</p>
<p>import com.twitter.simclusters_v2.thriftscala.SimClusterWithScore
import com.twitter.simclusters_v2.thriftscala.{SimClustersEmbedding =&gt; ThriftSimClustersEmbedding}
import scala.collection.mutable
import scala.language.implicitConversions
import scala.util.hashing.MurmurHash3.arrayHash
import scala.util.hashing.MurmurHash3.productHash
import scala.math._</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A representation of a SimClusters Embedding, designed for low memory footprint and performance.</p></li>
<li><p>For services that cache millions of embeddings, we found this to significantly reduce allocations,</p></li>
<li><p>memory footprint and overall performance.</p></li>
<li></li>
<li><p>Embedding data is stored in pre-sorted arrays rather than structures which use a lot of pointers</p></li>
<li><p>(e.g. Map). A minimal set of lazily-constructed intermediate data is kept.</p></li>
<li></li>
<li><p>Be wary of adding further <cite>val</cite> or <a href="#id1"><span class="problematic" id="id2">`</span></a>lazy val`s to this class; materializing and storing more data</p></li>
<li><p>on these objects could significantly affect in-memory cache performance.</p></li>
<li></li>
<li><p>Also, if you are using this code in a place where you care about memory footprint, be careful</p></li>
<li><p>not to materialize any of the lazy vals unless you need them.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>sealed trait SimClustersEmbedding extends Equals {</dt><dd><p>import SimClustersEmbedding._</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Any compliant implementation of the SimClustersEmbedding trait must ensure that:</p></li>
<li><ul>
<li><p>the cluster and score arrays are ordered as described below</p></li>
</ul>
</li>
<li><ul>
<li><p>the cluster and score arrays are treated as immutable (.hashCode is memoized)</p></li>
</ul>
</li>
<li><ul>
<li><p>the size of all cluster and score arrays is the same</p></li>
</ul>
</li>
<li><ul>
<li><p>all cluster scores are &gt; 0</p></li>
</ul>
</li>
<li><ul>
<li><p>cluster ids are unique</p></li>
</ul>
</li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
</dl>
<p>// In descending score order - this is useful for truncation, where we care most about the highest scoring elements
private[simclusters_v2] val clusterIds: Array[ClusterId]
private[simclusters_v2] val scores: Array[Double]
// In ascending cluster order. This is useful for operations where we try to find the same cluster in another embedding, e.g. dot product
private[simclusters_v2] val sortedClusterIds: Array[ClusterId]
private[simclusters_v2] val sortedScores: Array[Double]</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Build and return a Set of all clusters in this embedding</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
</dl>
<p>lazy val clusterIdSet: Set[ClusterId] = sortedClusterIds.toSet</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Build and return Seq representation of this embedding</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>lazy val embedding: Seq[(ClusterId, Double)] =</dt><dd><p>sortedClusterIds.zip(sortedScores).sortBy(-_._2).toSeq</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Build and return a Map representation of this embedding</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
</dl>
<p>lazy val map: Map[ClusterId, Double] = sortedClusterIds.zip(sortedScores).toMap</p>
<p>lazy val l1norm: Double = CosineSimilarityUtil.l1NormArray(sortedScores)</p>
<p>lazy val l2norm: Double = CosineSimilarityUtil.normArray(sortedScores)</p>
<p>lazy val logNorm: Double = CosineSimilarityUtil.logNormArray(sortedScores)</p>
<dl>
<dt>lazy val expScaledNorm: Double =</dt><dd><p>CosineSimilarityUtil.expScaledNormArray(sortedScores, DefaultExponent)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>The L2 Normalized Embedding. Optimize for Cosine Similarity Calculation.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>lazy val normalizedSortedScores: Array[Double] =</dt><dd><p>CosineSimilarityUtil.applyNormArray(sortedScores, l2norm)</p>
</dd>
<dt>lazy val logNormalizedSortedScores: Array[Double] =</dt><dd><p>CosineSimilarityUtil.applyNormArray(sortedScores, logNorm)</p>
</dd>
<dt>lazy val expScaledNormalizedSortedScores: Array[Double] =</dt><dd><p>CosineSimilarityUtil.applyNormArray(sortedScores, expScaledNorm)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>The Standard Deviation of an Embedding.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>lazy val std: Double = {</dt><dd><dl>
<dt>if (scores.isEmpty) {</dt><dd><p>0.0</p>
</dd>
<dt>} else {</dt><dd><p>val sum = scores.sum
val mean = sum / scores.length
var variance: Double = 0.0
for (i &lt;- scores.indices) {</p>
<blockquote>
<div><p>val v = scores(i) - mean
variance += (v * v)</p>
</div></blockquote>
<p>}
math.sqrt(variance / scores.length)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Return the score of a given clusterId.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>def get(clusterId: ClusterId): Option[Double] = {</dt><dd><p>var i = 0
while (i &lt; sortedClusterIds.length) {</p>
<blockquote>
<div><p>val thisId = sortedClusterIds(i)
if (clusterId == thisId) return Some(sortedScores(i))
if (thisId &gt; clusterId) return None
i += 1</p>
</div></blockquote>
<p>}
None</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Return the score of a given clusterId. If not exist, return default.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>def getOrElse(clusterId: ClusterId, default: Double = 0.0): Double = {</dt><dd><p>require(default &gt;= 0.0)
var i = 0
while (i &lt; sortedClusterIds.length) {</p>
<blockquote>
<div><p>val thisId = sortedClusterIds(i)
if (clusterId == thisId) return sortedScores(i)
if (thisId &gt; clusterId) return default
i += 1</p>
</div></blockquote>
<p>}
default</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Return the cluster ids</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
</dl>
<p>def getClusterIds(): Array[ClusterId] = clusterIds</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Return the cluster ids with the highest scores</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
</dl>
<p>def topClusterIds(size: Int): Seq[ClusterId] = clusterIds.take(size)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Return true if this embedding contains a given clusterId</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
</dl>
<p>def contains(clusterId: ClusterId): Boolean = clusterIdSet.contains(clusterId)</p>
<dl>
<dt>def sum(another: SimClustersEmbedding): SimClustersEmbedding = {</dt><dd><p>if (another.isEmpty) this
else if (this.isEmpty) another
else {</p>
<blockquote>
<div><p>var i1 = 0
var i2 = 0
val l = scala.collection.mutable.ArrayBuffer.empty[(Int, Double)]
while (i1 &lt; sortedClusterIds.length &amp;&amp; i2 &lt; another.sortedClusterIds.length) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (sortedClusterIds(i1) == another.sortedClusterIds(i2)) {</dt><dd><p>l += Tuple2(sortedClusterIds(i1), sortedScores(i1) + another.sortedScores(i2))
i1 += 1
i2 += 1</p>
</dd>
<dt>} else if (sortedClusterIds(i1) &gt; another.sortedClusterIds(i2)) {</dt><dd><p>l += Tuple2(another.sortedClusterIds(i2), another.sortedScores(i2))
// another cluster is lower. Increment it to see if the next one matches this’s
i2 += 1</p>
</dd>
<dt>} else {</dt><dd><p>l += Tuple2(sortedClusterIds(i1), sortedScores(i1))
// this cluster is lower. Increment it to see if the next one matches anothers’s
i1 += 1</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if (i1 == sortedClusterIds.length &amp;&amp; i2 != another.sortedClusterIds.length)</p>
<blockquote>
<div><p>// this was shorter. Prepend remaining elements from another
l ++= another.sortedClusterIds.drop(i2).zip(another.sortedScores.drop(i2))</p>
</div></blockquote>
<dl class="simple">
<dt>else if (i1 != sortedClusterIds.length &amp;&amp; i2 == another.sortedClusterIds.length)</dt><dd><p>// another was shorter. Prepend remaining elements from this
l ++= sortedClusterIds.drop(i1).zip(sortedScores.drop(i1))</p>
</dd>
</dl>
<p>SimClustersEmbedding(l)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def scalarMultiply(multiplier: Double): SimClustersEmbedding = {</dt><dd><p>require(multiplier &gt; 0.0, “SimClustersEmbedding.scalarMultiply requires multiplier &gt; 0.0”)
DefaultSimClustersEmbedding(</p>
<blockquote>
<div><p>clusterIds,
scores.map(_ * multiplier),
sortedClusterIds,
sortedScores.map(_ * multiplier)</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def scalarDivide(divisor: Double): SimClustersEmbedding = {</dt><dd><p>require(divisor &gt; 0.0, “SimClustersEmbedding.scalarDivide requires divisor &gt; 0.0”)
DefaultSimClustersEmbedding(</p>
<blockquote>
<div><p>clusterIds,
scores.map(_ / divisor),
sortedClusterIds,
sortedScores.map(_ / divisor)</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def dotProduct(another: SimClustersEmbedding): Double = {</dt><dd><dl class="simple">
<dt>CosineSimilarityUtil.dotProductForSortedClusterAndScores(</dt><dd><p>sortedClusterIds,
sortedScores,
another.sortedClusterIds,
another.sortedScores)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def cosineSimilarity(another: SimClustersEmbedding): Double = {</dt><dd><dl class="simple">
<dt>CosineSimilarityUtil.dotProductForSortedClusterAndScores(</dt><dd><p>sortedClusterIds,
normalizedSortedScores,
another.sortedClusterIds,
another.normalizedSortedScores)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def logNormCosineSimilarity(another: SimClustersEmbedding): Double = {</dt><dd><dl class="simple">
<dt>CosineSimilarityUtil.dotProductForSortedClusterAndScores(</dt><dd><p>sortedClusterIds,
logNormalizedSortedScores,
another.sortedClusterIds,
another.logNormalizedSortedScores)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def expScaledCosineSimilarity(another: SimClustersEmbedding): Double = {</dt><dd><dl class="simple">
<dt>CosineSimilarityUtil.dotProductForSortedClusterAndScores(</dt><dd><p>sortedClusterIds,
expScaledNormalizedSortedScores,
another.sortedClusterIds,
another.expScaledNormalizedSortedScores)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Return true if this is an empty embedding</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
</dl>
<p>def isEmpty: Boolean = sortedClusterIds.isEmpty</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Return the Jaccard Similarity Score between two embeddings.</p></li>
<li><p>Note: this implementation should be optimized if we start to use it in production</p></li>
</ul>
<p><a href="#id29"><span class="problematic" id="id30">*</span></a>/</p>
</dd>
<dt>def jaccardSimilarity(another: SimClustersEmbedding): Double = {</dt><dd><dl class="simple">
<dt>if (this.isEmpty || another.isEmpty) {</dt><dd><p>0.0</p>
</dd>
<dt>} else {</dt><dd><p>val intersect = clusterIdSet.intersect(another.clusterIdSet).size
val union = clusterIdSet.union(another.clusterIdSet).size
intersect.toDouble / union</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Return the Fuzzy Jaccard Similarity Score between two embeddings.</p></li>
<li><p>Treat each Simclusters embedding as fuzzy set, calculate the fuzzy set similarity</p></li>
<li><p>metrics of two embeddings</p></li>
<li></li>
<li><p>Paper 2.2.1: <a class="reference external" href="https://openreview.net/pdf?id=SkxXg2C5FX">https://openreview.net/pdf?id=SkxXg2C5FX</a></p></li>
</ul>
<p><a href="#id31"><span class="problematic" id="id32">*</span></a>/</p>
</dd>
<dt>def fuzzyJaccardSimilarity(another: SimClustersEmbedding): Double = {</dt><dd><dl>
<dt>if (this.isEmpty || another.isEmpty) {</dt><dd><p>0.0</p>
</dd>
<dt>} else {</dt><dd><p>val v1C = sortedClusterIds
val v1S = sortedScores
val v2C = another.sortedClusterIds
val v2S = another.sortedScores</p>
<p>require(v1C.length == v1S.length)
require(v2C.length == v2S.length)</p>
<p>var i1 = 0
var i2 = 0
var numerator = 0.0
var denominator = 0.0</p>
<dl>
<dt>while (i1 &lt; v1C.length &amp;&amp; i2 &lt; v2C.length) {</dt><dd><dl class="simple">
<dt>if (v1C(i1) == v2C(i2)) {</dt><dd><p>numerator += min(v1S(i1), v2S(i2))
denominator += max(v1S(i1), v2S(i2))
i1 += 1
i2 += 1</p>
</dd>
<dt>} else if (v1C(i1) &gt; v2C(i2)) {</dt><dd><p>denominator += v2S(i2)
i2 += 1</p>
</dd>
<dt>} else {</dt><dd><p>denominator += v1S(i1)
i1 += 1</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>while (i1 &lt; v1C.length) {</dt><dd><p>denominator += v1S(i1)
i1 += 1</p>
</dd>
</dl>
<p>}
while (i2 &lt; v2C.length) {</p>
<blockquote>
<div><p>denominator += v2S(i2)
i2 += 1</p>
</div></blockquote>
<p>}</p>
<p>numerator / denominator</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Return the Euclidean Distance Score between two embeddings.</p></li>
<li><p>Note: this implementation should be optimized if we start to use it in production</p></li>
</ul>
<p><a href="#id33"><span class="problematic" id="id34">*</span></a>/</p>
</dd>
<dt>def euclideanDistance(another: SimClustersEmbedding): Double = {</dt><dd><p>val unionClusters = clusterIdSet.union(another.clusterIdSet)
val variance = unionClusters.foldLeft(0.0) {</p>
<blockquote>
<div><dl class="simple">
<dt>case (sum, clusterId) =&gt;</dt><dd><p>val distance = math.abs(this.getOrElse(clusterId) - another.getOrElse(clusterId))
sum + distance * distance</p>
</dd>
</dl>
</div></blockquote>
<p>}
math.sqrt(variance)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Return the Manhattan Distance Score between two embeddings.</p></li>
<li><p>Note: this implementation should be optimized if we start to use it in production</p></li>
</ul>
<p><a href="#id35"><span class="problematic" id="id36">*</span></a>/</p>
</dd>
<dt>def manhattanDistance(another: SimClustersEmbedding): Double = {</dt><dd><p>val unionClusters = clusterIdSet.union(another.clusterIdSet)
unionClusters.foldLeft(0.0) {</p>
<blockquote>
<div><dl class="simple">
<dt>case (sum, clusterId) =&gt;</dt><dd><p>sum + math.abs(this.getOrElse(clusterId) - another.getOrElse(clusterId))</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Return the number of overlapping clusters between two embeddings.</p></li>
</ul>
<p><a href="#id37"><span class="problematic" id="id38">*</span></a>/</p>
</dd>
<dt>def overlappingClusters(another: SimClustersEmbedding): Int = {</dt><dd><p>var i1 = 0
var i2 = 0
var count = 0</p>
<dl>
<dt>while (i1 &lt; sortedClusterIds.length &amp;&amp; i2 &lt; another.sortedClusterIds.length) {</dt><dd><dl class="simple">
<dt>if (sortedClusterIds(i1) == another.sortedClusterIds(i2)) {</dt><dd><p>count += 1
i1 += 1
i2 += 1</p>
</dd>
<dt>} else if (sortedClusterIds(i1) &gt; another.sortedClusterIds(i2)) {</dt><dd><p>// v2 cluster is lower. Increment it to see if the next one matches v1’s
i2 += 1</p>
</dd>
<dt>} else {</dt><dd><p>// v1 cluster is lower. Increment it to see if the next one matches v2’s
i1 += 1</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
count</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Return the largest product cluster scores</p></li>
</ul>
<p><a href="#id39"><span class="problematic" id="id40">*</span></a>/</p>
</dd>
<dt>def maxElementwiseProduct(another: SimClustersEmbedding): Double = {</dt><dd><p>var i1 = 0
var i2 = 0
var maxProduct: Double = 0.0</p>
<dl>
<dt>while (i1 &lt; sortedClusterIds.length &amp;&amp; i2 &lt; another.sortedClusterIds.length) {</dt><dd><dl class="simple">
<dt>if (sortedClusterIds(i1) == another.sortedClusterIds(i2)) {</dt><dd><p>val product = sortedScores(i1) * another.sortedScores(i2)
if (product &gt; maxProduct) maxProduct = product
i1 += 1
i2 += 1</p>
</dd>
<dt>} else if (sortedClusterIds(i1) &gt; another.sortedClusterIds(i2)) {</dt><dd><p>// v2 cluster is lower. Increment it to see if the next one matches v1’s
i2 += 1</p>
</dd>
<dt>} else {</dt><dd><p>// v1 cluster is lower. Increment it to see if the next one matches v2’s
i1 += 1</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
maxProduct</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Return a new SimClustersEmbedding with Max Embedding Size.</p></li>
<li></li>
<li><p>Prefer to truncate on embedding construction where possible. Doing so is cheaper.</p></li>
</ul>
<p><a href="#id41"><span class="problematic" id="id42">*</span></a>/</p>
</dd>
<dt>def truncate(size: Int): SimClustersEmbedding = {</dt><dd><dl>
<dt>if (clusterIds.length &lt;= size) {</dt><dd><p>this</p>
</dd>
<dt>} else {</dt><dd><p>val truncatedClusterIds = clusterIds.take(size)
val truncatedScores = scores.take(size)
val (sortedClusterIds, sortedScores) =</p>
<blockquote>
<div><p>truncatedClusterIds.zip(truncatedScores).sortBy(_._1).unzip</p>
</div></blockquote>
<dl class="simple">
<dt>DefaultSimClustersEmbedding(</dt><dd><p>truncatedClusterIds,
truncatedScores,
sortedClusterIds,
sortedScores)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def toNormalized: SimClustersEmbedding = {</dt><dd><p>// Additional safety check. Only EmptyEmbedding’s l2norm is 0.0.
if (l2norm == 0.0) {</p>
<blockquote>
<div><p>EmptyEmbedding</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>this.scalarDivide(l2norm)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>implicit def toThrift: ThriftSimClustersEmbedding = {</dt><dd><dl>
<dt>ThriftSimClustersEmbedding(</dt><dd><dl class="simple">
<dt>embedding.map {</dt><dd><dl class="simple">
<dt>case (clusterId, score) =&gt;</dt><dd><p>SimClusterWithScore(clusterId, score)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<p>def canEqual(a: Any): Boolean = a.isInstanceOf[SimClustersEmbedding]</p>
<dl>
<dt>/* We define equality as having the same clusters and scores.</dt><dd><ul class="simple">
<li><p>This implementation is arguably incorrect in this case:</p></li>
<li><p>(1 -&gt; 1.0, 2 -&gt; 0.0) == (1 -&gt; 1.0)  // equals returns false</p></li>
<li><p>However, compliant implementations of SimClustersEmbedding should not include zero-weight</p></li>
<li><p>clusters, so this implementation should work correctly.</p></li>
</ul>
<p><a href="#id43"><span class="problematic" id="id44">*</span></a>/</p>
</dd>
<dt>override def equals(that: Any): Boolean =</dt><dd><dl>
<dt>that match {</dt><dd><dl class="simple">
<dt>case that: SimClustersEmbedding =&gt;</dt><dd><dl class="simple">
<dt>that.canEqual(this) &amp;&amp;</dt><dd><p>this.sortedClusterIds.sameElements(that.sortedClusterIds) &amp;&amp;
this.sortedScores.sameElements(that.sortedScores)</p>
</dd>
</dl>
</dd>
</dl>
<p>case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>hashcode implementation based on the contents of the embedding. As a lazy val, this relies on</p></li>
<li><p>the embedding contents being immutable.</p></li>
</ul>
<p><a href="#id45"><span class="problematic" id="id46">*</span></a>/</p>
</dd>
<dt>override lazy val hashCode: Int = {</dt><dd><dl>
<dt>/* Arrays uses object id as hashCode, so different arrays with the same contents hash</dt><dd><ul class="simple">
<li><p>differently. To provide a stable hash code, we take the same approach as how a</p></li>
<li><p><cite>case class(clusters: Seq[Int], scores: Seq[Double])</cite> would be hashed. See</p></li>
<li><p>ScalaRunTime._hashCode and MurmurHash3.productHash</p></li>
<li><p><a class="reference external" href="https://github.com/scala/scala/blob/2.12.x/src/library/scala/runtime/ScalaRunTime.scala#L167">https://github.com/scala/scala/blob/2.12.x/src/library/scala/runtime/ScalaRunTime.scala#L167</a></p></li>
<li><p><a class="reference external" href="https://github.com/scala/scala/blob/2.12.x/src/library/scala/util/hashing/MurmurHash3.scala#L64">https://github.com/scala/scala/blob/2.12.x/src/library/scala/util/hashing/MurmurHash3.scala#L64</a></p></li>
<li></li>
<li><p>Note that the hashcode is arguably incorrect in this case:</p></li>
<li><p>(1 -&gt; 1.0, 2 -&gt; 0.0).hashcode == (1 -&gt; 1.0).hashcode  // returns false</p></li>
<li><p>However, compliant implementations of SimClustersEmbedding should not include zero-weight</p></li>
<li><p>clusters, so this implementation should work correctly.</p></li>
</ul>
<p><a href="#id47"><span class="problematic" id="id48">*</span></a>/</p>
</dd>
</dl>
<p>productHash((arrayHash(sortedClusterIds), arrayHash(sortedScores)))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>object SimClustersEmbedding {</dt><dd><dl class="simple">
<dt>val EmptyEmbedding: SimClustersEmbedding =</dt><dd><p>DefaultSimClustersEmbedding(Array.empty, Array.empty, Array.empty, Array.empty)</p>
</dd>
</dl>
<p>val DefaultExponent: Double = 0.3</p>
<p>// Descending by score then ascending by ClusterId
implicit val order: Ordering[(ClusterId, Double)] =</p>
<blockquote>
<div><dl>
<dt>(a: (ClusterId, Double), b: (ClusterId, Double)) =&gt; {</dt><dd><dl class="simple">
<dt>b._2 compare a._2 match {</dt><dd><p>case 0 =&gt; a._1 compare b._1
case c =&gt; c</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Constructors</p></li>
<li></li>
<li><p>These constructors:</p></li>
<li><ul>
<li><p>do not make assumptions about the ordering of the cluster/scores.</p></li>
</ul>
</li>
<li><ul>
<li><p>do assume that cluster ids are unique</p></li>
</ul>
</li>
<li><ul>
<li><p>ignore (drop) any cluster whose score is &lt;= 0</p></li>
</ul>
</li>
</ul>
<p><a href="#id49"><span class="problematic" id="id50">*</span></a>/</p>
</dd>
<dt>def apply(embedding: (ClusterId, Double)*): SimClustersEmbedding =</dt><dd><p>buildDefaultSimClustersEmbedding(embedding)</p>
</dd>
<dt>def apply(embedding: Iterable[(ClusterId, Double)]): SimClustersEmbedding =</dt><dd><p>buildDefaultSimClustersEmbedding(embedding)</p>
</dd>
<dt>def apply(embedding: Iterable[(ClusterId, Double)], size: Int): SimClustersEmbedding =</dt><dd><p>buildDefaultSimClustersEmbedding(embedding, truncate = Some(size))</p>
</dd>
<dt>implicit def apply(thriftEmbedding: ThriftSimClustersEmbedding): SimClustersEmbedding =</dt><dd><p>buildDefaultSimClustersEmbedding(thriftEmbedding.embedding.map(_.toTuple))</p>
</dd>
<dt>def apply(thriftEmbedding: ThriftSimClustersEmbedding, truncate: Int): SimClustersEmbedding =</dt><dd><dl class="simple">
<dt>buildDefaultSimClustersEmbedding(</dt><dd><p>thriftEmbedding.embedding.map(_.toTuple),
truncate = Some(truncate))</p>
</dd>
</dl>
</dd>
<dt>private def buildDefaultSimClustersEmbedding(</dt><dd><p>embedding: Iterable[(ClusterId, Double)],
truncate: Option[Int] = None</p>
</dd>
<dt>): SimClustersEmbedding = {</dt><dd><dl>
<dt>val truncatedIdAndScores = {</dt><dd><p>val idsAndScores = embedding.filter(_._2 &gt; 0.0).toArray.sorted(order)
truncate match {</p>
<blockquote>
<div><p>case Some(t) =&gt; idsAndScores.take(t)
case _ =&gt; idsAndScores</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (truncatedIdAndScores.isEmpty) {</dt><dd><p>EmptyEmbedding</p>
</dd>
<dt>} else {</dt><dd><p>val (clusterIds, scores) = truncatedIdAndScores.unzip
val (sortedClusterIds, sortedScores) = truncatedIdAndScores.sortBy(_._1).unzip
DefaultSimClustersEmbedding(clusterIds, scores, sortedClusterIds, sortedScores)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>/** <strong>*</strong> Aggregation Methods <strong>**</strong>/
/**</p>
<blockquote>
<div><ul class="simple">
<li><p>A high performance version of Sum a list of SimClustersEmbeddings.</p></li>
<li><p>Suggest using in Online Services to avoid the unnecessary GC.</p></li>
<li><p>For offline or streaming. Please check [[SimClustersEmbeddingMonoid]]</p></li>
</ul>
<p><a href="#id51"><span class="problematic" id="id52">*</span></a>/</p>
</div></blockquote>
<dl>
<dt>def sum(simClustersEmbeddings: Iterable[SimClustersEmbedding]): SimClustersEmbedding = {</dt><dd><dl>
<dt>if (simClustersEmbeddings.isEmpty) {</dt><dd><p>EmptyEmbedding</p>
</dd>
<dt>} else {</dt><dd><dl>
<dt>val sum = simClustersEmbeddings.foldLeft(mutable.Map[ClusterId, Double]()) {</dt><dd><dl>
<dt>(sum, embedding) =&gt;</dt><dd><dl class="simple">
<dt>for (i &lt;- embedding.sortedClusterIds.indices) {</dt><dd><p>val clusterId = embedding.sortedClusterIds(i)
sum.put(clusterId, embedding.sortedScores(i) + sum.getOrElse(clusterId, 0.0))</p>
</dd>
</dl>
<p>}
sum</p>
</dd>
</dl>
</dd>
</dl>
<p>}
SimClustersEmbedding(sum)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Support a fixed size SimClustersEmbedding Sum</p></li>
</ul>
<p><a href="#id53"><span class="problematic" id="id54">*</span></a>/</p>
</dd>
<dt>def sum(</dt><dd><p>simClustersEmbeddings: Iterable[SimClustersEmbedding],
maxSize: Int</p>
</dd>
<dt>): SimClustersEmbedding = {</dt><dd><p>sum(simClustersEmbeddings).truncate(maxSize)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A high performance version of Mean a list of SimClustersEmbeddings.</p></li>
<li><p>Suggest using in Online Services to avoid the unnecessary GC.</p></li>
</ul>
<p><a href="#id55"><span class="problematic" id="id56">*</span></a>/</p>
</dd>
<dt>def mean(simClustersEmbeddings: Iterable[SimClustersEmbedding]): SimClustersEmbedding = {</dt><dd><dl class="simple">
<dt>if (simClustersEmbeddings.isEmpty) {</dt><dd><p>EmptyEmbedding</p>
</dd>
<dt>} else {</dt><dd><p>sum(simClustersEmbeddings).scalarDivide(simClustersEmbeddings.size)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Support a fixed size SimClustersEmbedding Mean</p></li>
</ul>
<p><a href="#id57"><span class="problematic" id="id58">*</span></a>/</p>
</dd>
<dt>def mean(</dt><dd><p>simClustersEmbeddings: Iterable[SimClustersEmbedding],
maxSize: Int</p>
</dd>
<dt>): SimClustersEmbedding = {</dt><dd><p>mean(simClustersEmbeddings).truncate(maxSize)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class DefaultSimClustersEmbedding(</dt><dd><p>override val clusterIds: Array[ClusterId],
override val scores: Array[Double],
override val sortedClusterIds: Array[ClusterId],
override val sortedScores: Array[Double])</p>
<blockquote>
<div><p>extends SimClustersEmbedding {</p>
</div></blockquote>
<dl class="simple">
<dt>override def toString: String =</dt><dd><p>s”DefaultSimClustersEmbedding(${clusterIds.zip(scores).mkString(“,”)})”</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>object DefaultSimClustersEmbedding {</dt><dd><p>// To support existing code which builds embeddings from a Seq
def apply(embedding: Seq[(ClusterId, Double)]): SimClustersEmbedding = SimClustersEmbedding(</p>
<blockquote>
<div><p>embedding)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../_sources/src/scala/com/twitter/simclusters_v2/common/SimClustersEmbedding.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>