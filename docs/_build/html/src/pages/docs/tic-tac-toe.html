<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>docs/src/pages/docs/tic-tac-toe.md &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="docs-src-pages-docs-tic-tac-toe-md">
<h1>docs/src/pages/docs/tic-tac-toe.md<a class="headerlink" href="#docs-src-pages-docs-tic-tac-toe-md" title="Permalink to this heading">Â¶</a></h1>
<p>Last edited: 2022-12-14 20:15:57</p>
<p>Contents:</p>
<div class="highlight-md notranslate"><div class="highlight"><pre><span></span>---
</pre></div>
</div>
<p>title: Project - Tic-Tac-Toe
description: Anchor - Milestone Project - Tic-Tac-Toe
â€”</p>
<p>&gt; [Program Code](<a class="reference external" href="https://github.com/coral-xyz/anchor/tree/master/docs/programs/tic-tac-toe">https://github.com/coral-xyz/anchor/tree/master/docs/programs/tic-tac-toe</a>)</p>
<p>Youâ€™re now ready to build your first anchor project. Create a new anchor workspace with</p>
<p><code class="docutils literal notranslate"><span class="pre">`shell</span>
<span class="pre">anchor</span> <span class="pre">init</span> <span class="pre">tic-tac-toe</span>
<span class="pre">`</span></code></p>
<p>The program will have 2 instructions. First, we need to setup the game. We need to save who is playing it and create a board to play on. Then, the players take turns until there is a winner or a tie.</p>
<p>We recommend keeping programs in a single <cite>lib.rs</cite> file until they get too big. We would not split up this project into multiple files either but there is a section at the end of this chapter that explains how to do it for this and other programs.</p>
<p>## Setting up the game</p>
<p>### State</p>
<p>Letâ€™s begin by thinking about what data we should store. Each game has players, turns, a board, and a game state. This game state describes whether the game is active, tied, or one of the two players won. We can save all this data in an account. This means that each new game will have its own account. Add the following to the bottom of the <cite>lib.rs</cite> file:</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>rust
#[account]
pub struct Game {</p>
<blockquote>
<div><p>players: [Pubkey; 2],          // (32 * 2)
turn: u8,                      // 1
board: [[Option&lt;Sign&gt;; 3]; 3], // 9 * (1 + 1) = 18
state: GameState,              // 32 + 1</p>
</div></blockquote>
<section id="id5">
<h2>}<a class="headerlink" href="#id5" title="Permalink to this heading">Â¶</a></h2>
<p>This is the game account. Next to the field definitions, you can see how many bytes each field requires. This will be very important later. Letâ€™s also add the <cite>Sign</cite> and the <cite>GameState</cite> type.</p>
<p><a href="#id6"><span class="problematic" id="id7">``</span></a><a href="#id8"><span class="problematic" id="id9">`</span></a>rust
#[derive(AnchorSerialize, AnchorDeserialize, Clone, PartialEq, Eq)]
pub enum GameState {</p>
<blockquote>
<div><p>Active,
Tie,
Won { winner: Pubkey },</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>#[derive(</dt><dd><p>AnchorSerialize,
AnchorDeserialize,
FromPrimitive,
ToPrimitive,
Copy,
Clone,
PartialEq,
Eq</p>
</dd>
</dl>
<p>)]
pub enum Sign {</p>
<blockquote>
<div><p>X,
O,</p>
</div></blockquote>
</section>
<section id="id10">
<h2>}<a class="headerlink" href="#id10" title="Permalink to this heading">Â¶</a></h2>
<p>Both <cite>GameState</cite> and <cite>Sign</cite> derive some traits. <cite>AnchorSerialize</cite> and <cite>AnchorDeserialize</cite> are the crucial ones. All types that are used in types that are marked with <cite>#[account]</cite> must implement these two traits (or be marked with <cite>#[account]</cite> themselves). All other traits are important to our game logic and we are going to use them later. Generally, it is good practice to derive even more traits to make the life of others trying to interface with your program easier (see [Rustâ€™s API guidelines](<a class="reference external" href="https://rust-lang.github.io/api-guidelines/interoperability.html#types-eagerly-implement-common-traits-c-common-traits">https://rust-lang.github.io/api-guidelines/interoperability.html#types-eagerly-implement-common-traits-c-common-traits</a>)) but for brevityâ€™s sake, we are not going to do that in this guide.</p>
<p>This wonâ€™t quite work yet because <cite>FromPrimitive</cite> and <cite>ToPrimitive</cite> are unknown. Go to the <cite>Cargo.toml</cite> file right outside <cite>src</cite> (not the one at the root of the workspace) and add these two dependencies:</p>
<p><code class="docutils literal notranslate"><span class="pre">`toml</span>
<span class="pre">num-traits</span> <span class="pre">=</span> <span class="pre">&quot;0.2&quot;</span>
<span class="pre">num-derive</span> <span class="pre">=</span> <span class="pre">&quot;0.3&quot;</span>
<span class="pre">`</span></code></p>
<p>Then, import them at the top of <cite>lib.rs</cite>:</p>
<p><code class="docutils literal notranslate"><span class="pre">`rust</span>
<span class="pre">use</span> <span class="pre">num_derive::*;</span>
<span class="pre">use</span> <span class="pre">num_traits::*;</span>
<span class="pre">`</span></code></p>
<p>Now add the game logic:</p>
<p><a href="#id11"><span class="problematic" id="id12">``</span></a><a href="#id13"><span class="problematic" id="id14">`</span></a>rust
impl Game {</p>
<blockquote>
<div><p>pub const MAXIMUM_SIZE: usize = (32 * 2) + 1 + (9 * (1 + 1)) + (32 + 1);</p>
<dl class="simple">
<dt>pub fn start(&amp;mut self, players: [Pubkey; 2]) -&gt; Result&lt;()&gt; {</dt><dd><p>require_eq!(self.turn, 0, TicTacToeError::GameAlreadyStarted);
self.players = players;
self.turn = 1;
Ok(())</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>pub fn is_active(&amp;self) -&gt; bool {</dt><dd><p>self.state == GameState::Active</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>fn current_player_index(&amp;self) -&gt; usize {</dt><dd><p>((self.turn - 1) % 2) as usize</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>pub fn current_player(&amp;self) -&gt; Pubkey {</dt><dd><p>self.players[self.current_player_index()]</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>pub fn play(&amp;mut self, tile: &amp;Tile) -&gt; Result&lt;()&gt; {</dt><dd><p>require!(self.is_active(), TicTacToeError::GameAlreadyOver);</p>
<dl>
<dt>match tile {</dt><dd><dl>
<dt>tile &#64; Tile {</dt><dd><p>row: 0..=2,
column: 0..=2,</p>
</dd>
<dt>} =&gt; match self.board[tile.row as usize][tile.column as usize] {</dt><dd><p>Some(_) =&gt; return Err(TicTacToeError::TileAlreadySet.into()),
None =&gt; {</p>
<blockquote>
<div><dl class="simple">
<dt>self.board[tile.row as usize][tile.column as usize] =</dt><dd><p>Some(Sign::from_usize(self.current_player_index()).unwrap());</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>},
_ =&gt; return Err(TicTacToeError::TileOutOfBounds.into()),</p>
</dd>
</dl>
<p>}</p>
<p>self.update_state();</p>
<dl class="simple">
<dt>if GameState::Active == self.state {</dt><dd><p>self.turn += 1;</p>
</dd>
</dl>
<p>}</p>
<p>Ok(())</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>fn is_winning_trio(&amp;self, trio: [(usize, usize); 3]) -&gt; bool {</dt><dd><p>let [first, second, third] = trio;
self.board[first.0][first.1].is_some()</p>
<blockquote>
<div><p>&amp;&amp; self.board[first.0][first.1] == self.board[second.0][second.1]
&amp;&amp; self.board[first.0][first.1] == self.board[third.0][third.1]</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>fn update_state(&amp;mut self) {</dt><dd><dl>
<dt>for i in 0..=2 {</dt><dd><p>// three of the same in one row
if self.is_winning_trio([(i, 0), (i, 1), (i, 2)]) {</p>
<blockquote>
<div><dl class="simple">
<dt>self.state = GameState::Won {</dt><dd><p>winner: self.current_player(),</p>
</dd>
</dl>
<p>};
return;</p>
</div></blockquote>
<p>}
// three of the same in one column
if self.is_winning_trio([(0, i), (1, i), (2, i)]) {</p>
<blockquote>
<div><dl class="simple">
<dt>self.state = GameState::Won {</dt><dd><p>winner: self.current_player(),</p>
</dd>
</dl>
<p>};
return;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// three of the same in one diagonal
if self.is_winning_trio([(0, 0), (1, 1), (2, 2)])</p>
<blockquote>
<div><p>|| self.is_winning_trio([(0, 2), (1, 1), (2, 0)])</p>
</div></blockquote>
<dl>
<dt>{</dt><dd><dl class="simple">
<dt>self.state = GameState::Won {</dt><dd><p>winner: self.current_player(),</p>
</dd>
</dl>
<p>};
return;</p>
</dd>
</dl>
<p>}</p>
<p>// reaching this code means the game has not been won,
// so if there are unfilled tiles left, itâ€™s still active
for row in 0..=2 {</p>
<blockquote>
<div><dl>
<dt>for column in 0..=2 {</dt><dd><dl class="simple">
<dt>if self.board[row][column].is_none() {</dt><dd><p>return;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// game has not been won
// game has no more free tiles
// -&gt; game ends in a tie
self.state = GameState::Tie;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</section>
<section id="id15">
<h2>}<a class="headerlink" href="#id15" title="Permalink to this heading">Â¶</a></h2>
<p>We are not going to explore this code in detail together because itâ€™s rather simple rust code. Itâ€™s just tic-tac-toe after all! Roughly, what happens when <cite>play</cite> is called:</p>
<ol class="arabic simple">
<li><p>Return error if game is over or
return error if given row or column are outside the 3x3 board or
return error if tile on board is already set</p></li>
<li><p>Determine current player and set tile to X or O</p></li>
<li><p>Update game state</p></li>
<li><p>If game is still active, increase the turn</p></li>
</ol>
<p>Currently, the code doesnâ€™t compile because we need to add the <cite>Tile</cite></p>
<p><a href="#id16"><span class="problematic" id="id17">``</span></a><a href="#id18"><span class="problematic" id="id19">`</span></a>rust
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct Tile {</p>
<blockquote>
<div><p>row: u8,
column: u8,</p>
</div></blockquote>
</section>
<section id="id20">
<h2>}<a class="headerlink" href="#id20" title="Permalink to this heading">Â¶</a></h2>
<p>and the <cite>TicTacToeError</cite> type.</p>
<p><a href="#id21"><span class="problematic" id="id22">``</span></a><a href="#id23"><span class="problematic" id="id24">`</span></a>rust
#[error_code]
pub enum TicTacToeError {</p>
<blockquote>
<div><p>TileOutOfBounds,
TileAlreadySet,
GameAlreadyOver,
NotPlayersTurn,
GameAlreadyStarted</p>
</div></blockquote>
</section>
<section id="id25">
<h2>}<a class="headerlink" href="#id25" title="Permalink to this heading">Â¶</a></h2>
<p>### The Setup Instruction</p>
<p>Before we write any game logic, we can add the instruction that will set up the game in its initial state. Rename the already existing instruction function and accounts struct to <cite>setup_game</cite> and <cite>SetupGame</cite> respectively. Now think about which accounts are needed to set up the game. Clearly, we need the game account. Before we can fill it with values, we need to create it. For that, we use the <cite>init</cite> constraint.</p>
<p><a href="#id26"><span class="problematic" id="id27">``</span></a><a href="#id28"><span class="problematic" id="id29">`</span></a>rust
#[derive(Accounts)]
pub struct SetupGame&lt;â€™info&gt; {</p>
<blockquote>
<div><p>#[account(init)]
pub game: Account&lt;â€™info, Game&gt;</p>
</div></blockquote>
</section>
<section id="id30">
<h2>}<a class="headerlink" href="#id30" title="Permalink to this heading">Â¶</a></h2>
<p><cite>init</cite> immediately shouts at us and tells us to add a payer. Why do we need it? Because <cite>init</cite> creates <cite>rent-exempt</cite> accounts and someone has to pay for that. Naturally, if we want to take money from someone, we should make them sign as well as mark their account as mutable.</p>
<p><a href="#id31"><span class="problematic" id="id32">``</span></a><a href="#id33"><span class="problematic" id="id34">`</span></a>rust
#[derive(Accounts)]
pub struct SetupGame&lt;â€™info&gt; {</p>
<blockquote>
<div><p>#[account(init, payer = player_one)]
pub game: Account&lt;â€™info, Game&gt;,
#[account(mut)]
pub player_one: Signer&lt;â€™info&gt;</p>
</div></blockquote>
</section>
<section id="id35">
<h2>}<a class="headerlink" href="#id35" title="Permalink to this heading">Â¶</a></h2>
<p><cite>init</cite> is not happy yet. It wants the system program to be inside the struct because <cite>init</cite> creates the game account by making a call to that program. So letâ€™s add it.</p>
<p><a href="#id36"><span class="problematic" id="id37">``</span></a><a href="#id38"><span class="problematic" id="id39">`</span></a>rust
#[derive(Accounts)]
pub struct SetupGame&lt;â€™info&gt; {</p>
<blockquote>
<div><p>#[account(init, payer = player_one)]
pub game: Account&lt;â€™info, Game&gt;,
#[account(mut)]
pub player_one: Signer&lt;â€™info&gt;,
pub system_program: Program&lt;â€™info, System&gt;</p>
</div></blockquote>
</section>
<section id="id40">
<h2>}<a class="headerlink" href="#id40" title="Permalink to this heading">Â¶</a></h2>
<p>Thereâ€™s one more thing to do to complete <cite>SetupGame</cite>. Every account is created with a fixed amount of space, so we have to add this space to the instruction as well. This is what the comments next to the <cite>Game</cite> struct indicated.</p>
<p><a href="#id41"><span class="problematic" id="id42">``</span></a><a href="#id43"><span class="problematic" id="id44">`</span></a>rust
#[derive(Accounts)]
pub struct SetupGame&lt;â€™info&gt; {</p>
<blockquote>
<div><p>#[account(init, payer = player_one, space = 8 + Game::MAXIMUM_SIZE)]
pub game: Account&lt;â€™info, Game&gt;,
#[account(mut)]
pub player_one: Signer&lt;â€™info&gt;,
pub system_program: Program&lt;â€™info, System&gt;</p>
</div></blockquote>
</section>
<section id="id45">
<h2>}<a class="headerlink" href="#id45" title="Permalink to this heading">Â¶</a></h2>
<p>Let us briefly explain how we arrived at the <cite>Game::MAXIMUM_SIZE</cite>. Anchor uses the [borsh](<a class="reference external" href="https://borsh.io">https://borsh.io</a>) specification to (de)serialize its state accounts.</p>
<ul class="simple">
<li><p>Pubkey has a length of <cite>32</cite> bytes so <cite>2*32 = 64</cite></p></li>
<li><p>u8 as a vector has a length of <cite>1</cite></p></li>
<li><p>the <cite>board</cite> has a length of (<cite>9 * (1 + 1)</cite>). We know the board has 9 tiles (-&gt; <cite>9</cite>) of type <cite>Option</cite> which borsh serializes with 1 byte (set to <cite>1</cite> for Some and <cite>0</cite> for None) plus the size of whateverâ€™s in the <cite>Option</cite>. In this case, itâ€™s a simple enum with types that donâ€™t hold more types so the maximum size of the enum is also just <cite>1</cite> (for its discriminant). In total that means we get <cite>9 (tiles) * (1 (Option) + 1(Sign discriminant))</cite>.</p></li>
<li><p><cite>state</cite> is also an enum so we need <cite>1</cite> byte for the discriminant. We have to init the account with the maximum size and the maximum size of an enum is the size of its biggest variant. In this case thatâ€™s the <cite>winner</cite> variant which holds a Pubkey. A Pubkey is <cite>32</cite> bytes long so the size of <cite>state</cite> is <cite>1 (discriminant) + 32 (winner pubkey)</cite> (<cite>MAXIMUM_SIZE</cite> is a [<cite>const</cite>](<a class="reference external" href="https://doc.rust-lang.org/std/keyword.const.html">https://doc.rust-lang.org/std/keyword.const.html</a>) variable so specifying it in terms of a sum of the sizes of <cite>Game</cite>â€™s membersâ€™ fields does not incur any runtime cost).</p></li>
</ul>
<p>In addition to the gameâ€™s size, we have to add another 8 to the space. This is space for the internal discriminator which anchor sets automatically. In short, the discriminator is how anchor can differentiate between different accounts of the same program. For more information, check out the Anchor space reference.</p>
<p>&gt; [Anchor Space Reference](./../anchor_references/space.md)</p>
<p>&gt; (What about using <cite>mem::size_of&lt;Game&gt;()</cite>? This almost works but not quite. The issue is that borsh will always serialize an option as 1 byte for the variant identifier and then additional x bytes for the content if itâ€™s Some. Rust uses null-pointer optimization to make Optionâ€™s variant identifier 0 bytes when it can, so an option is sometimes just as big as its contents. This is the case with <cite>Sign</cite>. This means the <cite>MAXIMUM_SIZE</cite> could also be expressed as <cite>mem::size_of&lt;Game&gt;() + 9</cite>.)</p>
<p>And with this, <cite>SetupGame</cite> is complete and we can move on to the <cite>setup_game</cite> function. (If you like playing detective, you can pause here and try to figure out why what we just did will not work. Hint: Have a look at the [specification](<a class="reference external" href="https://borsh.io/">https://borsh.io/</a>) of the serialization library Anchor uses. If you cannot figure it out, donâ€™t worry. We are going to fix it very soon, together.)</p>
<p>Letâ€™s start by adding an argument to the <cite>setup_game</cite> function.</p>
<p><a href="#id46"><span class="problematic" id="id47">``</span></a><a href="#id48"><span class="problematic" id="id49">`</span></a>rust
pub fn setup_game(ctx: Context&lt;SetupGame&gt;, player_two: Pubkey) -&gt; Result&lt;()&gt; {</p>
</section>
<section id="id50">
<h2>}<a class="headerlink" href="#id50" title="Permalink to this heading">Â¶</a></h2>
<p>Why didnâ€™t we just add <cite>player_two</cite> as an account in the accounts struct? There are two reasons for this. First, adding it there requires a little more space in the transaction that saves whether the account is writable and whether itâ€™s a signer. But we care about neither the mutability of the account nor whether itâ€™s a signer. We just need its address. This brings us to the second and more important reason: Simultaneous network transactions can affect each other if they share the same accounts. For example, if we add <cite>player_two</cite> to the accounts struct, during our transaction, no other transaction can edit <cite>player_two</cite>â€™s account. Therefore, we block all other transactions that want to edit <cite>player_two</cite>â€™s account, even though we neither want to read from nor write to the account. We just care about its address!</p>
<p>Finish the instruction function by setting the game to its initial values:</p>
<p><a href="#id51"><span class="problematic" id="id52">``</span></a><a href="#id53"><span class="problematic" id="id54">`</span></a>rust
pub fn setup_game(ctx: Context&lt;SetupGame&gt;, player_two: Pubkey) -&gt; Result&lt;()&gt; {</p>
<blockquote>
<div><p>ctx.accounts.game.start([ctx.accounts.player_one.key(), player_two])</p>
</div></blockquote>
</section>
<section id="id55">
<h2>}<a class="headerlink" href="#id55" title="Permalink to this heading">Â¶</a></h2>
<p>Now, run <cite>anchor build</cite>. On top of compiling your program, this command creates an [IDL](<a class="reference external" href="https://en.wikipedia.org/wiki/Interface_description_language">https://en.wikipedia.org/wiki/Interface_description_language</a>) for your program. You can find it in <cite>target/idl</cite>. The anchor typescript client can automatically parse this IDL and generate functions based on it. What this means is that each anchor program gets its own typescript client for free! (Technically, you donâ€™t have to call <cite>anchor build</cite> before testing. <cite>anchor test</cite> will do it for you.)</p>
<p>### Testing the Setup Instruction</p>
<p>Time to test our code! Head over into the <cite>tests</cite> folder in the root directory. Open the <cite>tic-tac-toe.ts</cite> file and remove the existing <cite>it</cite> test. Then, put the following into the <cite>describe</cite> section:</p>
<p><a href="#id56"><span class="problematic" id="id57">``</span></a><a href="#id58"><span class="problematic" id="id59">`</span></a>typescript
it(â€˜setup game!â€™, async () =&gt; {</p>
<blockquote>
<div><p>const gameKeypair = anchor.web3.Keypair.generate()
const playerOne = (program.provider as anchor.AnchorProvider).wallet
const playerTwo = anchor.web3.Keypair.generate()
await program.methods</p>
<blockquote>
<div><p>.setupGame(playerTwo.publicKey)
.accounts({</p>
<blockquote>
<div><p>game: gameKeypair.publicKey,
playerOne: playerOne.publicKey,</p>
</div></blockquote>
<p>})
.signers([gameKeypair])
.rpc()</p>
</div></blockquote>
<p>let gameState = await program.account.game.fetch(gameKeypair.publicKey)
expect(gameState.turn).to.equal(1)
expect(gameState.players).to.eql([playerOne.publicKey, playerTwo.publicKey])
expect(gameState.state).to.eql({ active: {} })
expect(gameState.board).to.eql([</p>
<blockquote>
<div><p>[null, null, null],
[null, null, null],
[null, null, null],</p>
</div></blockquote>
<p>])</p>
</div></blockquote>
</section>
<section id="id60">
<h2>})<a class="headerlink" href="#id60" title="Permalink to this heading">Â¶</a></h2>
<p>and add this to the top of your file:</p>
<p><code class="docutils literal notranslate"><span class="pre">`typescript</span>
<span class="pre">import</span> <span class="pre">{</span> <span class="pre">expect</span> <span class="pre">}</span> <span class="pre">from</span> <span class="pre">'chai'</span>
<span class="pre">`</span></code></p>
<p>&gt; When you adjust your test files it may happen that youâ€™ll see errors everywhere.
&gt; This is likely because the test file is looking for types from your program that havenâ€™t been generated yet.
&gt; To generate them, run <cite>anchor build</cite>. This builds the program and creates the idl and typescript types.</p>
<p>The test begins by creating some keypairs. Importantly, <cite>playerOne</cite> is not a keypair but the wallet of the programâ€™s provider. The provider details are defined in the <cite>Anchor.toml</cite> file in the root of the project. The provider serves as the keypair that pays for (and therefore signs) all transactions.
Then, we send the transaction.
The structure of the transaction function is as follows: First come the instruction arguments. For this function, the public key of the second player. Then come the accounts. Lastly, we add a signers array. We have to add the <cite>gameKeypair</cite> here because whenever an account gets created, it has to sign its creation transaction. We donâ€™t have to add <cite>playerOne</cite> even though we gave it the <cite>Signer</cite> type in the program because it is the program provider and therefore signs the transaction by default.
We did not have to specify the <cite>system_program</cite> account. This is because anchor recognizes this account and is able to infer it. This is also true for other known accounts such as the <cite>token_program</cite> or the <cite>rent</cite> sysvar account.</p>
<p>After the transaction returns, we can fetch the state of the game account. You can fetch account state using the <cite>program.account</cite> namespace.
Finally, we verify the game has been set up properly by comparing the actual state and the expected state. To learn how Anchor maps the Rust types to the js/ts types, check out the [Javascript Anchor Types Reference](./../anchor_references/javascript_anchor_types_reference.md).</p>
<p>Now, run <cite>anchor test</cite>. This starts up (and subsequently shuts down) a local validator (make sure you donâ€™t have one running before) and runs your tests using the test script defined in <cite>Anchor.toml</cite>.</p>
<p>&gt; If you get the error <cite>Error: Unable to read keypair file</cite> when running the test, you likely need to generate a Solana keypair using <cite>solana-keygen new</cite>.</p>
<p>## Playing the game</p>
<p>### The Play Instruction</p>
<p>The <cite>Play</cite> accounts struct is straightforward. We need the game and a player:</p>
<p><a href="#id61"><span class="problematic" id="id62">``</span></a><a href="#id63"><span class="problematic" id="id64">`</span></a>rust
#[derive(Accounts)]
pub struct Play&lt;â€™info&gt; {</p>
<blockquote>
<div><p>#[account(mut)]
pub game: Account&lt;â€™info, Game&gt;,
pub player: Signer&lt;â€™info&gt;,</p>
</div></blockquote>
</section>
<section id="id65">
<h2>}<a class="headerlink" href="#id65" title="Permalink to this heading">Â¶</a></h2>
<p><cite>player</cite> needs to sign or someone else could play for the player.</p>
<p>Finally, we can add the <cite>play</cite> function inside the program module.</p>
<p><a href="#id66"><span class="problematic" id="id67">``</span></a><a href="#id68"><span class="problematic" id="id69">`</span></a>rust
pub fn play(ctx: Context&lt;Play&gt;, tile: Tile) -&gt; Result&lt;()&gt; {</p>
<blockquote>
<div><p>let game = &amp;mut ctx.accounts.game;</p>
<dl class="simple">
<dt>require_keys_eq!(</dt><dd><p>game.current_player(),
ctx.accounts.player.key(),
TicTacToeError::NotPlayersTurn</p>
</dd>
</dl>
<p>);</p>
<p>game.play(&amp;tile)</p>
</div></blockquote>
</section>
<section id="id70">
<h2>}<a class="headerlink" href="#id70" title="Permalink to this heading">Â¶</a></h2>
<p>Weâ€™ve checked in the accounts struct that the <cite>player</cite> account has signed the transaction, but we do not check that it is the <cite>player</cite> we expect. Thatâ€™s what the <cite>require_keys_eq</cite> check in <cite>play</cite> is for.</p>
<p>### Testing the Play Instruction</p>
<p>Testing the <cite>play</cite> instruction works the exact same way. To avoid repeating yourself, create a helper function at the top of the test file:</p>
<p><a href="#id71"><span class="problematic" id="id72">``</span></a><a href="#id73"><span class="problematic" id="id74">`</span></a>typescript
async function play(</p>
<blockquote>
<div><p>program: Program&lt;TicTacToe&gt;,
game,
player,
tile,
expectedTurn,
expectedGameState,
expectedBoard</p>
</div></blockquote>
<dl>
<dt>) {</dt><dd><dl>
<dt>await program.methods</dt><dd><p>.play(tile)
.accounts({</p>
<blockquote>
<div><p>player: player.publicKey,
game,</p>
</div></blockquote>
<p>})
.signers(player instanceof (anchor.Wallet as any) ? [] : [player])
.rpc()</p>
</dd>
</dl>
<p>const gameState = await program.account.game.fetch(game)
expect(gameState.turn).to.equal(expectedTurn)
expect(gameState.state).to.eql(expectedGameState)
expect(gameState.board).to.eql(expectedBoard)</p>
</dd>
</dl>
</section>
<section id="id75">
<h2>}<a class="headerlink" href="#id75" title="Permalink to this heading">Â¶</a></h2>
<p>You can create then a new <cite>it</cite> test, setup the game like in the previous test, but then keep calling the <cite>play</cite> function you just added to simulate a complete run of the game. Letâ€™s begin with the first turn:</p>
<p><a href="#id76"><span class="problematic" id="id77">``</span></a><a href="#id78"><span class="problematic" id="id79">`</span></a>typescript
it(â€˜player one winsâ€™, async () =&gt; {</p>
<blockquote>
<div><p>const gameKeypair = anchor.web3.Keypair.generate()
const playerOne = (program.provider as anchor.AnchorProvider).wallet
const playerTwo = anchor.web3.Keypair.generate()
await program.methods</p>
<blockquote>
<div><p>.setupGame(playerTwo.publicKey)
.accounts({</p>
<blockquote>
<div><p>game: gameKeypair.publicKey,
playerOne: playerOne.publicKey,</p>
</div></blockquote>
<p>})
.signers([gameKeypair])
.rpc()</p>
</div></blockquote>
<p>let gameState = await program.account.game.fetch(gameKeypair.publicKey)
expect(gameState.turn).to.equal(1)
expect(gameState.players).to.eql([playerOne.publicKey, playerTwo.publicKey])
expect(gameState.state).to.eql({ active: {} })
expect(gameState.board).to.eql([</p>
<blockquote>
<div><p>[null, null, null],
[null, null, null],
[null, null, null],</p>
</div></blockquote>
<p>])</p>
<dl>
<dt>await play(</dt><dd><p>program,
gameKeypair.publicKey,
playerOne,
{ row: 0, column: 0 },
2,
{ active: {} },
[</p>
<blockquote>
<div><p>[{ x: {} }, null, null],
[null, null, null],
[null, null, null],</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
</section>
<section id="id80">
<h2>})<a class="headerlink" href="#id80" title="Permalink to this heading">Â¶</a></h2>
<p>and run <cite>anchor test</cite>.</p>
<p>You can finish writing the test by yourself (or check out [the reference implementation](<a class="reference external" href="https://github.com/coral-xyz/anchor/tree/master/docs/programs/tic-tac-toe">https://github.com/coral-xyz/anchor/tree/master/docs/programs/tic-tac-toe</a>)). Try to simulate a win and a tie!</p>
<p>Proper testing also includes tests that try to exploit the contract. You can check whether youâ€™ve protected yourself properly by calling <cite>play</cite> with unexpected parameters. You can also familiarize yourself with the returned <cite>AnchorErrors</cite> this way. For example:</p>
<p><a href="#id81"><span class="problematic" id="id82">``</span></a><a href="#id83"><span class="problematic" id="id84">`</span></a>typescript
try {</p>
<blockquote>
<div><dl>
<dt>await play(</dt><dd><p>program,
gameKeypair.publicKey,
playerTwo,
{ row: 5, column: 1 }, // ERROR: out of bounds row
4,
{ active: {} },
[</p>
<blockquote>
<div><p>[{ x: {} }, { x: {} }, null],
[{ o: {} }, null, null],
[null, null, null],</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>)
// we use this to make sure we definitely throw an error
chai.assert(false, â€œshouldâ€™ve failed but didnâ€™t â€œ)</p>
</div></blockquote>
<dl class="simple">
<dt>} catch (_err) {</dt><dd><p>expect(_err).to.be.instanceOf(AnchorError)
const err: AnchorError = _err
expect(err.error.errorCode.number).to.equal(6000)</p>
</dd>
</dl>
</section>
<section id="id85">
<h2>}<a class="headerlink" href="#id85" title="Permalink to this heading">Â¶</a></h2>
<p>or</p>
<p><a href="#id86"><span class="problematic" id="id87">``</span></a><a href="#id88"><span class="problematic" id="id89">`</span></a>typescript
try {</p>
<blockquote>
<div><dl>
<dt>await play(</dt><dd><p>program,
gameKeypair.publicKey,
playerOne, // ERROR: same player in subsequent turns</p>
<p>// change sth about the tx because
// duplicate tx that come in too fast
// after each other may get dropped
{ row: 1, column: 0 },
2,
{ active: {} },
[</p>
<blockquote>
<div><p>[{ x: {} }, null, null],
[null, null, null],
[null, null, null],</p>
</div></blockquote>
<p>]</p>
</dd>
</dl>
<p>)
chai.assert(false, â€œshouldâ€™ve failed but didnâ€™t â€œ)</p>
</div></blockquote>
<dl>
<dt>} catch (_err) {</dt><dd><p>expect(_err).to.be.instanceOf(AnchorError)
const err: AnchorError = _err
expect(err.error.errorCode.code).to.equal(â€˜NotPlayersTurnâ€™)
expect(err.error.errorCode.number).to.equal(6003)
expect(err.program.equals(program.programId)).is.true
expect(err.error.comparedValues).to.deep.equal([</p>
<blockquote>
<div><p>playerTwo.publicKey,
playerOne.publicKey,</p>
</div></blockquote>
<p>])</p>
</dd>
</dl>
</section>
<section id="id90">
<h2>}<a class="headerlink" href="#id90" title="Permalink to this heading">Â¶</a></h2>
<p>## Deployment</p>
<p>Solana has three main clusters: <cite>mainnet-beta</cite>, <cite>devnet</cite>, and <cite>testnet</cite>.
For developers, <cite>devnet</cite> and <cite>mainnet-beta</cite> are the most interesting. <cite>devnet</cite> is where you test your application in a more realistic environment than <cite>localnet</cite>. <cite>testnet</cite> is mostly for validators.</p>
<p>We are going to deploy on <cite>devnet</cite>.</p>
<p>Here is your deployment checklist ðŸš€</p>
<ol class="arabic simple">
<li><p>Run <cite>anchor build</cite>. Your program keypair is now in <cite>target/deploy</cite>. Keep this keypair secret. You can reuse it on all clusters.</p></li>
<li><p>Run <cite>anchor keys list</cite> to display the keypairâ€™s public key and copy it into your <cite>declare_id!</cite> macro at the top of <cite>lib.rs</cite>.</p></li>
<li><p>Run <cite>anchor build</cite> again. This step is necessary to include the new program id in the binary.</p></li>
<li><p>Change the <cite>provider.cluster</cite> variable in <cite>Anchor.toml</cite> to <cite>devnet</cite>.</p></li>
<li><p>Run <cite>anchor deploy</cite></p></li>
<li><p>Run <cite>anchor test</cite></p></li>
</ol>
<p>There is more to deployments than this e.g. understanding how the BPFLoader works, how to manage keys, how to upgrade your programs and more. Keep reading to learn more!</p>
<p>## Program directory organization</p>
<p>&gt; [Program Code](<a class="reference external" href="https://github.com/coral-xyz/anchor/tree/master/docs/programs/tic-tac-toe">https://github.com/coral-xyz/anchor/tree/master/docs/programs/tic-tac-toe</a>)</p>
<p>Eventually, some programs become too big to keep them in a single file and it makes sense to break them up.</p>
<p>Splitting a program into multiple files works almost the exact same way as splitting up a regular rust program, so if you havenâ€™t already, now is the time to read all about that in the [rust book](<a class="reference external" href="https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html">https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html</a>).</p>
<p>We recommend the following directory structure (using the tic-tac-toe program as an example):</p>
<p><code class="docutils literal notranslate"><span class="pre">`</span>
<span class="pre">.</span>
<span class="pre">+--</span> <span class="pre">lib.rs</span>
<span class="pre">+--</span> <span class="pre">errors.rs</span>
<span class="pre">+--</span> <span class="pre">instructions</span>
<span class="pre">|</span>&#160;&#160; <span class="pre">+--</span> <span class="pre">play.rs</span>
<span class="pre">|</span>&#160;&#160; <span class="pre">+--</span> <span class="pre">setup_game.rs</span>
<span class="pre">|</span>&#160;&#160; <span class="pre">+--</span> <span class="pre">mod.rs</span>
<span class="pre">+--</span> <span class="pre">state</span>
<span class="pre">|</span>&#160;&#160; <span class="pre">+--</span> <span class="pre">game.rs</span>
<span class="pre">|</span>&#160;&#160; <span class="pre">+--</span> <span class="pre">mod.rs</span>
<span class="pre">`</span></code></p>
<p>The crucial difference to a normal rust layout is the way that instructions have to be imported. The <cite>lib.rs</cite> file has to import each instruction module with a wildcard import (e.g. <cite>use instructions::play::*;</cite>). This has to be done because the <cite>#[program]</cite> macro depends on generated code inside each instruction file.</p>
<p>To make the imports shorter you can re-export the instruction modules in the <cite>mod.rs</cite> file in the instructions directory with the <cite>pub use</cite> syntax and then import all instructions in the <cite>lib.rs</cite> file with <cite>use instructions::*;</cite>.</p>
<p>Well done! Youâ€™ve finished the essentials section. You can now move on to the more advanced parts of Anchor.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../_sources/src/pages/docs/tic-tac-toe.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>