<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>docs/src/pages/docs/cross-program-invocations.md &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="docs-src-pages-docs-cross-program-invocations-md">
<h1>docs/src/pages/docs/cross-program-invocations.md<a class="headerlink" href="#docs-src-pages-docs-cross-program-invocations-md" title="Permalink to this heading">¶</a></h1>
<p>Last edited: 2022-12-14 20:15:57</p>
<p>Contents:</p>
<div class="highlight-md notranslate"><div class="highlight"><pre><span></span>---
</pre></div>
</div>
<p>title: Cross-Program Invocations
description: Anchor - Cross-Program Invocations
—</p>
<p>Often it’s useful for programs to interact with each other. In Solana this is achieved via Cross-Program Invocations (CPIs).</p>
<p>—</p>
<p>Consider the following example of a puppet and a puppet master. Admittedly, it is not very realistic but it allows us to show you the many nuances of CPIs. The milestone project of the intermediate section covers a more realistic program with multiple CPIs.</p>
<p>## Setting up basic CPI functionality</p>
<p>Create a new workspace</p>
<p><code class="docutils literal notranslate"><span class="pre">`shell</span>
<span class="pre">anchor</span> <span class="pre">init</span> <span class="pre">puppet</span>
<span class="pre">`</span></code></p>
<p>and copy the following code.</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>rust
use anchor_lang::prelude::<a href="#id5"><span class="problematic" id="id6">*</span></a>;</p>
<p>declare_id!(“Fg6PaFpoGXkYsidMpWTK6W2BeZ7FEfcYkg476zPFsLnS”);</p>
<p>#[program]
pub mod puppet {</p>
<blockquote>
<div><p>use super::<a href="#id7"><span class="problematic" id="id8">*</span></a>;
pub fn initialize(_ctx: Context&lt;Initialize&gt;) -&gt; Result&lt;()&gt; {</p>
<blockquote>
<div><p>Ok(())</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>pub fn set_data(ctx: Context&lt;SetData&gt;, data: u64) -&gt; Result&lt;()&gt; {</dt><dd><p>let puppet = &amp;mut ctx.accounts.puppet;
puppet.data = data;
Ok(())</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>#[derive(Accounts)]
pub struct Initialize&lt;’info&gt; {</p>
<blockquote>
<div><p>#[account(init, payer = user, space = 8 + 8)]
pub puppet: Account&lt;’info, Data&gt;,
#[account(mut)]
pub user: Signer&lt;’info&gt;,
pub system_program: Program&lt;’info, System&gt;,</p>
</div></blockquote>
<p>}</p>
<p>#[derive(Accounts)]
pub struct SetData&lt;’info&gt; {</p>
<blockquote>
<div><p>#[account(mut)]
pub puppet: Account&lt;’info, Data&gt;,</p>
</div></blockquote>
<p>}</p>
<p>#[account]
pub struct Data {</p>
<blockquote>
<div><p>pub data: u64,</p>
</div></blockquote>
<section id="id9">
<h2>}<a class="headerlink" href="#id9" title="Permalink to this heading">¶</a></h2>
<p>There’s nothing special happening here. It’s a pretty simple program! The interesting part is how it interacts with the next program we are going to create.</p>
<p>Run</p>
<p><code class="docutils literal notranslate"><span class="pre">`shell</span>
<span class="pre">anchor</span> <span class="pre">new</span> <span class="pre">puppet-master</span>
<span class="pre">`</span></code></p>
<p>inside the workspace and copy the following code:</p>
<p><a href="#id10"><span class="problematic" id="id11">``</span></a><a href="#id12"><span class="problematic" id="id13">`</span></a>rust
use anchor_lang::prelude::<a href="#id14"><span class="problematic" id="id15">*</span></a>;
use puppet::cpi::accounts::SetData;
use puppet::program::Puppet;
use puppet::{self, Data};</p>
<p>declare_id!(“HmbTLCmaGvZhKnn1Zfa1JVnp7vkMV4DYVxPLWBVoN65L”);</p>
<p>#[program]
mod puppet_master {</p>
<blockquote>
<div><p>use super::<a href="#id16"><span class="problematic" id="id17">*</span></a>;
pub fn pull_strings(ctx: Context&lt;PullStrings&gt;, data: u64) -&gt; Result&lt;()&gt; {</p>
<blockquote>
<div><p>let cpi_program = ctx.accounts.puppet_program.to_account_info();
let cpi_accounts = SetData {</p>
<blockquote>
<div><p>puppet: ctx.accounts.puppet.to_account_info(),</p>
</div></blockquote>
<p>};
let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
puppet::cpi::set_data(cpi_ctx, data)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>#[derive(Accounts)]
pub struct PullStrings&lt;’info&gt; {</p>
<blockquote>
<div><p>#[account(mut)]
pub puppet: Account&lt;’info, Data&gt;,
pub puppet_program: Program&lt;’info, Puppet&gt;,</p>
</div></blockquote>
</section>
<section id="id18">
<h2>}<a class="headerlink" href="#id18" title="Permalink to this heading">¶</a></h2>
<p>Also add the line <cite>puppet_master = “HmbTLCmaGvZhKnn1Zfa1JVnp7vkMV4DYVxPLWBVoN65L”</cite> in the <cite>[programs.localnet]</cite> section of your <cite>Anchor.toml</cite>. Finally, import the puppet program into the puppet-master program by adding the following line to the <cite>[dependencies]</cite> section of the <cite>Cargo.toml</cite> file inside the <cite>puppet-master</cite> program folder:</p>
<p><code class="docutils literal notranslate"><span class="pre">`toml</span>
<span class="pre">puppet</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">path</span> <span class="pre">=</span> <span class="pre">&quot;../puppet&quot;,</span> <span class="pre">features</span> <span class="pre">=</span> <span class="pre">[&quot;cpi&quot;]}</span>
<span class="pre">`</span></code></p>
<p>The <cite>features = [“cpi”]</cite> is used so we can not only use puppet’s types but also its instruction builders and cpi functions. Without those, we would have to use low level solana syscalls. Fortunately, anchor provides abstractions on top of those. By enabling the <cite>cpi</cite> feature, the puppet-master program gets access to the <cite>puppet::cpi</cite> module. Anchor generates this module automatically and it contains tailor-made instructions builders and cpi helpers for the program.</p>
<p>In the case of the puppet program, the puppet-master uses the <cite>SetData</cite> instruction builder struct provided by the <cite>puppet::cpi::accounts</cite> module to submit the accounts the <cite>SetData</cite> instruction of the puppet program expects. Then, the puppet-master creates a new cpi context and passes it to the <cite>puppet::cpi::set_data</cite> cpi function. This function has the exact same function as the <cite>set_data</cite> function in the puppet program with the exception that it expects a <cite>CpiContext</cite> instead of a <cite>Context</cite>.</p>
<p>Setting up a CPI can distract from the business logic of the program so it’s recommended to move the CPI setup into the <cite>impl</cite> block of the instruction. The puppet-master program then looks like this:</p>
<p><a href="#id19"><span class="problematic" id="id20">``</span></a><a href="#id21"><span class="problematic" id="id22">`</span></a>rust
use anchor_lang::prelude::<a href="#id23"><span class="problematic" id="id24">*</span></a>;
use puppet::cpi::accounts::SetData;
use puppet::program::Puppet;
use puppet::{self, Data};</p>
<p>declare_id!(“HmbTLCmaGvZhKnn1Zfa1JVnp7vkMV4DYVxPLWBVoN65L”);</p>
<p>#[program]
mod puppet_master {</p>
<blockquote>
<div><p>use super::<a href="#id25"><span class="problematic" id="id26">*</span></a>;
pub fn pull_strings(ctx: Context&lt;PullStrings&gt;, data: u64) -&gt; Result&lt;()&gt; {</p>
<blockquote>
<div><p>puppet::cpi::set_data(ctx.accounts.set_data_ctx(), data)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>#[derive(Accounts)]
pub struct PullStrings&lt;’info&gt; {</p>
<blockquote>
<div><p>#[account(mut)]
pub puppet: Account&lt;’info, Data&gt;,
pub puppet_program: Program&lt;’info, Puppet&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl&lt;’info&gt; PullStrings&lt;’info&gt; {</dt><dd><dl>
<dt>pub fn set_data_ctx(&amp;self) -&gt; CpiContext&lt;’_, ‘_, ‘_, ‘info, SetData&lt;’info&gt;&gt; {</dt><dd><p>let cpi_program = self.puppet_program.to_account_info();
let cpi_accounts = SetData {</p>
<blockquote>
<div><p>puppet: self.puppet.to_account_info()</p>
</div></blockquote>
<p>};
CpiContext::new(cpi_program, cpi_accounts)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</section>
<section id="id27">
<h2>}<a class="headerlink" href="#id27" title="Permalink to this heading">¶</a></h2>
<p>We can verify that everything works as expected by replacing the contents of the <cite>puppet.ts</cite> file with:</p>
<p><a href="#id28"><span class="problematic" id="id29">``</span></a><a href="#id30"><span class="problematic" id="id31">`</span></a>ts
import * as anchor from <a class="reference external" href="mailto:'&#37;&#52;&#48;project-serum/anchor">‘<span>&#64;</span>project-serum/anchor</a>’
import { Program } from <a class="reference external" href="mailto:'&#37;&#52;&#48;project-serum/anchor">‘<span>&#64;</span>project-serum/anchor</a>’
import { Keypair } from <a class="reference external" href="mailto:'&#37;&#52;&#48;solana/web3&#46;js">‘<span>&#64;</span>solana/web3<span>&#46;</span>js</a>’
import { expect } from ‘chai’
import { Puppet } from ‘../target/types/puppet’
import { PuppetMaster } from ‘../target/types/puppet_master’</p>
<dl>
<dt>describe(‘puppet’, () =&gt; {</dt><dd><p>const provider = anchor.AnchorProvider.env()
anchor.setProvider(provider)</p>
<p>const puppetProgram = anchor.workspace.Puppet as Program&lt;Puppet&gt;
const puppetMasterProgram = anchor.workspace</p>
<blockquote>
<div><p>.PuppetMaster as Program&lt;PuppetMaster&gt;</p>
</div></blockquote>
<p>const puppetKeypair = Keypair.generate()</p>
<dl>
<dt>it(‘Does CPI!’, async () =&gt; {</dt><dd><dl>
<dt>await puppetProgram.methods</dt><dd><p>.initialize()
.accounts({</p>
<blockquote>
<div><p>puppet: puppetKeypair.publicKey,
user: provider.wallet.publicKey,</p>
</div></blockquote>
<p>})
.signers([puppetKeypair])
.rpc()</p>
</dd>
<dt>await puppetMasterProgram.methods</dt><dd><p>.pullStrings(new anchor.BN(42))
.accounts({</p>
<blockquote>
<div><p>puppetProgram: puppetProgram.programId,
puppet: puppetKeypair.publicKey,</p>
</div></blockquote>
<p>})
.rpc()</p>
</dd>
<dt>expect(</dt><dd><dl class="simple">
<dt>(</dt><dd><p>await puppetProgram.account.data.fetch(puppetKeypair.publicKey)</p>
</dd>
</dl>
<p>).data.toNumber()</p>
</dd>
</dl>
<p>).to.equal(42)</p>
</dd>
</dl>
<p>})</p>
</dd>
</dl>
</section>
<section id="id32">
<h2>})<a class="headerlink" href="#id32" title="Permalink to this heading">¶</a></h2>
<p>and running <cite>anchor test</cite>.</p>
<p>## Privilege Extension</p>
<p>CPIs extend the privileges of the caller to the callee. The puppet account was passed as a mutable account to the puppet-master but it was still mutable in the puppet program as well (otherwise the <cite>expect</cite> in the test would’ve failed). The same applies to signatures.</p>
<p>If you want to prove this for yourself, add an <cite>authority</cite> field to the <cite>Data</cite> struct in the puppet program.</p>
<p><a href="#id33"><span class="problematic" id="id34">``</span></a><a href="#id35"><span class="problematic" id="id36">`</span></a>rust
#[account]
pub struct Data {</p>
<blockquote>
<div><p>pub data: u64,
pub authority: Pubkey</p>
</div></blockquote>
</section>
<section id="id37">
<h2>}<a class="headerlink" href="#id37" title="Permalink to this heading">¶</a></h2>
<p>and adjust the <cite>initialize</cite> function:</p>
<p><a href="#id38"><span class="problematic" id="id39">``</span></a><a href="#id40"><span class="problematic" id="id41">`</span></a>rust
pub fn initialize(ctx: Context&lt;Initialize&gt;, authority: Pubkey) -&gt; Result&lt;()&gt; {</p>
<blockquote>
<div><p>ctx.accounts.puppet.authority = authority;
Ok(())</p>
</div></blockquote>
</section>
<section id="id42">
<h2>}<a class="headerlink" href="#id42" title="Permalink to this heading">¶</a></h2>
<p>Add <cite>32</cite> to the <cite>space</cite> constraint of the <cite>puppet</cite> field for the <cite>Pubkey</cite> field in the <cite>Data</cite> struct.</p>
<p><a href="#id43"><span class="problematic" id="id44">``</span></a><a href="#id45"><span class="problematic" id="id46">`</span></a>rust
#[derive(Accounts)]
pub struct Initialize&lt;’info&gt; {</p>
<blockquote>
<div><p>#[account(init, payer = user, space = 8 + 8 + 32)]
pub puppet: Account&lt;’info, Data&gt;,
#[account(mut)]
pub user: Signer&lt;’info&gt;,
pub system_program: Program&lt;’info, System&gt;,</p>
</div></blockquote>
</section>
<section id="id47">
<h2>}<a class="headerlink" href="#id47" title="Permalink to this heading">¶</a></h2>
<p>Then, adjust the <cite>SetData</cite> validation struct:</p>
<p><a href="#id48"><span class="problematic" id="id49">``</span></a><a href="#id50"><span class="problematic" id="id51">`</span></a>rust
#[derive(Accounts)]
pub struct SetData&lt;’info&gt; {</p>
<blockquote>
<div><p>#[account(mut, has_one = authority)]
pub puppet: Account&lt;’info, Data&gt;,
pub authority: Signer&lt;’info&gt;</p>
</div></blockquote>
</section>
<section id="id52">
<h2>}<a class="headerlink" href="#id52" title="Permalink to this heading">¶</a></h2>
<p>The <cite>has_one</cite> constraint checks that <cite>puppet.authority = authority.key()</cite>.</p>
<p>The puppet-master program now also needs adjusting:</p>
<p><a href="#id53"><span class="problematic" id="id54">``</span></a><a href="#id55"><span class="problematic" id="id56">`</span></a>rust
use anchor_lang::prelude::<a href="#id57"><span class="problematic" id="id58">*</span></a>;
use puppet::cpi::accounts::SetData;
use puppet::program::Puppet;
use puppet::{self, Data};</p>
<p>declare_id!(“HmbTLCmaGvZhKnn1Zfa1JVnp7vkMV4DYVxPLWBVoN65L”);</p>
<p>#[program]
mod puppet_master {</p>
<blockquote>
<div><p>use super::<a href="#id59"><span class="problematic" id="id60">*</span></a>;
pub fn pull_strings(ctx: Context&lt;PullStrings&gt;, data: u64) -&gt; Result&lt;()&gt; {</p>
<blockquote>
<div><p>puppet::cpi::set_data(ctx.accounts.set_data_ctx(), data)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>#[derive(Accounts)]
pub struct PullStrings&lt;’info&gt; {</p>
<blockquote>
<div><p>#[account(mut)]
pub puppet: Account&lt;’info, Data&gt;,
pub puppet_program: Program&lt;’info, Puppet&gt;,
// Even though the puppet program already checks that authority is a signer
// using the Signer type here is still required because the anchor ts client
// can not infer signers from programs called via CPIs
pub authority: Signer&lt;’info&gt;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl&lt;’info&gt; PullStrings&lt;’info&gt; {</dt><dd><dl>
<dt>pub fn set_data_ctx(&amp;self) -&gt; CpiContext&lt;’_, ‘_, ‘_, ‘info, SetData&lt;’info&gt;&gt; {</dt><dd><p>let cpi_program = self.puppet_program.to_account_info();
let cpi_accounts = SetData {</p>
<blockquote>
<div><p>puppet: self.puppet.to_account_info(),
authority: self.authority.to_account_info()</p>
</div></blockquote>
<p>};
CpiContext::new(cpi_program, cpi_accounts)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</section>
<section id="id61">
<h2>}<a class="headerlink" href="#id61" title="Permalink to this heading">¶</a></h2>
<p>Finally, change the test:</p>
<p><a href="#id62"><span class="problematic" id="id63">``</span></a><a href="#id64"><span class="problematic" id="id65">`</span></a>ts
import * as anchor from <a class="reference external" href="mailto:'&#37;&#52;&#48;project-serum/anchor">‘<span>&#64;</span>project-serum/anchor</a>’
import { Program } from <a class="reference external" href="mailto:'&#37;&#52;&#48;project-serum/anchor">‘<span>&#64;</span>project-serum/anchor</a>’
import { Keypair } from <a class="reference external" href="mailto:'&#37;&#52;&#48;solana/web3&#46;js">‘<span>&#64;</span>solana/web3<span>&#46;</span>js</a>’
import { Puppet } from ‘../target/types/puppet’
import { PuppetMaster } from ‘../target/types/puppet_master’
import { expect } from ‘chai’</p>
<dl>
<dt>describe(‘puppet’, () =&gt; {</dt><dd><p>const provider = anchor.AnchorProvider.env()
anchor.setProvider(provider)</p>
<p>const puppetProgram = anchor.workspace.Puppet as Program&lt;Puppet&gt;
const puppetMasterProgram = anchor.workspace</p>
<blockquote>
<div><p>.PuppetMaster as Program&lt;PuppetMaster&gt;</p>
</div></blockquote>
<p>const puppetKeypair = Keypair.generate()
const authorityKeypair = Keypair.generate()</p>
<dl>
<dt>it(‘Does CPI!’, async () =&gt; {</dt><dd><dl>
<dt>await puppetProgram.methods</dt><dd><p>.initialize(authorityKeypair.publicKey)
.accounts({</p>
<blockquote>
<div><p>puppet: puppetKeypair.publicKey,
user: provider.wallet.publicKey,</p>
</div></blockquote>
<p>})
.signers([puppetKeypair])
.rpc()</p>
</dd>
<dt>await puppetMasterProgram.methods</dt><dd><p>.pullStrings(new anchor.BN(42))
.accounts({</p>
<blockquote>
<div><p>puppetProgram: puppetProgram.programId,
puppet: puppetKeypair.publicKey,
authority: authorityKeypair.publicKey,</p>
</div></blockquote>
<p>})
.signers([authorityKeypair])
.rpc()</p>
</dd>
<dt>expect(</dt><dd><dl class="simple">
<dt>(</dt><dd><p>await puppetProgram.account.data.fetch(puppetKeypair.publicKey)</p>
</dd>
</dl>
<p>).data.toNumber()</p>
</dd>
</dl>
<p>).to.equal(42)</p>
</dd>
</dl>
<p>})</p>
</dd>
</dl>
</section>
<section id="id66">
<h2>})<a class="headerlink" href="#id66" title="Permalink to this heading">¶</a></h2>
<p>The test passes because the signature that was given to the puppet-master by the authority was then extended to the puppet program which used it to check that the authority for the puppet account had signed the transaction.</p>
<p>&gt; Privilege extension is convenient but also dangerous. If a CPI is unintentionally made to a malicious program,
&gt; this program has the same privileges as the caller.
&gt; Anchor protects you from CPIs to malicious programs with two measures.
&gt; First, the <cite>Program&lt;’info, T&gt;</cite> type checks that the given account is the expected program <cite>T</cite>.
&gt; Should you ever forget to use the <cite>Program</cite> type, the automatically generated cpi function
&gt; (in the previous example this was <cite>puppet::cpi::set_data</cite>)
&gt; also checks that the <cite>cpi_program</cite> argument equals the expected program.</p>
<p>## Reloading an Account</p>
<p>In the puppet program, the <cite>Account&lt;’info, T&gt;</cite> type is used for the <cite>puppet</cite> account. If a CPI edits an account of that type,
the caller’s account does not change during the instruction.</p>
<p>You can easily see this for yourself by adding the following right after the <cite>puppet::cpi::set_data(ctx.accounts.set_data_ctx(), data)</cite> cpi call.</p>
<p><a href="#id67"><span class="problematic" id="id68">``</span></a><a href="#id69"><span class="problematic" id="id70">`</span></a>rust
puppet::cpi::set_data(ctx.accounts.set_data_ctx(), data)?;
if ctx.accounts.puppet.data != 42 {</p>
<blockquote>
<div><p>panic!();</p>
</div></blockquote>
<p>}
Ok(())
<a href="#id71"><span class="problematic" id="id72">``</span></a><a href="#id73"><span class="problematic" id="id74">`</span></a></p>
<p>{% callout type=”warning” title=”Note” %}
Your test will fail. But why? After all the test used to pass, so the cpi definitely did change the <cite>data</cite> field to <cite>42</cite>.
{% /callout %}</p>
<p>The reason the <cite>data</cite> field has not been updated to <cite>42</cite> in the caller is that at the beginning of the instruction the <cite>Account&lt;’info, T&gt;</cite> type deserializes the incoming bytes into a new struct. This struct is no longer connected to the underlying data in the account. The CPI changes the data in the underlying account but since the struct in the caller has no connection to the underlying account the struct in the caller remains unchanged.</p>
<p>If you need to read the value of an account that has just been changed by a CPI, you can call its <cite>reload</cite> method which will re-deserialize the account. If you put <cite>ctx.accounts.puppet.reload()?;</cite> right after the cpi call, the test will pass again.</p>
<p><a href="#id75"><span class="problematic" id="id76">``</span></a><a href="#id77"><span class="problematic" id="id78">`</span></a>rust
puppet::cpi::set_data(ctx.accounts.set_data_ctx(), data)?;
ctx.accounts.puppet.reload()?;
if ctx.accounts.puppet.data != 42 {</p>
<blockquote>
<div><p>panic!();</p>
</div></blockquote>
<p>}
Ok(())
<a href="#id79"><span class="problematic" id="id80">``</span></a><a href="#id81"><span class="problematic" id="id82">`</span></a></p>
<p>## Returning values from handler functions</p>
<p>The Anchor handler functions are capable of returning data using the Solana <cite>set_return_data</cite> and <cite>get_return_data</cite> syscalls. This data can be used in CPI callers and clients.</p>
<p>Instead of returning a <cite>Result&lt;()&gt;</cite>, consider this version of the <cite>set_data</cite> function from above which has been modified to return <cite>Result&lt;u64&gt;</cite>:</p>
<p><a href="#id83"><span class="problematic" id="id84">``</span></a><a href="#id85"><span class="problematic" id="id86">`</span></a>rust
pub fn set_data(ctx: Context&lt;SetData&gt;, data: u64) -&gt; Result&lt;u64&gt; {</p>
<blockquote>
<div><p>let puppet = &amp;mut ctx.accounts.puppet;
puppet.data = data;
Ok(data)</p>
</div></blockquote>
</section>
<section id="id87">
<h2>}<a class="headerlink" href="#id87" title="Permalink to this heading">¶</a></h2>
<p>Defining a return type that isn’t the unit type <cite>()</cite> will cause Anchor to transparently call <cite>set_return_data</cite> with the given type (<cite>u64</cite> in this example) when this function is called. The return from the CPI call is wrapped in a struct to allow for lazy retrieval of this return data. E.g.</p>
<p><a href="#id88"><span class="problematic" id="id89">``</span></a><a href="#id90"><span class="problematic" id="id91">`</span></a>rust
pub fn pull_strings(ctx: Context&lt;PullStrings&gt;, data: u64) -&gt; Result&lt;()&gt; {</p>
<blockquote>
<div><p>let cpi_program = ctx.accounts.puppet_program.to_account_info();
let cpi_accounts = SetData {</p>
<blockquote>
<div><p>puppet: ctx.accounts.puppet.to_account_info(),</p>
</div></blockquote>
<p>};
let cpi_ctx = CpiContext::new(cpi_program, cpi_accounts);
let result = puppet::cpi::set_data(cpi_ctx, data)?;
// The below statement calls sol_get_return and deserializes the result.
// <cite>return_data</cite> contains the return from <cite>set_data</cite>,
// which in this example is just <cite>data</cite>.
let return_data = result.get();
// … do something with the <cite>return_data</cite> …</p>
</div></blockquote>
</section>
<section id="id92">
<h2>}<a class="headerlink" href="#id92" title="Permalink to this heading">¶</a></h2>
<p>{% callout type=”warning” title=”Note” %}
The type being returned must implement the <cite>AnchorSerialize</cite> and <cite>AnchorDeserialize</cite> traits, for example:
{% /callout %}</p>
<p><a href="#id93"><span class="problematic" id="id94">``</span></a><a href="#id95"><span class="problematic" id="id96">`</span></a>rust
#[derive(AnchorSerialize, AnchorDeserialize)]
pub struct StructReturn {</p>
<blockquote>
<div><p>pub value: u64,</p>
</div></blockquote>
</section>
<section id="id97">
<h2>}<a class="headerlink" href="#id97" title="Permalink to this heading">¶</a></h2>
<p>### Reading return data in the clients</p>
<p>It’s even possible to use return values without CPIs. This may be useful if you’re using a function to calculate a value that you need on the frontend without rewriting the code in the frontend.</p>
<p>Whether you’re using a CPI or not, you can use the <cite>view</cite> function to read whatever was set last as return data in the transaction (<cite>view</cite> simulates the transaction and reads the <cite>Program return</cite> log).</p>
<p>For example:</p>
<p><a href="#id98"><span class="problematic" id="id99">``</span></a><a href="#id100"><span class="problematic" id="id101">`</span></a>typescript
const returnData = await program.methods</p>
<blockquote>
<div><p>.calculate(someVariable)
.accounts({</p>
<blockquote>
<div><p>acc: somePubkey,
anotherAcc: someOtherPubkey,</p>
</div></blockquote>
<p>})
.view()</p>
</div></blockquote>
<p><a href="#id102"><span class="problematic" id="id103">``</span></a><a href="#id104"><span class="problematic" id="id105">`</span></a></p>
<p>### Return Data Size Limit Workarounds</p>
<p>The <cite>set_return_data</cite> and <cite>get_return_data</cite> syscalls are limited to 1024 bytes so it’s worth briefly explaining the old workaround for CPI return values.</p>
<p>By using a CPI together with <cite>reload</cite> it’s possible to simulate return values. One could imagine that instead of just setting the <cite>data</cite> field to <cite>42</cite> the puppet program did some calculation with the <cite>42</cite> and saved the result in <cite>data</cite>. The puppet-master can then call <cite>reload</cite> after the cpi and use the result of the puppet program’s calculation.</p>
<p>## Programs as Signers</p>
<p>There’s one more thing that can be done with CPIs. But for that, you need to first learn what PDAs are. We’ll cover those in the next chapter.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../_sources/src/pages/docs/cross-program-invocations.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>