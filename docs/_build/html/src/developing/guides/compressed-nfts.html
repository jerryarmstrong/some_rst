<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>docs/src/developing/guides/compressed-nfts.md &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="docs-src-developing-guides-compressed-nfts-md">
<h1>docs/src/developing/guides/compressed-nfts.md<a class="headerlink" href="#docs-src-developing-guides-compressed-nfts-md" title="Permalink to this heading">¶</a></h1>
<p>Last edited: 2023-08-11 21:38:33</p>
<p>Contents:</p>
<div class="highlight-md notranslate"><div class="highlight"><pre><span></span>---
</pre></div>
</div>
<p>title: Creating Compressed NFTs with JavaScript
description:</p>
<blockquote>
<div><p>“Compressed NFTs use the Bubblegum program from Metaplex to cheaply and
securely store NFT metadata using State Compression on Solana.”</p>
</div></blockquote>
<dl class="simple">
<dt>keywords:</dt><dd><ul class="simple">
<li><p>compression</p></li>
<li><p>merkle tree</p></li>
<li><p>read api</p></li>
<li><p>metaplex</p></li>
</ul>
</dd>
</dl>
<p>—</p>
<p>Compressed NFTs on Solana use the
[Bubblegum](<a class="reference external" href="https://docs.metaplex.com/programs/compression/">https://docs.metaplex.com/programs/compression/</a>) program from
Metaplex to cheaply and securely store NFT metadata using
[State Compression](../../learn/state-compression.md).</p>
<p>This developer guide will use JavaScript/TypeScript to demonstrate:</p>
<ul class="simple">
<li><p>[how to create a tree for compressed NFTs](#create-a-tree),</p></li>
<li><p>[how to mint compressed NFTs into a tree](#mint-compressed-nfts),</p></li>
<li><p>[how to get compressed NFT metadata from the Read API](#reading-compressed-nfts-metadata),
and</p></li>
<li><p>[how to transfer compressed NFTs](#transfer-compressed-nfts)</p></li>
</ul>
<p>## Intro to Compressed NFTs</p>
<p>Compressed NFTs use [State Compression](../../learn/state-compression.md) and
[merkle trees](../../learn/state-compression.md#what-is-a-merkle-tree) to
drastically reduce the storage cost for NFTs. Instead of storing an NFT’s
metadata in a typical Solana account, compressed NFTs store the metadata within
the ledger. This allows compressed NFTs to still inherit the security and speed
of the Solana blockchain, while at the same time reducing the overall storage
costs.</p>
<p>Even though the on-chain data storage mechanism is different than their
uncompressed counterparts, compressed NFTs still follow the exact same
[Metadata](<a class="reference external" href="https://docs.metaplex.com/programs/token-metadata/accounts#metadata">https://docs.metaplex.com/programs/token-metadata/accounts#metadata</a>)
schema/structure. Allowing you to define your Collection and NFT in an identical
way.</p>
<p>However, the process to mint and transfer compressed NFTs is different from
uncompressed NFTs. Aside from using a different on-chain program, compressed
NFTs are minting into a merkle tree and require verification of a “proof” to
transfer. More on this below.</p>
<p>### Compressed NFTs and indexers</p>
<p>Since compressed NFTs store all of their metadata in the
[ledger](../../terminology.md#ledger), instead of in traditional
[accounts](../../terminology.md#account) like uncompressed NFTs, we will need to
help of indexing services to quickly fetch our compressed NFT’s metadata.</p>
<p>Supporting RPC providers are using the Digital Asset Standard Read API (or “Read
API” for short) to add additional RPC methods that developers can call. These
additional, NFT oriented methods, are loaded with all the information about
particular NFTs. Including support for <strong>BOTH</strong> compressed NFTs <strong>AND</strong>
uncompressed NFTs.</p>
<p>:::caution Metadata is secured by the ledger and cached by indexers</p>
<p>Since validators do not keep a very long history of the recent ledger data,
these indexers effectively “cache” the compressed NFT metadata passed through
the Solana ledger. Quickly serving it back on request to improve speed and user
experience of applications.</p>
<p>However, since the metadata was already secured by the ledger when minting the
compressed NFT, anyone could re-index the metadata directly from the secure
ledger. Allowing for independent verification of the data, should the need or
desire arise.</p>
<p>::</p>
<p>These indexing services are already available from some of the common RPC
providers, with more rolling out support in the near future. To name a few of
the RPC providers that already support the Read API:</p>
<ul class="simple">
<li><p>Helius</p></li>
<li><p>Triton</p></li>
<li><p>SimpleHash</p></li>
</ul>
<p>### How to mint compressed NFTs</p>
<p>The process to create or mint compressed NFTs on Solana is similar to creating a
“traditional NFT collection”, with a few differences. The mint process will
happen in 3 primary steps:</p>
<ul class="simple">
<li><p>create an NFT collection (or use an existing one)</p></li>
<li><p>create a
[concurrent merkle tree](../../learn/state-compression.md#what-is-a-concurrent-merkle-tree)
(using the <cite>&#64;solana/spl-account-compression</cite> SDK)</p></li>
<li><p>mint compressed NFTs into your tree (to any owner’s address you want)</p></li>
</ul>
<p>### How to transfer a compressed NFT</p>
<p>Once your compressed NFT exists on the Solana blockchain, the process to
transfer ownership of a compressed NFT happens in a few broad steps:</p>
<ol class="arabic simple">
<li><p>get the NFT “asset” information (from the indexer)</p></li>
<li><p>get the NFT’s “proof” (from the indexer)</p></li>
<li><p>get the Merkle tree account (from the Solana blockchain)</p></li>
<li><p>prepare the asset proof (by parsing and formatting it)</p></li>
<li><p>build and send the transfer instruction</p></li>
</ol>
<p>The first three steps primarily involve gathering specific pieces of information
(the <cite>proof</cite> and the tree’s canopy depth) for the NFT to be transferred. These
pieces of information are needed to correctly parse/format the <cite>proof</cite> to
actually be sent within the transfer instruction itself.</p>
<p>## Getting started</p>
<p>For this guide, we are going to make a few assumptions about the compressed NFT
collection we are going to create:</p>
<ul class="simple">
<li><p>we are going to use TypeScript and NodeJS for this example</p></li>
<li><p>we will use a single, <strong>new</strong> Metaplex collection</p></li>
</ul>
<p>### Project Setup</p>
<p>Before we start creating our compressed NFT collection, we need to install a few
packages:</p>
<ul class="simple">
<li><p>[<cite>&#64;solana/web3.js</cite>](<a class="reference external" href="https://www.npmjs.com/package/&#64;solana/web3.js">https://www.npmjs.com/package/&#64;solana/web3.js</a>) - the base
Solana JS SDK for interacting with the blockchain, including making our RPC
connection and sending transactions</p></li>
<li><p>[<cite>&#64;solana/spl-token</cite>](<a class="reference external" href="https://www.npmjs.com/package/&#64;solana/spl-token">https://www.npmjs.com/package/&#64;solana/spl-token</a>) - used
in creating our collection and mint on-chain</p></li>
<li><p>[<cite>&#64;solana/spl-account-compression</cite>](<a class="reference external" href="https://www.npmjs.com/package/&#64;solana/spl-account-compression">https://www.npmjs.com/package/&#64;solana/spl-account-compression</a>) -
used to create the on-chain tree to store our compressed NFTs</p></li>
<li><p>[<cite>&#64;metaplex-foundation/mpl-bubblegum</cite>](<a class="reference external" href="https://www.npmjs.com/package/&#64;metaplex-foundation/mpl-bubblegum">https://www.npmjs.com/package/&#64;metaplex-foundation/mpl-bubblegum</a>) -
used to get the types and helper functions for minting and transferring
compressed NFTs on-chain</p></li>
<li><p>[<cite>&#64;metaplex-foundation/mpl-token-metadata</cite>](<a class="reference external" href="https://www.npmjs.com/package/&#64;metaplex-foundation/mpl-token-metadata">https://www.npmjs.com/package/&#64;metaplex-foundation/mpl-token-metadata</a>) -</p></li>
</ul>
<p>used to get the types and helper functions for our NFT’s metadata
&lt;!– - [<cite>&#64;metaplex-foundation/js</cite>](<a class="reference external" href="https://www.npmjs.com/package/&#64;metaplex-foundation/js">https://www.npmjs.com/package/&#64;metaplex-foundation/js</a>) –&gt;</p>
<p>Using your preferred package manager (e.g. npm, yarn, pnpm, etc), install these
packages into your project:</p>
<p><code class="docutils literal notranslate"><span class="pre">`sh</span>
<span class="pre">yarn</span> <span class="pre">add</span> <span class="pre">&#64;solana/web3.js</span> <span class="pre">&#64;solana/spl-token</span> <span class="pre">&#64;solana/spl-account-compression</span>
<span class="pre">`</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">`sh</span>
<span class="pre">yarn</span> <span class="pre">add</span> <span class="pre">&#64;metaplex-foundation/mpl-bubblegum</span> <span class="pre">&#64;metaplex-foundation/mpl-token-metadata</span>
<span class="pre">`</span></code></p>
<p>## Create a Collection</p>
<p>NFTs are normally grouped together into a
[Collection](<a class="reference external" href="https://docs.metaplex.com/programs/token-metadata/certified-collections#collection-nfts">https://docs.metaplex.com/programs/token-metadata/certified-collections#collection-nfts</a>)
using the Metaplex standard. This is true for <strong>BOTH</strong> traditional NFTs <strong>AND</strong>
compressed NFTs. The NFT Collection will store all the broad metadata for our
NFT grouping, such as the collection image and name that will appear in wallets
and explorers.</p>
<p>Under the hood, an NFT collection acts similar to any other token on Solana.
More specifically, a Collection is effectively a uncompressed NFT. So we
actually create them following the same process of creating an
[SPL token](<a class="reference external" href="https://spl.solana.com/token">https://spl.solana.com/token</a>):</p>
<ul class="simple">
<li><p>create a new token “mint”</p></li>
<li><p>create a associated token account (<cite>ata</cite>) for our token mint</p></li>
<li><p>actually mint a single single token</p></li>
<li><p>store the collection’s metadata in an Account on-chain</p></li>
</ul>
<p>Since NFT Collections having nothing special to do with
[State Compression](../../learn/state-compression.md) or
[compressed NFTs](./compressed-nfts.md), we will not cover creating one in this
guide.</p>
<p>### Collection addresses</p>
<p>Even though this guide does not cover creating one, we will need the many of the
various addresses for your Collection, including:</p>
<ul class="simple">
<li><p><cite>collectionAuthority</cite> - this may be your <cite>payer</cite> but it also might not be</p></li>
<li><p><cite>collectionMint</cite> - the collection’s mint address</p></li>
<li><p><cite>collectionMetadata</cite> - the collection’s metadata account</p></li>
<li><p><cite>editionAccount</cite> - for example, the <cite>masterEditionAccount</cite> created for your
collection</p></li>
</ul>
<p>## Create a tree</p>
<p>One of the most important decisions to make when creating compressed NFTs is
[how to setup your tree](../../learn/state-compression.md#sizing-a-concurrent-merkle-tree).
Especially since the values used to size your tree will determine the overall
cost of creation, and <strong>CANNOT</strong> be changed after creation.</p>
<p>:::caution</p>
<p>A tree is <strong>NOT</strong> the same thing as a collection. A single collection can use
_any_ number of trees. In fact, this is usually recommended for larger
collections due to smaller trees having greater composability.</p>
<p>Conversely, even though a tree <strong>could</strong> be used in multiple collections, it is
generally considered an anti-pattern and is not recommended.</p>
<p>::</p>
<p>Using the helper functions provided by the
[<cite>&#64;solana/spl-account-compression</cite>](<a class="reference external" href="https://www.npmjs.com/package/&#64;solana/spl-account-compression">https://www.npmjs.com/package/&#64;solana/spl-account-compression</a>)
SDK, we can create our tree in the following steps:</p>
<ul class="simple">
<li><p>decide on our tree size</p></li>
<li><p>generate a new Keypair and allocated space for the tree on-chain</p></li>
<li><p>actually create the tree (making it owned by the Bubblegum program)</p></li>
</ul>
<p>### Size your tree</p>
<p>Your tree size is set by 3 values, each serving a very specific purpose:</p>
<ol class="arabic simple">
<li><p><cite>maxDepth</cite> - used to determine how many NFTs we can have in the tree</p></li>
<li><p><cite>maxBufferSize</cite> - used to determine how many updates to your tree are
possible in the same block</p></li>
<li><p><cite>canopyDepth</cite> - used to store a portion of the proof on chain, and as such is
a large of cost and composability of your compressed NFT collection</p></li>
</ol>
<p>:::info</p>
<p>Read more about the details about
[State Compression](../../learn/state-compression.md), including
[how to size a tree](../../learn/state-compression.md#sizing-a-concurrent-merkle-tree)
and potential composability concerns.</p>
<p>::</p>
<p>Let’s assume we are going to create a compressed NFT collection with 10k NFTs in
it. And since our collection is relatively small, we only need a single smaller
tree to store all the NFTs:</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>ts
// define the depth and buffer size of our tree to be created
const maxDepthSizePair: ValidDepthSizePair = {</p>
<blockquote>
<div><p>// max=16,384 nodes (for a <cite>maxDepth</cite> of 14)
maxDepth: 14,
maxBufferSize: 64,</p>
</div></blockquote>
<p>};</p>
<p>// define the canopy depth of our tree to be created
const canopyDepth = 10;
<a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a></p>
<p>Setting a <cite>maxDepth</cite> of <cite>14</cite> will allow our tree to hold up to <cite>16,384</cite>
compressed NFTs, more than exceeding our <cite>10k</cite> collection size.</p>
<p>Since only specific
[<cite>ValidDepthSizePair</cite>](<a class="reference external" href="https://solana-labs.github.io/solana-program-library/account-compression/sdk/docs/modules/index.html#ValidDepthSizePair">https://solana-labs.github.io/solana-program-library/account-compression/sdk/docs/modules/index.html#ValidDepthSizePair</a>)
pairs are allowed, simply set the <cite>maxBufferSize</cite> to the corresponding value
tied to your desired <cite>maxDepth</cite>.</p>
<p>Next, setting <cite>canopyDepth</cite> of <cite>10</cite> tells our tree to store <cite>10</cite> of our “proof
node hashes” on-chain. Thus requiring us to always include <cite>4</cite> proof node values
(i.e. <cite>maxDepth - canopyDepth</cite>) in every compressed NFT transfer instruction.</p>
<p>### Generate addresses for the tree</p>
<p>When creating a new tree, we need to generate a new
[Keypair](../../terminology.md#keypair) address for the tree to have:</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">const</span> <span class="pre">treeKeypair</span> <span class="pre">=</span> <span class="pre">Keypair.generate();</span>
<span class="pre">`</span></code></p>
<p>Since our tree will be used for compressed NFTs, we will also need to derive an
Account with authority that is owned by the Bubblegum program (i.e. PDA):</p>
<p><a href="#id9"><span class="problematic" id="id10">``</span></a><a href="#id11"><span class="problematic" id="id12">`</span></a>ts
// derive the tree’s authority (PDA), owned by Bubblegum
const [treeAuthority, _bump] = PublicKey.findProgramAddressSync(</p>
<blockquote>
<div><p>[treeKeypair.publicKey.toBuffer()],
BUBBLEGUM_PROGRAM_ID,</p>
</div></blockquote>
<section id="id13">
<h2>);<a class="headerlink" href="#id13" title="Permalink to this heading">¶</a></h2>
<p>### Build the tree creation instructions</p>
<p>With our tree size values defined, and our addresses generated, we need to build
two related instructions:</p>
<ol class="arabic simple">
<li><p>allocate enough space on-chain for our tree</p></li>
<li><p>actually create the tree, owned by the Bubblegum program</p></li>
</ol>
<p>Using the
[<cite>createAllocTreeIx</cite>](<a class="reference external" href="https://solana-labs.github.io/solana-program-library/account-compression/sdk/docs/modules/index.html#createAllocTreeIx">https://solana-labs.github.io/solana-program-library/account-compression/sdk/docs/modules/index.html#createAllocTreeIx</a>)
helper function, we allocate enough space on-chain for our tree.</p>
<p><a href="#id14"><span class="problematic" id="id15">``</span></a><cite>ts
// allocate the tree’s account on chain with the `space</cite>
const allocTreeIx = await createAllocTreeIx(</p>
<blockquote>
<div><p>connection,
treeKeypair.publicKey,
payer.publicKey,
maxDepthSizePair,
canopyDepth,</p>
</div></blockquote>
</section>
<section id="id16">
<h2>);<a class="headerlink" href="#id16" title="Permalink to this heading">¶</a></h2>
<p>Then using the
[<cite>createCreateTreeInstruction</cite>](<a class="reference external" href="https://metaplex-foundation.github.io/metaplex-program-library/docs/bubblegum/functions/createCreateTreeInstruction.html">https://metaplex-foundation.github.io/metaplex-program-library/docs/bubblegum/functions/createCreateTreeInstruction.html</a>)
from the Bubblegum SDK, we actually create the tree on-chain. Making it owned by
the Bubblegum program.</p>
<p><a href="#id17"><span class="problematic" id="id18">``</span></a><a href="#id19"><span class="problematic" id="id20">`</span></a>ts
// create the instruction to actually create the tree
const createTreeIx = createCreateTreeInstruction(</p>
<blockquote>
<div><dl class="simple">
<dt>{</dt><dd><p>payer: payer.publicKey,
treeCreator: payer.publicKey,
treeAuthority,
merkleTree: treeKeypair.publicKey,
compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
// NOTE: this is used for some on chain logging
logWrapper: SPL_NOOP_PROGRAM_ID,</p>
</dd>
</dl>
<p>},
{</p>
<blockquote>
<div><p>maxBufferSize: maxDepthSizePair.maxBufferSize,
maxDepth: maxDepthSizePair.maxDepth,
public: false,</p>
</div></blockquote>
<p>},
BUBBLEGUM_PROGRAM_ID,</p>
</div></blockquote>
</section>
<section id="id21">
<h2>);<a class="headerlink" href="#id21" title="Permalink to this heading">¶</a></h2>
<p>### Build and send the transaction</p>
<p>With our two instructions built, we can add them into a transaction and send
them to the blockchain, making sure both the <cite>payer</cite> and generated <cite>treeKeypair</cite>
sign the transaction:</p>
<p><a href="#id22"><span class="problematic" id="id23">``</span></a><a href="#id24"><span class="problematic" id="id25">`</span></a>ts
// build the transaction
const tx = new Transaction().add(allocTreeIx).add(createTreeIx);
tx.feePayer = payer.publicKey;</p>
<p>// send the transaction
const txSignature = await sendAndConfirmTransaction(</p>
<blockquote>
<div><p>connection,
tx,
// ensuring the <cite>treeKeypair</cite> PDA and the <cite>payer</cite> are BOTH signers
[treeKeypair, payer],
{</p>
<blockquote>
<div><p>commitment: “confirmed”,
skipPreflight: true,</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
</section>
<section id="id26">
<h2>);<a class="headerlink" href="#id26" title="Permalink to this heading">¶</a></h2>
<p>After a few short moments, and once the transaction is confirmed, we are ready
to start minting compressed NFTs into our tree.</p>
<p>## Mint compressed NFTs</p>
<p>Since compressed NFTs follow the same Metaplex
[metadata standards](<a class="reference external" href="https://docs.metaplex.com/programs/token-metadata/accounts#metadata">https://docs.metaplex.com/programs/token-metadata/accounts#metadata</a>)
as traditional NFTs, we can define our actual NFTs data the same way.</p>
<p>The primary difference is that with compressed NFTs the metadata is actually
stored in the ledger (unlike traditional NFTs that store them in accounts). The
metadata gets “hashed” and stored in our tree, and by association, secured by
the Solana ledger.</p>
<p>Allowing us to cryptographically verify that our original metadata has not
changed (unless we want it to).</p>
<p>:::info</p>
<p>Learn more about how State Compression uses
[concurrent merkle trees](../../learn/state-compression.md#what-is-a-concurrent-merkle-tree)
to cryptographically secure off-chain data using the Solana ledger.</p>
<p>::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">### Define our NFT&#39;s metadata</span>
</pre></div>
</div>
<p>We can define the specific metadata for the single NFT we are about to mint:</p>
<p><a href="#id27"><span class="problematic" id="id28">``</span></a><a href="#id29"><span class="problematic" id="id30">`</span></a>ts
const compressedNFTMetadata: MetadataArgs = {</p>
<blockquote>
<div><p>name: “NFT Name”,
symbol: “ANY”,
// specific json metadata for each NFT
uri: “<a class="reference external" href="https://supersweetcollection.notarealurl/token.json">https://supersweetcollection.notarealurl/token.json</a>”,
creators: null,
editionNonce: 0,
uses: null,
collection: null,
primarySaleHappened: false,
sellerFeeBasisPoints: 0,
isMutable: false,
// these values are taken from the Bubblegum package
tokenProgramVersion: TokenProgramVersion.Original,
tokenStandard: TokenStandard.NonFungible,</p>
</div></blockquote>
</section>
<section id="id31">
<h2>};<a class="headerlink" href="#id31" title="Permalink to this heading">¶</a></h2>
<p>In this demo, the key pieces of our NFT’s metadata to note are:</p>
<ul class="simple">
<li><p><cite>name</cite> - this is the actual name of our NFT that will be displayed in wallets
and on explorers.</p></li>
<li><p><cite>uri</cite> - this is the address for your NFTs metadata JSON file.</p></li>
<li><p><cite>creators</cite> - for this example, we are not storing a list of creators. If you
want your NFTs to have royalties, you will need to store actual data here. You
can checkout the Metaplex docs for more info on it.</p></li>
</ul>
<p>### Derive the Bubblegum signer</p>
<p>When minting new compressed NFTs, the Bubblegum program needs a PDA to perform a
[cross-program invocation](../programming-model/calling-between-programs#cross-program-invocations)
(<cite>cpi</cite>) to the SPL compression program.</p>
<p>:::caution</p>
<p>This <cite>bubblegumSigner</cite> PDA is derived using a hard coded seed string of
<cite>collection_cpi</cite> and owned by the Bubblegum program. If this hard coded value is
not provided correctly, your compressed NFT minting will fail.</p>
<p>::</p>
<p>Below, we derive this PDA using the <strong>required</strong> hard coded seed string of
<cite>collection_cpi</cite>:</p>
<p><a href="#id32"><span class="problematic" id="id33">``</span></a><a href="#id34"><span class="problematic" id="id35">`</span></a>ts
// derive a PDA (owned by Bubblegum) to act as the signer of the compressed minting
const [bubblegumSigner, _bump2] = PublicKey.findProgramAddressSync(</p>
<blockquote>
<div><p>// <cite>collection_cpi</cite> is a custom prefix required by the Bubblegum program
[Buffer.from(“collection_cpi”, “utf8”)],
BUBBLEGUM_PROGRAM_ID,</p>
</div></blockquote>
</section>
<section id="id36">
<h2>);<a class="headerlink" href="#id36" title="Permalink to this heading">¶</a></h2>
<p>### Create the mint instruction</p>
<p>Now we should have all the information we need to actually mint our compressed
NFT.</p>
<p>Using the <cite>createMintToCollectionV1Instruction</cite> helper function provided in the
Bubblegum SDK, we can craft the instruction to actually mint our compressed NFT
directly into our collection.</p>
<p>If you have minted traditional NFTs on Solana, this will look fairly similar. We
are creating a new instruction, giving several of the account addresses you
might expect (e.g. the <cite>payer</cite>, <cite>tokenMetadataProgram</cite>, and various collection
addresses), and then some tree specific addresses.</p>
<p>The addresses to pay special attention to are:</p>
<ul class="simple">
<li><p><cite>leafOwner</cite> - this will be the owner of the compressed NFT. You can either
mint it your self (i.e. the <cite>payer</cite>), or airdrop to any other Solana address</p></li>
<li><p><cite>leafDelegate</cite> - this is the delegated authority of this specific NFT we are
about to mint. If you do not want to have a delegated authority for the NFT we
are about to mint, then this value should be set to the same address of
<cite>leafOwner</cite>.</p></li>
</ul>
<p><a href="#id37"><span class="problematic" id="id38">``</span></a><a href="#id39"><span class="problematic" id="id40">`</span></a>ts
const compressedMintIx = createMintToCollectionV1Instruction(</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>payer: payer.publicKey,</p>
<p>merkleTree: treeAddress,
treeAuthority,
treeDelegate: payer.publicKey,</p>
<p>// set the receiver of the NFT
leafOwner: receiverAddress || payer.publicKey,
// set a delegated authority over this NFT
leafDelegate: payer.publicKey,</p>
<p>// collection details
collectionAuthority: payer.publicKey,
collectionAuthorityRecordPda: BUBBLEGUM_PROGRAM_ID,
collectionMint: collectionMint,
collectionMetadata: collectionMetadata,
editionAccount: collectionMasterEditionAccount,</p>
<p>// other accounts
bubblegumSigner: bubblegumSigner,
compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
logWrapper: SPL_NOOP_PROGRAM_ID,
tokenMetadataProgram: TOKEN_METADATA_PROGRAM_ID,</p>
</dd>
</dl>
<p>},
{</p>
<blockquote>
<div><dl class="simple">
<dt>metadataArgs: Object.assign(compressedNFTMetadata, {</dt><dd><p>collection: { key: collectionMint, verified: false },</p>
</dd>
</dl>
<p>}),</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
</section>
<section id="id41">
<h2>);<a class="headerlink" href="#id41" title="Permalink to this heading">¶</a></h2>
<p>Some of the other tree specific addresses are:</p>
<ul class="simple">
<li><p><cite>merkleTree</cite> - the address of our tree we created</p></li>
<li><p><cite>treeAuthority</cite> - the authority of the tree</p></li>
<li><p><cite>treeDelegate</cite> - the delegated authority of the entire tree</p></li>
</ul>
<p>Then we also have all of our NFT collection’s addresses, including the mint
address, metadata account, and edition account. These addresses are also
standard to pass in when minting uncompressed NFTs.</p>
<p>#### Sign and send the transaction</p>
<p>Once our compressed mint instruction has been created, we can add it to a
transaction and send it to the Solana network:</p>
<p><a href="#id42"><span class="problematic" id="id43">``</span></a><a href="#id44"><span class="problematic" id="id45">`</span></a>ts
const tx = new Transaction().add(compressedMintIx);
tx.feePayer = payer.publicKey;</p>
<p>// send the transaction to the cluster
const txSignature = await sendAndConfirmTransaction(connection, tx, [payer], {</p>
<blockquote>
<div><p>commitment: “confirmed”,
skipPreflight: true,</p>
</div></blockquote>
</section>
<section id="id46">
<h2>});<a class="headerlink" href="#id46" title="Permalink to this heading">¶</a></h2>
<p>## Reading compressed NFTs metadata</p>
<p>With the help of a supporting RPC provider, developers can use the Digital Asset
Standard Read API (or “Read API” for short) to fetch the metadata of NFTs.</p>
<p>:::info</p>
<p>The Read API supports both compressed NFTs and traditional/uncompressed NFTs.
You can use the same RPC endpoints to retrieve all the assorted information for
both types of NFTs, including auto-fetching the NFTs’ JSON URI.</p>
<p>::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">### Using the Read API</span>
</pre></div>
</div>
<p>When working with the Read API and a supporting RPC provider, developers can
make <cite>POST</cite> requests to the RPC endpoint using your preferred method of making
such requests (e.g. <cite>curl</cite>, JavaScript <cite>fetch()</cite>, etc).</p>
<p>:::warning Asset ID</p>
<p>Within the Read API, digital assets (i.e. NFTs) are indexed by their <cite>id</cite>. This
asset <cite>id</cite> value differs slightly between traditional NFTs and compressed NFTs:</p>
<ul class="simple">
<li><p>for traditional/uncompressed NFTs: this is the token’s address for the actual
Account on-chain that stores the metadata for the asset.</p></li>
<li><p>for compressed NFTs: this is the <cite>id</cite> of the compressed NFT within the tree
and is <strong>NOT</strong> an actual on-chain Account address. While a compressed NFT’s
<cite>assetId</cite> resembles a traditional Solana Account address, it is not.</p></li>
</ul>
<p>::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">### Common Read API Methods</span>
</pre></div>
</div>
<p>While the Read API supports more than these listed below, the most commonly used
methods are:</p>
<ul class="simple">
<li><p><cite>getAsset</cite> - get a specific NFT asset by its <cite>id</cite></p></li>
<li><p><cite>getAssetProof</cite> - returns the merkle proof that is required to transfer a
compressed NFT, by its asset <cite>id</cite></p></li>
<li><p><cite>getAssetsByOwner</cite> - get the assets owned by a specific address</p></li>
<li><p><cite>getAssetsByGroup</cite> - get the assets by a specific grouping (i.e. a collection)</p></li>
</ul>
<p>:::info Read API Methods, Schema, and Specification</p>
<p>Explore all the additional RPC methods added by Digital Asset Standard Read API
on [Metaplex’s RPC Playground](<a class="reference external" href="https://metaplex-read-api.surge.sh/">https://metaplex-read-api.surge.sh/</a>). Here you
will also find the expected inputs and response schema for each supported RPC
method.</p>
<p>::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">### Example Read API Request</span>
</pre></div>
</div>
<p>For demonstration, below is an example request for the <cite>getAsset</cite> method using
the
[JavaScript Fetch API](<a class="reference external" href="https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API">https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API</a>),
which is built into modern JavaScript runtimes:</p>
<p><a href="#id47"><span class="problematic" id="id48">``</span></a><cite>ts
// make a POST request to the RPC using the JavaScript `fetch</cite> api
const response = await fetch(rpcEndpointUrl, {</p>
<blockquote>
<div><p>method: “POST”,
headers: {</p>
<blockquote>
<div><p>“Content-Type”: “application/json”,</p>
</div></blockquote>
<p>},
body: JSON.stringify({</p>
<blockquote>
<div><p>jsonrpc: “2.0”,
id: “rpd-op-123”,
method: “getAsset”,
params: {</p>
<blockquote>
<div><p>id: “5q7qQ4FWYyj4vnFrivRBe6beo6p88X8HTkkyVPjPkQmF”,</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>}),</p>
</div></blockquote>
</section>
<section id="id49">
<h2>});<a class="headerlink" href="#id49" title="Permalink to this heading">¶</a></h2>
<p>### Example Read API Response</p>
<p>With a successful response from the RPC, you should seem similar data to this:</p>
<p><a href="#id50"><span class="problematic" id="id51">``</span></a><a href="#id52"><span class="problematic" id="id53">`</span></a>ts
{</p>
<blockquote>
<div><p>interface: ‘V1_NFT’,
id: ‘5q7qQ4FWYyj4vnFrivRBe6beo6p88X8HTkkyVPjPkQmF’,
content: [Object],
authorities: [Array],
compression: [Object],
grouping: [],
royalty: [Object],
creators: [],
ownership: [Object],
supply: [Object],
mutable: false</p>
</div></blockquote>
</section>
<section id="id54">
<h2>}<a class="headerlink" href="#id54" title="Permalink to this heading">¶</a></h2>
<p>The response fields to pay special attention to are:</p>
<ul class="simple">
<li><p><cite>id</cite> - this is your asset’s <cite>id</cite></p></li>
<li><p><cite>grouping</cite> - can tell you the collection address that the NFT belongs to. The
collection address will be the <cite>group_value</cite>.</p></li>
<li><p><cite>metadata</cite> - contains the actual metadata for the NFT, including the auto
fetched JSON uri set when the NFT was minted</p></li>
<li><p><cite>ownership</cite> - gives you the NFT owner’s address (and also if the NFT has
delegated authority to another address)</p></li>
<li><p><cite>compression</cite> - tells you if this NFT is actually using compression or not.
For compressed NFTs, this will also give you the tree address that is storing
the compressed NFT on chain.</p></li>
</ul>
<p>:::caution</p>
<p>Some of the returned values may be empty if the NFT is <strong>not</strong> a compressed NFT,
such as many of the <cite>compression</cite> fields. This is expected.</p>
<p>::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## Transfer compressed NFTs</span>
</pre></div>
</div>
<p>Transferring compressed NFTs is different from transferring uncompressed NFTs.
Aside from using a different on-chain program, compressed NFTs require the use
of a asset’s “merkle proof” (or <cite>proof</cite> for short) to actually change ownership.</p>
<p>:::info What is a merkle proof?</p>
<p>An asset’s “merkle proof” is a listing of all the “adjacent hashes” within the
tree that are required to validate a specific leaf within said tree.</p>
<p>These proof hashes themselves, and the specific asset’s leaf data, are hashed
together in a deterministic way to compute the “root hash”. Therefore, allowing
for cryptographic validation of an asset within the merkle tree.</p>
<p><strong>NOTE:</strong> While each of these hash values resemble a Solana Account’s
[address/public key](../../terminology.md#public-key-pubkey), they are not
addresses.</p>
<p>::</p>
<p>Transferring ownership of a compressed NFT happens in 5 broad steps:</p>
<ol class="arabic simple">
<li><p>get the NFT’s “asset” data (from the indexer)</p></li>
<li><p>get the NFT’s proof (from the indexer)</p></li>
<li><p>get the Merkle tree account (directly from the Solana blockchain)</p></li>
<li><p>prepare the asset proof</p></li>
<li><p>build and send the transfer instruction</p></li>
</ol>
<p>The first three steps primarily involve gathering specific pieces of information
(the <cite>proof</cite> and the tree’s canopy depth) for the NFT to be transferred. These
pieces of information are needed to correctly parse/format the <cite>proof</cite> to
actually be sent within the transfer instruction itself.</p>
<p>### Get the asset</p>
<p>To perform the transfer of our compressed NFT, we will need to retrieve a few
pieces of information about the NFT.</p>
<p>For starters, we will need to get some the asset’s information in order to allow
the on-chain compression program to correctly perform validation and security
checks.</p>
<p>We can use the <cite>getAsset</cite> RPC method to retrieve two important pieces of
information for the compressed NFT: the <cite>data_hash</cite> and <cite>creator_hash</cite>.</p>
<p>#### Example response from the <cite>getAsset</cite> method</p>
<p>Below is an example response from the <cite>getAsset</cite> method:</p>
<p><a href="#id55"><span class="problematic" id="id56">``</span></a><a href="#id57"><span class="problematic" id="id58">`</span></a>ts
compression: {</p>
<blockquote>
<div><p>eligible: false,
compressed: true,
data_hash: ‘D57LAefACeaJesajt6VPAxY4QFXhHjPyZbjq9efrt3jP’,
creator_hash: ‘6Q7xtKPmmLihpHGVBA6u1ENE351YKoyqd3ssHACfmXbn’,
asset_hash: ‘F3oDH1mJ47Z7tNBHvrpN5UFf4VAeQSwTtxZeJmn7q3Fh’,
tree: ‘BBUkS4LZQ7mU8iZXYLVGNUjSxCYnB3x44UuPVHVXS9Fo’,
seq: 3,
leaf_id: 0</p>
</div></blockquote>
</section>
<section id="id59">
<h2>}<a class="headerlink" href="#id59" title="Permalink to this heading">¶</a></h2>
<p>### Get the asset proof</p>
<p>The next step in preparing your compressed NFT transfer instruction, is to get a
<strong>valid</strong> asset <cite>proof</cite> to perform the transfer. This proof is required by the
on-chain compression program to validate on-chain information.</p>
<p>We can use the <cite>getAssetProof</cite> RPC method to retrieve two important pieces of
information:</p>
<ul class="simple">
<li><p><cite>proof</cite> - the “full proof” that is required to perform the transfer (more on
this below)</p></li>
<li><p><cite>tree_id</cite> - the on-chain address of the compressed NFTs tree</p></li>
</ul>
<p>:::info Full proof is returned</p>
<p>The <cite>getAssetProof</cite> RPC method returns the complete listing of “proof hashes”
that are used to perform the compressed NFT transfer. Since this “full proof” is
returned from the RPC, we will need to remove the portion of the “full proof”
that is stored on-chain via the tree’s <cite>canopy</cite>.</p>
<p>::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">#### Example response from the `getAssetProof` method</span>
</pre></div>
</div>
<p>Below is an example response from the <cite>getAssetProof</cite> method:</p>
<p><a href="#id60"><span class="problematic" id="id61">``</span></a><a href="#id62"><span class="problematic" id="id63">`</span></a>ts
{</p>
<blockquote>
<div><p>root: ‘7dy5bzgaRcUnNH2KMExwNXXNaCJnf7wQqxc2VrGXy9qr’,
proof: [</p>
<blockquote>
<div><p>‘HdvzZ4hrPEdEarJfEzAavNJEZcCS1YU1fg2uBvQGwAAb’,
…
‘3e2oBSLfSDVdUdS7jRGFKa8nreJUA9sFPEELrHaQyd4J’</p>
</div></blockquote>
<p>],
node_index: 131072,
leaf: ‘F3oDH1mJ47Z7tNBHvrpN5UFf4VAeQSwTtxZeJmn7q3Fh’,
tree_id: ‘BBUkS4LZQ7mU8iZXYLVGNUjSxCYnB3x44UuPVHVXS9Fo’</p>
</div></blockquote>
</section>
<section id="id64">
<h2>}<a class="headerlink" href="#id64" title="Permalink to this heading">¶</a></h2>
<p>### Get the Merkle tree account</p>
<p>Since the <cite>getAssetProof</cite> will always return the “full proof”, we will have to
reduce it down in order to remove the proof hashes that are stored on-chain in
the tree’s canopy. But in order to remove the correct number of proof addresses,
we need to know the tree’s <cite>canopyDepth</cite>.</p>
<p>Once we have our compressed NFT’s tree address (the <cite>tree_id</cite> value from
<cite>getAssetProof</cite>), we can use the
[<cite>ConcurrentMerkleTreeAccount</cite>](<a class="reference external" href="https://solana-labs.github.io/solana-program-library/account-compression/sdk/docs/classes/index.ConcurrentMerkleTreeAccount.html">https://solana-labs.github.io/solana-program-library/account-compression/sdk/docs/classes/index.ConcurrentMerkleTreeAccount.html</a>)
class, from the <cite>&#64;solana/spl-account-compression</cite> SDK:</p>
<p><a href="#id65"><span class="problematic" id="id66">``</span></a><a href="#id67"><span class="problematic" id="id68">`</span></a>ts
// retrieve the merkle tree’s account from the blockchain
const treeAccount = await ConcurrentMerkleTreeAccount.fromAccountAddress(</p>
<blockquote>
<div><p>connection,
treeAddress,</p>
</div></blockquote>
<p>);</p>
<p>// extract the needed values for our transfer instruction
const treeAuthority = treeAccount.getAuthority();
const canopyDepth = treeAccount.getCanopyDepth();
<a href="#id69"><span class="problematic" id="id70">``</span></a><a href="#id71"><span class="problematic" id="id72">`</span></a></p>
<p>For the transfer instruction, we will also need the current <cite>treeAuthority</cite>
address which we can also get via the <cite>treeAccount</cite>.</p>
<p>### Prepare the asset proof</p>
<p>With our “full proof” and <cite>canopyDepth</cite> values on hand, we can correctly format
the <cite>proof</cite> to be submitted within the transfer instruction itself.</p>
<p>Since we will use the <cite>createTransferInstruction</cite> helper function from the
Bubblegum SDK to actually build our transfer instruction, we need to:</p>
<ul class="simple">
<li><p>remove the proof values that are already stored on-chain in the
[tree’s canopy](../../learn/state-compression.md#canopy-depth), and</p></li>
<li><p>convert the remaining proof values into the valid <cite>AccountMeta</cite> structure that
the instruction builder function accepts</p></li>
</ul>
<p><a href="#id73"><span class="problematic" id="id74">``</span></a><a href="#id75"><span class="problematic" id="id76">`</span></a>ts
// parse the list of proof addresses into a valid AccountMeta[]
const proof: AccountMeta[] = assetProof.proof</p>
<blockquote>
<div><p>.slice(0, assetProof.proof.length - (!!canopyDepth ? canopyDepth : 0))
.map((node: string) =&gt; ({</p>
<blockquote>
<div><p>pubkey: new PublicKey(node),
isSigner: false,
isWritable: false,</p>
</div></blockquote>
<p>}));</p>
</div></blockquote>
<p><a href="#id77"><span class="problematic" id="id78">``</span></a><a href="#id79"><span class="problematic" id="id80">`</span></a></p>
<p>In the TypeScript code example above, we are first taking a <cite>slice</cite> of our “full
proof”, starting at the beginning of the array, and ensuring we only have
<cite>proof.length - canopyDepth</cite> number of proof values. This will remove the
portion of the proof that is already stored on-chain in the tree’s canopy.</p>
<p>Then we are structuring each of the remaining proof values as a valid
<cite>AccountMeta</cite>, since the proof is submitted on-chain in the form of “extra
accounts” within the transfer instruction.</p>
<p>### Build the transfer instruction</p>
<p>Finally, with all the required pieces of data about our tree and compressed
NFTs, and a correctly formatted proof, we are ready to actually create the
transfer instruction.</p>
<p>Build your transfer instruction using the
[<cite>createTransferInstruction</cite>](<a class="reference external" href="https://metaplex-foundation.github.io/metaplex-program-library/docs/bubblegum/functions/createTransferInstruction.html">https://metaplex-foundation.github.io/metaplex-program-library/docs/bubblegum/functions/createTransferInstruction.html</a>)
helper function from the Bubblegum SDK:</p>
<p><a href="#id81"><span class="problematic" id="id82">``</span></a><a href="#id83"><span class="problematic" id="id84">`</span></a>ts
// create the NFT transfer instruction (via the Bubblegum package)
const transferIx = createTransferInstruction(</p>
<blockquote>
<div><dl class="simple">
<dt>{</dt><dd><p>merkleTree: treeAddress,
treeAuthority,
leafOwner,
leafDelegate,
newLeafOwner,
logWrapper: SPL_NOOP_PROGRAM_ID,
compressionProgram: SPL_ACCOUNT_COMPRESSION_PROGRAM_ID,
anchorRemainingAccounts: proof,</p>
</dd>
</dl>
<p>},
{</p>
<blockquote>
<div><p>root: […new PublicKey(assetProof.root.trim()).toBytes()],
dataHash: […new PublicKey(asset.compression.data_hash.trim()).toBytes()],
creatorHash: [</p>
<blockquote>
<div><p>…new PublicKey(asset.compression.creator_hash.trim()).toBytes(),</p>
</div></blockquote>
<p>],
nonce: asset.compression.leaf_id,
index: asset.compression.leaf_id,</p>
</div></blockquote>
<p>},
BUBBLEGUM_PROGRAM_ID,</p>
</div></blockquote>
</section>
<section id="id85">
<h2>);<a class="headerlink" href="#id85" title="Permalink to this heading">¶</a></h2>
<p>Aside from passing in our assorted Account addresses and the asset’s proof, we
are converting the string values of our <cite>data_hash</cite>, <cite>creator_hash</cite>, <cite>root</cite> hash
into an array of bytes that is accepted by the <cite>createTransferInstruction</cite>
helper function.</p>
<p>Since each of these hash values resemble and are formatted similar to
PublicKeys, we can use the
[<cite>PublicKey</cite>](<a class="reference external" href="https://solana-labs.github.io/solana-web3.js/classes/PublicKey.html">https://solana-labs.github.io/solana-web3.js/classes/PublicKey.html</a>)
class in web3.js to convert them into a accepted byte array format.</p>
<p>#### Send the transaction</p>
<p>With our transfer instructions built, we can add it into a transaction and send
it to the blockchain similar to before. Making sure either the current
<cite>leafOwner</cite> or the <cite>leafDelegate</cite> signs the transaction.</p>
<p>:::note</p>
<p>After each successful transfer of a compressed NFT, the <cite>leafDelegate</cite> should
reset to an empty value. Meaning the specific asset will not have delegated
authority to an address other than its owner.</p>
<p>::</p>
<p>And once confirmed by the cluster, we will have successfully transferred a
compressed NFT.</p>
<p>## Example code repository</p>
<p>You can find an example code repository for this developer guide on the Solana
Developers GitHub: <a class="reference external" href="https://github.com/solana-developers/compressed-nfts">https://github.com/solana-developers/compressed-nfts</a></p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../_sources/src/developing/guides/compressed-nfts.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>