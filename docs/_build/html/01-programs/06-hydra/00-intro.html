<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>docs/01-programs/06-hydra/00-intro.md &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="docs-01-programs-06-hydra-00-intro-md">
<h1>docs/01-programs/06-hydra/00-intro.md<a class="headerlink" href="#docs-01-programs-06-hydra-00-intro-md" title="Permalink to this heading">¬∂</a></h1>
<p>Last edited: 2023-08-08 19:56:25</p>
<p>Contents:</p>
<div class="highlight-md notranslate"><div class="highlight"><pre><span></span><span class="gh"># Introduction</span>
</pre></div>
</div>
<p>Hydra is a wallet of wallets, a fanout wallet if you will. It enables extremely large membership sets that can take part
in fund distribution from a central wallet. It works with SOL and any SPL token.</p>
<p>![](/assets/programs/hydra/hydra.jpg#radius#shadow)</p>
<p>üîó <strong>Helpful links:</strong></p>
<ul class="simple">
<li><p>[Hydra UI](<a class="reference external" href="https://github.com/cardinal-labs/hydra-ui">https://github.com/cardinal-labs/hydra-ui</a>)</p></li>
<li><p>[GitHub Repository](<a class="reference external" href="https://github.com/GlassEaters/hydra">https://github.com/GlassEaters/hydra</a>)</p></li>
<li><p>[JS SDK](<a class="reference external" href="https://www.npmjs.com/package/&#64;glasseaters/hydra-sdk">https://www.npmjs.com/package/&#64;glasseaters/hydra-sdk</a>)</p></li>
<li><p>[Rust Crate](<a class="reference external" href="https://crates.io/crates/hydra_wallet">https://crates.io/crates/hydra_wallet</a>)</p></li>
</ul>
<p>:::warning</p>
<p>The PROGRAM ID FOR Hydra is:</p>
<p>Devnet: hyDQ4Nz1eYyegS6JfenyKwKzYxRsCWCriYSAjtzP4Vg</p>
<p>Testnet: Do you want this?</p>
<p>Mainnet: hyDQ4Nz1eYyegS6JfenyKwKzYxRsCWCriYSAjtzP4Vg</p>
<p>::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## Basic Flow</span>
</pre></div>
</div>
<p>A Hydra Wallet‚Äôs lifecycle has 3 phases:</p>
<ol class="arabic simple">
<li><p>Creation - Create the Wallet</p></li>
<li><p>Member Addition - Add Members and specify their share</p></li>
<li><p>Distribution - Distribute funds to the Members according to their share</p></li>
</ol>
<p>The Distribution phase is an on-chain operation that‚Äôs called on a per-Member basis. We‚Äôll get into all the details of
this later, but Hydra will track all distributions and ensure that Members always get their fair share of the funds. As
new funds flow into the Hydra Wallet, members (or other automated processes) will call the Distribution operation to
disburse the appropriate share of funds to the given Member.</p>
<p>Let‚Äôs get into a bit more detail on these steps.</p>
<p>## Creating a Wallet</p>
<p>The creator of the Hydra Wallet is known as the <strong>Authority</strong>. The Authority will specify the globally unique name of
the wallet, the total number of shares to be distributed, and the Membership Model (which we‚Äôll cover in a moment).
We‚Äôve provided our own <cite>FanoutClient</cite> with the SDK, which you‚Äôll initialize with the Authority‚Äôs Wallet. You‚Äôll need
about XXX Sol to create the Hydra Wallet.</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>ts
const connection = new Connection(‚Äúdevnet‚Äù, ‚Äúconfirmed‚Äù);
let fanoutSdk: FanoutClient;</p>
<p>authorityWallet = Keypair.generate();</p>
<dl class="simple">
<dt>fanoutSdk = new FanoutClient(</dt><dd><p>connection,
new NodeWallet(new Account(authorityWallet.secretKey))</p>
</dd>
</dl>
<p>);</p>
<dl class="simple">
<dt>const init = await fanoutSdk.initializeFanout({</dt><dd><p>totalShares: 100,
name: <cite>Test${Date.now()}</cite>,
membershipModel: MembershipModel.Wallet,</p>
</dd>
</dl>
<section id="id5">
<h2>});<a class="headerlink" href="#id5" title="Permalink to this heading">¬∂</a></h2>
<p>### Also accept SPL Tokens</p>
<p>If you want to also accept other specific SPL Tokens, you can update your Hydra Wallet to accept those by specifying the
given token‚Äôs public key after initializing the wallet.</p>
<p><a href="#id6"><span class="problematic" id="id7">``</span></a><a href="#id8"><span class="problematic" id="id9">`</span></a>ts
const mintPublicKey = ‚ÄúSPL-Token-Public-Key‚Äù;</p>
<dl>
<dt>const { fanoutForMint, tokenAccount } = await fanoutSdk.initializeFanoutForMint(</dt><dd><dl class="simple">
<dt>{</dt><dd><p>fanout,
mint: mintPublicKey,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</section>
<section id="id10">
<h2>);<a class="headerlink" href="#id10" title="Permalink to this heading">¬∂</a></h2>
<p>## Adding Members</p>
<p>There are three different Membership Models shipping with this first version of Hydra:</p>
<ol class="arabic simple">
<li><p><strong>Wallet</strong> - This is the simplest membership model. It‚Äôs just a list of each Member‚Äôs public address and the number
of shares they own. The sum of all Member‚Äôs shares must equal the <cite>totalShares</cite> specified in the <cite>initializeFanout</cite>
call.</p></li>
</ol>
<p><a href="#id11"><span class="problematic" id="id12">``</span></a><a href="#id13"><span class="problematic" id="id14">`</span></a>ts
const member = new Keypair();</p>
<dl class="simple">
<dt>const { membershipAccount } = await fanoutSdk.addMemberWallet({</dt><dd><p>fanout: init.fanout,
fanoutNativeAccount: init.nativeAccount,
membershipKey: member.publicKey,
shares: 10</p>
</dd>
</dl>
<p>});</p>
<p>// Add members until sum of shares = totalShares
‚Ä¶
<a href="#id15"><span class="problematic" id="id16">``</span></a><a href="#id17"><span class="problematic" id="id18">`</span></a></p>
<ol class="arabic simple" start="2">
<li><p><strong>NFT</strong> - With this model membership is tied to an NFT mint address instead of static public address. Each NFT mint
address can still have a different quantity of shares as in the Wallet model. The greatest benefit of this model is
it effectively enables the simple transfer of rights to future distributions to any wallet owner that holds the given
NFT.</p></li>
</ol>
<p><a href="#id19"><span class="problematic" id="id20">``</span></a><a href="#id21"><span class="problematic" id="id22">`</span></a>ts</p>
<p>const nftMintPublicKey = ‚ÄúnftMintPublicKey‚Äù;</p>
<dl class="simple">
<dt>const init = await fanoutSdk.initializeFanout({</dt><dd><p>totalShares: 100,
name: <cite>Test${Date.now()}</cite>,
membershipModel: MembershipModel.NFT,</p>
</dd>
</dl>
<p>});</p>
<dl class="simple">
<dt>const { membershipAccount } = await fanoutSdk.addMemberNft({</dt><dd><p>fanout: init.fanout,
fanoutNativeAccount: init.nativeAccount,
membershipKey: nftMintPublicKey,
shares: 10</p>
</dd>
</dl>
<p>});</p>
<p>// Add members until sum of shares = totalShares
‚Ä¶
<a href="#id23"><span class="problematic" id="id24">``</span></a><a href="#id25"><span class="problematic" id="id26">`</span></a></p>
<ol class="arabic" start="3">
<li><p><strong>Token</strong> - This is the most flexible membership model, but is a bit more complicated. In this model, Membership is
associated with staked ownership of the specified Token. When creating a Hydra Wallet with the Token model, you
specify the mint of an SPL Token and distribute those tokens to your members (in whatever proportion you want). Then
those members need to stake their tokens with the Hydra Wallet to be able to claim their share of the distribution.</p>
<p>For example, if you mint a supply of 1000 tokens and distribute all 1000, but only 40 of them are staked, then
distributions will be calculated off of the 40 that are staked, not the 1000 total supply. Members who do not stake
get 0% and those that do get <cite>staked / 40</cite> of the distribution.</p>
<p>We are aware of some initialization issues with this model, so for now we recommend you don‚Äôt fund the Hydra Wallet
until you‚Äôve given your members enough time to stake their tokens.</p>
</li>
</ol>
<p><a href="#id27"><span class="problematic" id="id28">``</span></a><a href="#id29"><span class="problematic" id="id30">`</span></a>ts
const membershipMintPublicKey = ‚ÄúSPL-TokenPublicKey‚Äù;</p>
<dl class="simple">
<dt>const { fanout } = await fanoutSdk.initializeFanout({</dt><dd><p>totalShares: 0,
name: <cite>Test${Date.now()}</cite>,
membershipModel: MembershipModel.Token,
mint: membershipMintPublicKey,</p>
</dd>
</dl>
<p>});</p>
<p>// Staking tokens</p>
<dl class="simple">
<dt>const ixs = await fanoutSdk.stakeTokenMemberInstructions({</dt><dd><p>shares: supply * 0.1,
fanout: fanout,
membershipMintTokenAccount: tokenAcctMember,
membershipMint: membershipMint.publicKey,
member: member.publicKey,
payer: member.publicKey,</p>
</dd>
</dl>
<p>});</p>
<dl class="simple">
<dt>const tx = await fanoutSdk.sendInstructions(</dt><dd><p>ixs.instructions,
[member],
member.publicKey</p>
</dd>
</dl>
<p>);
if (!!tx.RpcResponseAndContext.value.err) {</p>
<blockquote>
<div><dl class="simple">
<dt>const txdetails = await connection.getConfirmedTransaction(</dt><dd><p>tx.TransactionSignature</p>
</dd>
</dl>
<p>);
console.log(txdetails, tx.RpcResponseAndContext.value.err);</p>
</div></blockquote>
<p>}</p>
<p>const stake = await membershipMint.getAccountInfo(ixs.output.stakeAccount);
<a href="#id31"><span class="problematic" id="id32">``</span></a><a href="#id33"><span class="problematic" id="id34">`</span></a></p>
<p>:::info</p>
<p>NOTE: Some Hydra use cases are Airdropping the membership token to the members. In this case, you may want to stake then
tokens on the members‚Äô behalf. The most effective way to do this is to use the <cite>stakeForTokenMemberInstructions</cite> method.
In the example below note that the <cite>membershipMintTokenAccount</cite> is the ATA of the Authority not the member. In this way
you are simply sending the membership tokens to the member‚Äôs stake account not their personal ATA for the membership
mint</p>
<p><a href="#id35"><span class="problematic" id="id36">``</span></a><a href="#id37"><span class="problematic" id="id38">`</span></a>ts
// Example of setting up a Hydra with a in Memory keypair.
let authorityWallet = Keypair.generate();
let fanoutSdk = new FanoutClient(</p>
<blockquote>
<div><p>connection,
new NodeWallet(new Account(authorityWallet.secretKey))</p>
</div></blockquote>
<p>);
// Setup a Hydra -&gt; Since you configured the SDK with the authority Wallet as the wallet you dont need to pass the signer into the init.
const { fanout } = await fanoutSdk.initializeFanout({</p>
<blockquote>
<div><p>totalShares: 0,
name: <cite>Test${Date.now()}</cite>,
membershipModel: MembershipModel.Token,
mint: membershipMint.publicKey</p>
</div></blockquote>
<p>});</p>
<p>‚Ä¶
const ixs = await fanoutSdk.stakeForTokenMemberInstructions(</p>
<blockquote>
<div><dl class="simple">
<dt>{</dt><dd><p>shares: supply * .1,
fanout: fanout,
membershipMintTokenAccount: tokenAcct,
membershipMint: membershipMint.publicKey,
fanoutAuthority: authorityWallet.publicKey,
member: member.publicKey,
payer: authorityWallet.publicKey</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</section>
<section id="id39">
<h2>);<a class="headerlink" href="#id39" title="Permalink to this heading">¬∂</a></h2>
<p>::</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="c1">## Distributing Funds</span>
</pre></div>
</div>
<p>The Distribute method is expected to be called many times over the lifetime of a Hydra Wallet. In order to keep the
processing and memory costs under Solana limits while enabling arbitrarily large membership sets, we require that you
specify the Member (and if applicable the Member‚Äôs NFT or SPL mint) that you want to distribute funds to.</p>
<p>:::caution</p>
<p>Distribution will fail if the sum of member shares does not equal the totalShares specified in the <cite>initializeFanout</cite>
call.</p>
<p>::</p>
<p>Hydra will track distribution, so you can call this multiple times and funds will only be distributed to the Member once.
The Distribute method is slightly different depending on the Membership Model:</p>
<p>### Wallet</p>
<p><a href="#id40"><span class="problematic" id="id41">``</span></a><a href="#id42"><span class="problematic" id="id43">`</span></a>ts
const member1
.
publicKey = ‚ÄúMember1.publicKey‚Äù;
const distributionBot = new Keypair();
// This is the caller of the Distribute method, it can be a bot or a user,
// they just need enough funds to pay for the transaction fee. If you‚Äôre using
// this code, airdrop a sol to distributionBot.</p>
<dl>
<dt>let distributeToMember1 = await fanoutSdk.distributeWalletMemberInstructions(</dt><dd><dl class="simple">
<dt>{</dt><dd><p>distributeForMint: false,
member: member1.publicKey,
fanout: fanout, // From initialization
payer: distributionBot.publicKey,</p>
</dd>
</dl>
<p>},</p>
</dd>
</dl>
<p>);</p>
<dl class="simple">
<dt>const tx = await fanoutSdk.sendInstructions(</dt><dd><p>[‚Ä¶distMember1.instructions],
[distributionBot],
distributionBot.publicKey</p>
</dd>
</dl>
<p>);
if (!!tx.RpcResponseAndContext.value.err) {</p>
<blockquote>
<div><p>const txdetails = await connection.getConfirmedTransaction(tx.TransactionSignature);
console.log(txdetails, tx.RpcResponseAndContext.value.err);</p>
</div></blockquote>
</section>
<section id="id44">
<h2>}<a class="headerlink" href="#id44" title="Permalink to this heading">¬∂</a></h2>
<p>### NFT</p>
<p>Same as above, but replace distributeToMember1 with this:</p>
<p><a href="#id45"><span class="problematic" id="id46">``</span></a><a href="#id47"><span class="problematic" id="id48">`</span></a>ts
const member1
.
mint = ‚ÄúNFT Mint for Member 1‚Äù;</p>
<dl>
<dt>let distributeToMember1 = await fanoutSdk.distributeNftMemberInstructions(</dt><dd><dl class="simple">
<dt>{</dt><dd><p>distributeForMint: false,
member: member1.publicKey,
membershipKey: member1.mint,
fanout: fanout,
payer: distributionBot.publicKey,</p>
</dd>
</dl>
<p>},</p>
</dd>
</dl>
</section>
<section id="id49">
<h2>);<a class="headerlink" href="#id49" title="Permalink to this heading">¬∂</a></h2>
<p>### Token</p>
<p>Same as Wallet, but replace distributeToMember1 with this:</p>
<p><a href="#id50"><span class="problematic" id="id51">``</span></a><a href="#id52"><span class="problematic" id="id53">`</span></a>ts
const membershiptMint
.
publicKey = ‚ÄúSPL-Token-PublicKey‚Äù;</p>
<dl>
<dt>let distributeToMember1 = await fanoutSdk.distributeTokenMemberInstructions(</dt><dd><dl class="simple">
<dt>{</dt><dd><p>distributeForMint: false,
membershipMint: membershipMint.publicKey,
fanout: fanout,
member: member1.publicKey,
payer: distributionBot.publicKey,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</section>
<section id="id54">
<h2>);<a class="headerlink" href="#id54" title="Permalink to this heading">¬∂</a></h2>
<p>### Distribute SPL Tokens</p>
<p>The process is basically the same, you‚Äôll additionally specify the Mint of the Token you want to distribute and set
distributeForMint to true.</p>
<p>Example for the Wallet member model:</p>
<p><a href="#id55"><span class="problematic" id="id56">``</span></a><a href="#id57"><span class="problematic" id="id58">`</span></a>ts
const mint
.
publicKey = ‚ÄúSPL-Token-To-Distribute-PublicKey‚Äù;</p>
<dl>
<dt>let distributeToMember1 = await fanoutSdk.distributeWalletMemberInstructions(</dt><dd><dl class="simple">
<dt>{</dt><dd><p>distributeForMint: true,
member: member1.publicKey,
fanout: builtFanout.fanout,
payer: distributionBot.publicKey,
fanoutMint: mint.publicKey</p>
</dd>
</dl>
<p>},</p>
</dd>
</dl>
<p>);</p>
<p><a href="#id59"><span class="problematic" id="id60">``</span></a><a href="#id61"><span class="problematic" id="id62">`</span></a></p>
<p>## Additional Capabilities</p>
<p>### Signing Metadata as Creator</p>
<p>One key use case for Hydra is specifying the Hydra Wallet as a creator with some royalty share for an NFT. We‚Äôve enabled
the Authority of the Hydra Wallet to sign NFTs as the Hydra Wallet so the wallet is a verified creator in the NFT
metadata. We‚Äôve left out the details of creating the NFT, but assuming you‚Äôve set the Hydra wallet a creator
via <cite>init.fanout</cite>, you can sign with the instruction below.</p>
<p><a href="#id63"><span class="problematic" id="id64">``</span></a><a href="#id65"><span class="problematic" id="id66">`</span></a>ts
// Create Hydra as above.</p>
<p>// Set Royalties
const allCreators = [</p>
<blockquote>
<div><p>{ creator: authorityWallet.publicKey, share: 0 },
{</p>
<blockquote>
<div><p>creator: init.fanout,
publicKey,
share: 100,</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>];</p>
<p>// CREATE NFT Code Adding allCreators as Creator for the NFT</p>
<p>const instructions: TransactionInstruction[] = [];
instructions.push(</p>
<blockquote>
<div><p>/// Create NFT Instructions
/// Sign the nft
‚Ä¶fanoutSdk.signMetadataInstructions({</p>
<blockquote>
<div><p>metadata: metadataAccount,
holdingAccount: init.nativeAccount,
fanout: init.fanout,</p>
</div></blockquote>
<p>}).instructions</p>
</div></blockquote>
<p>);</p>
<p>///‚Ä¶.send instructions to solana
<a href="#id67"><span class="problematic" id="id68">``</span></a><a href="#id69"><span class="problematic" id="id70">`</span></a></p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../_sources/01-programs/06-hydra/00-intro.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>