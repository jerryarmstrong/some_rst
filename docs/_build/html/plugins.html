<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>docs/plugins.md &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=039e1c02" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=b3ba4146"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="docs-plugins-md">
<h1>docs/plugins.md<a class="headerlink" href="#docs-plugins-md" title="Permalink to this heading">¶</a></h1>
<p>Last edited: 2023-07-27 15:49:41</p>
<p>Contents:</p>
<div class="highlight-md notranslate"><div class="highlight"><pre><span></span><span class="gh"># Umi plugins</span>
</pre></div>
</div>
<p>Whilst Umi is a small zero-dependency framework, it is designed to be extended with plugins. Plugins allow us to not only interact with its interfaces or swap out its interface implementations but also to add new features to Umi itself.</p>
<p>## Using plugins</p>
<p>To install a Umi plugin, you may simply call the <cite>use</cite> method on the Umi instance. This <cite>use</cite> method returns the Umi instance so they can be chained together.</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>ts
import { somePlugin } from ‘some-umi-library’;
import { myLocalPlugin } from ‘../plugins’;</p>
<p>umi.use(somePlugin).use(myLocalPlugin);
<a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a></p>
<p>It is worth noting that libraries will often provide a function that returns a plugin instead of the plugin itself. This is done so that we can pass any arguments to configure the behaviour of the plugin.</p>
<p><a href="#id9"><span class="problematic" id="id10">``</span></a><a href="#id11"><span class="problematic" id="id12">`</span></a>ts
import { somePlugin } from ‘some-umi-library’;
import { myLocalPlugin } from ‘../plugins’;</p>
<dl class="simple">
<dt>umi.use(somePlugin(somePluginOptions))</dt><dd><p>.use(myLocalPlugin(myLocalPluginOptions));</p>
</dd>
</dl>
<p><a href="#id13"><span class="problematic" id="id14">``</span></a><a href="#id15"><span class="problematic" id="id16">`</span></a></p>
<p>To stay consistent, the plugins provided by Umi always follow this pattern even if they don’t require any arguments. Here are some examples:</p>
<p><a href="#id17"><span class="problematic" id="id18">``</span></a><a href="#id19"><span class="problematic" id="id20">`</span></a>ts
import { web3JsRpc } from <a class="reference external" href="mailto:'&#37;&#52;&#48;metaplex-foundation/umi-rpc-web3js">‘<span>&#64;</span>metaplex-foundation/umi-rpc-web3js</a>’;
import { mockStorage } from <a class="reference external" href="mailto:'&#37;&#52;&#48;metaplex-foundation/umi-storage-mock">‘<span>&#64;</span>metaplex-foundation/umi-storage-mock</a>’;
import { httpDownloader } from <a class="reference external" href="mailto:'&#37;&#52;&#48;metaplex-foundation/umi-downloader-http">‘<span>&#64;</span>metaplex-foundation/umi-downloader-http</a>’;</p>
<dl class="simple">
<dt>umi.use(web3JsRpc(’<a class="reference external" href="https://api.mainnet-beta.solana.com">https://api.mainnet-beta.solana.com</a>’))</dt><dd><p>.use(mockStorage())
.use(httpDownloader());</p>
</dd>
</dl>
<p><a href="#id21"><span class="problematic" id="id22">``</span></a><a href="#id23"><span class="problematic" id="id24">`</span></a></p>
<p>## Creating plugins</p>
<p>Under the hood, Umi defines a plugin as an object with an <cite>install</cite> function that can be used to extend the Umi instance however we want.</p>
<p><a href="#id25"><span class="problematic" id="id26">``</span></a><a href="#id27"><span class="problematic" id="id28">`</span></a>ts
export const myPlugin: UmiPlugin = {</p>
<blockquote>
<div><dl class="simple">
<dt>install(umi: Umi) {</dt><dd><p>// Do something with the Umi instance.</p>
</dd>
</dl>
<p>},</p>
</div></blockquote>
<section id="id29">
<h2>}<a class="headerlink" href="#id29" title="Permalink to this heading">¶</a></h2>
<p>As mentioned above, it is recommended to export plugin functions so we can request any argument that might be needed from the end user.</p>
<p><a href="#id30"><span class="problematic" id="id31">``</span></a><a href="#id32"><span class="problematic" id="id33">`</span></a>ts
export const myPlugin = (myPluginOptions?: MyPluginOptions): UmiPlugin =&gt; ({</p>
<blockquote>
<div><dl class="simple">
<dt>install(umi: Umi) {</dt><dd><p>// Do something with the Umi instance.</p>
</dd>
</dl>
<p>},</p>
</div></blockquote>
</section>
<section id="id34">
<h2>})<a class="headerlink" href="#id34" title="Permalink to this heading">¶</a></h2>
<p>## What to do in a plugin</p>
<p>Now that we know how to create a plugin, let’s have a look at some examples of what we can do with them.</p>
<p>### Setting interface implementations</p>
<p>One of the most common use cases for plugins is to assign an implementation to one or several Umi interfaces. Here’s an example of setting a fictional <cite>MyRpc</cite> implementation to the <cite>rpc</cite> interface. Notice how we can pass the Umi instance to the <cite>MyRpc</cite> implementation so it can rely on other interfaces if needed.</p>
<p><a href="#id35"><span class="problematic" id="id36">``</span></a><a href="#id37"><span class="problematic" id="id38">`</span></a>ts
export const myRpc = (endpoint: string): UmiPlugin =&gt; ({</p>
<blockquote>
<div><dl class="simple">
<dt>install(umi: Umi) {</dt><dd><p>umi.rpc = new MyRpc(umi, endpoint);</p>
</dd>
</dl>
<p>},</p>
</div></blockquote>
</section>
<section id="id39">
<h2>})<a class="headerlink" href="#id39" title="Permalink to this heading">¶</a></h2>
<p>### Decorating interface implementations</p>
<p>Another way of setting interface implementations is to decorate existing ones. This allows the end-user to compose plugins together by adding extra functionality to existing implementations without worrying about their underlying implementation details.</p>
<p>Here’s an example of a plugin that decorates the <cite>rpc</cite> interface such that it logs all sent transactions to a third-party service.</p>
<p><a href="#id40"><span class="problematic" id="id41">``</span></a><a href="#id42"><span class="problematic" id="id43">`</span></a>ts
export const myLoggingRpc = (provider: LoggingProvider): UmiPlugin =&gt; ({</p>
<blockquote>
<div><dl class="simple">
<dt>install(umi: Umi) {</dt><dd><p>umi.rpc = new MyLoggingRpc(umi.rpc, provider);</p>
</dd>
</dl>
<p>},</p>
</div></blockquote>
</section>
<section id="id44">
<h2>})<a class="headerlink" href="#id44" title="Permalink to this heading">¶</a></h2>
<p>### Creating bundles</p>
<p>Since plugins can also call the <cite>use</cite> method on the Umi instance, it is possible to install plugins within plugins. This allows us to create bundles of plugins that can be installed together.</p>
<p>For instance, this is how Umi’s “defaults” plugin bundle is defined:</p>
<p><a href="#id45"><span class="problematic" id="id46">``</span></a><a href="#id47"><span class="problematic" id="id48">`</span></a>ts
export const defaultPlugins = (</p>
<blockquote>
<div><p>endpoint: string,
rpcOptions?: Web3JsRpcOptions</p>
</div></blockquote>
<dl>
<dt>): UmiPlugin =&gt; ({</dt><dd><dl class="simple">
<dt>install(umi) {</dt><dd><p>umi.use(dataViewSerializer());
umi.use(defaultProgramRepository());
umi.use(fetchHttp());
umi.use(httpDownloader());
umi.use(web3JsEddsa());
umi.use(web3JsRpc(endpoint, rpcOptions));
umi.use(web3JsTransactionFactory());</p>
</dd>
</dl>
<p>},</p>
</dd>
</dl>
</section>
<section id="id49">
<h2>});<a class="headerlink" href="#id49" title="Permalink to this heading">¶</a></h2>
<p>### Using interfaces</p>
<p>On top of setting and updating Umi’s interfaces, plugins can also use them. One common use case for this is to allow libraries to register new programs to the program repository interfaces. Here’s an example illustrating how the Token Metadata library registers its program. Notice how it sets the <cite>override</cite> argument to <cite>false</cite> so that the program is only registered if it doesn’t already exist.</p>
<p><a href="#id50"><span class="problematic" id="id51">``</span></a><a href="#id52"><span class="problematic" id="id53">`</span></a>ts
export const mplTokenMetadata = (): UmiPlugin =&gt; ({</p>
<blockquote>
<div><dl class="simple">
<dt>install(umi) {</dt><dd><p>umi.programs.add(createMplTokenMetadataProgram(), false);</p>
</dd>
</dl>
<p>},</p>
</div></blockquote>
</section>
<section id="id54">
<h2>});<a class="headerlink" href="#id54" title="Permalink to this heading">¶</a></h2>
<p>### Extending the Umi instance</p>
<p>Last but not least, plugins can also extend the feature set of the Umi instance. This allows libraries to provide their own interfaces, extend existing ones, etc.</p>
<p>A good example of that is the Candy Machine library which stores all candy guards in a repository — much like the program repository. This allows end-users to register their own guards so they can be recognised when creating, fetching and minting from candy machines with associated candy guards. To make this work, the library adds a new <cite>guards</cite> property to the Umi instance and assigns a new guard repository to it.</p>
<p><a href="#id55"><span class="problematic" id="id56">``</span></a><a href="#id57"><span class="problematic" id="id58">`</span></a>ts
export const mplCandyMachine = (): UmiPlugin =&gt; ({</p>
<blockquote>
<div><dl class="simple">
<dt>install(umi) {</dt><dd><p>umi.guards = new DefaultGuardRepository(umi);
umi.guards.add(botTaxGuardManifest);
umi.guards.add(solPaymentGuardManifest);
umi.guards.add(tokenPaymentGuardManifest);
// …</p>
</dd>
</dl>
<p>},</p>
</div></blockquote>
</section>
<section id="id59">
<h2>});<a class="headerlink" href="#id59" title="Permalink to this heading">¶</a></h2>
<p>The slight issue with the code above is that the <cite>Umi</cite> type no longer reflects the actual instance. That is, TypeScript will complain that the <cite>guards</cite> property doesn’t exist on the <cite>Umi</cite> type. To fix this, we can use TypeScript’s [Module Augmentation](<a class="reference external" href="https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation">https://www.typescriptlang.org/docs/handbook/declaration-merging.html#module-augmentation</a>) to extend the <cite>Umi</cite> type so it includes the new property like so</p>
<p><a href="#id60"><span class="problematic" id="id61">``</span></a><a href="#id62"><span class="problematic" id="id63">`</span></a>ts
declare module <a class="reference external" href="mailto:'&#37;&#52;&#48;metaplex-foundation/umi">‘<span>&#64;</span>metaplex-foundation/umi</a>’ {</p>
<blockquote>
<div><dl class="simple">
<dt>interface Umi {</dt><dd><p>guards: GuardRepository;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</section>
<section id="id64">
<h2>}<a class="headerlink" href="#id64" title="Permalink to this heading">¶</a></h2>
<p>This module augmentation can also be used to extend an existing interface. For instance, we could assign a new RPC interface that contains additional methods whilst letting TypeScript know about our added methods like so.</p>
<p><a href="#id65"><span class="problematic" id="id66">``</span></a><a href="#id67"><span class="problematic" id="id68">`</span></a>ts
export const myRpcWithAddedMethods = (): UmiPlugin =&gt; ({</p>
<blockquote>
<div><dl class="simple">
<dt>install(umi) {</dt><dd><p>umi.rpc = new MyRpcWithAddedMethods(umi.rpc);</p>
</dd>
</dl>
<p>},</p>
</div></blockquote>
<p>});</p>
<dl>
<dt>declare module <a class="reference external" href="mailto:'&#37;&#52;&#48;metaplex-foundation/umi">‘<span>&#64;</span>metaplex-foundation/umi</a>’ {</dt><dd><dl class="simple">
<dt>interface Umi {</dt><dd><p>rpc: MyRpcWithAddedMethods;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</section>
<section id="id69">
<h2>}<a class="headerlink" href="#id69" title="Permalink to this heading">¶</a></h2>
<p>&lt;p align=”center”&gt;
&lt;strong&gt;Next: &lt;a href=”./kinobi.md”&gt;Generating Umi clients via Kinobi ≫&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/plugins.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>