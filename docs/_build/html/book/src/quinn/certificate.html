<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>docs/book/src/quinn/certificate.md &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="docs-book-src-quinn-certificate-md">
<h1>docs/book/src/quinn/certificate.md<a class="headerlink" href="#docs-book-src-quinn-certificate-md" title="Permalink to this heading">¶</a></h1>
<p>Last edited: 2022-02-11 21:48:07</p>
<p>Contents:</p>
<div class="highlight-md notranslate"><div class="highlight"><pre><span></span><span class="gh"># Certificates</span>
</pre></div>
</div>
<p>In this chapter, we discuss the configuration of the certificates that are <strong>required</strong> for a working Quinn connection.</p>
<p>As QUIC uses TLS 1.3 for authentication of connections, the server needs to provide the client with a certificate confirming its identity, and the client must be configured to trust the certificates it receives from the server.</p>
<p>## Insecure Connection</p>
<p>For our example use case, the easiest way to allow the client to trust our server is to disable certificate verification (don’t do this in production!).
When the [rustls][3] <cite>dangerous_configuration</cite> feature flag is enabled, a client can be configured to trust any server.</p>
<p>Start by adding a [rustls][3] dependency with the <cite>dangerous_configuration</cite> feature flag to your <cite>Cargo.toml</cite> file.</p>
<p><code class="docutils literal notranslate"><span class="pre">`toml</span>
<span class="pre">quinn</span> <span class="pre">=</span> <span class="pre">&quot;*&quot;</span>
<span class="pre">rustls</span> <span class="pre">=</span> <span class="pre">{</span> <span class="pre">version</span> <span class="pre">=</span> <span class="pre">&quot;*&quot;,</span> <span class="pre">features</span> <span class="pre">=</span> <span class="pre">[&quot;dangerous_configuration&quot;,</span> <span class="pre">&quot;quic&quot;]</span> <span class="pre">}</span>
<span class="pre">`</span></code></p>
<p>Then, allow the client to skip the certificate validation by implementing [ServerCertVerifier][ServerCertVerifier] and letting it assert verification for any server.</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><cite>rust
// Implementation of `ServerCertVerifier</cite> that verifies everything as trustworthy.
struct SkipServerVerification;</p>
<dl>
<dt>impl SkipServerVerification {</dt><dd><dl class="simple">
<dt>fn new() -&gt; Arc&lt;Self&gt; {</dt><dd><p>Arc::new(Self)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl rustls::client::ServerCertVerifier for SkipServerVerification {</dt><dd><dl class="simple">
<dt>fn verify_server_cert(</dt><dd><p>&amp;self,
_end_entity: &amp;rustls::Certificate,
_intermediates: &amp;[rustls::Certificate],
_server_name: &amp;rustls::ServerName,
_scts: &amp;mut dyn Iterator&lt;Item = &amp;[u8]&gt;,
_ocsp_response: &amp;[u8],
_now: std::time::SystemTime,</p>
</dd>
<dt>) -&gt; Result&lt;rustls::client::ServerCertVerified, rustls::Error&gt; {</dt><dd><p>Ok(rustls::client::ServerCertVerified::assertion())</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<section id="id3">
<h2>}<a class="headerlink" href="#id3" title="Permalink to this heading">¶</a></h2>
<p>After that, modify the [ClientConfig][ClientConfig] to use this [ServerCertVerifier][ServerCertVerifier] implementation.</p>
<p><a href="#id4"><span class="problematic" id="id5">``</span></a><a href="#id6"><span class="problematic" id="id7">`</span></a>rust
fn configure_client() -&gt; ClientConfig {</p>
<blockquote>
<div><dl class="simple">
<dt>let crypto = rustls::ClientConfig::builder()</dt><dd><p>.with_safe_defaults()
.with_custom_certificate_verifier(SkipServerVerification::new())
.with_no_client_auth();</p>
</dd>
</dl>
<p>ClientConfig::new(Arc::new(crypto))</p>
</div></blockquote>
</section>
<section id="id8">
<h2>}<a class="headerlink" href="#id8" title="Permalink to this heading">¶</a></h2>
<p>Finally, if you plug this [ClientConfig][ClientConfig] into the [Endpoint::set_default_client_config()][set_default_client_config] your client endpoint should verify all connections as trustworthy.</p>
<p>## Using Certificates</p>
<p>In this section, we look at certifying an endpoint with a certificate.
The certificate can be signed with its key, or with a certificate authority’s key.</p>
<p>### Self Signed Certificates</p>
<p>Relying on [self-signed][5] certificates means that clients allow servers to sign their certificates.
This is simpler because no third party is involved in signing the server’s certificate.
However, self-signed certificates do not protect users from person-in-the-middle attacks, because an interceptor can trivially replace the certificate with one that it has signed. Self-signed certificates, among other options, can be created using the [rcgen][4] crate or the openssl binary.
This example uses [rcgen][4] to generate a certificate.</p>
<p>Let’s look at an example:</p>
<p><a href="#id9"><span class="problematic" id="id10">``</span></a><a href="#id11"><span class="problematic" id="id12">`</span></a>rust
fn generate_self_signed_cert() -&gt; Result&lt;(rustls::Certificate, rustls::PrivateKey), Box&lt;dyn Error&gt;&gt;
{</p>
<blockquote>
<div><p>let cert = rcgen::generate_simple_self_signed(vec![“localhost”.to_string()])?;
let key = rustls::PrivateKey(cert.serialize_private_key_der());
Ok((rustls::Certificate(cert.serialize_der()?), key))</p>
</div></blockquote>
</section>
<section id="id13">
<h2>}<a class="headerlink" href="#id13" title="Permalink to this heading">¶</a></h2>
<p><em>Note that [generate_simple_self_signed][generate_simple_self_signed] returns a [Certificate][2] that can be serialized to both `.der` and `.pem` formats.</em></p>
<p>### Non-self-signed Certificates</p>
<p>For this example, we use [Let’s Encrypt][6], a well-known Certificate Authority ([CA][1]) (certificate issuer) which distributes certificates for free.</p>
<p><strong>Generate Certificate</strong></p>
<p>[certbot][7] can be used with Let’s Encrypt to generate certificates; its website comes with clear instructions.
Because we’re generating a certificate for an internal test server, the process used will be slightly different compared to what you would do when generating certificates for an existing (public) website.</p>
<p>On the certbot website, select that you do not have a public web server and follow the given installation instructions.
certbot must answer a cryptographic challenge of the Let’s Encrypt API to prove that you control the domain.
It needs to listen on port 80 (HTTP) or 443 (HTTPS) to achieve this. Open the appropriate port in your firewall and router.</p>
<p>If certbot is installed, run <cite>certbot certonly –standalone</cite>, this command will start a web server in the background and start the challenge.
certbot asks for the required data and writes the certificate to <cite>cert.pem</cite> and the private key to <cite>privkey.pem</cite>.
These files can then be referenced in code.</p>
<p><a href="#id14"><span class="problematic" id="id15">``</span></a><a href="#id16"><span class="problematic" id="id17">`</span></a>rust
pub fn read_cert_from_file() -&gt; Result&lt;(rustls::Certificate, rustls::PrivateKey), Box&lt;dyn Error&gt;&gt; {</p>
<blockquote>
<div><p>// Read from certificate and key from directory.
let (cert, key) = fs::read(&amp;”./cert.pem”).and_then(<a href="#id27"><span class="problematic" id="id28">|x|</span></a> Ok((x, fs::read(&amp;”./privkey.pem”)?)))?;</p>
<p>// Parse to certificate chain whereafter taking the first certifcater in this chain.
let cert = rustls::Certificate(cert);
let key = rustls::PrivateKey(key);</p>
<p>Ok((cert, key))</p>
</div></blockquote>
</section>
<section id="id18">
<h2>}<a class="headerlink" href="#id18" title="Permalink to this heading">¶</a></h2>
<p>### Configuring Certificates</p>
<p>Now that you have a valid certificate, the client and server need to be configured to use it.
After configuring plug the configuration into the <cite>Endpoint</cite>.</p>
<p><strong>Configure Server</strong></p>
<p><code class="docutils literal notranslate"><span class="pre">`rust</span>
<span class="pre">let</span> <span class="pre">server_config</span> <span class="pre">=</span> <span class="pre">ServerConfig::with_single_cert(vec![cert]),</span> <span class="pre">key)?;</span>
<span class="pre">`</span></code></p>
<p>This is the only thing you need to do for your server to be secured.</p>
<p><strong>Configure Client</strong></p>
<p><a href="#id19"><span class="problematic" id="id20">``</span></a><a href="#id21"><span class="problematic" id="id22">`</span></a>rust
let mut crypto = rustls::ClientConfig::builder()</p>
<blockquote>
<div><p>.with_safe_defaults()
.with_single_cert(vec![cert]), key)?
.with_no_client_auth();</p>
</div></blockquote>
<p>let client_config = ClientConfig::new(Arc::new(crypto));
<a href="#id23"><span class="problematic" id="id24">``</span></a><a href="#id25"><span class="problematic" id="id26">`</span></a></p>
<p>This is the only thing you need to do for your client to trust a server certificate.</p>
<p>&lt;br&gt;&lt;hr&gt;</p>
<p>[Next](set-up-connection.md), let’s have a look at how to set up a connection.</p>
<p>[1]: <a class="reference external" href="https://en.wikipedia.org/wiki/Certificate_authority">https://en.wikipedia.org/wiki/Certificate_authority</a>
[2]: <a class="reference external" href="https://en.wikipedia.org/wiki/Public_key_certificate">https://en.wikipedia.org/wiki/Public_key_certificate</a>
[3]: <a class="reference external" href="https://github.com/ctz/rustls">https://github.com/ctz/rustls</a>
[4]: <a class="reference external" href="https://github.com/est31/rcgen">https://github.com/est31/rcgen</a>
[5]: <a class="reference external" href="https://en.wikipedia.org/wiki/Self-signed_certificate#:~:text=In%20cryptography%20and%20computer%20security,a%20CA%20aim%20to%20provide">https://en.wikipedia.org/wiki/Self-signed_certificate#:~:text=In%20cryptography%20and%20computer%20security,a%20CA%20aim%20to%20provide</a>.
[6]: <a class="reference external" href="https://letsencrypt.org/getting-started/">https://letsencrypt.org/getting-started/</a>
[7]: <a class="reference external" href="https://certbot.eff.org/instructions">https://certbot.eff.org/instructions</a></p>
<p>[ClientConfig]: <a class="reference external" href="https://docs.rs/quinn/latest/quinn/struct.ClientConfig.html">https://docs.rs/quinn/latest/quinn/struct.ClientConfig.html</a>
[ServerCertVerifier]: <a class="reference external" href="https://docs.rs/rustls/latest/rustls/client/trait.ServerCertVerifier.html">https://docs.rs/rustls/latest/rustls/client/trait.ServerCertVerifier.html</a>
[set_default_client_config]: <a class="reference external" href="https://docs.rs/quinn/latest/quinn/struct.Endpoint.html#method.set_default_client_config">https://docs.rs/quinn/latest/quinn/struct.Endpoint.html#method.set_default_client_config</a>
[generate_simple_self_signed]: <a class="reference external" href="https://docs.rs/rcgen/latest/rcgen/fn.generate_simple_self_signed.html">https://docs.rs/rcgen/latest/rcgen/fn.generate_simple_self_signed.html</a>
[Certificate]: <a class="reference external" href="https://docs.rs/rcgen/latest/rcgen/struct.Certificate.html">https://docs.rs/rcgen/latest/rcgen/struct.Certificate.html</a></p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../_sources/book/src/quinn/certificate.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>