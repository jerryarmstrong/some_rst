<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>docs/transactions.md &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=039e1c02" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=b3ba4146"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="docs-transactions-md">
<h1>docs/transactions.md<a class="headerlink" href="#docs-transactions-md" title="Permalink to this heading">¶</a></h1>
<p>Last edited: 2023-07-27 15:49:41</p>
<p>Contents:</p>
<div class="highlight-md notranslate"><div class="highlight"><pre><span></span><span class="gh"># Sending transactions</span>
</pre></div>
</div>
<p>Managing and sending transactions is an important part of any Solana client. To help manage them, Umi provides a bunch of components:
- A [TransactionFactoryInterface](<a class="reference external" href="https://umi-docs.vercel.app/interfaces/umi.TransactionFactoryInterface.html">https://umi-docs.vercel.app/interfaces/umi.TransactionFactoryInterface.html</a>) that can be used to create and (de)serialize transactions.
- A [TransactionBuilder](<a class="reference external" href="https://umi-docs.vercel.app/classes/umi.TransactionBuilder.html">https://umi-docs.vercel.app/classes/umi.TransactionBuilder.html</a>) that makes it easy to build transactions.
- A [RpcInterface](<a class="reference external" href="https://umi-docs.vercel.app/interfaces/umi.RpcInterface.html">https://umi-docs.vercel.app/interfaces/umi.RpcInterface.html</a>) that can be used to send, confirm and fetch transactions. You can [read more about the RPC interface here](./rpc.md).</p>
<p>## Transactions and Instructions</p>
<p>Umi defines its own set of interfaces for transactions, instructions and all other related types. Here’s a quick overview of the most important ones with a link to their API documentation:</p>
<ul class="simple">
<li><p>[<cite>Transaction</cite>](<a class="reference external" href="https://umi-docs.vercel.app/interfaces/umi.Transaction.html">https://umi-docs.vercel.app/interfaces/umi.Transaction.html</a>): A transaction is composed of a versioned transaction message, a list of required signatures and a serialized version of its message so it can be easily signed.</p></li>
<li><p>[<cite>TransactionMessage</cite>](<a class="reference external" href="https://umi-docs.vercel.app/interfaces/umi.TransactionMessage.html">https://umi-docs.vercel.app/interfaces/umi.TransactionMessage.html</a>): A transaction message is composed of all required public keys, one or many compiled instructions using indexes instead of public keys, a recent blockhash and other attributes such as its version. A transaction message can have one of the following versions:
- Version: <cite>“legacy”</cite>: The first Solana iteration of the transaction message.
- Version: <cite>0</cite>: The first transaction message version that introduces transaction versioning. It also introduces address lookup tables.</p></li>
<li><p>[<cite>Instruction</cite>](<a class="reference external" href="https://umi-docs.vercel.app/interfaces/umi.Instruction.html">https://umi-docs.vercel.app/interfaces/umi.Instruction.html</a>): An instruction is composed of a program id, a list of [<cite>AccountMeta</cite>](<a class="reference external" href="https://umi-docs.vercel.app/types/umi.AccountMeta.html">https://umi-docs.vercel.app/types/umi.AccountMeta.html</a>) and some serialized data. Each account <cite>AccountMeta</cite> is composed of a public key, a boolean indicating whether it will be signing the transaction and another boolean indicating whether it’s writable or not.</p></li>
</ul>
<p>To create a new transaction, you may use the <cite>create</cite> method of the <cite>TransactionFactoryInterface</cite>. For instance, here’s how you’d create a version <cite>0</cite> transaction with a single instruction:</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>ts
const transaction = umi.transactions.create({</p>
<blockquote>
<div><p>version: 0,
blockhash: (await umi.rpc.getLatestBlockhash()).blockhash,
instructions: [myInstruction],
payer: umi.payer.publicKey,</p>
</div></blockquote>
<section id="id5">
<h2>})<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h2>
<p>The transaction factory interface can also be used to serialize and deserialize transactions and their messages.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">const</span> <span class="pre">mySerializedTransaction</span> <span class="pre">=</span> <span class="pre">umi.transactions.serialize(myTransaction);</span>
<span class="pre">const</span> <span class="pre">myTransaction</span> <span class="pre">=</span> <span class="pre">umi.transactions.deserialize(mySerializedTransaction);</span>
<span class="pre">const</span> <span class="pre">mySerializedMessage</span> <span class="pre">=</span> <span class="pre">umi.transactions.serializeMessage(myMessage);</span>
<span class="pre">const</span> <span class="pre">myMessage</span> <span class="pre">=</span> <span class="pre">umi.transactions.deserializeMessage(mySerializedMessage);</span>
<span class="pre">`</span></code></p>
<p>All of this is nice but can be a bit tedious to build every single time we want to send a transaction to the blockchain. Fortunately, Umi provides a <cite>TransactionBuilder</cite> that can help with that.</p>
<p>## Transaction Builders</p>
<p>Transaction builders are immutable objects that can be used to gradually build transactions until we are ready to build, sign and/or send them. They are composed of a list of [<cite>WrappedInstruction</cite>](<a class="reference external" href="https://umi-docs.vercel.app/types/umi.WrappedInstruction.html">https://umi-docs.vercel.app/types/umi.WrappedInstruction.html</a>) and various options that can be used to configure the built transaction. A <cite>WrappedInstruction</cite> is a simple object containing an <cite>instruction</cite> and a bunch of other attributes. Namely:
- A <cite>bytesCreatedOnChain</cite> attribute that, if the instruction ends up creating accounts, tells us how many bytes they will take on chain (including the account headers).
- and a <cite>signers</cite> array so that we know which signers are required for this particular instruction as opposed to the whole transaction. This enables us to split the transaction builder into two without losing any information as we will see later.</p>
<p>We can create a new transaction builder using the <cite>transactionBuilder</cite> function and add instructions to it using its <cite>add</cite> method. You may also use the <cite>prepend</cite> method to push an instruction at the beginning of the transaction.</p>
<p><a href="#id6"><span class="problematic" id="id7">``</span></a><a href="#id8"><span class="problematic" id="id9">`</span></a>ts
let builder = transactionBuilder()</p>
<blockquote>
<div><p>.add(myWrappedInstruction)
.add(myOtherWrappedInstruction)
.prepend(myFirstWrappedInstruction);</p>
</div></blockquote>
<p><a href="#id10"><span class="problematic" id="id11">``</span></a><a href="#id12"><span class="problematic" id="id13">`</span></a></p>
<p>Since transaction builders are immutable, we must be careful to always assign the result of the <cite>add</cite> and <cite>prepend</cite> methods to a new variable. The same goes for any other method that updates the transaction builder by returning a new one.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">builder</span> <span class="pre">=</span> <span class="pre">builder.add(myWrappedInstruction);</span>
<span class="pre">builder</span> <span class="pre">=</span> <span class="pre">builder.prepend(myWrappedInstruction);</span>
<span class="pre">`</span></code></p>
<p>Note that either of these methods also accepts other transaction builders and will merge them into the current one. In practice, this means program libraries can write (or [auto-generate](./kinobi.md)) their own helper methods that return transaction builders so they can be composed together by the end-user.</p>
<p><a href="#id14"><span class="problematic" id="id15">``</span></a><a href="#id16"><span class="problematic" id="id17">`</span></a>ts
import { transferSol, addMemo } from <a class="reference external" href="mailto:'&#37;&#52;&#48;metaplex-foundation/mpl-toolbox">‘<span>&#64;</span>metaplex-foundation/mpl-toolbox</a>’;
import { createNft } from <a class="reference external" href="mailto:'&#37;&#52;&#48;metaplex-foundation/mpl-token-metadata">‘<span>&#64;</span>metaplex-foundation/mpl-token-metadata</a>’;</p>
<dl class="simple">
<dt>let builder = transactionBuilder()</dt><dd><p>.add(addMemo(umi, { … }))
.add(createNft(umi, { … }))
.add(transferSol(umi, { … }))</p>
</dd>
</dl>
<p><a href="#id18"><span class="problematic" id="id19">``</span></a><a href="#id20"><span class="problematic" id="id21">`</span></a></p>
<p>You may also split a transaction builder into two if, for instance, the transaction that would be created from the original builder would be too big to be sent to the blockchain. To do so, you may use the [<cite>splitByIndex</cite>](<a class="reference external" href="https://umi-docs.vercel.app/classes/umi.TransactionBuilder.html#splitByIndex">https://umi-docs.vercel.app/classes/umi.TransactionBuilder.html#splitByIndex</a>) method or the more dangerous [<cite>unsafeSplitByTransactionSize</cite>](<a class="reference external" href="https://umi-docs.vercel.app/classes/umi.TransactionBuilder.html#unsafeSplitByTransactionSize">https://umi-docs.vercel.app/classes/umi.TransactionBuilder.html#unsafeSplitByTransactionSize</a>) method. Make sure to read the comment on the API reference for the latter.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">const</span> <span class="pre">[builderA,</span> <span class="pre">builderB]</span> <span class="pre">=</span> <span class="pre">builder.splitByIndex(2);</span>
<span class="pre">const</span> <span class="pre">splitBuilders</span> <span class="pre">=</span> <span class="pre">builder.unsafeSplitByTransactionSize(umi);</span>
<span class="pre">`</span></code></p>
<p>And there’s much more you can do with transaction builders. Feel free to [read the API reference](<a class="reference external" href="https://umi-docs.vercel.app/classes/umi.TransactionBuilder.html">https://umi-docs.vercel.app/classes/umi.TransactionBuilder.html</a>) to learn more but here’s a quick overview of some of the other methods that can configure our transaction builders.</p>
<p><a href="#id22"><span class="problematic" id="id23">``</span></a><a href="#id24"><span class="problematic" id="id25">`</span></a>ts
// Setters.
builder = builder.setVersion(myTransactionVersion); // Sets the transaction version.
builder = builder.useLegacyVersion(); // Sets the transaction version to “legacy”.
builder = builder.useV0(); // Sets the transaction version to 0 (default).
builder = builder.empty(); // Removes all instructions from the builder but keeps the configurations.
builder = builder.setItems(myWrappedInstructions); // Overwrite the wrapped instructions with the given ones.
builder = builder.setAddressLookupTables(myLuts); // Set the address lookup tables, only for version 0 transactions.
builder = builder.setFeePayer(myPayer); // Set a custom fee payer.
builder = builder.setBlockhash(myBlockhash); // Set the blockhash to use for the transaction.
builder = await builder.setLatestBlockhash(umi); // Fetch the latest blockhash and use it for the transaction.</p>
<p>// Getters.
const transactionSize = builder.getTransactionSize(umi); // Return the size in bytes of the built transaction.
const isSmallEnough = builder.fitsInOneTransaction(umi); // Whether the built transaction would fit in one transaction.
const transactionRequired = builder.minimumTransactionsRequired(umi); // Return the minimum number of transactions required to send all instructions.
const blockhash = builder.getBlockhash(); // Return the configured blockhash if any.
const feePayer = builder.getFeePayer(umi); // Return the configured fee payer or uses <cite>umi.payer</cite> if none is configured.
const instructions = builder.getInstructions(umi); // Return all unwrapped instructions.
const signers = builder.getSigners(umi); // Return all deduplicated signers, including the fee payer.
const bytes = builder.getBytesCreatedOnChain(); // Return the total number of bytes that would be created on chain.
const solAmount = await builder.getRentCreatedOnChain(umi); // Return the total number of bytes that would be created on chain.
<a href="#id26"><span class="problematic" id="id27">``</span></a><a href="#id28"><span class="problematic" id="id29">`</span></a></p>
<p>Notice that we are passing an instance of <cite>Umi</cite> to some of them. This is because they will need to access some of Umi’s core interfaces to perform their task.</p>
<p>Now that we have our transaction builder ready, let’s see how we can use it to build, sign and send transactions.</p>
<p>## Building and signing transactions</p>
<p>When you’re ready to build your transaction, you may simply use the <cite>build</cite> method. This method will return a <cite>Transaction</cite> object that you can then sign and send to the blockchain.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">const</span> <span class="pre">transaction</span> <span class="pre">=</span> <span class="pre">builder.build(umi);</span>
<span class="pre">`</span></code></p>
<p>Note that the <cite>build</cite> method will throw an error if no blockhash was set on the builder. If you wish to build the transaction using the latest blockhash, you may use the <cite>buildWithLatestBlockhash</cite> method instead.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">const</span> <span class="pre">transaction</span> <span class="pre">=</span> <span class="pre">await</span> <span class="pre">builder.buildWithLatestBlockhash(umi);</span>
<span class="pre">`</span></code></p>
<p>At this point, you could use the built transaction and get all deduplicated signers from the builder via the <cite>getSigners</cite> method to sign it (See [Signing transactions](./publickeys-signers.md#signing-transactions) for more details). However, Umi provides a <cite>buildAndSign</cite> method that can do that for you. When using <cite>buildAndSign</cite>, the latest blockhash will be used if and only if it was not set on the builder.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">const</span> <span class="pre">signedTransaction</span> <span class="pre">=</span> <span class="pre">await</span> <span class="pre">builder.buildAndSign(umi);</span>
<span class="pre">`</span></code></p>
<p>## Sending transactions</p>
<p>Now that we have a signed transaction, let’s see how we can send it to the blockchain.</p>
<p>One way to do this is to use the <cite>sendTransaction</cite> and <cite>confirmTransaction</cite> methods of the <cite>RpcInterface</cite> like so. When confirming the transaction, we have to provide a confirm strategy which can be of type <cite>blockhash</cite> or <cite>durableNonce</cite>, each of them requiring a different set of parameters. Here’s how we would send and confirm a transaction using the <cite>blockhash</cite> strategy.</p>
<p><a href="#id30"><span class="problematic" id="id31">``</span></a><a href="#id32"><span class="problematic" id="id33">`</span></a>ts
const signedTransaction = await builder.buildAndSign(umi);
const signature = await umi.rpc.sendTransaction(signedTransaction);
const confirmResult = await umi.rpc.confirmTransaction(signature, {</p>
<blockquote>
<div><p>strategy: { type: ‘blockhash’, …(await umi.rpc.getLatestBlockhash()) }</p>
</div></blockquote>
</section>
<section id="id34">
<h2>});<a class="headerlink" href="#id34" title="Permalink to this heading">¶</a></h2>
<p>Since this is a very common task, Umi provides helper methods on the transaction builder to do this for us. That way, the code above can be rewritten as follows.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">const</span> <span class="pre">confirmResult</span> <span class="pre">=</span> <span class="pre">await</span> <span class="pre">builder.sendAndConfirm(umi);</span>
<span class="pre">`</span></code></p>
<p>This will build and sign the transaction using the <cite>buildAndSign</cite> method before sending and confirming the transaction using the <cite>blockhash</cite> strategy by default. It will reuse the transaction blockhash for the confirm strategy to avoid the extra Http request when applicable. That being said, you may still explicitly provide a confirm strategy or set any options like so.</p>
<p><a href="#id35"><span class="problematic" id="id36">``</span></a><a href="#id37"><span class="problematic" id="id38">`</span></a>ts
const confirmResult = await builder.sendAndConfirm(umi, {</p>
<blockquote>
<div><p>// Send options.
send: {</p>
<blockquote>
<div><p>skipPreflight: true,</p>
</div></blockquote>
<p>},</p>
<p>// Confirm options.
confirm: {</p>
<blockquote>
<div><p>strategy: { type: ‘durableNonce’, minContextSlot, nonceAccountPubkey, nonceValue },</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</section>
<section id="id39">
<h2>});<a class="headerlink" href="#id39" title="Permalink to this heading">¶</a></h2>
<p>Also note that you may send a transaction without waiting for it to be confirmed via the <cite>send</cite> method of the transaction builder.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">const</span> <span class="pre">signature</span> <span class="pre">=</span> <span class="pre">await</span> <span class="pre">builder.send(umi);</span>
<span class="pre">`</span></code></p>
<p>## Using address lookup tables</p>
<p>Starting from version 0 transactions, you may use address lookup tables to reduce the size of transactions.</p>
<p><a href="#id40"><span class="problematic" id="id41">``</span></a><a href="#id42"><span class="problematic" id="id43">`</span></a>ts
const myLut: AddressLookupTableInput = {</p>
<blockquote>
<div><p>publicKey: publicKey(’…’) // The address of the lookup table account.
addresses: [ // The addresses registered in the lookup table.</p>
<blockquote>
<div><p>publicKey(’…’),
publicKey(’…’),
publicKey(’…’),</p>
</div></blockquote>
<p>]</p>
</div></blockquote>
<p>}</p>
<p>builder = builder.setAddressLookupTables([myLut]);
<a href="#id44"><span class="problematic" id="id45">``</span></a><a href="#id46"><span class="problematic" id="id47">`</span></a></p>
<p>To create an address lookup table, you might be interested in the <cite>&#64;metaplex-foundation/mpl-toolbox</cite> package which provides helpers for creating them.</p>
<p><a href="#id48"><span class="problematic" id="id49">``</span></a><a href="#id50"><span class="problematic" id="id51">`</span></a>ts
import { createLut } from <a class="reference external" href="mailto:'&#37;&#52;&#48;metaplex-foundation/mpl-toolbox">‘<span>&#64;</span>metaplex-foundation/mpl-toolbox</a>’;</p>
<p>// Create a lookup table.
const [lutBuilder, lut] = createLut(umi, {</p>
<blockquote>
<div><p>recentSlot: await umi.rpc.getSlot({ commitment: ‘finalized’ }),
addresses: [myAddressA, myAddressB, myAddressC],</p>
</div></blockquote>
<p>});
await lutBuilder.sendAndConfirm(umi);</p>
<p>// Later on, use the created lookup table.
myBuilder = myBuilder.setAddressLookupTables([lut]);
<a href="#id52"><span class="problematic" id="id53">``</span></a><a href="#id54"><span class="problematic" id="id55">`</span></a></p>
<p>## Fetching sent transactions</p>
<p>Let’s now take a look at how to fetch a transaction that was sent to the blockchain.</p>
<p>For that, we can use the <cite>getTransaction</cite> method of the <cite>RpcInterface</cite> and provide the signature of the transaction we want to fetch.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">const</span> <span class="pre">transaction</span> <span class="pre">=</span> <span class="pre">await</span> <span class="pre">umi.rpc.getTransaction(signature);</span>
<span class="pre">`</span></code></p>
<p>This will return an instance of [<cite>TransactionWithMeta</cite>](<a class="reference external" href="https://umi-docs.vercel.app/types/umi.TransactionWithMeta.html">https://umi-docs.vercel.app/types/umi.TransactionWithMeta.html</a>) which is a superset of <cite>Transaction</cite> and contains an extra <cite>meta</cite> property that provides additional information on the transaction. For instance, you could access the logs of a sent transaction like so.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">const</span> <span class="pre">transaction</span> <span class="pre">=</span> <span class="pre">await</span> <span class="pre">umi.rpc.getTransaction(signature);</span>
<span class="pre">const</span> <span class="pre">logs:</span> <span class="pre">string[]</span> <span class="pre">=</span> <span class="pre">transaction.meta.logs;</span>
<span class="pre">`</span></code></p>
<p>&lt;p align=”center”&gt;
&lt;strong&gt;Next: &lt;a href=”./accounts.md”&gt;Fetching accounts ≫&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/transactions.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>