<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>// Autogenerated by Thrift Compiler (0.17.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING</p>
<p>#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_skip)]</p>
<p>use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;</p>
<p>use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;</p>
<p>use crate::tensor;</p>
<p>#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FeatureType(pub i32);</p>
<dl>
<dt>impl FeatureType {</dt><dd><p>pub const BINARY: FeatureType = FeatureType(1);
pub const CONTINUOUS: FeatureType = FeatureType(2);
pub const DISCRETE: FeatureType = FeatureType(3);
pub const STRING: FeatureType = FeatureType(4);
pub const SPARSE_BINARY: FeatureType = FeatureType(5);
pub const SPARSE_CONTINUOUS: FeatureType = FeatureType(6);
pub const UNKNOWN: FeatureType = FeatureType(7);
pub const BLOB: FeatureType = FeatureType(8);
pub const TENSOR: FeatureType = FeatureType(9);
pub const SPARSE_TENSOR: FeatureType = FeatureType(10);
pub const FEATURE_TYPE11: FeatureType = FeatureType(11);
pub const FEATURE_TYPE12: FeatureType = FeatureType(12);
pub const ENUM_VALUES: &amp;’static [Self] = &amp;[</p>
<blockquote>
<div><p>Self::BINARY,
Self::CONTINUOUS,
Self::DISCRETE,
Self::STRING,
Self::SPARSE_BINARY,
Self::SPARSE_CONTINUOUS,
Self::UNKNOWN,
Self::BLOB,
Self::TENSOR,
Self::SPARSE_TENSOR,
Self::FEATURE_TYPE11,
Self::FEATURE_TYPE12,</p>
</div></blockquote>
<p>];</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for FeatureType {</dt><dd><p>#[allow(clippy::trivially_copy_pass_by_ref)]
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>o_prot.write_i32(self.0)</p>
</div></blockquote>
<p>}
fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;FeatureType&gt; {</p>
<blockquote>
<div><p>let enum_value = i_prot.read_i32()?;
Ok(FeatureType::from(enum_value))</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl From&lt;i32&gt; for FeatureType {</dt><dd><dl>
<dt>fn from(i: i32) -&gt; Self {</dt><dd><dl class="simple">
<dt>match i {</dt><dd><p>1 =&gt; FeatureType::BINARY,
2 =&gt; FeatureType::CONTINUOUS,
3 =&gt; FeatureType::DISCRETE,
4 =&gt; FeatureType::STRING,
5 =&gt; FeatureType::SPARSE_BINARY,
6 =&gt; FeatureType::SPARSE_CONTINUOUS,
7 =&gt; FeatureType::UNKNOWN,
8 =&gt; FeatureType::BLOB,
9 =&gt; FeatureType::TENSOR,
10 =&gt; FeatureType::SPARSE_TENSOR,
11 =&gt; FeatureType::FEATURE_TYPE11,
12 =&gt; FeatureType::FEATURE_TYPE12,
_ =&gt; FeatureType(i)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl From&lt;&amp;i32&gt; for FeatureType {</dt><dd><dl class="simple">
<dt>fn from(i: &amp;i32) -&gt; Self {</dt><dd><p>FeatureType::from(<a href="#id1"><span class="problematic" id="id2">*</span></a>i)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl From&lt;FeatureType&gt; for i32 {</dt><dd><dl class="simple">
<dt>fn from(e: FeatureType) -&gt; i32 {</dt><dd><p>e.0</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl From&lt;&amp;FeatureType&gt; for i32 {</dt><dd><dl class="simple">
<dt>fn from(e: &amp;FeatureType) -&gt; i32 {</dt><dd><p>e.0</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// DataRecord
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DataRecord {</p>
<blockquote>
<div><p>pub binary_features: Option&lt;BTreeSet&lt;i64&gt;&gt;,
pub continuous_features: Option&lt;BTreeMap&lt;i64, OrderedFloat&lt;f64&gt;&gt;&gt;,
pub discrete_features: Option&lt;BTreeMap&lt;i64, i64&gt;&gt;,
pub string_features: Option&lt;BTreeMap&lt;i64, String&gt;&gt;,
pub sparse_binary_features: Option&lt;BTreeMap&lt;i64, BTreeSet&lt;String&gt;&gt;&gt;,
pub sparse_continuous_features: Option&lt;BTreeMap&lt;i64, BTreeMap&lt;String, OrderedFloat&lt;f64&gt;&gt;&gt;&gt;,
pub blob_features: Option&lt;BTreeMap&lt;i64, Vec&lt;u8&gt;&gt;&gt;,
pub tensors: Option&lt;BTreeMap&lt;i64, tensor::GeneralTensor&gt;&gt;,
pub sparse_tensors: Option&lt;BTreeMap&lt;i64, tensor::SparseTensor&gt;&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl DataRecord {</dt><dd><dl>
<dt>pub fn new&lt;F1, F2, F3, F4, F5, F6, F7, F8, F9&gt;(binary_features: F1, continuous_features: F2, discrete_features: F3, string_features: F4, sparse_binary_features: F5, sparse_continuous_features: F6, blob_features: F7, tensors: F8, sparse_tensors: F9) -&gt; DataRecord where F1: Into&lt;Option&lt;BTreeSet&lt;i64&gt;&gt;&gt;, F2: Into&lt;Option&lt;BTreeMap&lt;i64, OrderedFloat&lt;f64&gt;&gt;&gt;&gt;, F3: Into&lt;Option&lt;BTreeMap&lt;i64, i64&gt;&gt;&gt;, F4: Into&lt;Option&lt;BTreeMap&lt;i64, String&gt;&gt;&gt;, F5: Into&lt;Option&lt;BTreeMap&lt;i64, BTreeSet&lt;String&gt;&gt;&gt;&gt;, F6: Into&lt;Option&lt;BTreeMap&lt;i64, BTreeMap&lt;String, OrderedFloat&lt;f64&gt;&gt;&gt;&gt;&gt;, F7: Into&lt;Option&lt;BTreeMap&lt;i64, Vec&lt;u8&gt;&gt;&gt;&gt;, F8: Into&lt;Option&lt;BTreeMap&lt;i64, tensor::GeneralTensor&gt;&gt;&gt;, F9: Into&lt;Option&lt;BTreeMap&lt;i64, tensor::SparseTensor&gt;&gt;&gt; {</dt><dd><dl class="simple">
<dt>DataRecord {</dt><dd><p>binary_features: binary_features.into(),
continuous_features: continuous_features.into(),
discrete_features: discrete_features.into(),
string_features: string_features.into(),
sparse_binary_features: sparse_binary_features.into(),
sparse_continuous_features: sparse_continuous_features.into(),
blob_features: blob_features.into(),
tensors: tensors.into(),
sparse_tensors: sparse_tensors.into(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for DataRecord {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;DataRecord&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;BTreeSet&lt;i64&gt;&gt; = None;
let mut f_2: Option&lt;BTreeMap&lt;i64, OrderedFloat&lt;f64&gt;&gt;&gt; = None;
let mut f_3: Option&lt;BTreeMap&lt;i64, i64&gt;&gt; = None;
let mut f_4: Option&lt;BTreeMap&lt;i64, String&gt;&gt; = None;
let mut f_5: Option&lt;BTreeMap&lt;i64, BTreeSet&lt;String&gt;&gt;&gt; = None;
let mut f_6: Option&lt;BTreeMap&lt;i64, BTreeMap&lt;String, OrderedFloat&lt;f64&gt;&gt;&gt;&gt; = None;
let mut f_7: Option&lt;BTreeMap&lt;i64, Vec&lt;u8&gt;&gt;&gt; = None;
let mut f_8: Option&lt;BTreeMap&lt;i64, tensor::GeneralTensor&gt;&gt; = None;
let mut f_9: Option&lt;BTreeMap&lt;i64, tensor::SparseTensor&gt;&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl>
<dt>1 =&gt; {</dt><dd><p>let set_ident = i_prot.read_set_begin()?;
let mut val: BTreeSet&lt;i64&gt; = BTreeSet::new();
for _ in 0..set_ident.size {</p>
<blockquote>
<div><p>let set_elem_0 = i_prot.read_i64()?;
val.insert(set_elem_0);</p>
</div></blockquote>
<p>}
i_prot.read_set_end()?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
2 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, OrderedFloat&lt;f64&gt;&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_1 = i_prot.read_i64()?;
let map_val_2 = OrderedFloat::from(i_prot.read_double()?);
val.insert(map_key_1, map_val_2);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_2 = Some(val);</p>
</div></blockquote>
<p>},
3 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, i64&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_3 = i_prot.read_i64()?;
let map_val_4 = i_prot.read_i64()?;
val.insert(map_key_3, map_val_4);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_3 = Some(val);</p>
</div></blockquote>
<p>},
4 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, String&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_5 = i_prot.read_i64()?;
let map_val_6 = i_prot.read_string()?;
val.insert(map_key_5, map_val_6);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_4 = Some(val);</p>
</div></blockquote>
<p>},
5 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, BTreeSet&lt;String&gt;&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_7 = i_prot.read_i64()?;
let set_ident = i_prot.read_set_begin()?;
let mut map_val_8: BTreeSet&lt;String&gt; = BTreeSet::new();
for _ in 0..set_ident.size {</p>
<blockquote>
<div><p>let set_elem_9 = i_prot.read_string()?;
map_val_8.insert(set_elem_9);</p>
</div></blockquote>
<p>}
i_prot.read_set_end()?;
val.insert(map_key_7, map_val_8);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_5 = Some(val);</p>
</div></blockquote>
<p>},
6 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, BTreeMap&lt;String, OrderedFloat&lt;f64&gt;&gt;&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_10 = i_prot.read_i64()?;
let map_ident = i_prot.read_map_begin()?;
let mut map_val_11: BTreeMap&lt;String, OrderedFloat&lt;f64&gt;&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_12 = i_prot.read_string()?;
let map_val_13 = OrderedFloat::from(i_prot.read_double()?);
map_val_11.insert(map_key_12, map_val_13);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
val.insert(map_key_10, map_val_11);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_6 = Some(val);</p>
</div></blockquote>
<p>},
7 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, Vec&lt;u8&gt;&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_14 = i_prot.read_i64()?;
let map_val_15 = i_prot.read_bytes()?;
val.insert(map_key_14, map_val_15);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_7 = Some(val);</p>
</div></blockquote>
<p>},
8 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, tensor::GeneralTensor&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_16 = i_prot.read_i64()?;
let map_val_17 = tensor::GeneralTensor::read_from_in_protocol(i_prot)?;
val.insert(map_key_16, map_val_17);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_8 = Some(val);</p>
</div></blockquote>
<p>},
9 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, tensor::SparseTensor&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_18 = i_prot.read_i64()?;
let map_val_19 = tensor::SparseTensor::read_from_in_protocol(i_prot)?;
val.insert(map_key_18, map_val_19);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_9 = Some(val);</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
let ret = DataRecord {</p>
<blockquote>
<div><p>binary_features: f_1,
continuous_features: f_2,
discrete_features: f_3,
string_features: f_4,
sparse_binary_features: f_5,
sparse_continuous_features: f_6,
blob_features: f_7,
tensors: f_8,
sparse_tensors: f_9,</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“DataRecord”);
o_prot.write_struct_begin(&amp;struct_ident)?;
if let Some(ref fld_var) = self.binary_features {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“binaryFeatures”, TType::Set, 1))?;
o_prot.write_set_begin(&amp;TSetIdentifier::new(TType::I64, fld_var.len() as i32))?;
for e in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id3"><span class="problematic" id="id4">*</span></a>e)?;</p>
</div></blockquote>
<p>}
o_prot.write_set_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.continuous_features {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“continuousFeatures”, TType::Map, 2))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::Double, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id5"><span class="problematic" id="id6">*</span></a>k)?;
o_prot.write_double((<a href="#id7"><span class="problematic" id="id8">*</span></a>v).into())?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.discrete_features {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“discreteFeatures”, TType::Map, 3))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::I64, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id9"><span class="problematic" id="id10">*</span></a>k)?;
o_prot.write_i64(<a href="#id11"><span class="problematic" id="id12">*</span></a>v)?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.string_features {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“stringFeatures”, TType::Map, 4))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::String, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id13"><span class="problematic" id="id14">*</span></a>k)?;
o_prot.write_string(v)?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.sparse_binary_features {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“sparseBinaryFeatures”, TType::Map, 5))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::Set, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id15"><span class="problematic" id="id16">*</span></a>k)?;
o_prot.write_set_begin(&amp;TSetIdentifier::new(TType::String, v.len() as i32))?;
for e in v {</p>
<blockquote>
<div><p>o_prot.write_string(e)?;</p>
</div></blockquote>
<p>}
o_prot.write_set_end()?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.sparse_continuous_features {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“sparseContinuousFeatures”, TType::Map, 6))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::Map, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id17"><span class="problematic" id="id18">*</span></a>k)?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::String, TType::Double, v.len() as i32))?;
for (k, v) in v {</p>
<blockquote>
<div><p>o_prot.write_string(k)?;
o_prot.write_double((<a href="#id19"><span class="problematic" id="id20">*</span></a>v).into())?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.blob_features {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“blobFeatures”, TType::Map, 7))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::String, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id21"><span class="problematic" id="id22">*</span></a>k)?;
o_prot.write_bytes(v)?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.tensors {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“tensors”, TType::Map, 8))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::Struct, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id23"><span class="problematic" id="id24">*</span></a>k)?;
v.write_to_out_protocol(o_prot)?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.sparse_tensors {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“sparseTensors”, TType::Map, 9))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::Struct, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id25"><span class="problematic" id="id26">*</span></a>k)?;
v.write_to_out_protocol(o_prot)?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl Default for DataRecord {</dt><dd><dl>
<dt>fn default() -&gt; Self {</dt><dd><dl class="simple">
<dt>DataRecord{</dt><dd><p>binary_features: Some(BTreeSet::new()),
continuous_features: Some(BTreeMap::new()),
discrete_features: Some(BTreeMap::new()),
string_features: Some(BTreeMap::new()),
sparse_binary_features: Some(BTreeMap::new()),
sparse_continuous_features: Some(BTreeMap::new()),
blob_features: Some(BTreeMap::new()),
tensors: Some(BTreeMap::new()),
sparse_tensors: Some(BTreeMap::new()),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// CompactDataRecord
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct CompactDataRecord {</p>
<blockquote>
<div><p>pub binary_features: Option&lt;BTreeSet&lt;i64&gt;&gt;,
pub continuous_features: Option&lt;BTreeMap&lt;i64, i32&gt;&gt;,
pub discrete_features: Option&lt;BTreeMap&lt;i64, i64&gt;&gt;,
pub string_features: Option&lt;BTreeMap&lt;i64, String&gt;&gt;,
pub sparse_binary_features: Option&lt;BTreeMap&lt;i64, BTreeSet&lt;String&gt;&gt;&gt;,
pub sparse_binary_features_with16b_sparse_key: Option&lt;BTreeMap&lt;i64, BTreeSet&lt;i16&gt;&gt;&gt;,
pub sparse_binary_features_with32b_sparse_key: Option&lt;BTreeMap&lt;i64, BTreeSet&lt;i32&gt;&gt;&gt;,
pub sparse_binary_features_with64b_sparse_key: Option&lt;BTreeMap&lt;i64, BTreeSet&lt;i64&gt;&gt;&gt;,
pub sparse_continuous_features: Option&lt;BTreeMap&lt;i64, BTreeMap&lt;String, i32&gt;&gt;&gt;,
pub sparse_continuous_features_with16b_sparse_key: Option&lt;BTreeMap&lt;i64, BTreeMap&lt;i16, i32&gt;&gt;&gt;,
pub sparse_continuous_features_with32b_sparse_key: Option&lt;BTreeMap&lt;i64, BTreeMap&lt;i32, i32&gt;&gt;&gt;,
pub sparse_continuous_features_with64b_sparse_key: Option&lt;BTreeMap&lt;i64, BTreeMap&lt;i64, i32&gt;&gt;&gt;,
pub blob_features: Option&lt;BTreeMap&lt;i64, Vec&lt;u8&gt;&gt;&gt;,
pub tensors: Option&lt;BTreeMap&lt;i64, tensor::GeneralTensor&gt;&gt;,
pub sparse_tensors: Option&lt;BTreeMap&lt;i64, tensor::SparseTensor&gt;&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl CompactDataRecord {</dt><dd><dl>
<dt>pub fn new&lt;F1, F2, F3, F4, F5, F6, F7, F8, F9, F10, F11, F12, F13, F14, F15&gt;(binary_features: F1, continuous_features: F2, discrete_features: F3, string_features: F4, sparse_binary_features: F5, sparse_binary_features_with16b_sparse_key: F6, sparse_binary_features_with32b_sparse_key: F7, sparse_binary_features_with64b_sparse_key: F8, sparse_continuous_features: F9, sparse_continuous_features_with16b_sparse_key: F10, sparse_continuous_features_with32b_sparse_key: F11, sparse_continuous_features_with64b_sparse_key: F12, blob_features: F13, tensors: F14, sparse_tensors: F15) -&gt; CompactDataRecord where F1: Into&lt;Option&lt;BTreeSet&lt;i64&gt;&gt;&gt;, F2: Into&lt;Option&lt;BTreeMap&lt;i64, i32&gt;&gt;&gt;, F3: Into&lt;Option&lt;BTreeMap&lt;i64, i64&gt;&gt;&gt;, F4: Into&lt;Option&lt;BTreeMap&lt;i64, String&gt;&gt;&gt;, F5: Into&lt;Option&lt;BTreeMap&lt;i64, BTreeSet&lt;String&gt;&gt;&gt;&gt;, F6: Into&lt;Option&lt;BTreeMap&lt;i64, BTreeSet&lt;i16&gt;&gt;&gt;&gt;, F7: Into&lt;Option&lt;BTreeMap&lt;i64, BTreeSet&lt;i32&gt;&gt;&gt;&gt;, F8: Into&lt;Option&lt;BTreeMap&lt;i64, BTreeSet&lt;i64&gt;&gt;&gt;&gt;, F9: Into&lt;Option&lt;BTreeMap&lt;i64, BTreeMap&lt;String, i32&gt;&gt;&gt;&gt;, F10: Into&lt;Option&lt;BTreeMap&lt;i64, BTreeMap&lt;i16, i32&gt;&gt;&gt;&gt;, F11: Into&lt;Option&lt;BTreeMap&lt;i64, BTreeMap&lt;i32, i32&gt;&gt;&gt;&gt;, F12: Into&lt;Option&lt;BTreeMap&lt;i64, BTreeMap&lt;i64, i32&gt;&gt;&gt;&gt;, F13: Into&lt;Option&lt;BTreeMap&lt;i64, Vec&lt;u8&gt;&gt;&gt;&gt;, F14: Into&lt;Option&lt;BTreeMap&lt;i64, tensor::GeneralTensor&gt;&gt;&gt;, F15: Into&lt;Option&lt;BTreeMap&lt;i64, tensor::SparseTensor&gt;&gt;&gt; {</dt><dd><dl class="simple">
<dt>CompactDataRecord {</dt><dd><p>binary_features: binary_features.into(),
continuous_features: continuous_features.into(),
discrete_features: discrete_features.into(),
string_features: string_features.into(),
sparse_binary_features: sparse_binary_features.into(),
sparse_binary_features_with16b_sparse_key: sparse_binary_features_with16b_sparse_key.into(),
sparse_binary_features_with32b_sparse_key: sparse_binary_features_with32b_sparse_key.into(),
sparse_binary_features_with64b_sparse_key: sparse_binary_features_with64b_sparse_key.into(),
sparse_continuous_features: sparse_continuous_features.into(),
sparse_continuous_features_with16b_sparse_key: sparse_continuous_features_with16b_sparse_key.into(),
sparse_continuous_features_with32b_sparse_key: sparse_continuous_features_with32b_sparse_key.into(),
sparse_continuous_features_with64b_sparse_key: sparse_continuous_features_with64b_sparse_key.into(),
blob_features: blob_features.into(),
tensors: tensors.into(),
sparse_tensors: sparse_tensors.into(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for CompactDataRecord {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;CompactDataRecord&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;BTreeSet&lt;i64&gt;&gt; = None;
let mut f_2: Option&lt;BTreeMap&lt;i64, i32&gt;&gt; = None;
let mut f_3: Option&lt;BTreeMap&lt;i64, i64&gt;&gt; = None;
let mut f_4: Option&lt;BTreeMap&lt;i64, String&gt;&gt; = None;
let mut f_5: Option&lt;BTreeMap&lt;i64, BTreeSet&lt;String&gt;&gt;&gt; = None;
let mut f_6: Option&lt;BTreeMap&lt;i64, BTreeSet&lt;i16&gt;&gt;&gt; = None;
let mut f_7: Option&lt;BTreeMap&lt;i64, BTreeSet&lt;i32&gt;&gt;&gt; = None;
let mut f_8: Option&lt;BTreeMap&lt;i64, BTreeSet&lt;i64&gt;&gt;&gt; = None;
let mut f_9: Option&lt;BTreeMap&lt;i64, BTreeMap&lt;String, i32&gt;&gt;&gt; = None;
let mut f_10: Option&lt;BTreeMap&lt;i64, BTreeMap&lt;i16, i32&gt;&gt;&gt; = None;
let mut f_11: Option&lt;BTreeMap&lt;i64, BTreeMap&lt;i32, i32&gt;&gt;&gt; = None;
let mut f_12: Option&lt;BTreeMap&lt;i64, BTreeMap&lt;i64, i32&gt;&gt;&gt; = None;
let mut f_13: Option&lt;BTreeMap&lt;i64, Vec&lt;u8&gt;&gt;&gt; = None;
let mut f_14: Option&lt;BTreeMap&lt;i64, tensor::GeneralTensor&gt;&gt; = None;
let mut f_15: Option&lt;BTreeMap&lt;i64, tensor::SparseTensor&gt;&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl>
<dt>1 =&gt; {</dt><dd><p>let set_ident = i_prot.read_set_begin()?;
let mut val: BTreeSet&lt;i64&gt; = BTreeSet::new();
for _ in 0..set_ident.size {</p>
<blockquote>
<div><p>let set_elem_20 = i_prot.read_i64()?;
val.insert(set_elem_20);</p>
</div></blockquote>
<p>}
i_prot.read_set_end()?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
2 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, i32&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_21 = i_prot.read_i64()?;
let map_val_22 = i_prot.read_i32()?;
val.insert(map_key_21, map_val_22);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_2 = Some(val);</p>
</div></blockquote>
<p>},
3 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, i64&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_23 = i_prot.read_i64()?;
let map_val_24 = i_prot.read_i64()?;
val.insert(map_key_23, map_val_24);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_3 = Some(val);</p>
</div></blockquote>
<p>},
4 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, String&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_25 = i_prot.read_i64()?;
let map_val_26 = i_prot.read_string()?;
val.insert(map_key_25, map_val_26);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_4 = Some(val);</p>
</div></blockquote>
<p>},
5 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, BTreeSet&lt;String&gt;&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_27 = i_prot.read_i64()?;
let set_ident = i_prot.read_set_begin()?;
let mut map_val_28: BTreeSet&lt;String&gt; = BTreeSet::new();
for _ in 0..set_ident.size {</p>
<blockquote>
<div><p>let set_elem_29 = i_prot.read_string()?;
map_val_28.insert(set_elem_29);</p>
</div></blockquote>
<p>}
i_prot.read_set_end()?;
val.insert(map_key_27, map_val_28);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_5 = Some(val);</p>
</div></blockquote>
<p>},
6 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, BTreeSet&lt;i16&gt;&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_30 = i_prot.read_i64()?;
let set_ident = i_prot.read_set_begin()?;
let mut map_val_31: BTreeSet&lt;i16&gt; = BTreeSet::new();
for _ in 0..set_ident.size {</p>
<blockquote>
<div><p>let set_elem_32 = i_prot.read_i16()?;
map_val_31.insert(set_elem_32);</p>
</div></blockquote>
<p>}
i_prot.read_set_end()?;
val.insert(map_key_30, map_val_31);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_6 = Some(val);</p>
</div></blockquote>
<p>},
7 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, BTreeSet&lt;i32&gt;&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_33 = i_prot.read_i64()?;
let set_ident = i_prot.read_set_begin()?;
let mut map_val_34: BTreeSet&lt;i32&gt; = BTreeSet::new();
for _ in 0..set_ident.size {</p>
<blockquote>
<div><p>let set_elem_35 = i_prot.read_i32()?;
map_val_34.insert(set_elem_35);</p>
</div></blockquote>
<p>}
i_prot.read_set_end()?;
val.insert(map_key_33, map_val_34);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_7 = Some(val);</p>
</div></blockquote>
<p>},
8 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, BTreeSet&lt;i64&gt;&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_36 = i_prot.read_i64()?;
let set_ident = i_prot.read_set_begin()?;
let mut map_val_37: BTreeSet&lt;i64&gt; = BTreeSet::new();
for _ in 0..set_ident.size {</p>
<blockquote>
<div><p>let set_elem_38 = i_prot.read_i64()?;
map_val_37.insert(set_elem_38);</p>
</div></blockquote>
<p>}
i_prot.read_set_end()?;
val.insert(map_key_36, map_val_37);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_8 = Some(val);</p>
</div></blockquote>
<p>},
9 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, BTreeMap&lt;String, i32&gt;&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_39 = i_prot.read_i64()?;
let map_ident = i_prot.read_map_begin()?;
let mut map_val_40: BTreeMap&lt;String, i32&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_41 = i_prot.read_string()?;
let map_val_42 = i_prot.read_i32()?;
map_val_40.insert(map_key_41, map_val_42);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
val.insert(map_key_39, map_val_40);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_9 = Some(val);</p>
</div></blockquote>
<p>},
10 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, BTreeMap&lt;i16, i32&gt;&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_43 = i_prot.read_i64()?;
let map_ident = i_prot.read_map_begin()?;
let mut map_val_44: BTreeMap&lt;i16, i32&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_45 = i_prot.read_i16()?;
let map_val_46 = i_prot.read_i32()?;
map_val_44.insert(map_key_45, map_val_46);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
val.insert(map_key_43, map_val_44);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_10 = Some(val);</p>
</div></blockquote>
<p>},
11 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, BTreeMap&lt;i32, i32&gt;&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_47 = i_prot.read_i64()?;
let map_ident = i_prot.read_map_begin()?;
let mut map_val_48: BTreeMap&lt;i32, i32&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_49 = i_prot.read_i32()?;
let map_val_50 = i_prot.read_i32()?;
map_val_48.insert(map_key_49, map_val_50);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
val.insert(map_key_47, map_val_48);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_11 = Some(val);</p>
</div></blockquote>
<p>},
12 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, BTreeMap&lt;i64, i32&gt;&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_51 = i_prot.read_i64()?;
let map_ident = i_prot.read_map_begin()?;
let mut map_val_52: BTreeMap&lt;i64, i32&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_53 = i_prot.read_i64()?;
let map_val_54 = i_prot.read_i32()?;
map_val_52.insert(map_key_53, map_val_54);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
val.insert(map_key_51, map_val_52);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_12 = Some(val);</p>
</div></blockquote>
<p>},
13 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, Vec&lt;u8&gt;&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_55 = i_prot.read_i64()?;
let map_val_56 = i_prot.read_bytes()?;
val.insert(map_key_55, map_val_56);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_13 = Some(val);</p>
</div></blockquote>
<p>},
14 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, tensor::GeneralTensor&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_57 = i_prot.read_i64()?;
let map_val_58 = tensor::GeneralTensor::read_from_in_protocol(i_prot)?;
val.insert(map_key_57, map_val_58);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_14 = Some(val);</p>
</div></blockquote>
<p>},
15 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, tensor::SparseTensor&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_59 = i_prot.read_i64()?;
let map_val_60 = tensor::SparseTensor::read_from_in_protocol(i_prot)?;
val.insert(map_key_59, map_val_60);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_15 = Some(val);</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
let ret = CompactDataRecord {</p>
<blockquote>
<div><p>binary_features: f_1,
continuous_features: f_2,
discrete_features: f_3,
string_features: f_4,
sparse_binary_features: f_5,
sparse_binary_features_with16b_sparse_key: f_6,
sparse_binary_features_with32b_sparse_key: f_7,
sparse_binary_features_with64b_sparse_key: f_8,
sparse_continuous_features: f_9,
sparse_continuous_features_with16b_sparse_key: f_10,
sparse_continuous_features_with32b_sparse_key: f_11,
sparse_continuous_features_with64b_sparse_key: f_12,
blob_features: f_13,
tensors: f_14,
sparse_tensors: f_15,</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“CompactDataRecord”);
o_prot.write_struct_begin(&amp;struct_ident)?;
if let Some(ref fld_var) = self.binary_features {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“binaryFeatures”, TType::Set, 1))?;
o_prot.write_set_begin(&amp;TSetIdentifier::new(TType::I64, fld_var.len() as i32))?;
for e in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id27"><span class="problematic" id="id28">*</span></a>e)?;</p>
</div></blockquote>
<p>}
o_prot.write_set_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.continuous_features {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“continuousFeatures”, TType::Map, 2))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::I32, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id29"><span class="problematic" id="id30">*</span></a>k)?;
o_prot.write_i32(<a href="#id31"><span class="problematic" id="id32">*</span></a>v)?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.discrete_features {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“discreteFeatures”, TType::Map, 3))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::I64, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id33"><span class="problematic" id="id34">*</span></a>k)?;
o_prot.write_i64(<a href="#id35"><span class="problematic" id="id36">*</span></a>v)?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.string_features {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“stringFeatures”, TType::Map, 4))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::String, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id37"><span class="problematic" id="id38">*</span></a>k)?;
o_prot.write_string(v)?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.sparse_binary_features {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“sparseBinaryFeatures”, TType::Map, 5))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::Set, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id39"><span class="problematic" id="id40">*</span></a>k)?;
o_prot.write_set_begin(&amp;TSetIdentifier::new(TType::String, v.len() as i32))?;
for e in v {</p>
<blockquote>
<div><p>o_prot.write_string(e)?;</p>
</div></blockquote>
<p>}
o_prot.write_set_end()?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.sparse_binary_features_with16b_sparse_key {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“sparseBinaryFeaturesWith16bSparseKey”, TType::Map, 6))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::Set, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id41"><span class="problematic" id="id42">*</span></a>k)?;
o_prot.write_set_begin(&amp;TSetIdentifier::new(TType::I16, v.len() as i32))?;
for e in v {</p>
<blockquote>
<div><p>o_prot.write_i16(<a href="#id43"><span class="problematic" id="id44">*</span></a>e)?;</p>
</div></blockquote>
<p>}
o_prot.write_set_end()?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.sparse_binary_features_with32b_sparse_key {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“sparseBinaryFeaturesWith32bSparseKey”, TType::Map, 7))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::Set, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id45"><span class="problematic" id="id46">*</span></a>k)?;
o_prot.write_set_begin(&amp;TSetIdentifier::new(TType::I32, v.len() as i32))?;
for e in v {</p>
<blockquote>
<div><p>o_prot.write_i32(<a href="#id47"><span class="problematic" id="id48">*</span></a>e)?;</p>
</div></blockquote>
<p>}
o_prot.write_set_end()?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.sparse_binary_features_with64b_sparse_key {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“sparseBinaryFeaturesWith64bSparseKey”, TType::Map, 8))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::Set, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id49"><span class="problematic" id="id50">*</span></a>k)?;
o_prot.write_set_begin(&amp;TSetIdentifier::new(TType::I64, v.len() as i32))?;
for e in v {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id51"><span class="problematic" id="id52">*</span></a>e)?;</p>
</div></blockquote>
<p>}
o_prot.write_set_end()?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.sparse_continuous_features {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“sparseContinuousFeatures”, TType::Map, 9))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::Map, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id53"><span class="problematic" id="id54">*</span></a>k)?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::String, TType::I32, v.len() as i32))?;
for (k, v) in v {</p>
<blockquote>
<div><p>o_prot.write_string(k)?;
o_prot.write_i32(<a href="#id55"><span class="problematic" id="id56">*</span></a>v)?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.sparse_continuous_features_with16b_sparse_key {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“sparseContinuousFeaturesWith16bSparseKey”, TType::Map, 10))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::Map, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id57"><span class="problematic" id="id58">*</span></a>k)?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I16, TType::I32, v.len() as i32))?;
for (k, v) in v {</p>
<blockquote>
<div><p>o_prot.write_i16(<a href="#id59"><span class="problematic" id="id60">*</span></a>k)?;
o_prot.write_i32(<a href="#id61"><span class="problematic" id="id62">*</span></a>v)?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.sparse_continuous_features_with32b_sparse_key {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“sparseContinuousFeaturesWith32bSparseKey”, TType::Map, 11))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::Map, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id63"><span class="problematic" id="id64">*</span></a>k)?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I32, TType::I32, v.len() as i32))?;
for (k, v) in v {</p>
<blockquote>
<div><p>o_prot.write_i32(<a href="#id65"><span class="problematic" id="id66">*</span></a>k)?;
o_prot.write_i32(<a href="#id67"><span class="problematic" id="id68">*</span></a>v)?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.sparse_continuous_features_with64b_sparse_key {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“sparseContinuousFeaturesWith64bSparseKey”, TType::Map, 12))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::Map, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id69"><span class="problematic" id="id70">*</span></a>k)?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::I32, v.len() as i32))?;
for (k, v) in v {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id71"><span class="problematic" id="id72">*</span></a>k)?;
o_prot.write_i32(<a href="#id73"><span class="problematic" id="id74">*</span></a>v)?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.blob_features {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“blobFeatures”, TType::Map, 13))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::String, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id75"><span class="problematic" id="id76">*</span></a>k)?;
o_prot.write_bytes(v)?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.tensors {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“tensors”, TType::Map, 14))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::Struct, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id77"><span class="problematic" id="id78">*</span></a>k)?;
v.write_to_out_protocol(o_prot)?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.sparse_tensors {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“sparseTensors”, TType::Map, 15))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::Struct, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id79"><span class="problematic" id="id80">*</span></a>k)?;
v.write_to_out_protocol(o_prot)?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl Default for CompactDataRecord {</dt><dd><dl>
<dt>fn default() -&gt; Self {</dt><dd><dl class="simple">
<dt>CompactDataRecord{</dt><dd><p>binary_features: Some(BTreeSet::new()),
continuous_features: Some(BTreeMap::new()),
discrete_features: Some(BTreeMap::new()),
string_features: Some(BTreeMap::new()),
sparse_binary_features: Some(BTreeMap::new()),
sparse_binary_features_with16b_sparse_key: Some(BTreeMap::new()),
sparse_binary_features_with32b_sparse_key: Some(BTreeMap::new()),
sparse_binary_features_with64b_sparse_key: Some(BTreeMap::new()),
sparse_continuous_features: Some(BTreeMap::new()),
sparse_continuous_features_with16b_sparse_key: Some(BTreeMap::new()),
sparse_continuous_features_with32b_sparse_key: Some(BTreeMap::new()),
sparse_continuous_features_with64b_sparse_key: Some(BTreeMap::new()),
blob_features: Some(BTreeMap::new()),
tensors: Some(BTreeMap::new()),
sparse_tensors: Some(BTreeMap::new()),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// TensorRecord
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct TensorRecord {</p>
<blockquote>
<div><p>pub tensors: Option&lt;BTreeMap&lt;i64, tensor::GeneralTensor&gt;&gt;,
pub sparse_tensors: Option&lt;BTreeMap&lt;i64, tensor::SparseTensor&gt;&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl TensorRecord {</dt><dd><dl>
<dt>pub fn new&lt;F1, F2&gt;(tensors: F1, sparse_tensors: F2) -&gt; TensorRecord where F1: Into&lt;Option&lt;BTreeMap&lt;i64, tensor::GeneralTensor&gt;&gt;&gt;, F2: Into&lt;Option&lt;BTreeMap&lt;i64, tensor::SparseTensor&gt;&gt;&gt; {</dt><dd><dl class="simple">
<dt>TensorRecord {</dt><dd><p>tensors: tensors.into(),
sparse_tensors: sparse_tensors.into(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for TensorRecord {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;TensorRecord&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;BTreeMap&lt;i64, tensor::GeneralTensor&gt;&gt; = None;
let mut f_2: Option&lt;BTreeMap&lt;i64, tensor::SparseTensor&gt;&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl>
<dt>1 =&gt; {</dt><dd><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, tensor::GeneralTensor&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_61 = i_prot.read_i64()?;
let map_val_62 = tensor::GeneralTensor::read_from_in_protocol(i_prot)?;
val.insert(map_key_61, map_val_62);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
2 =&gt; {</p>
<blockquote>
<div><p>let map_ident = i_prot.read_map_begin()?;
let mut val: BTreeMap&lt;i64, tensor::SparseTensor&gt; = BTreeMap::new();
for _ in 0..map_ident.size {</p>
<blockquote>
<div><p>let map_key_63 = i_prot.read_i64()?;
let map_val_64 = tensor::SparseTensor::read_from_in_protocol(i_prot)?;
val.insert(map_key_63, map_val_64);</p>
</div></blockquote>
<p>}
i_prot.read_map_end()?;
f_2 = Some(val);</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
let ret = TensorRecord {</p>
<blockquote>
<div><p>tensors: f_1,
sparse_tensors: f_2,</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“TensorRecord”);
o_prot.write_struct_begin(&amp;struct_ident)?;
if let Some(ref fld_var) = self.tensors {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“tensors”, TType::Map, 1))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::Struct, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id81"><span class="problematic" id="id82">*</span></a>k)?;
v.write_to_out_protocol(o_prot)?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.sparse_tensors {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“sparseTensors”, TType::Map, 2))?;
o_prot.write_map_begin(&amp;TMapIdentifier::new(TType::I64, TType::Struct, fld_var.len() as i32))?;
for (k, v) in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id83"><span class="problematic" id="id84">*</span></a>k)?;
v.write_to_out_protocol(o_prot)?;</p>
</div></blockquote>
<p>}
o_prot.write_map_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl Default for TensorRecord {</dt><dd><dl>
<dt>fn default() -&gt; Self {</dt><dd><dl class="simple">
<dt>TensorRecord{</dt><dd><p>tensors: Some(BTreeMap::new()),
sparse_tensors: Some(BTreeMap::new()),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// FeatureMetaInfo
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FeatureMetaInfo {</p>
<blockquote>
<div><p>pub feature_id: Option&lt;i64&gt;,
pub full_feature_name: Option&lt;String&gt;,
pub feature_type: Option&lt;FeatureType&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl FeatureMetaInfo {</dt><dd><dl>
<dt>pub fn new&lt;F1, F2, F3&gt;(feature_id: F1, full_feature_name: F2, feature_type: F3) -&gt; FeatureMetaInfo where F1: Into&lt;Option&lt;i64&gt;&gt;, F2: Into&lt;Option&lt;String&gt;&gt;, F3: Into&lt;Option&lt;FeatureType&gt;&gt; {</dt><dd><dl class="simple">
<dt>FeatureMetaInfo {</dt><dd><p>feature_id: feature_id.into(),
full_feature_name: full_feature_name.into(),
feature_type: feature_type.into(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for FeatureMetaInfo {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;FeatureMetaInfo&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;i64&gt; = None;
let mut f_2: Option&lt;String&gt; = None;
let mut f_3: Option&lt;FeatureType&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl class="simple">
<dt>1 =&gt; {</dt><dd><p>let val = i_prot.read_i64()?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
2 =&gt; {</p>
<blockquote>
<div><p>let val = i_prot.read_string()?;
f_2 = Some(val);</p>
</div></blockquote>
<p>},
3 =&gt; {</p>
<blockquote>
<div><p>let val = FeatureType::read_from_in_protocol(i_prot)?;
f_3 = Some(val);</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
let ret = FeatureMetaInfo {</p>
<blockquote>
<div><p>feature_id: f_1,
full_feature_name: f_2,
feature_type: f_3,</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“FeatureMetaInfo”);
o_prot.write_struct_begin(&amp;struct_ident)?;
if let Some(fld_var) = self.feature_id {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“featureId”, TType::I64, 1))?;
o_prot.write_i64(fld_var)?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.full_feature_name {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“fullFeatureName”, TType::String, 2))?;
o_prot.write_string(fld_var)?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.feature_type {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“featureType”, TType::I32, 3))?;
fld_var.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl Default for FeatureMetaInfo {</dt><dd><dl>
<dt>fn default() -&gt; Self {</dt><dd><dl class="simple">
<dt>FeatureMetaInfo{</dt><dd><p>feature_id: Some(0),
full_feature_name: Some(“”.to_owned()),
feature_type: None,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// FeatureMetaInfoList
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FeatureMetaInfoList {</p>
<blockquote>
<div><p>pub contents: Option&lt;Vec&lt;FeatureMetaInfo&gt;&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl FeatureMetaInfoList {</dt><dd><dl>
<dt>pub fn new&lt;F1&gt;(contents: F1) -&gt; FeatureMetaInfoList where F1: Into&lt;Option&lt;Vec&lt;FeatureMetaInfo&gt;&gt;&gt; {</dt><dd><dl class="simple">
<dt>FeatureMetaInfoList {</dt><dd><p>contents: contents.into(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for FeatureMetaInfoList {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;FeatureMetaInfoList&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;Vec&lt;FeatureMetaInfo&gt;&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl>
<dt>1 =&gt; {</dt><dd><p>let list_ident = i_prot.read_list_begin()?;
let mut val: Vec&lt;FeatureMetaInfo&gt; = Vec::with_capacity(list_ident.size as usize);
for _ in 0..list_ident.size {</p>
<blockquote>
<div><p>let list_elem_65 = FeatureMetaInfo::read_from_in_protocol(i_prot)?;
val.push(list_elem_65);</p>
</div></blockquote>
<p>}
i_prot.read_list_end()?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
let ret = FeatureMetaInfoList {</p>
<blockquote>
<div><p>contents: f_1,</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“FeatureMetaInfoList”);
o_prot.write_struct_begin(&amp;struct_ident)?;
if let Some(ref fld_var) = self.contents {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“contents”, TType::List, 1))?;
o_prot.write_list_begin(&amp;TListIdentifier::new(TType::Struct, fld_var.len() as i32))?;
for e in fld_var {</p>
<blockquote>
<div><p>e.write_to_out_protocol(o_prot)?;</p>
</div></blockquote>
<p>}
o_prot.write_list_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl Default for FeatureMetaInfoList {</dt><dd><dl>
<dt>fn default() -&gt; Self {</dt><dd><dl class="simple">
<dt>FeatureMetaInfoList{</dt><dd><p>contents: Some(Vec::new()),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../_sources/navi/thrift_bpr_adapter/thrift/src/data.rs.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>