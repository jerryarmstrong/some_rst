<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>docs/publickeys-signers.md &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=039e1c02" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=b3ba4146"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="docs-publickeys-signers-md">
<h1>docs/publickeys-signers.md<a class="headerlink" href="#docs-publickeys-signers-md" title="Permalink to this heading">¶</a></h1>
<p>Last edited: 2023-07-27 15:49:41</p>
<p>Contents:</p>
<div class="highlight-md notranslate"><div class="highlight"><pre><span></span><span class="gh"># Public keys and signers</span>
</pre></div>
</div>
<p>On this page, we’ll see how to manage public keys and signers in Umi which is partially made possible by the EdDSA interface.</p>
<p>The [EdDSA interface](<a class="reference external" href="https://umi-docs.vercel.app/interfaces/umi.EddsaInterface.html">https://umi-docs.vercel.app/interfaces/umi.EddsaInterface.html</a>) is used to create keypairs, find PDAs and sign/verify messages using the EdDSA algorithm. We can either use this interface directly and/or use helper methods that delegate to this interface to provide a better developer experience.</p>
<p>Let’s tackle this on a per-use case basis.</p>
<p>## Public keys</p>
<p>In Umi, a public key is a simple base58 <cite>string</cite> representing a 32-byte array. We use an opaque type to tell TypeScript that the given public key has been verified and is valid. We also use a type parameter to offer more granular type safety.</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>ts
// In short:
type PublicKey = string;</p>
<p>// In reality:
type PublicKey&lt;TAddress extends string = string&gt; = TAddress &amp; { __publicKey: unique symbol };
<a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a></p>
<p>We can create a new valid public key from a variety of inputs using the <cite>publicKey</cite> helper method. If the provided input cannot be converted to a valid public key, an error will be thrown.</p>
<p><a href="#id9"><span class="problematic" id="id10">``</span></a><a href="#id11"><span class="problematic" id="id12">`</span></a>ts
// From a base58 string.
publicKey(‘LorisCg1FTs89a32VSrFskYDgiRbNQzct1WxyZb7nuA’);</p>
<p>// From a 32-byte buffer.
publicKey(new Uint8Array(32));</p>
<p>// From a PublicKey or Signer type.
publicKey(someWallet as PublicKey | Signer);
<a href="#id13"><span class="problematic" id="id14">``</span></a><a href="#id15"><span class="problematic" id="id16">`</span></a></p>
<p>It is possible to convert a public key to a <cite>Uint8Array</cite> using the <cite>publicKeyBytes</cite> helper method.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">publicKeyBytes(myPublicKey);</span>
<span class="pre">//</span> <span class="pre">-&gt;</span> <span class="pre">Uint8Array(32)</span>
<span class="pre">`</span></code></p>
<p>Additional helper methods are also available to help manage public keys.</p>
<p><a href="#id17"><span class="problematic" id="id18">``</span></a><a href="#id19"><span class="problematic" id="id20">`</span></a>ts
// Check if the provided value is a valid public key.
isPublicKey(myPublicKey);</p>
<p>// Assert the provided value is a valid public key and fail otherwise.
assertPublicKey(myPublicKey);</p>
<p>// Deduplicate an array of public keys.
uniquePublicKeys(myPublicKeys);</p>
<p>// Create the default public key which is a 32-bytes array of zeros.
defaultPublicKey();
<a href="#id21"><span class="problematic" id="id22">``</span></a><a href="#id23"><span class="problematic" id="id24">`</span></a></p>
<p>## PDAs</p>
<p>A PDA — or Program-Derived Address — is a public key that is derived from a program ID and an array of predefined seeds. A <cite>bump</cite> number ranging from 0 to 255 is required to ensure the PDA does not live on the EdDSA elliptic curve and therefore does not conflict with cryptographically generated public keys.</p>
<p>In Umi, PDAs are represented as a tuple composed of the derived public key and the bump number. Similarly to public keys, it uses opaque types and type parameters.</p>
<p><a href="#id25"><span class="problematic" id="id26">``</span></a><a href="#id27"><span class="problematic" id="id28">`</span></a>ts
// In short:
type Pda = [PublicKey, number];</p>
<p>// In reality:
export type Pda&lt;</p>
<blockquote>
<div><p>TAddress extends string = string,
TBump extends number = number</p>
</div></blockquote>
<p>&gt; = [PublicKey&lt;TAddress&gt;, TBump] &amp; { readonly __pda: unique symbol };
<a href="#id29"><span class="problematic" id="id30">``</span></a><a href="#id31"><span class="problematic" id="id32">`</span></a></p>
<p>To derive a new PDA, we can use the <cite>findPda</cite> method of the EdDSA interface.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">const</span> <span class="pre">pda</span> <span class="pre">=</span> <span class="pre">umi.eddsa.findPda(programId,</span> <span class="pre">seeds);</span>
<span class="pre">`</span></code></p>
<p>Each seed must be serialized as a <cite>Uint8Array</cite>. You can learn more about serializers on [the Serializers page](./serializers.md) but here is a quick example showing how to find the metadata PDA of a given mint address.</p>
<p><a href="#id33"><span class="problematic" id="id34">``</span></a><a href="#id35"><span class="problematic" id="id36">`</span></a>ts
import { publicKey } from <a class="reference external" href="mailto:'&#37;&#52;&#48;metaplex-foundation/umi">‘<span>&#64;</span>metaplex-foundation/umi</a>’;
import { publicKey as publicKeySerializer, string } from <a class="reference external" href="mailto:'&#37;&#52;&#48;metaplex-foundation/umi/serializers">‘<span>&#64;</span>metaplex-foundation/umi/serializers</a>’;</p>
<p>const tokenMetadataProgramId = publicKey(‘metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s’);
const metadata = umi.eddsa.findPda(tokenMetadataProgramId, [</p>
<blockquote>
<div><p>string({ size: ‘variable’ }).serialize(‘metadata’),
publicKeySerializer().serialize(tokenMetadataProgramId),
publicKeySerializer().serialize(mint),</p>
</div></blockquote>
<section id="id37">
<h2>]);<a class="headerlink" href="#id37" title="Permalink to this heading">¶</a></h2>
<p>Note that in most cases, programs will provide helper methods to find specific PDAs. For instance, the code snippet above can be simplified to the following using the <cite>findMetadataPda</cite> method of the [<cite>&#64;metaplex-foundation/mpl-token-metadata</cite>](<a class="reference external" href="https://github.com/metaplex-foundation/mpl-token-metadata">https://github.com/metaplex-foundation/mpl-token-metadata</a>) [Kinobi](./kinobi.md)-generated library.</p>
<p><a href="#id38"><span class="problematic" id="id39">``</span></a><a href="#id40"><span class="problematic" id="id41">`</span></a>ts
import { findMetadataPda } from <a class="reference external" href="mailto:'&#37;&#52;&#48;metaplex-foundation/mpl-token-metadata">‘<span>&#64;</span>metaplex-foundation/mpl-token-metadata</a>’;</p>
<p>const metadata = findMetadataPda(umi, { mint })
<a href="#id42"><span class="problematic" id="id43">``</span></a><a href="#id44"><span class="problematic" id="id45">`</span></a></p>
<p>The following helper methods are also available to help manage PDAs.</p>
<p><a href="#id46"><span class="problematic" id="id47">``</span></a><a href="#id48"><span class="problematic" id="id49">`</span></a>ts
// Check if the provided value is a Pda.
isPda(myPda);</p>
<p>// Check if the provided public key is on the EdDSA elliptic curve.
umi.eddsa.isOnCurve(myPublicKey);
<a href="#id50"><span class="problematic" id="id51">``</span></a><a href="#id52"><span class="problematic" id="id53">`</span></a></p>
<p>## Signers</p>
<p>A signer is a public key that can sign transactions and messages. This enables transactions to be signed by the required accounts and wallets to prove their identity by signing messages. In Umi, it is represented by the following interface.</p>
<p><a href="#id54"><span class="problematic" id="id55">``</span></a><a href="#id56"><span class="problematic" id="id57">`</span></a>ts
interface Signer {</p>
<blockquote>
<div><p>publicKey: PublicKey;
signMessage(message: Uint8Array): Promise&lt;Uint8Array&gt;;
signTransaction(transaction: Transaction): Promise&lt;Transaction&gt;;
signAllTransactions(transactions: Transaction[]): Promise&lt;Transaction[]&gt;;</p>
</div></blockquote>
</section>
<section id="id58">
<h2>}<a class="headerlink" href="#id58" title="Permalink to this heading">¶</a></h2>
<p>You may generate a new signer cryptographically using the <cite>generateSigner</cite> helper method. Under the hood, this method uses the <cite>generateKeypair</cite> method of the EdDSA interface as described in the next section.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">const</span> <span class="pre">mySigner</span> <span class="pre">=</span> <span class="pre">generateSigner(umi);</span>
<span class="pre">`</span></code></p>
<p>The following helper functions can also be used to manage signers.</p>
<p><a href="#id59"><span class="problematic" id="id60">``</span></a><a href="#id61"><span class="problematic" id="id62">`</span></a>ts
// Check if the provided value is a Signer.
isSigner(mySigner);</p>
<p>// Deduplicate an array of signers by public key.
uniqueSigners(mySigners);
<a href="#id63"><span class="problematic" id="id64">``</span></a><a href="#id65"><span class="problematic" id="id66">`</span></a></p>
<p>As mentioned in [the Umi interfaces page](./interfaces.md), the <cite>Umi</cite> interface stores two instances of <cite>Signer</cite>: The <cite>identity</cite> using the app and the <cite>payer</cite> paying for transaction and storage fees. Umi provides plugins to quickly assign new signers to these attributes. The <cite>signerIdentity</cite> and <cite>signerPayer</cite> plugins are available for this purpose. Note that, by default, the <cite>signerIdentity</cite> method will also update the <cite>payer</cite> attribute since, in most cases, the identity is also the payer.</p>
<p><a href="#id67"><span class="problematic" id="id68">``</span></a><a href="#id69"><span class="problematic" id="id70">`</span></a>ts
umi.use(signerIdentity(mySigner));
// Is equivalent to:
umi.identity = mySigner;
umi.payer = mySigner;</p>
<p>umi.use(signerIdentity(mySigner, false));
// Is equivalent to:
umi.identity = mySigner;</p>
<p>umi.use(signerPayer(mySigner));
// Is equivalent to:
umi.payer = mySigner;
<a href="#id71"><span class="problematic" id="id72">``</span></a><a href="#id73"><span class="problematic" id="id74">`</span></a></p>
<p>You may also use the <cite>generatedSignerIdentity</cite> and <cite>generatedSignerPayer</cite> plugins to generate a new signer and immediately assign it to the <cite>identity</cite> and/or <cite>payer</cite> attributes.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">umi.use(generatedSignerIdentity());</span>
<span class="pre">umi.use(generatedSignerPayer());</span>
<span class="pre">`</span></code></p>
<p>In some cases, a library may require a <cite>Signer</cite> to be provided but the current environment does not have access to this wallet as a signer. For instance, this can happen if a transaction is being created on the client but will be later on signed on a private server. It’s for that reason that Umi provides a <cite>createNoopSigner</cite> helper that creates a new signer from the given public key and simply ignores any signing request. It is then your responsibility to ensure that the transaction is signed before being sent to the blockchain.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">const</span> <span class="pre">mySigner</span> <span class="pre">=</span> <span class="pre">createNoopSigner(myPublicKey);</span>
<span class="pre">`</span></code></p>
<p>## Keypairs</p>
<p>Whilst Umi only relies on the <cite>Signer</cite> interface to request signatures from a wallet, it also defines a <cite>Keypair</cite> type and a <cite>KeypairSigner</cite> type that are explicitly aware of their secret key.</p>
<p><a href="#id75"><span class="problematic" id="id76">``</span></a><a href="#id77"><span class="problematic" id="id78">`</span></a>ts
type KeypairSigner = Signer &amp; Keypair;
type Keypair = {</p>
<blockquote>
<div><p>publicKey: PublicKey;
secretKey: Uint8Array;</p>
</div></blockquote>
</section>
<section id="id79">
<h2>};<a class="headerlink" href="#id79" title="Permalink to this heading">¶</a></h2>
<p>The <cite>generateKeypair</cite>, <cite>createKeypairFromSeed</cite> and <cite>createKeypairFromSecretKey</cite> methods of the EdDSA interface can be used to generate new <cite>Keypair</cite> objects.</p>
<p><a href="#id80"><span class="problematic" id="id81">``</span></a><a href="#id82"><span class="problematic" id="id83">`</span></a>ts
// Generate a new random keypair.
const myKeypair = umi.eddsa.generateKeypair();</p>
<p>// Restore a keypair using a seed.
const myKeypair = umi.eddsa.createKeypairFromSeed(mySeed);</p>
<p>// Restore a keypair using its secret key.
const myKeypair = umi.eddsa.createKeypairFromSecretKey(mySecretKey);
<a href="#id84"><span class="problematic" id="id85">``</span></a><a href="#id86"><span class="problematic" id="id87">`</span></a></p>
<p>In order to use these keypairs as signers throughout your application, you can use the <cite>createSignerFromKeypair</cite> helper method. This method will return an instance of <cite>KeypairSigner</cite> to ensure that we can access the secret key when needed.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">const</span> <span class="pre">myKeypair</span> <span class="pre">=</span> <span class="pre">umi.eddsa.generateKeypair();</span>
<span class="pre">const</span> <span class="pre">myKeypairSigner</span> <span class="pre">=</span> <span class="pre">createSignerFromKeypair(myKeypair);</span>
<span class="pre">`</span></code></p>
<p>Note that the code snippet above is equivalent to using the <cite>generateSigner</cite> helper method described in the previous section.</p>
<p>Helper functions and plugins also exist to manage keypairs.</p>
<p><a href="#id88"><span class="problematic" id="id89">``</span></a><a href="#id90"><span class="problematic" id="id91">`</span></a>ts
// Check if the provided signer is a KeypairSigner object.
isKeypairSigner(mySigner);</p>
<p>// Register a new keypair as the identity and payer.
umi.use(keypairIdentity(myKeypair));</p>
<p>// Register a new keypair as the payer only.
umi.use(keypairPayer(myKeypair));
<a href="#id92"><span class="problematic" id="id93">``</span></a><a href="#id94"><span class="problematic" id="id95">`</span></a></p>
<p>## Signing messages</p>
<p>The <cite>Signer</cite> object and the EdDSA interface can be used together to sign and verify messages like so.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">const</span> <span class="pre">myMessage</span> <span class="pre">=</span> <span class="pre">utf8.serialize('Hello,</span> <span class="pre">world!');</span>
<span class="pre">const</span> <span class="pre">mySignature</span> <span class="pre">=</span> <span class="pre">await</span> <span class="pre">mySigner.signMessage(myMessage)</span>
<span class="pre">const</span> <span class="pre">mySignatureIsCorrect</span> <span class="pre">=</span> <span class="pre">umi.eddsa.verify(myMessage,</span> <span class="pre">mySignature,</span> <span class="pre">mySigner.publicKey);</span>
<span class="pre">`</span></code></p>
<p>## Signing transactions</p>
<p>Once we have a <cite>Signer</cite> instance, signing a transaction or a set of transactions is as simple as calling the <cite>signTransaction</cite> or <cite>signAllTransactions</cite> methods.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">const</span> <span class="pre">mySignedTransaction</span> <span class="pre">=</span> <span class="pre">await</span> <span class="pre">mySigner.signTransaction(myTransaction);</span>
<span class="pre">const</span> <span class="pre">mySignedTransactions</span> <span class="pre">=</span> <span class="pre">await</span> <span class="pre">mySigner.signAllTransactions(myTransactions);</span>
<span class="pre">`</span></code></p>
<p>If you need multiple signers to all sign the same transaction, you may use the <cite>signTransaction</cite> helper method like so.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">const</span> <span class="pre">mySignedTransaction</span> <span class="pre">=</span> <span class="pre">await</span> <span class="pre">signTransaction(myTransaction,</span> <span class="pre">mySigners);</span>
<span class="pre">`</span></code></p>
<p>Going one step further, if you have multiple transactions that each need to be signed by one or more signers, the <cite>signAllTransactions</cite> function can help you with that. It will even ensure that, if a signer is required to sign more than one transaction, it will use the <cite>signer.signAllTransactions</cite> method on all of them at once.</p>
<p><a href="#id96"><span class="problematic" id="id97">``</span></a><a href="#id98"><span class="problematic" id="id99">`</span></a>ts
// In this example, mySigner2 will sign both transactions
// using the signAllTransactions method.
const mySignedTransactions = await signAllTransactions([</p>
<blockquote>
<div><p>{ transaction: myFirstTransaction, signers: [mySigner1, mySigner2] },
{ transaction: mySecondTransaction, signers: [mySigner2, mySigner3] }</p>
</div></blockquote>
</section>
<section id="id100">
<h2>]);<a class="headerlink" href="#id100" title="Permalink to this heading">¶</a></h2>
<p>If you are creating a <cite>Signer</cite> manually and therefore implementing its <cite>signTransaction</cite> method, you may want to use the <cite>addTransactionSignature</cite> helper function to add the signature to the transaction. This will ensure the provided signature is required by the transaction and pushed at the right index of the transaction’s <cite>signatures</cite> array.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">const</span> <span class="pre">mySignedTransaction</span> <span class="pre">=</span> <span class="pre">addTransactionSignature(myTransaction,</span> <span class="pre">mySignature,</span> <span class="pre">myPublicKey);</span>
<span class="pre">`</span></code></p>
<p>&lt;p align=”center”&gt;
&lt;strong&gt;Next: &lt;a href=”./rpc.md”&gt;Connecting with an RPC ≫&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/publickeys-signers.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>