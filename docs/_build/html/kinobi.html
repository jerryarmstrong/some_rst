<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>docs/kinobi.md &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=039e1c02" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=b3ba4146"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="docs-kinobi-md">
<h1>docs/kinobi.md<a class="headerlink" href="#docs-kinobi-md" title="Permalink to this heading">¶</a></h1>
<p>Last edited: 2023-07-27 15:49:41</p>
<p>Contents:</p>
<div class="highlight-md notranslate"><div class="highlight"><pre><span></span><span class="gh"># Generating Umi clients via Kinobi</span>
</pre></div>
</div>
<p>The Umi framework provides the basis for building Solana clients in JavaScript. It becomes a lot more powerful when programs offer Umi-compatible libraries as it allows end-users to simply plug their Umi instance into whichever helper functions they provide. To simplify and automate the process of creating Umi-compatible libraries, Umi provides a powerful code generator called Kinobi.</p>
<p>[Kinobi](<a class="reference external" href="https://github.com/metaplex-foundation/kinobi">https://github.com/metaplex-foundation/kinobi</a>) introduces a language-agnostic representation of Solana clients which can be composed of one or several programs. It does this by using a tree of nodes that can be visited by <cite>Visitor</cite> classes. Visitors can be used to update any aspect of the tree allowing developers to tailor the client to their needs. Once the tree is to the developer’s liking, language-specific visitors can be used to generate the code for the target language or framework.</p>
<p>The good news is Kinobi ships with a <cite>RenderJavaScriptVisitor</cite> that generates Umi-compatible libraries for us.</p>
<p>Here’s a quick overview of how to use Kinobi and Umi to create JavaScript clients for Solana programs. Note that [you might be interested in this thread](<a class="reference external" href="https://twitter.com/lorismatic/status/1637890024992833536">https://twitter.com/lorismatic/status/1637890024992833536</a>) that goes through this diagram step by step.</p>
<p>![](<a class="reference external" href="https://pbs.twimg.com/media/Frr0StQaIAAc16a?format=jpg&amp;name=4096x4096">https://pbs.twimg.com/media/Frr0StQaIAAc16a?format=jpg&amp;name=4096x4096</a>)</p>
<p>## Getting started with Kinobi</p>
<p>You may want to check the [Kinobi documentation](<a class="reference external" href="https://github.com/metaplex-foundation/kinobi">https://github.com/metaplex-foundation/kinobi</a>) for more details but here’s a quick overview of how to get started with Kinobi.</p>
<p>First, you need to install Kinobi:</p>
<p><code class="docutils literal notranslate"><span class="pre">`sh</span>
<span class="pre">npm</span> <span class="pre">install</span> <span class="pre">&#64;metaplex-foundation/kinobi</span>
<span class="pre">`</span></code></p>
<p>Then, you need to create a JavaScript file — e.g. <cite>kinobi.js</cite> — that creates and renders a Kinobi tree. This is done by creating a <cite>Kinobi</cite> instance and passing it an array of paths to IDL files. You may want to check the [Shank JS library](<a class="reference external" href="https://github.com/metaplex-foundation/shank-js">https://github.com/metaplex-foundation/shank-js</a>) to generate your IDL files. You can then use visitors to update the tree and render it as a Umi-compatible library via the <cite>RenderJavaScriptVisitor</cite>. Here’s an example.</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>ts
import { createFromIdls, RenderJavaScriptVisitor } from “&#64;metaplex-foundation/kinobi”;</p>
<p>// Instanciate Kinobi.
const kinobi = createFromIdls([</p>
<blockquote>
<div><p>path.join(__dirname, “idls”, “my_idl.json”),
path.join(__dirname, “idls”, “my_other_idl.json”),</p>
</div></blockquote>
<p>]);</p>
<p>// Update the Kinobi tree using visitors…</p>
<p>// Render JavaScript.
const jsDir = path.join(__dirname, “clients”, “js”, “src”, “generated”);
kinobi.accept(new RenderJavaScriptVisitor(jsDir));
<a href="#id5"><span class="problematic" id="id6">``</span></a><a href="#id7"><span class="problematic" id="id8">`</span></a></p>
<p>Now, all you need to do is run this file with Node.js like so.</p>
<p><code class="docutils literal notranslate"><span class="pre">`sh</span>
<span class="pre">node</span> <span class="pre">./kinobi.js</span>
<span class="pre">`</span></code></p>
<p>The first time you are generating your JS client, make sure to prepare the library as needed. You’ll need to at least create its <cite>package.json</cite> file, install its dependencies and provide a top-level <cite>index.ts</cite> file that imports the generated folder.</p>
<p>## Features of Kinobi-generated clients</p>
<p>Now that we know how to generate Umi-compatible libraries via Kinobi, let’s take a look at what they can do.</p>
<p>### Types and serializers</p>
<p>Kinobi-generated libraries provide a serializer for each type, account and instruction defined on the program. It also exports the two TypeScript types required to create the serializer — i.e. its <cite>From</cite> and <cite>To</cite> type parameters. It will suffix the <cite>From</cite> type with <cite>Args</cite> to distinguish the two. For instance, if you have a <cite>MyType</cite> type defined in your IDL, you can use the following code to serialize and deserialize it.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">const</span> <span class="pre">serializer:</span> <span class="pre">Serializer&lt;MyTypeArgs,</span> <span class="pre">MyType&gt;</span> <span class="pre">=</span> <span class="pre">getMyTypeSerializer();</span>
<span class="pre">serializer.serialize(myType);</span>
<span class="pre">serializer.deserialize(myBuffer);</span>
<span class="pre">`</span></code></p>
<p>For instructions, the name of the type is suffixed with <cite>InstructionData</cite> and, for accounts, it is suffixed with <cite>AccountData</cite>. This allows the unsuffixed account name to be used as an <cite>Account&lt;T&gt;</cite> type. For example, if you have a <cite>Token</cite> account and a <cite>Transfer</cite> instruction on your program, you will get the following types and serializers.</p>
<p><a href="#id9"><span class="problematic" id="id10">``</span></a><a href="#id11"><span class="problematic" id="id12">`</span></a>ts
// For accounts.
type Token = Account&lt;TokenAccountData&gt;;
type TokenAccountData = {…};
type TokenAccountDataArgs = {…};
const tokenDataSerializer = getTokenAccountDataSerializer();</p>
<p>// For instructions.
type TransferInstructionData = {…};
type TransferInstructionDataArgs = {…};
const transferDataSerializer = getTransferInstructionDataSerializer();
<a href="#id13"><span class="problematic" id="id14">``</span></a><a href="#id15"><span class="problematic" id="id16">`</span></a></p>
<p>### Data enum helpers</p>
<p>If a generated type is identified as a [data enum](./serializers.md#data-enums), additional helper methods will be created to help improve the developer experience. For instance, say you have the following data enum type generated.</p>
<p><a href="#id17"><span class="problematic" id="id18">``</span></a><a href="#id19"><span class="problematic" id="id20">`</span></a>ts
type Message =</p>
<blockquote>
<div><div class="line-block">
<div class="line">{ __kind: ‘Quit’ } // Empty variant.</div>
<div class="line">{ __kind: ‘Write’; fields: [string] } // Tuple variant.</div>
<div class="line">{ __kind: ‘Move’; x: number; y: number }; // Struct variant.</div>
</div>
</div></blockquote>
<p><a href="#id21"><span class="problematic" id="id22">``</span></a><a href="#id23"><span class="problematic" id="id24">`</span></a></p>
<p>Then, on top of generating the types and <cite>getMessageSerializer</cite> function, it will also generate a <cite>message</cite> and <cite>isMessage</cite> function that can be used to create a new data enum and check the type of its variant respectively.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">message('Quit');</span> <span class="pre">//</span> <span class="pre">-&gt;</span> <span class="pre">{</span> <span class="pre">__kind:</span> <span class="pre">'Quit'</span> <span class="pre">}</span>
<span class="pre">message('Write',</span> <span class="pre">['Hi']);</span> <span class="pre">//</span> <span class="pre">-&gt;</span> <span class="pre">{</span> <span class="pre">__kind:</span> <span class="pre">'Write',</span> <span class="pre">fields:</span> <span class="pre">['Hi']</span> <span class="pre">}</span>
<span class="pre">message('Move',</span> <span class="pre">{</span> <span class="pre">x:</span> <span class="pre">5,</span> <span class="pre">y:</span> <span class="pre">6</span> <span class="pre">});</span> <span class="pre">//</span> <span class="pre">-&gt;</span> <span class="pre">{</span> <span class="pre">__kind:</span> <span class="pre">'Move',</span> <span class="pre">x:</span> <span class="pre">5,</span> <span class="pre">y:</span> <span class="pre">6</span> <span class="pre">}</span>
<span class="pre">isMessage('Quit',</span> <span class="pre">message('Quit'));</span> <span class="pre">//</span> <span class="pre">-&gt;</span> <span class="pre">true</span>
<span class="pre">isMessage('Write',</span> <span class="pre">message('Quit'));</span> <span class="pre">//</span> <span class="pre">-&gt;</span> <span class="pre">false</span>
<span class="pre">`</span></code></p>
<p>### Account helpers</p>
<p>Kinobi will also provide additional helper methods for accounts, providing us with an easy way to fetch and deserialize them. Assuming the account name is <cite>Metadata</cite> here are the additional helper methods available to you.</p>
<p><a href="#id25"><span class="problematic" id="id26">``</span></a><a href="#id27"><span class="problematic" id="id28">`</span></a>ts
// Deserialize a raw account into a parsed account.
deserializeMetadata(rawAccount); // -&gt; Metadata</p>
<p>// Fetch an deserialized account from its public key.
await fetchMetadata(umi, publicKey); // -&gt; Metadata or fail
await safeFetchMetadata(umi, publicKey); // -&gt; Metadata or null</p>
<p>// Fetch all deserialized accounts by public key.
await fetchAllMetadata(umi, publicKeys); // -&gt; Metadata[], fails if any account is missing
await safeFetchAllMetadata(umi, publicKeys) // -&gt; Metadata[], filters out missing accounts</p>
<p>// Create a getProgramAccount builder for the account.
await getMetadataGpaBuilder()</p>
<blockquote>
<div><p>.whereField(‘updateAuthority’, updateAuthority)
.selectField(‘mint’)
.getDataAsPublicKeys() // -&gt; PublicKey[]</p>
</div></blockquote>
<p>// Get the size of the account data in bytes, if it has a fixed size.
getMetadataSize() // -&gt; number</p>
<p>// Find the PDA address of the account from its seeds.
findMetadataPda(umi, seeds) // -&gt; Pda
<a href="#id29"><span class="problematic" id="id30">``</span></a><a href="#id31"><span class="problematic" id="id32">`</span></a></p>
<p>You may want to check the [documentation on <a href="#id33"><span class="problematic" id="id34">`</span></a>GpaBuilder`s](./helpers.md#gpabuilders) to learn more about what they can do.</p>
<p>### Transaction builders</p>
<p>Each generated instruction will also have its own function that can be used to create a transaction builder containing the instruction. For instance, if you have a <cite>Transfer</cite> instruction, it will generate a <cite>transfer</cite> function returning a <cite>TransactionBuilder</cite>.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">await</span> <span class="pre">transfer(umi,</span> <span class="pre">{</span> <span class="pre">from,</span> <span class="pre">to,</span> <span class="pre">amount</span> <span class="pre">}).sendAndConfirm();</span>
<span class="pre">`</span></code></p>
<p>Because transaction builders can be combined together, this allows us to easily create transactions that contain multiple instructions like so.</p>
<p><a href="#id35"><span class="problematic" id="id36">``</span></a><a href="#id37"><span class="problematic" id="id38">`</span></a>ts
await transfer(umi, { from, to: destinationA, amount })</p>
<blockquote>
<div><p>.add(transfer(umi, { from, to: destinationB, amount }))
.add(transfer(umi, { from, to: destinationC, amount }))
.sendAndConfirm();</p>
</div></blockquote>
<p><a href="#id39"><span class="problematic" id="id40">``</span></a><a href="#id41"><span class="problematic" id="id42">`</span></a></p>
<p>### Errors and programs</p>
<p>Kinobi will also generate a function that returns a <cite>Program</cite> type for each program defined in the client as well as some helpers to access them. For instance, say your client defines a <cite>MplTokenMetadata</cite> program, then the following helpers will be generated.</p>
<p><a href="#id43"><span class="problematic" id="id44">``</span></a><a href="#id45"><span class="problematic" id="id46">`</span></a>ts
// The program’s public key as a constant variable.
MPL_TOKEN_METADATA_PROGRAM_ID; // -&gt; PublicKey</p>
<p>// Create a program object that can be registered in the program repository.
createMplTokenMetadataProgram(); // -&gt; Program</p>
<p>// Get the program object from the program repository.
getMplTokenMetadataProgram(umi); // -&gt; Program</p>
<p>// Get the program’s public key from the program repository.
getMplTokenMetadataProgramId(umi); // -&gt; PublicKey
<a href="#id47"><span class="problematic" id="id48">``</span></a><a href="#id49"><span class="problematic" id="id50">`</span></a></p>
<p>Note that Kinobi does not auto-generate a Umi plugin for your client allowing you to customize it however you want. That means you’ll need to create a plugin yourself and, at the very least, register the programs defined by your client. Here’s an example using the <cite>MplTokenMetadata</cite> program.</p>
<p><a href="#id51"><span class="problematic" id="id52">``</span></a><a href="#id53"><span class="problematic" id="id54">`</span></a>ts
export const mplTokenMetadata = (): UmiPlugin =&gt; ({</p>
<blockquote>
<div><dl class="simple">
<dt>install(umi) {</dt><dd><p>umi.programs.add(createMplTokenMetadataProgram(), false);</p>
</dd>
</dl>
<p>},</p>
</div></blockquote>
<section id="id55">
<h2>});<a class="headerlink" href="#id55" title="Permalink to this heading">¶</a></h2>
<p>Additionally, each program generates a custom <cite>ProgramError</cite> for each error it may throw. For instance, if your program defines a <cite>UpdateAuthorityIncorrect</cite> error, it will generate the following class.</p>
<p><a href="#id56"><span class="problematic" id="id57">``</span></a><a href="#id58"><span class="problematic" id="id59">`</span></a>ts
export class UpdateAuthorityIncorrectError extends ProgramError {</p>
<blockquote>
<div><p>readonly name: string = ‘UpdateAuthorityIncorrect’;</p>
<p>readonly code: number = 0x7; // 7</p>
<dl class="simple">
<dt>constructor(program: Program, cause?: Error) {</dt><dd><p>super(‘Update Authority given does not match’, program, cause);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</section>
<section id="id60">
<h2>}<a class="headerlink" href="#id60" title="Permalink to this heading">¶</a></h2>
<p>Each generated error is also registered in a <cite>codeToErrorMap</cite> and a <cite>nameToErrorMap</cite> allowing the library to provide two helper methods that can find any error class from its name or code.</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">getMplTokenMetadataErrorFromCode(0x7,</span> <span class="pre">program);</span> <span class="pre">//</span> <span class="pre">-&gt;</span> <span class="pre">UpdateAuthorityIncorrectError</span>
<span class="pre">getMplTokenMetadataErrorFromName('UpdateAuthorityIncorrect',</span> <span class="pre">program);</span> <span class="pre">//</span> <span class="pre">-&gt;</span> <span class="pre">UpdateAuthorityIncorrectError</span>
<span class="pre">`</span></code></p>
<p>Note that these methods are used by the <cite>createMplTokenMetadataProgram</cite> function to fill the <cite>getErrorFromCode</cite> and <cite>getErrorFromName</cite> functions of the <cite>Program</cite> object.</p>
<p>&lt;p align=”center”&gt;
&lt;strong&gt;Next: &lt;a href=”./helpers.md”&gt;Umi helpers ≫&lt;/a&gt;&lt;/strong&gt;
&lt;/p&gt;</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/kinobi.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>