<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>docs/guide.md &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=039e1c02" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=b3ba4146"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="docs-guide-md">
<h1>docs/guide.md<a class="headerlink" href="#docs-guide-md" title="Permalink to this heading">¶</a></h1>
<p>Last edited: 2020-08-13 15:30:25</p>
<p>Contents:</p>
<div class="highlight-md notranslate"><div class="highlight"><pre><span></span><span class="gh"># Getting Started</span>
</pre></div>
</div>
<ul class="simple">
<li><p>[Getting Started](#getting-started)
- [Installing Superstruct](#installing-superstruct)
- [Creating Structs](#creating-structs)
- [Making Values Optional](#making-values-optional)
- [Setting Default Values](#setting-default-values)
- [Defining Custom Data Types](#defining-custom-data-types)
- [Throwing Customized Errors](#throwing-customized-errors)
- [Validating Complex Shapes](#validating-complex-shapes)
- [Composing Structs](#composing-structs)
- [Refining Types](#refining-types)
- [Coercing Values](#coercing-values)
- [Using TypeScript](#using-typescript)</p></li>
</ul>
<p>## Installing Superstruct</p>
<p>To install Superstruct with Yarn or Npm, simply:</p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">yarn</span> <span class="pre">add</span> <span class="pre">superstruct</span>
<span class="pre">`</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">`bash</span>
<span class="pre">npm</span> <span class="pre">install</span> <span class="pre">--save</span> <span class="pre">superstruct</span>
<span class="pre">`</span></code></p>
<p>And then you can import it into your code base:</p>
<p><code class="docutils literal notranslate"><span class="pre">`ts</span>
<span class="pre">import</span> <span class="pre">{</span> <span class="pre">assert</span> <span class="pre">}</span> <span class="pre">from</span> <span class="pre">'superstruct'</span>
<span class="pre">`</span></code></p>
<p>Superstruct has many importable methods. To reduce the friction of importing many methods you can use a wildcard. The methods are then accessed from one object.</p>
<p><a href="#id1"><span class="problematic" id="id2">``</span></a><a href="#id3"><span class="problematic" id="id4">`</span></a>ts
import * as s from ‘superstruct’</p>
<dl class="simple">
<dt>const User = s.object({</dt><dd><p>id: s.number(),
name: s.string(),</p>
</dd>
</dl>
<section id="id5">
<h2>})<a class="headerlink" href="#id5" title="Permalink to this heading">¶</a></h2>
<p>If you would rather import Superstruct with a <cite>&lt;script&gt;</cite> tag, you can use the bundled build:</p>
<p><code class="docutils literal notranslate"><span class="pre">`html</span>
<span class="pre">&lt;script</span> <span class="pre">src=&quot;https://unpkg.com/superstruct/umd/superstruct.min.js&quot;&gt;&lt;/script&gt;</span>
<span class="pre">`</span></code></p>
<p>This will expose the <cite>Superstruct</cite> global with the exported functions.</p>
<p>## Creating Structs</p>
<p>Once you’ve got Superstruct installed, the next step is to create a struct for some data you want validate. In our case, lets start with data describing a user:</p>
<p><a href="#id6"><span class="problematic" id="id7">``</span></a><a href="#id8"><span class="problematic" id="id9">`</span></a>ts
const data = {</p>
<blockquote>
<div><p>id: 42,
name: ‘Jane Smith’,
email: <a class="reference external" href="mailto:'jane&#37;&#52;&#48;example&#46;com">‘jane<span>&#64;</span>example<span>&#46;</span>com</a>’,</p>
</div></blockquote>
</section>
<section id="id10">
<h2>}<a class="headerlink" href="#id10" title="Permalink to this heading">¶</a></h2>
<p>We’ll import Superstruct and create a struct with it:</p>
<p><a href="#id11"><span class="problematic" id="id12">``</span></a><a href="#id13"><span class="problematic" id="id14">`</span></a>ts
import { object, number, string } from ‘superstruct’</p>
<dl class="simple">
<dt>const User = object({</dt><dd><p>id: number(),
name: string(),
email: string(),</p>
</dd>
</dl>
</section>
<section id="id15">
<h2>})<a class="headerlink" href="#id15" title="Permalink to this heading">¶</a></h2>
<p>Now we can use our <cite>User</cite> struct to validate the data. The easiest way to do this is to use the <cite>assert</cite> helper, like so:</p>
<p><a href="#id16"><span class="problematic" id="id17">``</span></a><a href="#id18"><span class="problematic" id="id19">`</span></a>ts
import { assert } from ‘superstruct’</p>
<p>assert(data, User)
<a href="#id20"><span class="problematic" id="id21">``</span></a><a href="#id22"><span class="problematic" id="id23">`</span></a></p>
<p>This will throw an error if the data is invalid. In this case, the data is valid, so no error is thrown.</p>
<p>But what if we pass it an invalid user object, where the name is not a string:</p>
<p><a href="#id24"><span class="problematic" id="id25">``</span></a><a href="#id26"><span class="problematic" id="id27">`</span></a>ts
const data = {</p>
<blockquote>
<div><p>id: 43,
name: false,
email: <a class="reference external" href="mailto:'jane&#37;&#52;&#48;example&#46;com">‘jane<span>&#64;</span>example<span>&#46;</span>com</a>’,</p>
</div></blockquote>
<p>}</p>
<p>assert(data, User)</p>
<p>// StructError: ‘Expected a value of type “string” for <cite>name</cite> but received <cite>false</cite>.’ {
//   type: ‘string’,
//   value: false,
//   branch: [{ … }, false],
//   path: [‘name’],
//   failures: […],
// }
<a href="#id28"><span class="problematic" id="id29">``</span></a><a href="#id30"><span class="problematic" id="id31">`</span></a></p>
<p>An error was thrown! That’s what we expected.</p>
<p>If you’d rather have the error returned instead of thrown, you can use the <cite>validate</cite> helper. Or, if you’d just like receive a boolean of whether the data is valid or not, use the <cite>is</cite> helper.</p>
<p>&gt; 🤖 Check out the [Validation reference](<a class="reference external" href="https://superstructjs.org/interfaces/struct">https://superstructjs.org/interfaces/struct</a>) for more information.</p>
<p>## Making Values Optional</p>
<p>What about when you have a property like <cite>is_admin</cite> that only appears on a few special users? In that case you can make certain properties optional, like so:</p>
<p><a href="#id32"><span class="problematic" id="id33">``</span></a><a href="#id34"><span class="problematic" id="id35">`</span></a>ts
import { optional } from ‘superstruct’</p>
<dl class="simple">
<dt>const User = object({</dt><dd><p>id: number(),
name: string(),
email: string(),
is_admin: optional(boolean()),</p>
</dd>
</dl>
</section>
<section id="id36">
<h2>})<a class="headerlink" href="#id36" title="Permalink to this heading">¶</a></h2>
<p>Wrapping a struct in <cite>optional</cite> means that the value can also be <cite>undefined</cite> and it will still be considered valid.</p>
<p>So now both of these pieces of data would be valid:</p>
<p><a href="#id37"><span class="problematic" id="id38">``</span></a><a href="#id39"><span class="problematic" id="id40">`</span></a>ts
const jane = {</p>
<blockquote>
<div><p>id: 43,
name: ‘Jane Smith’,
email: <a class="reference external" href="mailto:'jane&#37;&#52;&#48;example&#46;com">‘jane<span>&#64;</span>example<span>&#46;</span>com</a>’,
is_admin: true,</p>
</div></blockquote>
<p>})</p>
<dl class="simple">
<dt>const jack = {</dt><dd><p>id: 44,
name: ‘Jack Smith’,
email: <a class="reference external" href="mailto:'jack&#37;&#52;&#48;example&#46;com">‘jack<span>&#64;</span>example<span>&#46;</span>com</a>’,</p>
</dd>
</dl>
</section>
<section id="id41">
<h2>})<a class="headerlink" href="#id41" title="Permalink to this heading">¶</a></h2>
<p>## Setting Default Values</p>
<p>In the case of optional values, you might also want to define a default value for a property if the input is <cite>undefined</cite>. This is helpful for data consistency. For example, you can make the new <cite>is_admin</cite> property default to <cite>false</cite>.</p>
<p>To allow for these use cases, Superstruct has a concept called “coercion”, which allows you to encode specific logic about how to transform a piece of data before validating it.</p>
<p>To apply default values, you can use the <cite>defaulted</cite> coercion:</p>
<p><a href="#id42"><span class="problematic" id="id43">``</span></a><a href="#id44"><span class="problematic" id="id45">`</span></a>ts
import { defaulted } from ‘superstruct’</p>
<dl>
<dt>const User = defaulted(</dt><dd><dl class="simple">
<dt>object({</dt><dd><p>id: number(),
name: string(),
email: string(),
is_admin: optional(boolean()),</p>
</dd>
</dl>
<p>}),
{</p>
<blockquote>
<div><p>is_admin: false,</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</section>
<section id="id46">
<h2>)<a class="headerlink" href="#id46" title="Permalink to this heading">¶</a></h2>
<p>To receive the data with the defaults applied, you’ll need to use <cite>coerce</cite> to retrieve the coerced value:</p>
<p><a href="#id47"><span class="problematic" id="id48">``</span></a><a href="#id49"><span class="problematic" id="id50">`</span></a>ts
import { coerce } from ‘superstruct’</p>
<dl class="simple">
<dt>const data = {</dt><dd><p>id: 43,
name: ‘Jane Smith’,
email: <a class="reference external" href="mailto:'jane&#37;&#52;&#48;example&#46;com">‘jane<span>&#64;</span>example<span>&#46;</span>com</a>’,</p>
</dd>
</dl>
<p>}</p>
<p>const user = coerce(data, User)
// {
//   id: ‘43’,
//   name: ‘Jane Smith’,
//   email: <a class="reference external" href="mailto:'jane&#37;&#52;&#48;example&#46;com">‘jane<span>&#64;</span>example<span>&#46;</span>com</a>’,
//   is_admin: false,
// }
<a href="#id51"><span class="problematic" id="id52">``</span></a><a href="#id53"><span class="problematic" id="id54">`</span></a></p>
<p>The original <cite>data</cite> did not define an <cite>is_admin</cite> property, but after running the struct’s coercion logic the default was applied. If the value had been invalid, an error would have been thrown.</p>
<p>## Defining Custom Data Types</p>
<p>Next up, you might have been wondering about the <cite>email</cite> property. So far we’ve just defined it as a string, which means that any old string will pass validation.</p>
<p>But we’d really like to validate that the email is a valid email address.</p>
<p>To define custom data types, we can use the [<cite>struct</cite>](<a class="reference external" href="https://superstructjs.org/interfaces/superstruct">https://superstructjs.org/interfaces/superstruct</a>) factory…</p>
<p><a href="#id55"><span class="problematic" id="id56">``</span></a><a href="#id57"><span class="problematic" id="id58">`</span></a>ts
import { struct } from ‘superstruct’
import isEmail from ‘is-email’</p>
<p>const Email = struct(‘Email’, (value) =&gt; isEmail(value))
<a href="#id59"><span class="problematic" id="id60">``</span></a><a href="#id61"><span class="problematic" id="id62">`</span></a></p>
<p>Now we can define structs know about the <cite>‘email’</cite> type:</p>
<p><a href="#id63"><span class="problematic" id="id64">``</span></a><a href="#id65"><span class="problematic" id="id66">`</span></a>ts
const User = object({</p>
<blockquote>
<div><p>id: number(),
name: string(),
email: email(),
is_admin: optional(boolean()),</p>
</div></blockquote>
</section>
<section id="id67">
<h2>})<a class="headerlink" href="#id67" title="Permalink to this heading">¶</a></h2>
<p>Now if you pass in an email string that is invalid, it will throw:</p>
<p><a href="#id68"><span class="problematic" id="id69">``</span></a><a href="#id70"><span class="problematic" id="id71">`</span></a>ts
const data = {</p>
<blockquote>
<div><p>id: 43,
name: ‘Jane Smith’,
email: ‘jane’,</p>
</div></blockquote>
<p>}</p>
<p>assert(data, User)
// StructError: ‘Expected a value of type “Email” for <cite>email</cite> but received <cite>‘jane’</cite>.’ {
//   type: ‘email’,
//   value: ‘jane’,
//   path: [‘email’],
//   branch: [{…}, ‘jane’],
//   failures: […]
// }
<a href="#id72"><span class="problematic" id="id73">``</span></a><a href="#id74"><span class="problematic" id="id75">`</span></a></p>
<p>And there you have it!</p>
<p>&gt; 🤖 For the full list of built-in data types, check out the [Types reference](<a class="reference external" href="https://superstructjs.org/#types">https://superstructjs.org/#types</a>).</p>
<p>## Throwing Customized Errors</p>
<p>Finally, although the errors Superstruct throws are very descriptive, and developer readable, they’re not really domain-specific. If you’re building a REST or GraphQL API, you probably want to customize your errors to be specific to your application, and to follow a spec.</p>
<p>Doing that with Superstruct is easy. Just <cite>try/catch</cite> the errors like usual, and then use the exposed information to build your own errors.</p>
<p>For example, lets throw a <cite>‘user_email_invalid’</cite> error using the <cite>User</cite> struct from above…</p>
<p><a href="#id76"><span class="problematic" id="id77">``</span></a><a href="#id78"><span class="problematic" id="id79">`</span></a>ts
router.post(‘/users’, ({ request, response }) =&gt; {</p>
<blockquote>
<div><p>const data = request.body</p>
<dl>
<dt>try {</dt><dd><p>assert(data, User)</p>
</dd>
<dt>} catch (e) {</dt><dd><p>const { path, value, type } = e
const key = path[0]</p>
<dl class="simple">
<dt>if (value === undefined) {</dt><dd><p>const error = new Error(<cite>user_${key}_required</cite>)
error.attribute = key
throw error</p>
</dd>
<dt>} else if (type === ‘never’) {</dt><dd><p>const error = new Error(<cite>user_attribute_unknown</cite>)
error.attribute = key
throw error</p>
</dd>
<dt>} else {</dt><dd><p>const error = new Error(<cite>user_${key}_invalid</cite>)
error.attribute = key
error.value = value
throw error</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</section>
<section id="id80">
<h2>})<a class="headerlink" href="#id80" title="Permalink to this heading">¶</a></h2>
<p>Now all of your user validation errors are standardized, so you end up with errors with codes like:</p>
<p><a href="#id81"><span class="problematic" id="id82">``</span></a>`
user_email_invalid
user_email_required
user_email_unknown</p>
<p>user_name_invalid
user_name_required
…
<a href="#id83"><span class="problematic" id="id84">``</span></a><a href="#id85"><span class="problematic" id="id86">`</span></a></p>
<p>Although this example is simplified, the struct errors expose all of the possible information about why the validation failed, so you can use them to construct extremely detailed errors for your end users.</p>
<p>&gt; To see all of the information embedded in <cite>StructError</cite> objects, check out the [<cite>StructError</cite> reference](<a class="reference external" href="https://superstructjs.org/classes/structerror">https://superstructjs.org/classes/structerror</a>).</p>
<p>## Validating Complex Shapes</p>
<p>In the most common uses, you’ll be modeling your data using <cite>object</cite> structs at the top level. However, there are more structures of data you might like to validate that simple objects with key/values.</p>
<p>Superstruct makes it easy to validate things like tuples, enums, dictionaries, lists, unions, literals, etc.</p>
<p>For example, say you wanted to validate coordinate tuples:</p>
<p><a href="#id87"><span class="problematic" id="id88">``</span></a><a href="#id89"><span class="problematic" id="id90">`</span></a>ts
import { tuple } from ‘superstruct’</p>
<p>const Coordinates = tuple([number(), number()])
const data = [0, 3]
assert(data, Coordinates)
<a href="#id91"><span class="problematic" id="id92">``</span></a><a href="#id93"><span class="problematic" id="id94">`</span></a></p>
<p>Or, you might want to validate that one of the properties of your user objects is an enum of a particular set of values:</p>
<p><a href="#id95"><span class="problematic" id="id96">``</span></a><a href="#id97"><span class="problematic" id="id98">`</span></a>ts
import { enums } from ‘superstruct’</p>
<dl class="simple">
<dt>const User = object({</dt><dd><p>id: number(),
name: string(),
role: enums([‘collaborator’, ‘owner’, ‘admin’]),</p>
</dd>
</dl>
</section>
<section id="id99">
<h2>})<a class="headerlink" href="#id99" title="Permalink to this heading">¶</a></h2>
<p>All of this can be achieved using the helpers that ship with Superstruct by default.</p>
<p>&gt; 🤖 For a full list of the kinds of structs you can create, check out the [Superstruct reference](<a class="reference external" href="https://superstructjs.org/interfaces/superstruct">https://superstructjs.org/interfaces/superstruct</a>).</p>
<p>## Composing Structs</p>
<p>Sometimes you want to break validations down into components, and compose them together to validate more complex objects. Superstruct makes this easy by allowing an existing struct to be passed in as a schema. For example:</p>
<p><a href="#id100"><span class="problematic" id="id101">``</span></a><a href="#id102"><span class="problematic" id="id103">`</span></a>ts
const User = struct({</p>
<blockquote>
<div><p>id: number(),
name: string(),</p>
</div></blockquote>
<p>})</p>
<dl class="simple">
<dt>const Article = struct({</dt><dd><p>id: number(),
title: string(),
author: User,</p>
</dd>
</dl>
</section>
<section id="id104">
<h2>})<a class="headerlink" href="#id104" title="Permalink to this heading">¶</a></h2>
<p>## Refining Types</p>
<p>There are some cases where you want to create a validation that is more fine-grained than a “type”. For example, you might want not just a <cite>string</cite>, but a specific format of string. Or not just a <cite>User</cite>, but a user that is also an administrator.</p>
<p>For these situations, you can use refinements. They allow you to create a new struct that is derived from an exsisting struct with an extra bit of validation layered on top.</p>
<p>For example, for a specific kind of string:</p>
<p><a href="#id105"><span class="problematic" id="id106">``</span></a><a href="#id107"><span class="problematic" id="id108">`</span></a>ts
import { refinement } from ‘superstruct’</p>
<dl class="simple">
<dt>const MyString = refinement(string(), value =&gt; {</dt><dd><p>return value.startsWith(‘The’) &amp;&amp; value.length &gt; 20)</p>
</dd>
</dl>
</section>
<section id="id109">
<h2>})<a class="headerlink" href="#id109" title="Permalink to this heading">¶</a></h2>
<p>Now the <cite>MyString</cite> will only validate strings that begin with “The” and are longer than 20 characters.</p>
<p>## Coercing Values</p>
<p>We’ve already covered default values, but sometimes you’ll need to create coercions that aren’t just defaulted <cite>undefined</cite> values, but instead transforming the input data from one format to another.</p>
<p>For example, maybe you want to ensure that any string is trimmed before passing it into the validator:</p>
<p><a href="#id110"><span class="problematic" id="id111">``</span></a><a href="#id112"><span class="problematic" id="id113">`</span></a>ts
import { coercion } from ‘superstruct’</p>
<dl class="simple">
<dt>const TrimmedString = coercion(string, (value) =&gt; {</dt><dd><p>return typeof value === ‘string’ ? value.trim() : value</p>
</dd>
</dl>
</section>
<section id="id114">
<h2>})<a class="headerlink" href="#id114" title="Permalink to this heading">¶</a></h2>
<p>Now before using <cite>assert()</cite> or <cite>is()</cite> you can use <cite>coerce()</cite> to apply your custom coercion logic:</p>
<p><a href="#id115"><span class="problematic" id="id116">``</span></a><a href="#id117"><span class="problematic" id="id118">`</span></a>ts
import { coerce } from ‘superstruct’</p>
<p>const data = ‘  a wEird str1ng        ‘
const output = coerce(data, TrimmedString)
// “a wEird str1ng”
<a href="#id119"><span class="problematic" id="id120">``</span></a><a href="#id121"><span class="problematic" id="id122">`</span></a></p>
<p>## Using TypeScript</p>
<p>Most of the time, TypeScript “just works” but knowing a little more will help you get the most out of TypeScript.</p>
<p>## Custom Data Types</p>
<p>When you define a custom type, it is returned as <cite>unknown</cite> by default. In order to get better typing, you can use a generic to specify the type.</p>
<p>The following defines a custom email type and adds a generic to declare the value is of type <cite>string</cite>.</p>
<p><a href="#id123"><span class="problematic" id="id124">``</span></a><a href="#id125"><span class="problematic" id="id126">`</span></a>ts
import { struct } from ‘superstruct’
import isEmail from ‘is-email’</p>
<p>const Email = struct&lt;string&gt;(‘Email’, (value) =&gt; isEmail(value))
<a href="#id127"><span class="problematic" id="id128">``</span></a><a href="#id129"><span class="problematic" id="id130">`</span></a></p>
<p>## Extracting a Type</p>
<p>If you have a struct definition, you can extract its type using the <cite>StructType</cite> utility.</p>
<p><a href="#id131"><span class="problematic" id="id132">``</span></a><a href="#id133"><span class="problematic" id="id134">`</span></a>ts
const User = object({</p>
<blockquote>
<div><p>id: number(),
name: string(),</p>
</div></blockquote>
<p>})</p>
<p>type User = StructType&lt;typeof User&gt;
// type User = {
//   id: number
//   name: string
// }
<a href="#id135"><span class="problematic" id="id136">``</span></a><a href="#id137"><span class="problematic" id="id138">`</span></a></p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/guide.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>