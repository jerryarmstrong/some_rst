<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.cr_mixer.candidate_generation</p>
<p>import com.twitter.contentrecommender.thriftscala.TweetInfo
import com.twitter.cr_mixer.model.CandidateGenerationInfo
import com.twitter.cr_mixer.model.GraphSourceInfo
import com.twitter.cr_mixer.model.InitialCandidate
import com.twitter.cr_mixer.model.ModelConfig
import com.twitter.cr_mixer.model.ModuleNames
import com.twitter.cr_mixer.model.SimilarityEngineInfo
import com.twitter.cr_mixer.model.SourceInfo
import com.twitter.cr_mixer.model.TripTweetWithScore
import com.twitter.cr_mixer.model.TweetWithCandidateGenerationInfo
import com.twitter.cr_mixer.model.TweetWithScore
import com.twitter.cr_mixer.model.TweetWithScoreAndSocialProof
import com.twitter.cr_mixer.param.ConsumerBasedWalsParams
import com.twitter.cr_mixer.param.ConsumerEmbeddingBasedCandidateGenerationParams
import com.twitter.cr_mixer.param.ConsumersBasedUserVideoGraphParams
import com.twitter.cr_mixer.param.GlobalParams
import com.twitter.cr_mixer.similarity_engine.ConsumersBasedUserVideoGraphSimilarityEngine
import com.twitter.cr_mixer.similarity_engine.ConsumerBasedWalsSimilarityEngine
import com.twitter.cr_mixer.similarity_engine.ConsumerEmbeddingBasedTripSimilarityEngine
import com.twitter.cr_mixer.similarity_engine.ConsumerEmbeddingBasedTwHINSimilarityEngine
import com.twitter.cr_mixer.similarity_engine.ConsumerEmbeddingBasedTwoTowerSimilarityEngine
import com.twitter.cr_mixer.similarity_engine.EngineQuery
import com.twitter.cr_mixer.similarity_engine.FilterUtil
import com.twitter.cr_mixer.similarity_engine.HnswANNEngineQuery
import com.twitter.cr_mixer.similarity_engine.HnswANNSimilarityEngine
import com.twitter.cr_mixer.similarity_engine.ProducerBasedUnifiedSimilarityEngine
import com.twitter.cr_mixer.similarity_engine.StandardSimilarityEngine
import com.twitter.cr_mixer.similarity_engine.TripEngineQuery
import com.twitter.cr_mixer.similarity_engine.TweetBasedUnifiedSimilarityEngine
import com.twitter.cr_mixer.similarity_engine.UserTweetEntityGraphSimilarityEngine
import com.twitter.cr_mixer.thriftscala.SimilarityEngineType
import com.twitter.cr_mixer.thriftscala.SourceType
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.simclusters_v2.common.TweetId
import com.twitter.simclusters_v2.common.UserId
import com.twitter.simclusters_v2.thriftscala.InternalId
import com.twitter.storehaus.ReadableStore
import com.twitter.timelines.configapi
import com.twitter.util.Future
import javax.inject.Inject
import javax.inject.Named
import javax.inject.Singleton</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Route the SourceInfo to the associated Candidate Engines.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
</dl>
<p>&#64;Singleton
case class CandidateSourcesRouter &#64;Inject() (</p>
<blockquote>
<div><p>customizedRetrievalCandidateGeneration: CustomizedRetrievalCandidateGeneration,
simClustersInterestedInCandidateGeneration: SimClustersInterestedInCandidateGeneration,
&#64;Named(ModuleNames.TweetBasedUnifiedSimilarityEngine)
tweetBasedUnifiedSimilarityEngine: StandardSimilarityEngine[</p>
<blockquote>
<div><p>TweetBasedUnifiedSimilarityEngine.Query,
TweetWithCandidateGenerationInfo</p>
</div></blockquote>
<p>],
&#64;Named(ModuleNames.ProducerBasedUnifiedSimilarityEngine)
producerBasedUnifiedSimilarityEngine: StandardSimilarityEngine[</p>
<blockquote>
<div><p>ProducerBasedUnifiedSimilarityEngine.Query,
TweetWithCandidateGenerationInfo</p>
</div></blockquote>
<p>],
&#64;Named(ModuleNames.ConsumerEmbeddingBasedTripSimilarityEngine)
consumerEmbeddingBasedTripSimilarityEngine: StandardSimilarityEngine[</p>
<blockquote>
<div><p>TripEngineQuery,
TripTweetWithScore</p>
</div></blockquote>
<p>],
&#64;Named(ModuleNames.ConsumerEmbeddingBasedTwHINANNSimilarityEngine)
consumerBasedTwHINANNSimilarityEngine: HnswANNSimilarityEngine,
&#64;Named(ModuleNames.ConsumerEmbeddingBasedTwoTowerANNSimilarityEngine)
consumerBasedTwoTowerSimilarityEngine: HnswANNSimilarityEngine,
&#64;Named(ModuleNames.ConsumersBasedUserVideoGraphSimilarityEngine)
consumersBasedUserVideoGraphSimilarityEngine: StandardSimilarityEngine[</p>
<blockquote>
<div><p>ConsumersBasedUserVideoGraphSimilarityEngine.Query,
TweetWithScore</p>
</div></blockquote>
<p>],
&#64;Named(ModuleNames.UserTweetEntityGraphSimilarityEngine) userTweetEntityGraphSimilarityEngine: StandardSimilarityEngine[</p>
<blockquote>
<div><p>UserTweetEntityGraphSimilarityEngine.Query,
TweetWithScoreAndSocialProof</p>
</div></blockquote>
<p>],
&#64;Named(ModuleNames.ConsumerBasedWalsSimilarityEngine)
consumerBasedWalsSimilarityEngine: StandardSimilarityEngine[</p>
<blockquote>
<div><p>ConsumerBasedWalsSimilarityEngine.Query,
TweetWithScore</p>
</div></blockquote>
<p>],
tweetInfoStore: ReadableStore[TweetId, TweetInfo],
globalStats: StatsReceiver,</p>
</div></blockquote>
<p>) {</p>
<blockquote>
<div><p>import CandidateSourcesRouter._
val stats: StatsReceiver = globalStats.scope(this.getClass.getSimpleName)</p>
<dl class="simple">
<dt>def fetchCandidates(</dt><dd><p>requestUserId: UserId,
sourceSignals: Set[SourceInfo],
sourceGraphs: Map[String, Option[GraphSourceInfo]],
params: configapi.Params,</p>
</dd>
</dl>
<p>): Future[Seq[Seq[InitialCandidate]]] = {</p>
<blockquote>
<div><dl>
<dt>val tweetBasedCandidatesFuture = getCandidates(</dt><dd><p>getTweetBasedSourceInfo(sourceSignals),
params,
TweetBasedUnifiedSimilarityEngine.fromParams,
tweetBasedUnifiedSimilarityEngine.getCandidates)</p>
</dd>
<dt>val producerBasedCandidatesFuture =</dt><dd><dl class="simple">
<dt>getCandidates(</dt><dd><p>getProducerBasedSourceInfo(sourceSignals),
params,
ProducerBasedUnifiedSimilarityEngine.fromParams(_, _),
producerBasedUnifiedSimilarityEngine.getCandidates</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val simClustersInterestedInBasedCandidatesFuture =</dt><dd><dl class="simple">
<dt>getCandidatesPerSimilarityEngineModel(</dt><dd><p>requestUserId,
params,
SimClustersInterestedInCandidateGeneration.fromParams,
simClustersInterestedInCandidateGeneration.get)</p>
</dd>
</dl>
</dd>
<dt>val consumerEmbeddingBasedLogFavBasedTripCandidatesFuture =</dt><dd><dl>
<dt>if (params(</dt><dd><blockquote>
<div><p>ConsumerEmbeddingBasedCandidateGenerationParams.EnableLogFavBasedSimClustersTripParam)) {</p>
</div></blockquote>
<dl>
<dt>getSimClustersTripCandidates(</dt><dd><p>params,
ConsumerEmbeddingBasedTripSimilarityEngine.fromParams(</p>
<blockquote>
<div><p>ModelConfig.ConsumerLogFavBasedInterestedInEmbedding,
InternalId.UserId(requestUserId),
params</p>
</div></blockquote>
<p>),
consumerEmbeddingBasedTripSimilarityEngine</p>
</dd>
<dt>).map {</dt><dd><p>Seq(_)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else</dt><dd><p>Future.Nil</p>
</dd>
</dl>
</dd>
<dt>val consumersBasedUvgRealGraphInCandidatesFuture =</dt><dd><dl>
<dt>if (params(ConsumersBasedUserVideoGraphParams.EnableSourceParam)) {</dt><dd><dl>
<dt>val realGraphInGraphSourceInfoOpt =</dt><dd><p>getGraphSourceInfoBySourceType(SourceType.RealGraphIn.name, sourceGraphs)</p>
</dd>
<dt>getGraphBasedCandidates(</dt><dd><p>params,
ConsumersBasedUserVideoGraphSimilarityEngine</p>
<blockquote>
<div><dl>
<dt>.fromParamsForRealGraphIn(</dt><dd><dl class="simple">
<dt>realGraphInGraphSourceInfoOpt</dt><dd><p>.map { graphSourceInfo =&gt; graphSourceInfo.seedWithScores }.getOrElse(Map.empty),</p>
</dd>
</dl>
<p>params),</p>
</dd>
</dl>
</div></blockquote>
<p>consumersBasedUserVideoGraphSimilarityEngine,
ConsumersBasedUserVideoGraphSimilarityEngine.toSimilarityEngineInfo,
realGraphInGraphSourceInfoOpt</p>
</dd>
<dt>).map {</dt><dd><p>Seq(_)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>} else Future.Nil</p>
</dd>
<dt>val consumerEmbeddingBasedFollowBasedTripCandidatesFuture =</dt><dd><dl>
<dt>if (params(</dt><dd><blockquote>
<div><p>ConsumerEmbeddingBasedCandidateGenerationParams.EnableFollowBasedSimClustersTripParam)) {</p>
</div></blockquote>
<dl>
<dt>getSimClustersTripCandidates(</dt><dd><p>params,
ConsumerEmbeddingBasedTripSimilarityEngine.fromParams(</p>
<blockquote>
<div><p>ModelConfig.ConsumerFollowBasedInterestedInEmbedding,
InternalId.UserId(requestUserId),
params</p>
</div></blockquote>
<p>),
consumerEmbeddingBasedTripSimilarityEngine</p>
</dd>
<dt>).map {</dt><dd><p>Seq(_)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else</dt><dd><p>Future.Nil</p>
</dd>
</dl>
</dd>
<dt>val consumerBasedWalsCandidatesFuture =</dt><dd><dl>
<dt>if (params(</dt><dd><blockquote>
<div><p>ConsumerBasedWalsParams.EnableSourceParam</p>
</div></blockquote>
<p>)) {
getConsumerBasedWalsCandidates(sourceSignals, params)</p>
</dd>
</dl>
<p>}.map { Seq(_) }
else Future.Nil</p>
</dd>
<dt>val consumerEmbeddingBasedTwHINCandidatesFuture =</dt><dd><dl>
<dt>if (params(ConsumerEmbeddingBasedCandidateGenerationParams.EnableTwHINParam)) {</dt><dd><dl>
<dt>getHnswCandidates(</dt><dd><p>params,
ConsumerEmbeddingBasedTwHINSimilarityEngine.fromParams(</p>
<blockquote>
<div><p>InternalId.UserId(requestUserId),
params),</p>
</div></blockquote>
<p>consumerBasedTwHINANNSimilarityEngine</p>
</dd>
</dl>
<p>).map { Seq(_) }</p>
</dd>
</dl>
<p>} else Future.Nil</p>
</dd>
<dt>val consumerEmbeddingBasedTwoTowerCandidatesFuture =</dt><dd><dl>
<dt>if (params(ConsumerEmbeddingBasedCandidateGenerationParams.EnableTwoTowerParam)) {</dt><dd><dl>
<dt>getHnswCandidates(</dt><dd><p>params,
ConsumerEmbeddingBasedTwoTowerSimilarityEngine.fromParams(</p>
<blockquote>
<div><p>InternalId.UserId(requestUserId),
params),</p>
</div></blockquote>
<p>consumerBasedTwoTowerSimilarityEngine</p>
</dd>
<dt>).map {</dt><dd><p>Seq(_)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>} else Future.Nil</p>
</dd>
<dt>val customizedRetrievalBasedCandidatesFuture =</dt><dd><dl class="simple">
<dt>getCandidatesPerSimilarityEngineModel(</dt><dd><p>requestUserId,
params,
CustomizedRetrievalCandidateGeneration.fromParams,
customizedRetrievalCandidateGeneration.get)</p>
</dd>
</dl>
</dd>
<dt>Future</dt><dd><dl>
<dt>.collect(</dt><dd><dl class="simple">
<dt>Seq(</dt><dd><p>tweetBasedCandidatesFuture,
producerBasedCandidatesFuture,
simClustersInterestedInBasedCandidatesFuture,
consumerBasedWalsCandidatesFuture,
consumerEmbeddingBasedLogFavBasedTripCandidatesFuture,
consumerEmbeddingBasedFollowBasedTripCandidatesFuture,
consumerEmbeddingBasedTwHINCandidatesFuture,
consumerEmbeddingBasedTwoTowerCandidatesFuture,
consumersBasedUvgRealGraphInCandidatesFuture,
customizedRetrievalBasedCandidatesFuture</p>
</dd>
</dl>
<p>)).map { candidatesList =&gt;
// remove empty innerSeq
val result = candidatesList.flatten.filter(_.nonEmpty)
stats.stat(“numOfSequences”).add(result.size)
stats.stat(“flattenCandidatesWithDup”).add(result.flatten.size)</p>
<p>result</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl>
<dt>private def getGraphBasedCandidates[QueryType](</dt><dd><p>params: configapi.Params,
query: EngineQuery[QueryType],
engine: StandardSimilarityEngine[QueryType, TweetWithScore],
toSimilarityEngineInfo: Double =&gt; SimilarityEngineInfo,
graphSourceInfoOpt: Option[GraphSourceInfo] = None</p>
</dd>
<dt>): Future[Seq[InitialCandidate]] = {</dt><dd><p>val candidatesOptFut = engine.getCandidates(query)
val tweetsWithCandidateGenerationInfoOptFut = candidatesOptFut.map {</p>
<blockquote>
<div><dl>
<dt>_.map { tweetsWithScores =&gt;</dt><dd><p>val sortedCandidates = tweetsWithScores.sortBy(-_.score)
engine.getScopedStats.stat(“sortedCandidates_size”).add(sortedCandidates.size)
val tweetsWithCandidateGenerationInfo = sortedCandidates.map { tweetWithScore =&gt;</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><p>val similarityEngineInfo = toSimilarityEngineInfo(tweetWithScore.score)
val sourceInfo = graphSourceInfoOpt.map { graphSourceInfo =&gt;</p>
<blockquote>
<div><p>// The internalId is a placeholder value. We do not plan to store the full seedUserId set.
SourceInfo(</p>
<blockquote>
<div><p>sourceType = graphSourceInfo.sourceType,
internalId = InternalId.UserId(0L),
sourceEventTime = None</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>}
TweetWithCandidateGenerationInfo(</p>
<blockquote>
<div><p>tweetWithScore.tweetId,
CandidateGenerationInfo(</p>
<blockquote>
<div><p>sourceInfo,
similarityEngineInfo,
Seq.empty // Atomic Similarity Engine. Hence it has no contributing SEs</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
val maxCandidateNum = params(GlobalParams.MaxCandidateNumPerSourceKeyParam)
tweetsWithCandidateGenerationInfo.take(maxCandidateNum)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
for {</p>
<blockquote>
<div><p>tweetsWithCandidateGenerationInfoOpt &lt;- tweetsWithCandidateGenerationInfoOptFut
initialCandidates &lt;- convertToInitialCandidates(</p>
<blockquote>
<div><p>tweetsWithCandidateGenerationInfoOpt.toSeq.flatten)</p>
</div></blockquote>
</div></blockquote>
<p>} yield initialCandidates</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getCandidates[QueryType](</dt><dd><p>sourceSignals: Set[SourceInfo],
params: configapi.Params,
fromParams: (SourceInfo, configapi.Params) =&gt; QueryType,
getFunc: QueryType =&gt; Future[Option[Seq[TweetWithCandidateGenerationInfo]]]</p>
</dd>
<dt>): Future[Seq[Seq[InitialCandidate]]] = {</dt><dd><dl class="simple">
<dt>val queries = sourceSignals.map { sourceInfo =&gt;</dt><dd><p>fromParams(sourceInfo, params)</p>
</dd>
</dl>
<p>}.toSeq</p>
<dl>
<dt>Future</dt><dd><dl>
<dt>.collect {</dt><dd><dl>
<dt>queries.map { query =&gt;</dt><dd><dl class="simple">
<dt>for {</dt><dd><p>candidates &lt;- getFunc(query)
prefilterCandidates &lt;- convertToInitialCandidates(candidates.toSeq.flatten)</p>
</dd>
<dt>} yield {</dt><dd><p>prefilterCandidates</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getConsumerBasedWalsCandidates(</dt><dd><p>sourceSignals: Set[SourceInfo],
params: configapi.Params</p>
</dd>
<dt>): Future[Seq[InitialCandidate]] = {</dt><dd><p>// Fetch source signals and filter them based on age.
val signals = FilterUtil.tweetSourceAgeFilter(</p>
<blockquote>
<div><p>getConsumerBasedWalsSourceInfo(sourceSignals).toSeq,
params(ConsumerBasedWalsParams.MaxTweetSignalAgeHoursParam))</p>
</div></blockquote>
<dl class="simple">
<dt>val candidatesOptFut = consumerBasedWalsSimilarityEngine.getCandidates(</dt><dd><p>ConsumerBasedWalsSimilarityEngine.fromParams(signals, params)</p>
</dd>
</dl>
<p>)
val tweetsWithCandidateGenerationInfoOptFut = candidatesOptFut.map {</p>
<blockquote>
<div><dl>
<dt>_.map { tweetsWithScores =&gt;</dt><dd><p>val sortedCandidates = tweetsWithScores.sortBy(-_.score)
val filteredCandidates =</p>
<blockquote>
<div><p>FilterUtil.tweetAgeFilter(sortedCandidates, params(GlobalParams.MaxTweetAgeHoursParam))</p>
</div></blockquote>
<dl>
<dt>consumerBasedWalsSimilarityEngine.getScopedStats</dt><dd><p>.stat(“filteredCandidates_size”).add(filteredCandidates.size)</p>
</dd>
<dt>val tweetsWithCandidateGenerationInfo = filteredCandidates.map { tweetWithScore =&gt;</dt><dd><dl>
<dt>{</dt><dd><dl>
<dt>val similarityEngineInfo =</dt><dd><p>ConsumerBasedWalsSimilarityEngine.toSimilarityEngineInfo(tweetWithScore.score)</p>
</dd>
<dt>TweetWithCandidateGenerationInfo(</dt><dd><p>tweetWithScore.tweetId,
CandidateGenerationInfo(</p>
<blockquote>
<div><p>None,
similarityEngineInfo,
Seq.empty // Atomic Similarity Engine. Hence it has no contributing SEs</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
val maxCandidateNum = params(GlobalParams.MaxCandidateNumPerSourceKeyParam)
tweetsWithCandidateGenerationInfo.take(maxCandidateNum)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
for {</p>
<blockquote>
<div><p>tweetsWithCandidateGenerationInfoOpt &lt;- tweetsWithCandidateGenerationInfoOptFut
initialCandidates &lt;- convertToInitialCandidates(</p>
<blockquote>
<div><p>tweetsWithCandidateGenerationInfoOpt.toSeq.flatten)</p>
</div></blockquote>
</div></blockquote>
<p>} yield initialCandidates</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getSimClustersTripCandidates(</dt><dd><p>params: configapi.Params,
query: TripEngineQuery,
engine: StandardSimilarityEngine[</p>
<blockquote>
<div><p>TripEngineQuery,
TripTweetWithScore</p>
</div></blockquote>
<p>],</p>
</dd>
<dt>): Future[Seq[InitialCandidate]] = {</dt><dd><dl>
<dt>val tweetsWithCandidatesGenerationInfoOptFut =</dt><dd><dl>
<dt>engine.getCandidates(EngineQuery(query, params)).map {</dt><dd><dl>
<dt>_.map {</dt><dd><dl>
<dt>_.map { tweetWithScore =&gt;</dt><dd><p>// define filters
TweetWithCandidateGenerationInfo(</p>
<blockquote>
<div><p>tweetWithScore.tweetId,
CandidateGenerationInfo(</p>
<blockquote>
<div><p>None,
SimilarityEngineInfo(</p>
<blockquote>
<div><p>SimilarityEngineType.ExploreTripOfflineSimClustersTweets,
None,
Some(tweetWithScore.score)),</p>
</div></blockquote>
<p>Seq.empty</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>for {</dt><dd><p>tweetsWithCandidateGenerationInfoOpt &lt;- tweetsWithCandidatesGenerationInfoOptFut
initialCandidates &lt;- convertToInitialCandidates(</p>
<blockquote>
<div><p>tweetsWithCandidateGenerationInfoOpt.toSeq.flatten)</p>
</div></blockquote>
</dd>
</dl>
<p>} yield initialCandidates</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getHnswCandidates(</dt><dd><p>params: configapi.Params,
query: HnswANNEngineQuery,
engine: HnswANNSimilarityEngine,</p>
</dd>
<dt>): Future[Seq[InitialCandidate]] = {</dt><dd><p>val candidatesOptFut = engine.getCandidates(query)
val tweetsWithCandidateGenerationInfoOptFut = candidatesOptFut.map {</p>
<blockquote>
<div><dl>
<dt>_.map { tweetsWithScores =&gt;</dt><dd><p>val sortedCandidates = tweetsWithScores.sortBy(-_.score)
val filteredCandidates =</p>
<blockquote>
<div><p>FilterUtil.tweetAgeFilter(sortedCandidates, params(GlobalParams.MaxTweetAgeHoursParam))</p>
</div></blockquote>
<p>engine.getScopedStats.stat(“filteredCandidates_size”).add(filteredCandidates.size)
val tweetsWithCandidateGenerationInfo = filteredCandidates.map { tweetWithScore =&gt;</p>
<blockquote>
<div><dl>
<dt>{</dt><dd><dl>
<dt>val similarityEngineInfo =</dt><dd><p>engine.toSimilarityEngineInfo(query, tweetWithScore.score)</p>
</dd>
<dt>TweetWithCandidateGenerationInfo(</dt><dd><p>tweetWithScore.tweetId,
CandidateGenerationInfo(</p>
<blockquote>
<div><p>None,
similarityEngineInfo,
Seq.empty // Atomic Similarity Engine. Hence it has no contributing SEs</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
val maxCandidateNum = params(GlobalParams.MaxCandidateNumPerSourceKeyParam)
tweetsWithCandidateGenerationInfo.take(maxCandidateNum)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
for {</p>
<blockquote>
<div><p>tweetsWithCandidateGenerationInfoOpt &lt;- tweetsWithCandidateGenerationInfoOptFut
initialCandidates &lt;- convertToInitialCandidates(</p>
<blockquote>
<div><p>tweetsWithCandidateGenerationInfoOpt.toSeq.flatten)</p>
</div></blockquote>
</div></blockquote>
<p>} yield initialCandidates</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns candidates from each similarity engine separately.</p></li>
<li><p>For 1 requestUserId, it will fetch results from each similarity engine e_i,</p></li>
<li><p>and returns Seq[Seq[TweetCandidate]].</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>private def getCandidatesPerSimilarityEngineModel[QueryType](</dt><dd><p>requestUserId: UserId,
params: configapi.Params,
fromParams: (InternalId, configapi.Params) =&gt; QueryType,
getFunc: QueryType =&gt; Future[</p>
<blockquote>
<div><p>Option[Seq[Seq[TweetWithCandidateGenerationInfo]]]</p>
</div></blockquote>
<p>]</p>
</dd>
<dt>): Future[Seq[Seq[InitialCandidate]]] = {</dt><dd><p>val query = fromParams(InternalId.UserId(requestUserId), params)
getFunc(query).flatMap { candidatesPerSimilarityEngineModelOpt =&gt;</p>
<blockquote>
<div><p>val candidatesPerSimilarityEngineModel = candidatesPerSimilarityEngineModelOpt.toSeq.flatten
Future.collect {</p>
<blockquote>
<div><p>candidatesPerSimilarityEngineModel.map(convertToInitialCandidates)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private[candidate_generation] def convertToInitialCandidates(</dt><dd><p>candidates: Seq[TweetWithCandidateGenerationInfo],</p>
</dd>
<dt>): Future[Seq[InitialCandidate]] = {</dt><dd><p>val tweetIds = candidates.map(_.tweetId).toSet
Future.collect(tweetInfoStore.multiGet(tweetIds)).map { tweetInfos =&gt;</p>
<blockquote>
<div><dl>
<dt>/<a href="#id5"><span class="problematic" id="id6">**</span></a><a href="#id7"><span class="problematic" id="id8">*</span></a></dt><dd><ul class="simple">
<li><p>If tweetInfo does not exist, we will filter out this tweet candidate.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>candidates.collect {</dt><dd><dl>
<dt>case candidate if tweetInfos.getOrElse(candidate.tweetId, None).isDefined =&gt;</dt><dd><dl class="simple">
<dt>val tweetInfo = tweetInfos(candidate.tweetId)</dt><dd><p>.getOrElse(throw new IllegalStateException(“Check previous line’s condition”))</p>
</dd>
<dt>InitialCandidate(</dt><dd><p>tweetId = candidate.tweetId,
tweetInfo = tweetInfo,
candidate.candidateGenerationInfo</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>object CandidateSourcesRouter {</dt><dd><dl class="simple">
<dt>def getGraphSourceInfoBySourceType(</dt><dd><p>sourceTypeStr: String,
sourceGraphs: Map[String, Option[GraphSourceInfo]]</p>
</dd>
<dt>): Option[GraphSourceInfo] = {</dt><dd><p>sourceGraphs.getOrElse(sourceTypeStr, None)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getTweetBasedSourceInfo(</dt><dd><p>sourceSignals: Set[SourceInfo]</p>
</dd>
<dt>): Set[SourceInfo] = {</dt><dd><dl>
<dt>sourceSignals.collect {</dt><dd><dl>
<dt>case sourceInfo</dt><dd><blockquote>
<div><p>if AllowedSourceTypesForTweetBasedUnifiedSE.contains(sourceInfo.sourceType.value) =&gt;</p>
</div></blockquote>
<p>sourceInfo</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getProducerBasedSourceInfo(</dt><dd><p>sourceSignals: Set[SourceInfo]</p>
</dd>
<dt>): Set[SourceInfo] = {</dt><dd><dl>
<dt>sourceSignals.collect {</dt><dd><dl>
<dt>case sourceInfo</dt><dd><blockquote>
<div><p>if AllowedSourceTypesForProducerBasedUnifiedSE.contains(sourceInfo.sourceType.value) =&gt;</p>
</div></blockquote>
<p>sourceInfo</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getConsumerBasedWalsSourceInfo(</dt><dd><p>sourceSignals: Set[SourceInfo]</p>
</dd>
<dt>): Set[SourceInfo] = {</dt><dd><dl>
<dt>sourceSignals.collect {</dt><dd><dl>
<dt>case sourceInfo</dt><dd><blockquote>
<div><p>if AllowedSourceTypesForConsumerBasedWalsSE.contains(sourceInfo.sourceType.value) =&gt;</p>
</div></blockquote>
<p>sourceInfo</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/<a href="#id11"><span class="problematic" id="id12">**</span></a><a href="#id13"><span class="problematic" id="id14">*</span></a></dt><dd><ul class="simple">
<li><p>Signal funneling should not exist in CG or even in any SimilarityEngine.</p></li>
<li><p>They will be in Router, or eventually, in CrCandidateGenerator.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>val AllowedSourceTypesForConsumerBasedWalsSE = Set(</dt><dd><p>SourceType.TweetFavorite.value,
SourceType.Retweet.value,
SourceType.TweetDontLike.value, //currently no-op
SourceType.TweetReport.value, //currently no-op
SourceType.AccountMute.value, //currently no-op
SourceType.AccountBlock.value //currently no-op</p>
</dd>
</dl>
<p>)
val AllowedSourceTypesForTweetBasedUnifiedSE = Set(</p>
<blockquote>
<div><p>SourceType.TweetFavorite.value,
SourceType.Retweet.value,
SourceType.OriginalTweet.value,
SourceType.Reply.value,
SourceType.TweetShare.value,
SourceType.NotificationClick.value,
SourceType.GoodTweetClick.value,
SourceType.VideoTweetQualityView.value,
SourceType.VideoTweetPlayback50.value,
SourceType.TweetAggregation.value,</p>
</div></blockquote>
<p>)
val AllowedSourceTypesForProducerBasedUnifiedSE = Set(</p>
<blockquote>
<div><p>SourceType.UserFollow.value,
SourceType.UserRepeatedProfileVisit.value,
SourceType.RealGraphOon.value,
SourceType.FollowRecommendation.value,
SourceType.UserTrafficAttributionProfileVisit.value,
SourceType.GoodProfileClick.value,
SourceType.ProducerAggregation.value,</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/cr-mixer/server/src/main/scala/com/twitter/cr_mixer/candidate_generation/CandidateSourcesRouter.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>