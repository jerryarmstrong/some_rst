<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>docs/tools/dump_ast_matchers.py &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="docs-tools-dump-ast-matchers-py">
<h1>docs/tools/dump_ast_matchers.py<a class="headerlink" href="#docs-tools-dump-ast-matchers-py" title="Permalink to this heading">¶</a></h1>
<p>Last edited: 2018-11-26 16:38:37</p>
<p>Contents:</p>
<div class="highlight-py notranslate"><div class="highlight"><pre><span></span><span class="ch">#!/usr/bin/env python</span>
</pre></div>
</div>
<p># A tool to parse ASTMatchers.h and update the documentation in
# ../LibASTMatchersReference.html automatically. Run from the
# directory in which this file is located to update the docs.</p>
<p>import collections
import re
import urllib2</p>
<p>MATCHERS_FILE = ‘../../include/clang/ASTMatchers/ASTMatchers.h’</p>
<p># Each matcher is documented in one row of the form:
#   result | name | argA
# The subsequent row contains the documentation and is hidden by default,
# becoming visible via javascript when the user clicks the matcher name.
TD_TEMPLATE=”””
&lt;tr&gt;&lt;td&gt;%(result)s&lt;/td&gt;&lt;td class=”name” onclick=”toggle(‘%(id)s’)”&gt;&lt;a name=”%(id)sAnchor”&gt;%(name)s&lt;/a&gt;&lt;/td&gt;&lt;td&gt;%(args)s&lt;/td&gt;&lt;/tr&gt;
&lt;tr&gt;&lt;td colspan=”4” class=”doc” id=”%(id)s”&gt;&lt;pre&gt;%(comment)s&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;
“””</p>
<p># We categorize the matchers into these three categories in the reference:
node_matchers = {}
narrowing_matchers = {}
traversal_matchers = {}</p>
<p># We output multiple rows per matcher if the matcher can be used on multiple
# node types. Thus, we need a new id per row to control the documentation
# pop-up. ids[name] keeps track of those ids.
ids = collections.defaultdict(int)</p>
<p># Cache for doxygen urls we have already verified.
doxygen_probes = {}</p>
<dl>
<dt>def esc(text):</dt><dd><p>“””Escape any html in the given text.”””
text = re.sub(r’&amp;’, ‘&amp;amp;’, text)
text = re.sub(r’&lt;’, ‘&amp;lt;’, text)
text = re.sub(r’&gt;’, ‘&amp;gt;’, text)
def link_if_exists(m):</p>
<blockquote>
<div><p>name = m.group(1)
url = ‘<a class="reference external" href="https://clang.llvm.org/doxygen/classclang_1_1%s.html">https://clang.llvm.org/doxygen/classclang_1_1%s.html</a>’ % name
if url not in doxygen_probes:</p>
<blockquote>
<div><dl class="simple">
<dt>try:</dt><dd><p>print ‘Probing %s…’ % url
urllib2.urlopen(url)
doxygen_probes[url] = True</p>
</dd>
<dt>except:</dt><dd><p>doxygen_probes[url] = False</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>if doxygen_probes[url]:</dt><dd><p>return r’Matcher&amp;lt;&lt;a href=”%s”&gt;%s&lt;/a&gt;&amp;gt;’ % (url, name)</p>
</dd>
<dt>else:</dt><dd><p>return m.group(0)</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>text = re.sub(</dt><dd><p>r’Matcher&amp;lt;([^*&amp;]+)&amp;gt;’, link_if_exists, text)</p>
</dd>
</dl>
<p>return text</p>
</dd>
<dt>def extract_result_types(comment):</dt><dd><p>“””Extracts a list of result types from the given comment.</p>
<blockquote>
<div><p>We allow annotations in the comment of the matcher to specify what
nodes a matcher can match on. Those comments have the form:</p>
<blockquote>
<div><p>Usable as: Any Matcher | (Matcher&lt;T1&gt;[, Matcher&lt;t2&gt;[, …]])</p>
</div></blockquote>
<p>Returns [‘*’] in case of ‘Any Matcher’, or [‘T1’, ‘T2’, …].
Returns the empty list if no ‘Usable as’ specification could be
parsed.</p>
</div></blockquote>
<p>“””
result_types = []
m = re.search(r’Usable as: Any Matcher[sn]*$’, comment, re.S)
if m:</p>
<blockquote>
<div><p>return [‘*’]</p>
</div></blockquote>
<dl>
<dt>while True:</dt><dd><p>m = re.match(r’^(.*)Matcher&lt;([^&gt;]+)&gt;s*,?[sn]*$’, comment, re.S)
if not m:</p>
<blockquote>
<div><dl class="simple">
<dt>if re.search(r’Usable as:s*$’, comment):</dt><dd><p>return result_types</p>
</dd>
<dt>else:</dt><dd><p>return None</p>
</dd>
</dl>
</div></blockquote>
<p>result_types += [m.group(2)]
comment = m.group(1)</p>
</dd>
</dl>
</dd>
<dt>def strip_doxygen(comment):</dt><dd><p>“””Returns the given comment without -escaped words.”””
# If there is only a doxygen keyword in the line, delete the whole line.
comment = re.sub(r’^\[^s]+n’, r’’, comment, flags=re.M)</p>
<p># If there is a doxygen see command, change the see prefix into “See also:”.
# FIXME: it would be better to turn this into a link to the target instead.
comment = re.sub(r’\see’, r’See also:’, comment)</p>
<p># Delete the doxygen command and the following whitespace.
comment = re.sub(r’\[^s]+s+’, r’’, comment)
return comment</p>
</dd>
<dt>def unify_arguments(args):</dt><dd><p>“””Gets rid of anything the user doesn’t care about in the argument list.”””
args = re.sub(r’internal::’, r’’, args)
args = re.sub(r’extern consts+(.*)&amp;’, r’1 ‘, args)
args = re.sub(r’&amp;’, r’ ‘, args)
args = re.sub(r’(^|s)Md?(s)’, r’1Matcher&lt;*&gt;2’, args)
return args</p>
</dd>
<dt>def add_matcher(result_type, name, args, comment, is_dyncast=False):</dt><dd><p>“””Adds a matcher to one of our categories.”””
if name == ‘id’:</p>
<blockquote>
<div><p># FIXME: Figure out whether we want to support the ‘id’ matcher.
return</p>
</div></blockquote>
<p>matcher_id = ‘%s%d’ % (name, ids[name])
ids[name] += 1
args = unify_arguments(args)
matcher_html = TD_TEMPLATE % {</p>
<blockquote>
<div><p>‘result’: esc(‘Matcher&lt;%s&gt;’ % result_type),
‘name’: name,
‘args’: esc(args),
‘comment’: esc(strip_doxygen(comment)),
‘id’: matcher_id,</p>
</div></blockquote>
<p>}
if is_dyncast:</p>
<blockquote>
<div><p>node_matchers[result_type + name] = matcher_html</p>
</div></blockquote>
<p># Use a heuristic to figure out whether a matcher is a narrowing or
# traversal matcher. By default, matchers that take other matchers as
# arguments (and are not node matchers) do traversal. We specifically
# exclude known narrowing matchers that also take other matchers as
# arguments.
elif (‘Matcher&lt;’ not in args or</p>
<blockquote>
<div><blockquote>
<div><p>name in [‘allOf’, ‘anyOf’, ‘anything’, ‘unless’]):</p>
</div></blockquote>
<p>narrowing_matchers[result_type + name + esc(args)] = matcher_html</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>traversal_matchers[result_type + name + esc(args)] = matcher_html</p>
</dd>
</dl>
</dd>
<dt>def act_on_decl(declaration, comment, allowed_types):</dt><dd><p>“””Parse the matcher out of the given declaration and comment.</p>
<blockquote>
<div><p>If ‘allowed_types’ is set, it contains a list of node types the matcher
can match on, as extracted from the static type asserts in the matcher
definition.</p>
</div></blockquote>
<p>“””
if declaration.strip():</p>
<blockquote>
<div><p># Node matchers are defined by writing:
#   VariadicDynCastAllOfMatcher&lt;ResultType, ArgumentType&gt; name;
m = re.match(r”””.*Variadic(?:DynCast)?AllOfMatchers*&lt;</p>
<blockquote>
<div><p>s*([^s,]+)s*(?:,
s*([^s&gt;]+)s*)?&gt;
s*([^s;]+)s*;s*$”””, declaration, flags=re.X)</p>
</div></blockquote>
<dl>
<dt>if m:</dt><dd><p>result, inner, name = m.groups()
if not inner:</p>
<blockquote>
<div><p>inner = result</p>
</div></blockquote>
<dl class="simple">
<dt>add_matcher(result, name, ‘Matcher&lt;%s&gt;…’ % inner,</dt><dd><p>comment, is_dyncast=True)</p>
</dd>
</dl>
<p>return</p>
</dd>
</dl>
<p># Special case of type matchers:
#   AstTypeMatcher&lt;ArgumentType&gt; name
m = re.match(r”””.*AstTypeMatchers*&lt;</p>
<blockquote>
<div><p>s*([^s&gt;]+)s*&gt;
s*([^s;]+)s*;s*$”””, declaration, flags=re.X)</p>
</div></blockquote>
<dl>
<dt>if m:</dt><dd><p>inner, name = m.groups()
add_matcher(‘Type’, name, ‘Matcher&lt;%s&gt;…’ % inner,</p>
<blockquote>
<div><p>comment, is_dyncast=True)</p>
</div></blockquote>
<p># FIXME: re-enable once we have implemented casting on the TypeLoc
# hierarchy.
# add_matcher(‘TypeLoc’, ‘%sLoc’ % name, ‘Matcher&lt;%sLoc&gt;…’ % inner,
#             comment, is_dyncast=True)
return</p>
</dd>
</dl>
<p># Parse the various matcher definition macros.
m = re.match(“””.*AST_TYPE(LOC)?_TRAVERSE_MATCHER(?:_DECL)?(</p>
<blockquote>
<div><blockquote>
<div><p>s*([^s,]+s*),
s*(?:[^s,]+s*),
s*AST_POLYMORPHIC_SUPPORTED_TYPES(([^)]*))</p>
</div></blockquote>
<p>)s*;s*$”””, declaration, flags=re.X)</p>
</div></blockquote>
<dl>
<dt>if m:</dt><dd><p>loc, name, results = m.groups()[0:3]
result_types = [r.strip() for r in results.split(‘,’)]</p>
<p>comment_result_types = extract_result_types(comment)
if (comment_result_types and</p>
<blockquote>
<div><blockquote>
<div><p>sorted(result_types) != sorted(comment_result_types)):</p>
</div></blockquote>
<p>raise Exception(‘Inconsistent documentation for: %s’ % name)</p>
</div></blockquote>
<dl class="simple">
<dt>for result_type in result_types:</dt><dd><p>add_matcher(result_type, name, ‘Matcher&lt;Type&gt;’, comment)
# if loc:
#   add_matcher(‘%sLoc’ % result_type, ‘%sLoc’ % name, ‘Matcher&lt;TypeLoc&gt;’,
#               comment)</p>
</dd>
</dl>
<p>return</p>
</dd>
<dt>m = re.match(r”””^s*AST_POLYMORPHIC_MATCHER(_P)?(.?)(?:_OVERLOAD)?(</dt><dd><blockquote>
<div><blockquote>
<div><p>s*([^s,]+)s*,
s*AST_POLYMORPHIC_SUPPORTED_TYPES(([^)]*))</p>
</div></blockquote>
<dl class="simple">
<dt>(?:,s*([^s,]+)s*</dt><dd><p>,s*([^s,]+)s*)?</p>
</dd>
<dt>(?:,s*([^s,]+)s*</dt><dd><p>,s*([^s,]+)s*)?</p>
</dd>
</dl>
<p>(?:,s*d+s*)?</p>
</div></blockquote>
<p>)s*{s*$”””, declaration, flags=re.X)</p>
</dd>
<dt>if m:</dt><dd><p>p, n, name, results = m.groups()[0:4]
args = m.groups()[4:]
result_types = [r.strip() for r in results.split(‘,’)]
if allowed_types and allowed_types != result_types:</p>
<blockquote>
<div><p>raise Exception(‘Inconsistent documentation for: %s’ % name)</p>
</div></blockquote>
<dl class="simple">
<dt>if n not in [‘’, ‘2’]:</dt><dd><p>raise Exception(‘Cannot parse “%s”’ % declaration)</p>
</dd>
<dt>args = ‘, ‘.join(‘%s %s’ % (args[i], args[i+1])</dt><dd><p>for i in range(0, len(args), 2) if args[i])</p>
</dd>
<dt>for result_type in result_types:</dt><dd><p>add_matcher(result_type, name, args, comment)</p>
</dd>
</dl>
<p>return</p>
</dd>
<dt>m = re.match(r”””^s*AST_MATCHER_FUNCTION(_P)?(.?)(?:_OVERLOAD)?(</dt><dd><blockquote>
<div><dl class="simple">
<dt>(?:s*([^s,]+)s*,)?</dt><dd><p>s*([^s,]+)s*</p>
</dd>
<dt>(?:,s*([^s,]+)s*</dt><dd><p>,s*([^s,]+)s*)?</p>
</dd>
<dt>(?:,s*([^s,]+)s*</dt><dd><p>,s*([^s,]+)s*)?</p>
</dd>
</dl>
<p>(?:,s*d+s*)?</p>
</div></blockquote>
<p>)s*{s*$”””, declaration, flags=re.X)</p>
</dd>
<dt>if m:</dt><dd><p>p, n, result, name = m.groups()[0:4]
args = m.groups()[4:]
if n not in [‘’, ‘2’]:</p>
<blockquote>
<div><p>raise Exception(‘Cannot parse “%s”’ % declaration)</p>
</div></blockquote>
<dl class="simple">
<dt>args = ‘, ‘.join(‘%s %s’ % (args[i], args[i+1])</dt><dd><p>for i in range(0, len(args), 2) if args[i])</p>
</dd>
</dl>
<p>add_matcher(result, name, args, comment)
return</p>
</dd>
<dt>m = re.match(r”””^s*AST_MATCHER(_P)?(.?)(?:_OVERLOAD)?(</dt><dd><blockquote>
<div><dl class="simple">
<dt>(?:s*([^s,]+)s*,)?</dt><dd><p>s*([^s,]+)s*</p>
</dd>
<dt>(?:,s*([^,]+)s*</dt><dd><p>,s*([^s,]+)s*)?</p>
</dd>
<dt>(?:,s*([^s,]+)s*</dt><dd><p>,s*([^s,]+)s*)?</p>
</dd>
</dl>
<p>(?:,s*d+s*)?</p>
</div></blockquote>
<p>)s*{“””, declaration, flags=re.X)</p>
</dd>
<dt>if m:</dt><dd><p>p, n, result, name = m.groups()[0:4]
args = m.groups()[4:]
if not result:</p>
<blockquote>
<div><dl class="simple">
<dt>if not allowed_types:</dt><dd><p>raise Exception(‘Did not find allowed result types for: %s’ % name)</p>
</dd>
</dl>
<p>result_types = allowed_types</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>result_types = [result]</p>
</dd>
<dt>if n not in [‘’, ‘2’]:</dt><dd><p>raise Exception(‘Cannot parse “%s”’ % declaration)</p>
</dd>
<dt>args = ‘, ‘.join(‘%s %s’ % (args[i], args[i+1])</dt><dd><p>for i in range(0, len(args), 2) if args[i])</p>
</dd>
<dt>for result_type in result_types:</dt><dd><p>add_matcher(result_type, name, args, comment)</p>
</dd>
</dl>
<p>return</p>
</dd>
</dl>
<p># Parse ArgumentAdapting matchers.
m = re.match(</p>
<blockquote>
<div><dl class="simple">
<dt>r”””^.*ArgumentAdaptingMatcherFunc&lt;.*&gt;s*</dt><dd><p>([a-zA-Z]*);$”””,</p>
</dd>
</dl>
<p>declaration, flags=re.X)</p>
</div></blockquote>
<dl class="simple">
<dt>if m:</dt><dd><p>name = m.groups()[0]
add_matcher(‘*’, name, ‘Matcher&lt;*&gt;’, comment)
return</p>
</dd>
</dl>
<p># Parse Variadic functions.
m = re.match(</p>
<blockquote>
<div><dl class="simple">
<dt>r”””^.*internal::VariadicFunctions*&lt;s*([^,]+),s*([^,]+),s*[^&gt;]+&gt;s*</dt><dd><p>([a-zA-Z]*);$”””,</p>
</dd>
</dl>
<p>declaration, flags=re.X)</p>
</div></blockquote>
<dl class="simple">
<dt>if m:</dt><dd><p>result, arg, name = m.groups()[:3]
add_matcher(result, name, ‘%s, …, %s’ % (arg, arg), comment)
return</p>
</dd>
</dl>
<p># Parse Variadic operator matchers.
m = re.match(</p>
<blockquote>
<div><dl class="simple">
<dt>r”””^.*VariadicOperatorMatcherFuncs*&lt;s*([^,]+),s*([^s]+)s*&gt;s*</dt><dd><p>([a-zA-Z]*);$”””,</p>
</dd>
</dl>
<p>declaration, flags=re.X)</p>
</div></blockquote>
<dl>
<dt>if m:</dt><dd><p>min_args, max_args, name = m.groups()[:3]
if max_args == ‘1’:</p>
<blockquote>
<div><p>add_matcher(‘*’, name, ‘Matcher&lt;*&gt;’, comment)
return</p>
</div></blockquote>
<dl class="simple">
<dt>elif max_args == ‘std::numeric_limits&lt;unsigned&gt;::max()’:</dt><dd><p>add_matcher(‘*’, name, ‘Matcher&lt;*&gt;, …, Matcher&lt;*&gt;’, comment)
return</p>
</dd>
</dl>
</dd>
</dl>
<p># Parse free standing matcher functions, like:
#   Matcher&lt;ResultType&gt; Name(Matcher&lt;ArgumentType&gt; InnerMatcher) {
m = re.match(r”””^s*(.*)s+</p>
<blockquote>
<div><p>([^s(]+)s*(
(.*)
)s*{“””, declaration, re.X)</p>
</div></blockquote>
<dl>
<dt>if m:</dt><dd><p>result, name, args = m.groups()
args = ‘, ‘.join(p.strip() for p in args.split(‘,’))
m = re.match(r’.*s+internal::(Bindable)?Matcher&lt;([^&gt;]+)&gt;$’, result)
if m:</p>
<blockquote>
<div><p>result_types = [m.group(2)]</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>result_types = extract_result_types(comment)</p>
</dd>
<dt>if not result_types:</dt><dd><dl class="simple">
<dt>if not comment:</dt><dd><p># Only overloads don’t have their own doxygen comments; ignore those.
print ‘Ignoring “%s”’ % name</p>
</dd>
<dt>else:</dt><dd><p>print ‘Cannot determine result type for “%s”’ % name</p>
</dd>
</dl>
</dd>
<dt>else:</dt><dd><dl class="simple">
<dt>for result_type in result_types:</dt><dd><p>add_matcher(result_type, name, args, comment)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>else:</dt><dd><p>print ‘<strong>* Unparsable: “’ + declaration + ‘” *</strong>’</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>def sort_table(matcher_type, matcher_map):</dt><dd><p>“””Returns the sorted html table for the given row map.”””
table = ‘’
for key in sorted(matcher_map.keys()):</p>
<blockquote>
<div><p>table += matcher_map[key] + ‘n’</p>
</div></blockquote>
<dl>
<dt>return (‘&lt;!– START_%(type)s_MATCHERS –&gt;n’ +</dt><dd><blockquote>
<div><p>‘%(table)s’ +
‘&lt;!–END_%(type)s_MATCHERS –&gt;’) % {</p>
</div></blockquote>
<p>‘type’: matcher_type,
‘table’: table,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p># Parse the ast matchers.
# We alternate between two modes:
# body = True: We parse the definition of a matcher. We need
#   to parse the full definition before adding a matcher, as the
#   definition might contain static asserts that specify the result
#   type.
# body = False: We parse the comments and declaration of the matcher.
comment = ‘’
declaration = ‘’
allowed_types = []
body = False
for line in open(MATCHERS_FILE).read().splitlines():</p>
<blockquote>
<div><dl>
<dt>if body:</dt><dd><dl>
<dt>if line.strip() and line[0] == ‘}’:</dt><dd><dl class="simple">
<dt>if declaration:</dt><dd><p>act_on_decl(declaration, comment, allowed_types)
comment = ‘’
declaration = ‘’
allowed_types = []</p>
</dd>
</dl>
<p>body = False</p>
</dd>
<dt>else:</dt><dd><p>m = re.search(r’is_base_of&lt;([^,]+), NodeType&gt;’, line)
if m and m.group(1):</p>
<blockquote>
<div><p>allowed_types += [m.group(1)]</p>
</div></blockquote>
</dd>
</dl>
<p>continue</p>
</dd>
<dt>if line.strip() and line.lstrip()[0] == ‘/’:</dt><dd><p>comment += re.sub(r’/+s?’, ‘’, line) + ‘n’</p>
</dd>
<dt>else:</dt><dd><p>declaration += ‘ ‘ + line
if ((not line.strip()) or</p>
<blockquote>
<div><blockquote>
<div><p>line.rstrip()[-1] == ‘;’ or
(line.rstrip()[-1] == ‘{’ and line.rstrip()[-3:] != ‘= {‘)):</p>
</div></blockquote>
<dl class="simple">
<dt>if line.strip() and line.rstrip()[-1] == ‘{‘:</dt><dd><p>body = True</p>
</dd>
<dt>else:</dt><dd><p>act_on_decl(declaration, comment, allowed_types)
comment = ‘’
declaration = ‘’
allowed_types = []</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>node_matcher_table = sort_table(‘DECL’, node_matchers)
narrowing_matcher_table = sort_table(‘NARROWING’, narrowing_matchers)
traversal_matcher_table = sort_table(‘TRAVERSAL’, traversal_matchers)</p>
<p>reference = open(‘../LibASTMatchersReference.html’).read()
reference = re.sub(r’&lt;!– START_DECL_MATCHERS.*END_DECL_MATCHERS –&gt;’,</p>
<blockquote>
<div><p>node_matcher_table, reference, flags=re.S)</p>
</div></blockquote>
<dl class="simple">
<dt>reference = re.sub(r’&lt;!– START_NARROWING_MATCHERS.*END_NARROWING_MATCHERS –&gt;’,</dt><dd><p>narrowing_matcher_table, reference, flags=re.S)</p>
</dd>
<dt>reference = re.sub(r’&lt;!– START_TRAVERSAL_MATCHERS.*END_TRAVERSAL_MATCHERS –&gt;’,</dt><dd><p>traversal_matcher_table, reference, flags=re.S)</p>
</dd>
<dt>with open(‘../LibASTMatchersReference.html’, ‘wb’) as output:</dt><dd><p>output.write(reference)</p>
</dd>
</dl>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../_sources/tools/dump_ast_matchers.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>