<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>docs/SpeculativeLoadHardening.md &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=039e1c02" />
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=b3ba4146"></script>
    <script src="_static/doctools.js?v=888ff710"></script>
    <script src="_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="docs-speculativeloadhardening-md">
<h1>docs/SpeculativeLoadHardening.md<a class="headerlink" href="#docs-speculativeloadhardening-md" title="Permalink to this heading">¶</a></h1>
<p>Last edited: 2020-02-10 23:18:46</p>
<p>Contents:</p>
<div class="highlight-md notranslate"><div class="highlight"><pre><span></span><span class="gh"># Speculative Load Hardening</span>
</pre></div>
</div>
<p>### A Spectre Variant #1 Mitigation Technique</p>
<p>Author: Chandler Carruth - [<a class="reference external" href="mailto:chandlerc&#37;&#52;&#48;google&#46;com">chandlerc<span>&#64;</span>google<span>&#46;</span>com</a>](<a class="reference external" href="mailto:chandlerc&#37;&#52;&#48;google&#46;com">mailto:chandlerc<span>&#64;</span>google<span>&#46;</span>com</a>)</p>
<p>## Problem Statement</p>
<p>Recently, Google Project Zero and other researchers have found information leak
vulnerabilities by exploiting speculative execution in modern CPUs. These
exploits are currently broken down into three variants:
* GPZ Variant #1 (a.k.a. Spectre Variant #1): Bounds check (or predicate) bypass
* GPZ Variant #2 (a.k.a. Spectre Variant #2): Branch target injection
* GPZ Variant #3 (a.k.a. Meltdown): Rogue data cache load</p>
<p>For more details, see the Google Project Zero blog post and the Spectre research
paper:
* <a class="reference external" href="https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html">https://googleprojectzero.blogspot.com/2018/01/reading-privileged-memory-with-side.html</a>
* <a class="reference external" href="https://spectreattack.com/spectre.pdf">https://spectreattack.com/spectre.pdf</a></p>
<p>The core problem of GPZ Variant #1 is that speculative execution uses branch
prediction to select the path of instructions speculatively executed. This path
is speculatively executed with the available data, and may load from memory and
leak the loaded values through various side channels that survive even when the
speculative execution is unwound due to being incorrect. Mispredicted paths can
cause code to be executed with data inputs that never occur in correct
executions, making checks against malicious inputs ineffective and allowing
attackers to use malicious data inputs to leak secret data. Here is an example,
extracted and simplified from the Project Zero paper:
<a href="#id1"><span class="problematic" id="id2">``</span></a>`
struct array {</p>
<blockquote>
<div><p>unsigned long length;
unsigned char data[];</p>
</div></blockquote>
<p>};
struct array <a href="#id3"><span class="problematic" id="id4">*</span></a>arr1 = …; // small array
struct array <a href="#id5"><span class="problematic" id="id6">*</span></a>arr2 = …; // array of size 0x400
unsigned long untrusted_offset_from_caller = …;
if (untrusted_offset_from_caller &lt; arr1-&gt;length) {</p>
<blockquote>
<div><p>unsigned char value = arr1-&gt;data[untrusted_offset_from_caller];
unsigned long index2 = ((value&amp;1)*0x100)+0x200;
unsigned char value2 = arr2-&gt;data[index2];</p>
</div></blockquote>
<section id="id7">
<h2>}<a class="headerlink" href="#id7" title="Permalink to this heading">¶</a></h2>
<p>The key of the attack is to call this with <cite>untrusted_offset_from_caller</cite> that
is far outside of the bounds when the branch predictor will predict that it
will be in-bounds. In that case, the body of the <cite>if</cite> will be executed
speculatively, and may read secret data into <cite>value</cite> and leak it via a
cache-timing side channel when a dependent access is made to populate <cite>value2</cite>.</p>
<p>## High Level Mitigation Approach</p>
<p>While several approaches are being actively pursued to mitigate specific
branches and/or loads inside especially risky software (most notably various OS
kernels), these approaches require manual and/or static analysis aided auditing
of code and explicit source changes to apply the mitigation. They are unlikely
to scale well to large applications. We are proposing a comprehensive
mitigation approach that would apply automatically across an entire program
rather than through manual changes to the code. While this is likely to have a
high performance cost, some applications may be in a good position to take this
performance / security tradeoff.</p>
<p>The specific technique we propose is to cause loads to be checked using
branchless code to ensure that they are executing along a valid control flow
path. Consider the following C-pseudo-code representing the core idea of a
predicate guarding potentially invalid loads:
<a href="#id8"><span class="problematic" id="id9">``</span></a>`
void leak(int data);
void example(int* pointer1, int* pointer2) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (condition) {</dt><dd><p>// … lots of code …
leak(<a href="#id10"><span class="problematic" id="id11">*</span></a>pointer1);</p>
</dd>
<dt>} else {</dt><dd><p>// … more code …
leak(<a href="#id12"><span class="problematic" id="id13">*</span></a>pointer2);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</section>
<section id="id14">
<h2>}<a class="headerlink" href="#id14" title="Permalink to this heading">¶</a></h2>
<p>This would get transformed into something resembling the following:
<a href="#id15"><span class="problematic" id="id16">``</span></a>`
uintptr_t all_ones_mask = std::numerical_limits&lt;uintptr_t&gt;::max();
uintptr_t all_zeros_mask = 0;
void leak(int data);
void example(int* pointer1, int* pointer2) {</p>
<blockquote>
<div><p>uintptr_t predicate_state = all_ones_mask;
if (condition) {</p>
<blockquote>
<div><p>// Assuming ?: is implemented using branchless logic…
predicate_state = !condition ? all_zeros_mask : predicate_state;
// … lots of code …
//
// Harden the pointer so it can’t be loaded
pointer1 &amp;= predicate_state;
leak(<a href="#id17"><span class="problematic" id="id18">*</span></a>pointer1);</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>predicate_state = condition ? all_zeros_mask : predicate_state;
// … more code …
//
// Alternative: Harden the loaded value
int value2 = <a href="#id19"><span class="problematic" id="id20">*</span></a>pointer2 &amp; predicate_state;
leak(value2);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</section>
<section id="id21">
<h2>}<a class="headerlink" href="#id21" title="Permalink to this heading">¶</a></h2>
<p>The result should be that if the <cite>if (condition) {</cite> branch is mis-predicted,
there is a <em>data</em> dependency on the condition used to zero out any pointers
prior to loading through them or to zero out all of the loaded bits. Even
though this code pattern may still execute speculatively, <em>invalid</em> speculative
executions are prevented from leaking secret data from memory (but note that
this data might still be loaded in safe ways, and some regions of memory are
required to not hold secrets, see below for detailed limitations). This
approach only requires the underlying hardware have a way to implement a
branchless and unpredicted conditional update of a register’s value. All modern
architectures have support for this, and in fact such support is necessary to
correctly implement constant time cryptographic primitives.</p>
<p>Crucial properties of this approach:
* It is not preventing any particular side-channel from working. This is</p>
<blockquote>
<div><p>important as there are an unknown number of potential side channels and we
expect to continue discovering more. Instead, it prevents the observation of
secret data in the first place.</p>
</div></blockquote>
<ul class="simple">
<li><p>It accumulates the predicate state, protecting even in the face of nested
<em>correctly</em> predicted control flows.</p></li>
<li><p>It passes this predicate state across function boundaries to provide
[interprocedural protection](#interprocedural-checking).</p></li>
<li><p>When hardening the address of a load, it uses a <em>destructive</em> or
<em>non-reversible</em> modification of the address to prevent an attacker from
reversing the check using attacker-controlled inputs.</p></li>
<li><p>It does not completely block speculative execution, and merely prevents
<em>mis</em>-speculated paths from leaking secrets from memory (and stalls
speculation until this can be determined).</p></li>
<li><p>It is completely general and makes no fundamental assumptions about the
underlying architecture other than the ability to do branchless conditional
data updates and a lack of value prediction.</p></li>
<li><p>It does not require programmers to identify all possible secret data using
static source code annotations or code vulnerable to a variant #1 style
attack.</p></li>
</ul>
<p>Limitations of this approach:
* It requires re-compiling source code to insert hardening instruction</p>
<blockquote>
<div><p>sequences. Only software compiled in this mode is protected.</p>
</div></blockquote>
<ul class="simple">
<li><p>The performance is heavily dependent on a particular architecture’s
implementation strategy. We outline a potential x86 implementation below and
characterize its performance.</p></li>
<li><p>It does not defend against secret data already loaded from memory and
residing in registers or leaked through other side-channels in
non-speculative execution. Code dealing with this, e.g cryptographic
routines, already uses constant-time algorithms and code to prevent
side-channels. Such code should also scrub registers of secret data following
[these
guidelines](<a class="reference external" href="https://github.com/HACS-workshop/spectre-mitigations/blob/master/crypto_guidelines.md">https://github.com/HACS-workshop/spectre-mitigations/blob/master/crypto_guidelines.md</a>).</p></li>
<li><p>To achieve reasonable performance, many loads may not be checked, such as
those with compile-time fixed addresses. This primarily consists of accesses
at compile-time constant offsets of global and local variables. Code which
needs this protection and intentionally stores secret data must ensure the
memory regions used for secret data are necessarily dynamic mappings or heap
allocations. This is an area which can be tuned to provide more comprehensive
protection at the cost of performance.</p></li>
<li><p>[Hardened loads](#hardening-the-address-of-the-load) may still load data from
_valid_ addresses if not _attacker-<a href="#id167"><span class="problematic" id="id168">controlled_</span></a> addresses. To prevent these
from reading secret data, the low 2gb of the address space and 2gb above and
below any executable pages should be protected.</p></li>
</ul>
<p>Credit:
* The core idea of tracing misspeculation through data and marking pointers to</p>
<blockquote>
<div><p>block misspeculated loads was developed as part of a HACS 2018 discussion
between Chandler Carruth, Paul Kocher, Thomas Pornin, and several other
individuals.</p>
</div></blockquote>
<ul class="simple">
<li><p>Core idea of masking out loaded bits was part of the original mitigation
suggested by Jann Horn when these attacks were reported.</p></li>
</ul>
<p>### Indirect Branches, Calls, and Returns</p>
<p>It is possible to attack control flow other than conditional branches with
variant #1 style mispredictions.
* A prediction towards a hot call target of a virtual method can lead to it</p>
<blockquote>
<div><p>being speculatively executed when an expected type is used (often called
“type confusion”).</p>
</div></blockquote>
<ul class="simple">
<li><p>A hot case may be speculatively executed due to prediction instead of the
correct case for a switch statement implemented as a jump table.</p></li>
<li><p>A hot common return address may be predicted incorrectly when returning from
a function.</p></li>
</ul>
<p>These code patterns are also vulnerable to Spectre variant #2, and as such are
best mitigated with a
[retpoline](<a class="reference external" href="https://support.google.com/faqs/answer/7625886">https://support.google.com/faqs/answer/7625886</a>) on x86 platforms.
When a mitigation technique like retpoline is used, speculation simply cannot
proceed through an indirect control flow edge (or it cannot be mispredicted in
the case of a filled RSB) and so it is also protected from variant #1 style
attacks. However, some architectures, micro-architectures, or vendors do not
employ the retpoline mitigation, and on future x86 hardware (both Intel and
AMD) it is expected to become unnecessary due to hardware-based mitigation.</p>
<p>When not using a retpoline, these edges will need independent protection from
variant #1 style attacks. The analogous approach to that used for conditional
control flow should work:
<a href="#id22"><span class="problematic" id="id23">``</span></a>`
uintptr_t all_ones_mask = std::numerical_limits&lt;uintptr_t&gt;::max();
uintptr_t all_zeros_mask = 0;
void leak(int data);
void example(int* pointer1, int* pointer2) {</p>
<blockquote>
<div><p>uintptr_t predicate_state = all_ones_mask;
switch (condition) {
case 0:</p>
<blockquote>
<div><p>// Assuming ?: is implemented using branchless logic…
predicate_state = (condition != 0) ? all_zeros_mask : predicate_state;
// … lots of code …
//
// Harden the pointer so it can’t be loaded
pointer1 &amp;= predicate_state;
leak(<a href="#id24"><span class="problematic" id="id25">*</span></a>pointer1);
break;</p>
</div></blockquote>
<dl>
<dt>case 1:</dt><dd><p>predicate_state = (condition != 1) ? all_zeros_mask : predicate_state;
// … more code …
//
// Alternative: Harden the loaded value
int value2 = <a href="#id26"><span class="problematic" id="id27">*</span></a>pointer2 &amp; predicate_state;
leak(value2);
break;</p>
<p>// …</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</section>
<section id="id28">
<h2>}<a class="headerlink" href="#id28" title="Permalink to this heading">¶</a></h2>
<p>The core idea remains the same: validate the control flow using data-flow and
use that validation to check that loads cannot leak information along
misspeculated paths. Typically this involves passing the desired target of such
control flow across the edge and checking that it is correct afterwards. Note
that while it is tempting to think that this mitigates variant #2 attacks, it
does not. Those attacks go to arbitrary gadgets that don’t include the checks.</p>
<p>### Variant #1.1 and #1.2 attacks: “Bounds Check Bypass Store”</p>
<p>Beyond the core variant #1 attack, there are techniques to extend this attack.
The primary technique is known as “Bounds Check Bypass Store” and is discussed
in this research paper: <a class="reference external" href="https://people.csail.mit.edu/vlk/spectre11.pdf">https://people.csail.mit.edu/vlk/spectre11.pdf</a></p>
<p>We will analyze these two variants independently. First, variant #1.1 works by
speculatively storing over the return address after a bounds check bypass. This
speculative store then ends up being used by the CPU during speculative
execution of the return, potentially directing speculative execution to
arbitrary gadgets in the binary. Let’s look at an example.
<a href="#id29"><span class="problematic" id="id30">``</span></a>`
unsigned char local_buffer[4];
unsigned char <a href="#id31"><span class="problematic" id="id32">*</span></a>untrusted_data_from_caller = …;
unsigned long untrusted_size_from_caller = …;
if (untrusted_size_from_caller &lt; sizeof(local_buffer)) {</p>
<blockquote>
<div><p>// Speculative execution enters here with a too-large size.
memcpy(local_buffer, untrusted_data_from_caller,</p>
<blockquote>
<div><p>untrusted_size_from_caller);</p>
</div></blockquote>
<p>// The stack has now been smashed, writing an attacker-controlled
// address over the return adress.
minor_processing(local_buffer);
return;
// Control will speculate to the attacker-written address.</p>
</div></blockquote>
</section>
<section id="id33">
<h2>}<a class="headerlink" href="#id33" title="Permalink to this heading">¶</a></h2>
<p>However, this can be mitigated by hardening the load of the return address just
like any other load. This is sometimes complicated because x86 for example
<em>implicitly</em> loads the return address off the stack. However, the
implementation technique below is specifically designed to mitigate this
implicit load by using the stack pointer to communicate misspeculation between
functions. This additionally causes a misspeculation to have an invalid stack
pointer and never be able to read the speculatively stored return address. See
the detailed discussion below.</p>
<p>For variant #1.2, the attacker speculatively stores into the vtable or jump
table used to implement an indirect call or indirect jump. Because this is
speculative, this will often be possible even when these are stored in
read-only pages. For example:
<a href="#id34"><span class="problematic" id="id35">``</span></a>`
class FancyObject : public BaseObject {
public:</p>
<blockquote>
<div><p>void DoSomething() override;</p>
</div></blockquote>
<p>};
void f(unsigned long attacker_offset, unsigned long attacker_data) {</p>
<blockquote>
<div><p>FancyObject object = getMyObject();
unsigned long <a href="#id36"><span class="problematic" id="id37">*</span></a>arr[4] = getFourDataPointers();
if (attacker_offset &lt; 4) {</p>
<blockquote>
<div><p>// We have bypassed the bounds check speculatively.
unsigned long <a href="#id38"><span class="problematic" id="id39">*</span></a>data = arr[attacker_offset];
// Now we have computed a pointer inside of <cite>object</cite>, the vptr.
<a href="#id40"><span class="problematic" id="id41">*</span></a>data = attacker_data;
// The vptr points to the virtual table and we speculatively clobber that.
g(object); // Hand the object to some other routine.</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
// In another file, we call a method on the object.
void g(BaseObject &amp;object) {</p>
<blockquote>
<div><p>object.DoSomething();
// This speculatively calls the address stored over the vtable.</p>
</div></blockquote>
</section>
<section id="id42">
<h2>}<a class="headerlink" href="#id42" title="Permalink to this heading">¶</a></h2>
<p>Mitigating this requires hardening loads from these locations, or mitigating
the indirect call or indirect jump. Any of these are sufficient to block the
call or jump from using a speculatively stored value that has been read back.</p>
<p>For both of these, using retpolines would be equally sufficient. One possible
hybrid approach is to use retpolines for indirect call and jump, while relying
on SLH to mitigate returns.</p>
<p>Another approach that is sufficient for both of these is to harden all of the
speculative stores. However, as most stores aren’t interesting and don’t
inherently leak data, this is expected to be prohibitively expensive given the
attack it is defending against.</p>
<p>## Implementation Details</p>
<p>There are a number of complex details impacting the implementation of this
technique, both on a particular architecture and within a particular compiler.
We discuss proposed implementation techniques for the x86 architecture and the
LLVM compiler. These are primarily to serve as an example, as other
implementation techniques are very possible.</p>
<p>### x86 Implementation Details</p>
<p>On the x86 platform we break down the implementation into three core
components: accumulating the predicate state through the control flow graph,
checking the loads, and checking control transfers between procedures.</p>
<p>#### Accumulating Predicate State</p>
<p>Consider baseline x86 instructions like the following, which test three
conditions and if all pass, loads data from memory and potentially leaks it
through some side channel:
<a href="#id43"><span class="problematic" id="id44">``</span></a>`
# %bb.0:                                # %entry</p>
<blockquote>
<div><p>pushq   %rax
testl   %edi, %edi
jne     .LBB0_4</p>
</div></blockquote>
<dl class="simple">
<dt># %bb.1:                                # %then1</dt><dd><p>testl   %esi, %esi
jne     .LBB0_4</p>
</dd>
<dt># %bb.2:                                # %then2</dt><dd><p>testl   %edx, %edx
je      .LBB0_3</p>
</dd>
<dt>.LBB0_4:                                # %exit</dt><dd><p>popq    %rax
retq</p>
</dd>
<dt>.LBB0_3:                                # %danger</dt><dd><p>movl    (%rcx), %edi
callq   leak
popq    %rax
retq</p>
</dd>
</dl>
<p><a href="#id45"><span class="problematic" id="id46">``</span></a><a href="#id47"><span class="problematic" id="id48">`</span></a></p>
<p>When we go to speculatively execute the load, we want to know whether any of
the dynamically executed predicates have been misspeculated. To track that,
along each conditional edge, we need to track the data which would allow that
edge to be taken. On x86, this data is stored in the flags register used by the
conditional jump instruction. Along both edges after this fork in control flow,
the flags register remains alive and contains data that we can use to build up
our accumulated predicate state. We accumulate it using the x86 conditional
move instruction which also reads the flag registers where the state resides.
These conditional move instructions are known to not be predicted on any x86
processors, making them immune to misprediction that could reintroduce the
vulnerability. When we insert the conditional moves, the code ends up looking
like the following:
<a href="#id49"><span class="problematic" id="id50">``</span></a>`
# %bb.0:                                # %entry</p>
<blockquote>
<div><p>pushq   %rax
xorl    %eax, %eax              # Zero out initial predicate state.
movq    $-1, %r8                # Put all-ones mask into a register.
testl   %edi, %edi
jne     .LBB0_1</p>
</div></blockquote>
<dl class="simple">
<dt># %bb.2:                                # %then1</dt><dd><p>cmovneq %r8, %rax               # Conditionally update predicate state.
testl   %esi, %esi
jne     .LBB0_1</p>
</dd>
<dt># %bb.3:                                # %then2</dt><dd><p>cmovneq %r8, %rax               # Conditionally update predicate state.
testl   %edx, %edx
je      .LBB0_4</p>
</dd>
<dt>.LBB0_1:</dt><dd><p>cmoveq  %r8, %rax               # Conditionally update predicate state.
popq    %rax
retq</p>
</dd>
<dt>.LBB0_4:                                # %danger</dt><dd><p>cmovneq %r8, %rax               # Conditionally update predicate state.
…</p>
</dd>
</dl>
<p><a href="#id51"><span class="problematic" id="id52">``</span></a><a href="#id53"><span class="problematic" id="id54">`</span></a></p>
<p>Here we create the “empty” or “correct execution” predicate state by zeroing
<cite>%rax</cite>, and we create a constant “incorrect execution” predicate value by
putting <cite>-1</cite> into <cite>%r8</cite>. Then, along each edge coming out of a conditional
branch we do a conditional move that in a correct execution will be a no-op,
but if misspeculated, will replace the <cite>%rax</cite> with the value of <cite>%r8</cite>.
Misspeculating any one of the three predicates will cause <cite>%rax</cite> to hold the
“incorrect execution” value from <cite>%r8</cite> as we preserve incoming values when
execution is correct rather than overwriting it.</p>
<p>We now have a value in <cite>%rax</cite> in each basic block that indicates if at some
point previously a predicate was mispredicted. And we have arranged for that
value to be particularly effective when used below to harden loads.</p>
<p>##### Indirect Call, Branch, and Return Predicates</p>
<p>There is no analogous flag to use when tracing indirect calls, branches, and
returns. The predicate state must be accumulated through some other means.
Fundamentally, this is the reverse of the problem posed in CFI: we need to
check where we came from rather than where we are going. For function-local
jump tables, this is easily arranged by testing the input to the jump table
within each destination (not yet implemented, use retpolines):
<a href="#id55"><span class="problematic" id="id56">``</span></a><a href="#id57"><span class="problematic" id="id58">`</span></a></p>
<blockquote>
<div><p>pushq   %rax
xorl    %eax, %eax              # Zero out initial predicate state.
movq    $-1, %r8                # Put all-ones mask into a register.
jmpq    <a href="#id59"><span class="problematic" id="id60">*</span></a>.LJTI0_0(,%rdi,8)      # Indirect jump through table.</p>
</div></blockquote>
<dl>
<dt>.LBB0_2:                                # %sw.bb</dt><dd><p>testq   $0, %rdi                # Validate index used for jump table.
cmovneq %r8, %rax               # Conditionally update predicate state.
…
jmp     _Z4leaki                # TAILCALL</p>
</dd>
<dt>.LBB0_3:                                # %sw.bb1</dt><dd><p>testq   $1, %rdi                # Validate index used for jump table.
cmovneq %r8, %rax               # Conditionally update predicate state.
…
jmp     _Z4leaki                # TAILCALL</p>
</dd>
<dt>.LBB0_5:                                # %sw.bb10</dt><dd><p>testq   $2, %rdi                # Validate index used for jump table.
cmovneq %r8, %rax               # Conditionally update predicate state.
…
jmp     _Z4leaki                # TAILCALL
…</p>
<p>.section        .rodata,”a”,&#64;progbits
.p2align        3</p>
</dd>
<dt>.LJTI0_0:</dt><dd><p>.quad   .LBB0_2
.quad   .LBB0_3
.quad   .LBB0_5
…</p>
</dd>
</dl>
<p><a href="#id61"><span class="problematic" id="id62">``</span></a><a href="#id63"><span class="problematic" id="id64">`</span></a></p>
<p>Returns have a simple mitigation technique on x86-64 (or other ABIs which have
what is called a “red zone” region beyond the end of the stack). This region is
guaranteed to be preserved across interrupts and context switches, making the
return address used in returning to the current code remain on the stack and
valid to read. We can emit code in the caller to verify that a return edge was
not mispredicted:
<a href="#id65"><span class="problematic" id="id66">``</span></a><a href="#id67"><span class="problematic" id="id68">`</span></a></p>
<blockquote>
<div><p>callq   other_function</p>
</div></blockquote>
<dl class="simple">
<dt>return_addr:</dt><dd><p>testq   -8(%rsp), return_addr   # Validate return address.
cmovneq %r8, %rax               # Update predicate state.</p>
</dd>
</dl>
<p><a href="#id69"><span class="problematic" id="id70">``</span></a><a href="#id71"><span class="problematic" id="id72">`</span></a></p>
<p>For an ABI without a “red zone” (and thus unable to read the return address
from the stack), we can compute the expected return address prior to the call
into a register preserved across the call and use that similarly to the above.</p>
<p>Indirect calls (and returns in the absence of a red zone ABI) pose the most
significant challenge to propagate. The simplest technique would be to define a
new ABI such that the intended call target is passed into the called function
and checked in the entry. Unfortunately, new ABIs are quite expensive to deploy
in C and C++. While the target function could be passed in TLS, we would still
require complex logic to handle a mixture of functions compiled with and
without this extra logic (essentially, making the ABI backwards compatible).
Currently, we suggest using retpolines here and will continue to investigate
ways of mitigating this.</p>
<p>##### Optimizations, Alternatives, and Tradeoffs</p>
<p>Merely accumulating predicate state involves significant cost. There are
several key optimizations we employ to minimize this and various alternatives
that present different tradeoffs in the generated code.</p>
<p>First, we work to reduce the number of instructions used to track the state:
* Rather than inserting a <cite>cmovCC</cite> instruction along every conditional edge in</p>
<blockquote>
<div><p>the original program, we track each set of condition flags we need to capture
prior to entering each basic block and reuse a common <cite>cmovCC</cite> sequence for
those.
* We could further reuse suffixes when there are multiple <cite>cmovCC</cite></p>
<blockquote>
<div><p>instructions required to capture the set of flags. Currently this is
believed to not be worth the cost as paired flags are relatively rare and
suffixes of them are exceedingly rare.</p>
</div></blockquote>
</div></blockquote>
<ul class="simple">
<li><p>A common pattern in x86 is to have multiple conditional jump instructions
that use the same flags but handle different conditions. Naively, we could
consider each fallthrough between them an “edge” but this causes a much more
complex control flow graph. Instead, we accumulate the set of conditions
necessary for fallthrough and use a sequence of <cite>cmovCC</cite> instructions in a
single fallthrough edge to track it.</p></li>
</ul>
<p>Second, we trade register pressure for simpler <cite>cmovCC</cite> instructions by
allocating a register for the “bad” state. We could read that value from memory
as part of the conditional move instruction, however, this creates more
micro-ops and requires the load-store unit to be involved. Currently, we place
the value into a virtual register and allow the register allocator to decide
when the register pressure is sufficient to make it worth spilling to memory
and reloading.</p>
<p>#### Hardening Loads</p>
<p>Once we have the predicate accumulated into a special value for correct vs.
misspeculated, we need to apply this to loads in a way that ensures they do not
leak secret data. There are two primary techniques for this: we can either
harden the loaded value to prevent observation, or we can harden the address
itself to prevent the load from occuring. These have significantly different
performance tradeoffs.</p>
<p>##### Hardening loaded values</p>
<p>The most appealing way to harden loads is to mask out all of the bits loaded.
The key requirement is that for each bit loaded, along the misspeculated path
that bit is always fixed at either 0 or 1 regardless of the value of the bit
loaded. The most obvious implementation uses either an <cite>and</cite> instruction with
an all-zero mask along misspeculated paths and an all-one mask along correct
paths, or an <cite>or</cite> instruction with an all-one mask along misspeculated paths
and an all-zero mask along correct paths. Other options become less appealing
such as multiplying by zero, or multiple shift instructions. For reasons we
elaborate on below, we end up suggesting you use <cite>or</cite> with an all-ones mask,
making the x86 instruction sequence look like the following:
<a href="#id73"><span class="problematic" id="id74">``</span></a><a href="#id75"><span class="problematic" id="id76">`</span></a></p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<dl class="simple">
<dt>.LBB0_4:                                # %danger</dt><dd><p>cmovneq %r8, %rax               # Conditionally update predicate state.
movl    (%rsi), %edi            # Load potentially secret data from %rsi.
orl     %eax, %edi</p>
</dd>
</dl>
<p><a href="#id77"><span class="problematic" id="id78">``</span></a><a href="#id79"><span class="problematic" id="id80">`</span></a></p>
<p>Other useful patterns may be to fold the load into the <cite>or</cite> instruction itself
at the cost of a register-to-register copy.</p>
<p>There are some challenges with deploying this approach:
1. Many loads on x86 are folded into other instructions. Separating them would</p>
<blockquote>
<div><p>add very significant and costly register pressure with prohibitive
performance cost.</p>
</div></blockquote>
<ol class="arabic simple">
<li><p>Loads may not target a general purpose register requiring extra instructions
to map the state value into the correct register class, and potentially more
expensive instructions to mask the value in some way.</p></li>
</ol>
<ol class="arabic simple">
<li><p>The flags registers on x86 are very likely to be live, and challenging to
preserve cheaply.</p></li>
</ol>
<ol class="arabic simple">
<li><p>There are many more values loaded than pointers &amp; indices used for loads. As
a consequence, hardening the result of a load requires substantially more
instructions than hardening the address of the load (see below).</p></li>
</ol>
<p>Despite these challenges, hardening the result of the load critically allows
the load to proceed and thus has dramatically less impact on the total
speculative / out-of-order potential of the execution. There are also several
interesting techniques to try and mitigate these challenges and make hardening
the results of loads viable in at least some cases. However, we generally
expect to fall back when unprofitable from hardening the loaded value to the
next approach of hardening the address itself.</p>
<p>###### Loads folded into data-invariant operations can be hardened after the operation</p>
<p>The first key to making this feasible is to recognize that many operations on
x86 are “data-invariant”. That is, they have no (known) observable behavior
differences due to the particular input data. These instructions are often used
when implementing cryptographic primitives dealing with private key data
because they are not believed to provide any side-channels. Similarly, we can
defer hardening until after them as they will not in-and-of-themselves
introduce a speculative execution side-channel. This results in code sequences
that look like:
<a href="#id81"><span class="problematic" id="id82">``</span></a><a href="#id83"><span class="problematic" id="id84">`</span></a></p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<dl class="simple">
<dt>.LBB0_4:                                # %danger</dt><dd><p>cmovneq %r8, %rax               # Conditionally update predicate state.
addl    (%rsi), %edi            # Load and accumulate without leaking.
orl     %eax, %edi</p>
</dd>
</dl>
<p><a href="#id85"><span class="problematic" id="id86">``</span></a><a href="#id87"><span class="problematic" id="id88">`</span></a></p>
<p>While an addition happens to the loaded (potentially secret) value, that
doesn’t leak any data and we then immediately harden it.</p>
<p>###### Hardening of loaded values deferred down the data-invariant expression graph</p>
<p>We can generalize the previous idea and sink the hardening down the expression
graph across as many data-invariant operations as desirable. This can use very
conservative rules for whether something is data-invariant. The primary goal
should be to handle multiple loads with a single hardening instruction:
<a href="#id89"><span class="problematic" id="id90">``</span></a><a href="#id91"><span class="problematic" id="id92">`</span></a></p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<dl class="simple">
<dt>.LBB0_4:                                # %danger</dt><dd><p>cmovneq %r8, %rax               # Conditionally update predicate state.
addl    (%rsi), %edi            # Load and accumulate without leaking.
addl    4(%rsi), %edi           # Continue without leaking.
addl    8(%rsi), %edi
orl     %eax, %edi              # Mask out bits from all three loads.</p>
</dd>
</dl>
<p><a href="#id93"><span class="problematic" id="id94">``</span></a><a href="#id95"><span class="problematic" id="id96">`</span></a></p>
<p>###### Preserving the flags while hardening loaded values on Haswell, Zen, and newer processors</p>
<p>Sadly, there are no useful instructions on x86 that apply a mask to all 64 bits
without touching the flag registers. However, we can harden loaded values that
are narrower than a word (fewer than 32-bits on 32-bit systems and fewer than
64-bits on 64-bit systems) by zero-extending the value to the full word size
and then shifting right by at least the number of original bits using the BMI2
<cite>shrx</cite> instruction:
<a href="#id97"><span class="problematic" id="id98">``</span></a><a href="#id99"><span class="problematic" id="id100">`</span></a></p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<dl class="simple">
<dt>.LBB0_4:                                # %danger</dt><dd><p>cmovneq %r8, %rax               # Conditionally update predicate state.
addl    (%rsi), %edi            # Load and accumulate 32 bits of data.
shrxq   %rax, %rdi, %rdi        # Shift out all 32 bits loaded.</p>
</dd>
</dl>
<p><a href="#id101"><span class="problematic" id="id102">``</span></a><a href="#id103"><span class="problematic" id="id104">`</span></a></p>
<p>Because on x86 the zero-extend is free, this can efficiently harden the loaded
value.</p>
<p>##### Hardening the address of the load</p>
<p>When hardening the loaded value is inapplicable, most often because the
instruction directly leaks information (like <cite>cmp</cite> or <cite>jmpq</cite>), we switch to
hardening the _address_ of the load instead of the loaded value. This avoids
increasing register pressure by unfolding the load or paying some other high
cost.</p>
<p>To understand how this works in practice, we need to examine the exact
semantics of the x86 addressing modes which, in its fully general form, looks
like <cite>(%base,%index,scale)offset</cite>. Here <cite>%base</cite> and <cite>%index</cite> are 64-bit
registers that can potentially be any value, and may be attacker controlled,
and <cite>scale</cite> and <cite>offset</cite> are fixed immediate values. <cite>scale</cite> must be <cite>1</cite>, <cite>2</cite>,
<cite>4</cite>, or <cite>8</cite>, and <cite>offset</cite> can be any 32-bit sign extended value. The exact
computation performed to find the address is then: <cite>%base + (scale * %index) +
offset</cite> under 64-bit 2’s complement modular arithmetic.</p>
<p>One issue with this approach is that, after hardening, the  <cite>%base + (scale *
%index)</cite> subexpression will compute a value near zero (<cite>-1 + (scale * -1)</cite>) and
then a large, positive <cite>offset</cite> will index into memory within the first two
gigabytes of address space. While these offsets are not attacker controlled,
the attacker could chose to attack a load which happens to have the desired
offset and then successfully read memory in that region. This significantly
raises the burden on the attacker and limits the scope of attack but does not
eliminate it. To fully close the attack we must work with the operating system
to preclude mapping memory in the low two gigabytes of address space.</p>
<p>###### 64-bit load checking instructions</p>
<p>We can use the following instruction sequences to check loads. We set up <cite>%r8</cite>
in these examples to hold the special value of <cite>-1</cite> which will be <cite>cmov`ed over
`%rax</cite> in misspeculated paths.</p>
<p>Single register addressing mode:
<a href="#id105"><span class="problematic" id="id106">``</span></a><a href="#id107"><span class="problematic" id="id108">`</span></a></p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<dl class="simple">
<dt>.LBB0_4:                                # %danger</dt><dd><p>cmovneq %r8, %rax               # Conditionally update predicate state.
orq     %rax, %rsi              # Mask the pointer if misspeculating.
movl    (%rsi), %edi</p>
</dd>
</dl>
<p><a href="#id109"><span class="problematic" id="id110">``</span></a><a href="#id111"><span class="problematic" id="id112">`</span></a></p>
<p>Two register addressing mode:
<a href="#id113"><span class="problematic" id="id114">``</span></a><a href="#id115"><span class="problematic" id="id116">`</span></a></p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<dl class="simple">
<dt>.LBB0_4:                                # %danger</dt><dd><p>cmovneq %r8, %rax               # Conditionally update predicate state.
orq     %rax, %rsi              # Mask the pointer if misspeculating.
orq     %rax, %rcx              # Mask the index if misspeculating.
movl    (%rsi,%rcx), %edi</p>
</dd>
</dl>
<p><a href="#id117"><span class="problematic" id="id118">``</span></a><a href="#id119"><span class="problematic" id="id120">`</span></a></p>
<p>This will result in a negative address near zero or in <cite>offset</cite> wrapping the
address space back to a small positive address. Small, negative addresses will
fault in user-mode for most operating systems, but targets which need the high
address space to be user accessible may need to adjust the exact sequence used
above. Additionally, the low addresses will need to be marked unreadable by the
OS to fully harden the load.</p>
<p>###### RIP-relative addressing is even easier to break</p>
<p>There is a common addressing mode idiom that is substantially harder to check:
addressing relative to the instruction pointer. We cannot change the value of
the instruction pointer register and so we have the harder problem of forcing
<cite>%base + scale * %index + offset</cite> to be an invalid address, by <em>only</em> changing
<cite>%index</cite>. The only advantage we have is that the attacker also cannot modify
<cite>%base</cite>. If we use the fast instruction sequence above, but only apply it to
the index, we will always access <cite>%rip + (scale * -1) + offset</cite>. If the
attacker can find a load which with this address happens to point to secret
data, then they can reach it. However, the loader and base libraries can also
simply refuse to map the heap, data segments, or stack within 2gb of any of the
text in the program, much like it can reserve the low 2gb of address space.</p>
<p>###### The flag registers again make everything hard</p>
<p>Unfortunately, the technique of using <cite>orq</cite>-instructions has a serious flaw on
x86. The very thing that makes it easy to accumulate state, the flag registers
containing predicates, causes serious problems here because they may be alive
and used by the loading instruction or subsequent instructions. On x86, the
<cite>orq</cite> instruction <strong>sets</strong> the flags and will override anything already there.
This makes inserting them into the instruction stream very hazardous.
Unfortunately, unlike when hardening the loaded value, we have no fallback here
and so we must have a fully general approach available.</p>
<p>The first thing we must do when generating these sequences is try to analyze
the surrounding code to prove that the flags are not in fact alive or being
used. Typically, it has been set by some other instruction which just happens
to set the flags register (much like ours!) with no actual dependency. In those
cases, it is safe to directly insert these instructions. Alternatively we may
be able to move them earlier to avoid clobbering the used value.</p>
<p>However, this may ultimately be impossible. In that case, we need to preserve
the flags around these instructions:
<a href="#id121"><span class="problematic" id="id122">``</span></a><a href="#id123"><span class="problematic" id="id124">`</span></a></p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<dl class="simple">
<dt>.LBB0_4:                                # %danger</dt><dd><p>cmovneq %r8, %rax               # Conditionally update predicate state.
pushfq
orq     %rax, %rcx              # Mask the pointer if misspeculating.
orq     %rax, %rdx              # Mask the index if misspeculating.
popfq
movl    (%rcx,%rdx), %edi</p>
</dd>
</dl>
<p><a href="#id125"><span class="problematic" id="id126">``</span></a><a href="#id127"><span class="problematic" id="id128">`</span></a></p>
<p>Using the <cite>pushf</cite> and <cite>popf</cite> instructions saves the flags register around our
inserted code, but comes at a high cost. First, we must store the flags to the
stack and reload them. Second, this causes the stack pointer to be adjusted
dynamically, requiring a frame pointer be used for referring to temporaries
spilled to the stack, etc.</p>
<p>On newer x86 processors we can use the <cite>lahf</cite> and <cite>sahf</cite> instructions to save
all of the flags besides the overflow flag in a register rather than on the
stack. We can then use <cite>seto</cite> and <cite>add</cite> to save and restore the overflow flag
in a register. Combined, this will save and restore flags in the same manner as
above but using two registers rather than the stack. That is still very
expensive if slightly less expensive than <cite>pushf</cite> and <cite>popf</cite> in most cases.</p>
<p>###### A flag-less alternative on Haswell, Zen and newer processors</p>
<p>Starting with the BMI2 x86 instruction set extensions available on Haswell and
Zen processors, there is an instruction for shifting that does not set any
flags: <cite>shrx</cite>. We can use this and the <cite>lea</cite> instruction to implement analogous
code sequences to the above ones. However, these are still very marginally
slower, as there are fewer ports able to dispatch shift instructions in most
modern x86 processors than there are for <cite>or</cite> instructions.</p>
<p>Fast, single register addressing mode:
<a href="#id129"><span class="problematic" id="id130">``</span></a><a href="#id131"><span class="problematic" id="id132">`</span></a></p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<dl class="simple">
<dt>.LBB0_4:                                # %danger</dt><dd><p>cmovneq %r8, %rax               # Conditionally update predicate state.
shrxq   %rax, %rsi, %rsi        # Shift away bits if misspeculating.
movl    (%rsi), %edi</p>
</dd>
</dl>
<p><a href="#id133"><span class="problematic" id="id134">``</span></a><a href="#id135"><span class="problematic" id="id136">`</span></a></p>
<p>This will collapse the register to zero or one, and everything but the offset
in the addressing mode to be less than or equal to 9. This means the full
address can only be guaranteed to be less than <cite>(1 &lt;&lt; 31) + 9</cite>. The OS may wish
to protect an extra page of the low address space to account for this</p>
<p>##### Optimizations</p>
<p>A very large portion of the cost for this approach comes from checking loads in
this way, so it is important to work to optimize this. However, beyond making
the instruction sequences to <em>apply</em> the checks efficient (for example by
avoiding <cite>pushfq</cite> and <cite>popfq</cite> sequences), the only significant optimization is
to check fewer loads without introducing a vulnerability. We apply several
techniques to accomplish that.</p>
<p>###### Don’t check loads from compile-time constant stack offsets</p>
<p>We implement this optimization on x86 by skipping the checking of loads which
use a fixed frame pointer offset.</p>
<p>The result of this optimization is that patterns like reloading a spilled
register or accessing a global field don’t get checked. This is a very
significant performance win.</p>
<p>###### Don’t check dependent loads</p>
<p>A core part of why this mitigation strategy works is that it establishes a
data-flow check on the loaded address. However, this means that if the address
itself was already loaded using a checked load, there is no need to check a
dependent load provided it is within the same basic block as the checked load,
and therefore has no additional predicates guarding it. Consider code like the
following:
<a href="#id137"><span class="problematic" id="id138">``</span></a><a href="#id139"><span class="problematic" id="id140">`</span></a></p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<dl class="simple">
<dt>.LBB0_4:                                # %danger</dt><dd><p>movq    (%rcx), %rdi
movl    (%rdi), %edx</p>
</dd>
</dl>
<p><a href="#id141"><span class="problematic" id="id142">``</span></a><a href="#id143"><span class="problematic" id="id144">`</span></a></p>
<p>This will get transformed into:
<a href="#id145"><span class="problematic" id="id146">``</span></a><a href="#id147"><span class="problematic" id="id148">`</span></a></p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<dl class="simple">
<dt>.LBB0_4:                                # %danger</dt><dd><p>cmovneq %r8, %rax               # Conditionally update predicate state.
orq     %rax, %rcx              # Mask the pointer if misspeculating.
movq    (%rcx), %rdi            # Hardened load.
movl    (%rdi), %edx            # Unhardened load due to dependent addr.</p>
</dd>
</dl>
<p><a href="#id149"><span class="problematic" id="id150">``</span></a><a href="#id151"><span class="problematic" id="id152">`</span></a></p>
<p>This doesn’t check the load through <cite>%rdi</cite> as that pointer is dependent on a
checked load already.</p>
<p>###### Protect large, load-heavy blocks with a single lfence</p>
<p>It may be worth using a single <cite>lfence</cite> instruction at the start of a block
which begins with a (very) large number of loads that require independent
protection <em>and</em> which require hardening the address of the load. However, this
is unlikely to be profitable in practice. The latency hit of the hardening
would need to exceed that of an <cite>lfence</cite> when <em>correctly</em> speculatively
executed. But in that case, the <cite>lfence</cite> cost is a complete loss of speculative
execution (at a minimum). So far, the evidence we have of the performance cost
of using <cite>lfence</cite> indicates few if any hot code patterns where this trade off
would make sense.</p>
<p>###### Tempting optimizations that break the security model</p>
<p>Several optimizations were considered which didn’t pan out due to failure to
uphold the security model. One in particular is worth discussing as many others
will reduce to it.</p>
<p>We wondered whether only the <em>first</em> load in a basic block could be checked. If
the check works as intended, it forms an invalid pointer that doesn’t even
virtual-address translate in the hardware. It should fault very early on in its
processing. Maybe that would stop things in time for the misspeculated path to
fail to leak any secrets. This doesn’t end up working because the processor is
fundamentally out-of-order, even in its speculative domain. As a consequence,
the attacker could cause the initial address computation itself to stall and
allow an arbitrary number of unrelated loads (including attacked loads of
secret data) to pass through.</p>
<p>#### Interprocedural Checking</p>
<p>Modern x86 processors may speculate into called functions and out of functions
to their return address. As a consequence, we need a way to check loads that
occur after a misspeculated predicate but where the load and the misspeculated
predicate are in different functions. In essence, we need some interprocedural
generalization of the predicate state tracking. A primary challenge to passing
the predicate state between functions is that we would like to not require a
change to the ABI or calling convention in order to make this mitigation more
deployable, and further would like code mitigated in this way to be easily
mixed with code not mitigated in this way and without completely losing the
value of the mitigation.</p>
<p>##### Embed the predicate state into the high bit(s) of the stack pointer</p>
<p>We can use the same technique that allows hardening pointers to pass the
predicate state into and out of functions. The stack pointer is trivially
passed between functions and we can test for it having the high bits set to
detect when it has been marked due to misspeculation. The callsite instruction
sequence looks like (assuming a misspeculated state value of <cite>-1</cite>):
<a href="#id153"><span class="problematic" id="id154">``</span></a><a href="#id155"><span class="problematic" id="id156">`</span></a></p>
<blockquote>
<div><p>…</p>
</div></blockquote>
<dl class="simple">
<dt>.LBB0_4:                                # %danger</dt><dd><p>cmovneq %r8, %rax               # Conditionally update predicate state.
shlq    $47, %rax
orq     %rax, %rsp
callq   other_function
movq    %rsp, %rax
sarq    63, %rax                # Sign extend the high bit to all bits.</p>
</dd>
</dl>
<p><a href="#id157"><span class="problematic" id="id158">``</span></a><a href="#id159"><span class="problematic" id="id160">`</span></a></p>
<p>This first puts the predicate state into the high bits of <cite>%rsp</cite> before calling
the function and then reads it back out of high bits of <cite>%rsp</cite> afterward. When
correctly executing (speculatively or not), these are all no-ops. When
misspeculating, the stack pointer will end up negative. We arrange for it to
remain a canonical address, but otherwise leave the low bits alone to allow
stack adjustments to proceed normally without disrupting this. Within the
called function, we can extract this predicate state and then reset it on
return:
<a href="#id161"><span class="problematic" id="id162">``</span></a>`
other_function:</p>
<blockquote>
<div><p># prolog
callq   other_function
movq    %rsp, %rax
sarq    63, %rax                # Sign extend the high bit to all bits.
# …</p>
</div></blockquote>
<dl class="simple">
<dt>.LBB0_N:</dt><dd><p>cmovneq %r8, %rax               # Conditionally update predicate state.
shlq    $47, %rax
orq     %rax, %rsp
retq</p>
</dd>
</dl>
<p><a href="#id163"><span class="problematic" id="id164">``</span></a><a href="#id165"><span class="problematic" id="id166">`</span></a></p>
<p>This approach is effective when all code is mitigated in this fashion, and can
even survive very limited reaches into unmitigated code (the state will
round-trip in and back out of an unmitigated function, it just won’t be
updated). But it does have some limitations. There is a cost to merging the
state into <cite>%rsp</cite> and it doesn’t insulate mitigated code from misspeculation in
an unmitigated caller.</p>
<p>There is also an advantage to using this form of interprocedural mitigation: by
forming these invalid stack pointer addresses we can prevent speculative
returns from successfully reading speculatively written values to the actual
stack. This works first by forming a data-dependency between computing the
address of the return address on the stack and our predicate state. And even
when satisfied, if a misprediction causes the state to be poisoned the
resulting stack pointer will be invalid.</p>
<p>##### Rewrite API of internal functions to directly propagate predicate state</p>
<p>(Not yet implemented.)</p>
<p>We have the option with internal functions to directly adjust their API to
accept the predicate as an argument and return it. This is likely to be
marginally cheaper than embedding into <cite>%rsp</cite> for entering functions.</p>
<p>##### Use <cite>lfence</cite> to guard function transitions</p>
<p>An <cite>lfence</cite> instruction can be used to prevent subsequent loads from
speculatively executing until all prior mispredicted predicates have resolved.
We can use this broader barrier to speculative loads executing between
functions. We emit it in the entry block to handle calls, and prior to each
return. This approach also has the advantage of providing the strongest degree
of mitigation when mixed with unmitigated code by halting all misspeculation
entering a function which is mitigated, regardless of what occured in the
caller. However, such a mixture is inherently more risky. Whether this kind of
mixture is a sufficient mitigation requires careful analysis.</p>
<p>Unfortunately, experimental results indicate that the performance overhead of
this approach is very high for certain patterns of code. A classic example is
any form of recursive evaluation engine. The hot, rapid call and return
sequences exhibit dramatic performance loss when mitigated with <cite>lfence</cite>. This
component alone can regress performance by 2x or more, making it an unpleasant
tradeoff even when only used in a mixture of code.</p>
<p>##### Use an internal TLS location to pass predicate state</p>
<p>We can define a special thread-local value to hold the predicate state between
functions. This avoids direct ABI implications by using a side channel between
callers and callees to communicate the predicate state. It also allows implicit
zero-initialization of the state, which allows non-checked code to be the first
code executed.</p>
<p>However, this requires a load from TLS in the entry block, a store to TLS
before every call and every ret, and a load from TLS after every call. As a
consequence it is expected to be substantially more expensive even than using
<cite>%rsp</cite> and potentially <cite>lfence</cite> within the function entry block.</p>
<p>##### Define a new ABI and/or calling convention</p>
<p>We could define a new ABI and/or calling convention to explicitly pass the
predicate state in and out of functions. This may be interesting if none of the
alternatives have adequate performance, but it makes deployment and adoption
dramatically more complex, and potentially infeasible.</p>
<p>## High-Level Alternative Mitigation Strategies</p>
<p>There are completely different alternative approaches to mitigating variant 1
attacks. [Most](<a class="reference external" href="https://lwn.net/Articles/743265/">https://lwn.net/Articles/743265/</a>)
[discussion](<a class="reference external" href="https://lwn.net/Articles/744287/">https://lwn.net/Articles/744287/</a>) so far focuses on mitigating
specific known attackable components in the Linux kernel (or other kernels) by
manually rewriting the code to contain an instruction sequence that is not
vulnerable. For x86 systems this is done by either injecting an <cite>lfence</cite>
instruction along the code path which would leak data if executed speculatively
or by rewriting memory accesses to have branch-less masking to a known safe
region. On Intel systems, <cite>lfence</cite> [will prevent the speculative load of secret
data](<a class="reference external" href="https://newsroom.intel.com/wp-content/uploads/sites/11/2018/01/Intel-Analysis-of-Speculative-Execution-Side-Channels.pdf">https://newsroom.intel.com/wp-content/uploads/sites/11/2018/01/Intel-Analysis-of-Speculative-Execution-Side-Channels.pdf</a>).
On AMD systems <cite>lfence</cite> is currently a no-op, but can be made
dispatch-serializing by setting an MSR, and thus preclude misspeculation of the
code path ([mitigation G-2 +
V1-1](<a class="reference external" href="https://developer.amd.com/wp-content/resources/Managing-Speculation-on-AMD-Processors.pdf">https://developer.amd.com/wp-content/resources/Managing-Speculation-on-AMD-Processors.pdf</a>)).</p>
<p>However, this relies on finding and enumerating all possible points in code
which could be attacked to leak information. While in some cases static
analysis is effective at doing this at scale, in many cases it still relies on
human judgement to evaluate whether code might be vulnerable. Especially for
software systems which receive less detailed scrutiny but remain sensitive to
these attacks, this seems like an impractical security model. We need an
automatic and systematic mitigation strategy.</p>
<p>### Automatic <cite>lfence</cite> on Conditional Edges</p>
<p>A natural way to scale up the existing hand-coded mitigations is simply to
inject an <cite>lfence</cite> instruction into both the target and fallthrough
destinations of every conditional branch. This ensures that no predicate or
bounds check can be bypassed speculatively. However, the performance overhead
of this approach is, simply put, catastrophic. Yet it remains the only truly
“secure by default” approach known prior to this effort and serves as the
baseline for performance.</p>
<p>One attempt to address the performance overhead of this and make it more
realistic to deploy is [MSVC’s /Qspectre
switch](<a class="reference external" href="https://blogs.msdn.microsoft.com/vcblog/2018/01/15/spectre-mitigations-in-msvc/">https://blogs.msdn.microsoft.com/vcblog/2018/01/15/spectre-mitigations-in-msvc/</a>).
Their technique is to use static analysis within the compiler to only insert
<cite>lfence</cite> instructions into conditional edges at risk of attack. However,
[initial](<a class="reference external" href="https://arstechnica.com/gadgets/2018/02/microsofts-compiler-level-spectre-fix-shows-how-hard-this-problem-will-be-to-solve/">https://arstechnica.com/gadgets/2018/02/microsofts-compiler-level-spectre-fix-shows-how-hard-this-problem-will-be-to-solve/</a>)
[analysis](<a class="reference external" href="https://www.paulkocher.com/doc/MicrosoftCompilerSpectreMitigation.html">https://www.paulkocher.com/doc/MicrosoftCompilerSpectreMitigation.html</a>)
has shown that this approach is incomplete and only catches a small and limited
subset of attackable patterns which happen to resemble very closely the initial
proofs of concept. As such, while its performance is acceptable, it does not
appear to be an adequate systematic mitigation.</p>
<p>## Performance Overhead</p>
<p>The performance overhead of this style of comprehensive mitigation is very
high. However, it compares very favorably with previously recommended
approaches such as the <cite>lfence</cite> instruction. Just as users can restrict the
scope of <cite>lfence</cite> to control its performance impact, this mitigation technique
could be restricted in scope as well.</p>
<p>However, it is important to understand what it would cost to get a fully
mitigated baseline. Here we assume targeting a Haswell (or newer) processor and
using all of the tricks to improve performance (so leaves the low 2gb
unprotected and +/- 2gb surrounding any PC in the program). We ran both
Google’s microbenchmark suite and a large highly-tuned server built using
ThinLTO and PGO. All were built with <cite>-march=haswell</cite> to give access to BMI2
instructions, and benchmarks were run on large Haswell servers. We collected
data both with an <cite>lfence</cite>-based mitigation and load hardening as presented
here. The summary is that mitigating with load hardening is 1.77x faster than
mitigating with <cite>lfence</cite>, and the overhead of load hardening compared to a
normal program is likely between a 10% overhead and a 50% overhead with most
large applications seeing a 30% overhead or less.</p>
<div class="line-block">
<div class="line">Benchmark                              | <cite>lfence</cite> | Load Hardening | Mitigated Speedup |</div>
<div class="line">————————————– | ——-: | ————-: | —————-: |</div>
<div class="line">Google microbenchmark suite            |   -74.8% |         -36.4% |          <strong>2.5x</strong> |</div>
<div class="line">Large server QPS (using ThinLTO &amp; PGO) |   -62%   |         -29%   |          <strong>1.8x</strong> |</div>
</div>
<p>Below is a visualization of the microbenchmark suite results which helps show
the distribution of results that is somewhat lost in the summary. The y-axis is
a log-scale speedup ratio of load hardening relative to <cite>lfence</cite> (up -&gt; faster
-&gt; better). Each box-and-whiskers represents one microbenchmark which may have
many different metrics measured. The red line marks the median, the box marks
the first and third quartiles, and the whiskers mark the min and max.</p>
<p>![Microbenchmark result visualization](speculative_load_hardening_microbenchmarks.png)</p>
<p>We don’t yet have benchmark data on SPEC or the LLVM test suite, but we can
work on getting that. Still, the above should give a pretty clear
characterization of the performance, and specific benchmarks are unlikely to
reveal especially interesting properties.</p>
<p>### Future Work: Fine Grained Control and API-Integration</p>
<p>The performance overhead of this technique is likely to be very significant and
something users wish to control or reduce. There are interesting options here
that impact the implementation strategy used.</p>
<p>One particularly appealing option is to allow both opt-in and opt-out of this
mitigation at reasonably fine granularity such as on a per-function basis,
including intelligent handling of inlining decisions – protected code can be
prevented from inlining into unprotected code, and unprotected code will become
protected when inlined into protected code. For systems where only a limited
set of code is reachable by externally controlled inputs, it may be possible to
limit the scope of mitigation through such mechanisms without compromising the
application’s overall security. The performance impact may also be focused in a
few key functions that can be hand-mitigated in ways that have lower
performance overhead while the remainder of the application receives automatic
protection.</p>
<p>For both limiting the scope of mitigation or manually mitigating hot functions,
there needs to be some support for mixing mitigated and unmitigated code
without completely defeating the mitigation. For the first use case, it would
be particularly desirable that mitigated code remains safe when being called
during misspeculation from unmitigated code.</p>
<p>For the second use case, it may be important to connect the automatic
mitigation technique to explicit mitigation APIs such as what is described in
<a class="reference external" href="http://wg21.link/p0928">http://wg21.link/p0928</a> (or any other eventual API) so that there is a clean way
to switch from automatic to manual mitigation without immediately exposing a
hole. However, the design for how to do this is hard to come up with until the
APIs are better established. We will revisit this as those APIs mature.</p>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="_sources/SpeculativeLoadHardening.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>