<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>“”” This file contains tf.train.SessionRunHooks defined by TWML “””
from datetime import datetime
import json
import operator
import os</p>
<p>from absl import logging
import numpy as np
import tensorflow.compat.v1 as tf
from tensorflow.python.training.basic_session_run_hooks import NeverTriggerTimer, SecondOrStepTimer
import twml</p>
<dl>
<dt>class StepProgressHook(tf.train.SessionRunHook):</dt><dd><p>“””Hook that displays a progress bar to monitor global step progress “””</p>
<dl>
<dt>def __init__(self, max_step):</dt><dd><p>“””
Initializes a <cite>StepProgressHook</cite>.
This hook displays a progress bar for max_steps.</p>
<p>Note that this hook only works for training and calibration.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>max_steps:</dt><dd><p>maximum steps to monitor in progress bar.
When this many steps is reached, the progress bar will be full.</p>
</dd>
</dl>
</dd>
</dl>
<p>“””
self._max_step = max_step
self._start_step = 0
self._global_step_tensor = None
self._progress_bar = None</p>
</dd>
<dt>def begin(self):</dt><dd><p>“”” sets the global_step_tensor “””
self._global_step_tensor = tf.train.get_or_create_global_step()
if self._global_step_tensor is None:</p>
<blockquote>
<div><p>raise RuntimeError(“Global step should be created to use StepProgressHook.”)</p>
</div></blockquote>
</dd>
<dt>def after_create_session(self, session, coord):</dt><dd><p>“”” creates the progress bar and keeps track of the first global step upon session creation “””
global_step = session.run(self._global_step_tensor)
self._start_step = global_step
self._progress_bar = tf.keras.utils.Progbar(self._max_step)</p>
</dd>
<dt>def before_run(self, run_context):  # pylint: disable=unused-argument</dt><dd><p>“”” invoked before calling session.run “””
return tf.train.SessionRunArgs(self._global_step_tensor)</p>
</dd>
<dt>def after_run(self, run_context, run_values):</dt><dd><p>“”” invoked after run is called. Updates the progress bar. “””
step = run_context.session.run(self._global_step_tensor)
self._progress_bar.update(step - self._start_step)</p>
</dd>
</dl>
</dd>
<dt>class GetMetricsHook(tf.train.SessionRunHook):</dt><dd><p>“””
Hook used to obtain evaluation metrics.
Typically used for early-stopping by obtaining the value of a
metric at the end of an epoch.
Note that the metric tensor and its commensurate update Op
are responsible for aggregating the metric during the session
(one session per epoch). Used for evaluation.
“””</p>
<dl>
<dt>def __init__(self, get_metrics_fn):</dt><dd><p>“””GetMetricsHook constructor.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>get_metrics_fn:</dt><dd><p>Function that returns a dict mapping metric keys to
tensors as a tf.Tensor.
See Trainer.learn for an example use-case.</p>
</dd>
</dl>
</dd>
</dl>
<p>“””</p>
<p>self._get_metrics_fn = get_metrics_fn
self._metric_tensors = None
self.metric_values = None</p>
</dd>
<dt>def begin(self):</dt><dd><p>“”” sets the global_step_tensor and metric tensor”””
self._metric_tensors = self._get_metrics_fn()
assert isinstance(self._metric_tensors, dict)</p>
</dd>
<dt>def end(self, session):</dt><dd><p>self.metric_values = session.run(self._metric_tensors)</p>
</dd>
</dl>
</dd>
<dt>class EarlyStopHook(GetMetricsHook):</dt><dd><p>“””
A GetMetricsHook augmented with early-stopping logic for use
within the Trainer.learn method.
“””</p>
<dl>
<dt>def __init__(self,</dt><dd><blockquote>
<div><p>metric,
patience,
minimize,
get_estimator_spec_fn,
checkpoint_dir,
file_path=None,
exit_on_end=True,
start_epoch=0,
tolerance=0):</p>
</div></blockquote>
<p>“””
Prepare early-stopping hook and variables.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>metric:</dt><dd><p>String specifying the metric to early-stop on. Required with positive
<code class="docutils literal notranslate"><span class="pre">early_stop_patience</span></code>. For example, ‘accuracy’, ‘accuracy_0’, ‘loss’, etc.
The string is used to extract the relevant tensor Op from the dict returned by
the get_eval_metric_ops method. For <code class="docutils literal notranslate"><span class="pre">metrics</span></code> pass to the constructor,
the string is one of those. For multi-class (that is, multi-metric)
metrics, the string may be appended with a <code class="docutils literal notranslate"><span class="pre">_0</span></code>, <code class="docutils literal notranslate"><span class="pre">_1</span></code>, etc. or one
of the <code class="docutils literal notranslate"><span class="pre">multi_metric_names</span></code> (one per class).</p>
</dd>
<dt>patience:</dt><dd><p>Maximum number of epochs to wait for an improvement in the early_stop_metric
before breaking off training. For example, a patience of 10 means that
training will have 10 epochs to improve the metric before it is killed.
Whenever the metric is improved before running out of patience,
patience is reset to <code class="docutils literal notranslate"><span class="pre">early_stop_patience</span></code>.</p>
</dd>
<dt>minimize:</dt><dd><p>Set this to True for metrics that need to be minimized
(like <code class="docutils literal notranslate"><span class="pre">loss</span></code>). Metrics like <code class="docutils literal notranslate"><span class="pre">accuracy</span></code> that need to be maximized
should set this to False.</p>
</dd>
<dt>tolerance:</dt><dd><p>A non-negative tolerance for comparing early_stop_metric.
e.g. when maximizing the condition is current_metric &gt; best_metric + tolerance.”
Defaults to 0.</p>
</dd>
<dt>get_estimator_spec_fn:</dt><dd><p>function that returns the current EstimatorSpec.
The EstimatorSpec is used to obtain the current eval_metric_ops.</p>
</dd>
<dt>checkpoint_dir:</dt><dd><p>path to directory containing the Estimator checkpoints.</p>
</dd>
<dt>file_path:</dt><dd><p>path to file that is used by this hook to communicate early-stopping
to StopIfExistsHook. This hook would be used for evaluation, while
the StopIfExistsHooks (the listeners) would be used for training.
When the file is created, the StopIfExistsHooks detect and terminate training.
This argument is used by <code class="docutils literal notranslate"><span class="pre">Trainer.train_and_evaluate</span></code>.</p>
</dd>
<dt>exit_on_end:</dt><dd><p>when the end() method is called to indicate that the session is terminating,
and exit_on_end is True, twml.errors.EarlyStopError() is triggered to stop the evaluation job.
This is set to False by the trainer for non distributed jobs.</p>
</dd>
<dt>start_epoch:</dt><dd><p>Specifies the starting epoch number. This is used for logging purposes only.</p>
</dd>
</dl>
</dd>
</dl>
<p>“””
if not isinstance(metric, str):</p>
<blockquote>
<div><p>raise ValueError(“Expecting string for metric arg”)</p>
</div></blockquote>
<dl class="simple">
<dt>if not isinstance(patience, int):</dt><dd><p>raise ValueError(“Expecting positive number for metric arg”)</p>
</dd>
</dl>
<p>self.should_stop = False
self._metric = metric
self._patience = patience
self._current_patience = patience
self._checkpoint_dir = checkpoint_dir
self._exit_on_end = exit_on_end
self._latest_checkpoint_path = None
# used for distributed training (tf.estimator.train_and_evaluate)
self._file_path = file_path
self._epoch = start_epoch
if self._file_path is not None:</p>
<blockquote>
<div><p># TODO try to read epoch from a file that we create
if tf.io.gfile.exists(self._file_path):</p>
<blockquote>
<div><p># delete the file if it exists (not sure this makes sense)
logging.info(“EarlyStopHook: Removing existing file: %s.”, self._file_path)
tf.io.gfile.remove(self._file_path)</p>
</div></blockquote>
</div></blockquote>
<p># best_checkpoint dir will contain the best checkpoint
self._best_checkpoint_path = os.path.join(checkpoint_dir, ‘best_checkpoint’)
self._eval_checkpoint_path = os.path.join(checkpoint_dir, ‘eval_checkpoint’)
self._best_metric_path = os.path.join(self._best_checkpoint_path, self._metric)</p>
<dl>
<dt>if tf.io.gfile.exists(self._best_metric_path):</dt><dd><dl class="simple">
<dt>with tf.io.gfile.GFile(self._best_metric_path, mode=”r”) as f:</dt><dd><p>best_metric_from_file = float(f.read())</p>
</dd>
</dl>
</dd>
<dt>else:</dt><dd><p>best_metric_from_file = None</p>
</dd>
<dt>if minimize:</dt><dd><p># current &lt; best : is better
self._is_better_than = operator.lt
# worse metric possible
if best_metric_from_file is None:</p>
<blockquote>
<div><p>self._best_metric = np.inf</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>self._best_metric = best_metric_from_file - tolerance</p>
</dd>
</dl>
<p># used for printing
self._early_stop_name = “minimum”</p>
</dd>
<dt>else:</dt><dd><p># current &gt; best : is better
self._is_better_than = operator.gt
# worse metric possible
if best_metric_from_file is None:</p>
<blockquote>
<div><p>self._best_metric = -np.inf</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>self._best_metric = best_metric_from_file + tolerance</p>
</dd>
</dl>
<p># used for printing
self._early_stop_name = “maximum”</p>
</dd>
<dt>def get_metrics_fn():</dt><dd><p>“”” function to get metric tensors to early-stopping “””
estimator_spec = get_estimator_spec_fn()
eval_metric_ops = estimator_spec.eval_metric_ops
if metric not in eval_metric_ops:</p>
<blockquote>
<div><dl class="simple">
<dt>raise ValueError(</dt><dd><p>“Expecting early_stop_metric ‘%s’ key in eval_metric_ops dict”
% (metric))</p>
</dd>
</dl>
</div></blockquote>
<p># get the value_op from the (value_op, update_op) value
return {k: v[0] for k, v in eval_metric_ops.items()}</p>
</dd>
</dl>
<p># initialize GetMetricsHook to get current value of metric from session
super(EarlyStopHook, self).__init__(get_metrics_fn=get_metrics_fn)</p>
</dd>
<dt>def early_stop(self, epoch):</dt><dd><p>“””
Looks at the current value of the early stopping metric.
Decrements current patience. If metric improves, patience is reset
and latest checkpoint is moved to checkpoint_dir/best_checkpoint.
If current patience reaches zero, returns True.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>epoch:</dt><dd><p>The current epoch number.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>True when early-stopped. False otherwise.</p>
</dd>
</dl>
<p>“””
# decrement patience
self._current_patience -= 1</p>
<p># get the current metric value
current_metric = self.metric_values[self._metric]</p>
<dl>
<dt>if self._is_better_than(current_metric, self._best_metric):</dt><dd><p># save best version of model
self._best_metric = current_metric
logging.info(</p>
<blockquote>
<div><p>“Found new %s %s=%f &#64; epoch %d”,
self._early_stop_name, self._metric, self._best_metric, epoch)</p>
</div></blockquote>
<p># backup the file to checkpoint_dir/best_checkpoint
assert self._latest_checkpoint_path, “expecting latest checkpoint”
logging.info(“Backing up “ + self._latest_checkpoint_path)</p>
<dl>
<dt>try:</dt><dd><p>eval_checkpoint = tf.train.latest_checkpoint(self._eval_checkpoint_path)
twml.util.backup_checkpoint(</p>
<blockquote>
<div><p>checkpoint_path_prefix=eval_checkpoint,
backup_path=self._best_checkpoint_path)</p>
</div></blockquote>
</dd>
<dt>except twml.errors.CheckpointNotFoundError as ex:</dt><dd><p>msg = “Consider increasing ‘keep_checkpoint_max’ or ‘save_checkpoint_secs’”
raise twml.errors.CheckpointNotFoundError(str(ex) + “n” + msg)</p>
</dd>
</dl>
<p>tf.io.gfile.makedirs(os.path.dirname(self._best_metric_path))
with tf.io.gfile.GFile(self._best_metric_path, mode=”w”) as f:</p>
<blockquote>
<div><p># Write with enough precision
f.write(“%.8f” % self._best_metric)</p>
</div></blockquote>
<p># reset patience
self._current_patience = self._patience</p>
</dd>
<dt>elif self._current_patience &gt; 0:</dt><dd><dl class="simple">
<dt>logging.info(“No new %s found after %d epochs”,</dt><dd><p>self._early_stop_name, self._patience - self._current_patience)</p>
</dd>
</dl>
</dd>
<dt>elif self._current_patience == 0:</dt><dd><dl class="simple">
<dt>logging.info(</dt><dd><p>“No new %s found after %d epochs. Early-stopping experiment.”,
self._early_stop_name, self._patience)</p>
</dd>
</dl>
<p>return True</p>
</dd>
</dl>
<p>return False</p>
</dd>
<dt>def cleanup_checkpoints(self):</dt><dd><p>“””
makes it so that the best checkpoint is the only checkpoint
in checkpoint_dir.
“””
raise NotImplementedError(“cleanup_checkpoints is no longer supported”)</p>
</dd>
<dt>def end(self, session):</dt><dd><p>“””
This method is called at the end of an evaluation/epoch.
When file_path constructor argument is provided, this
will call <code class="docutils literal notranslate"><span class="pre">early_stop()</span></code>.
When <code class="docutils literal notranslate"><span class="pre">early_stop()</span></code> returns True, it creates the file_path,
which will be detected by StopIfExistsHooks
and stop training for all workers and the chief. It will
also call <code class="docutils literal notranslate"><span class="pre">cleanup_checkpoints()</span></code>.
“””
super(EarlyStopHook, self).end(session)</p>
<p># Checks for early stopping criteria and makes a backup
self.should_stop = self.early_stop(self._epoch)</p>
<dl>
<dt>if self._file_path is not None:</dt><dd><dl>
<dt>if self.should_stop:</dt><dd><p># create a file to inform workers
with tf.io.gfile.GFile(self._file_path, “wb”) as gfile:</p>
<blockquote>
<div><p>gfile.write(“early-stopn”)</p>
</div></blockquote>
<p># makes the best checkpoint the only checkpoint in save_dir.
msg = “early-stopping evaluation at epoch %d” % self._epoch
logging.info(msg)
if self._exit_on_end:</p>
<blockquote>
<div><p>raise twml.errors.EarlyStopError(msg)</p>
</div></blockquote>
</dd>
<dt>else:</dt><dd><p>self._latest_checkpoint_path = None</p>
</dd>
</dl>
</dd>
</dl>
<p>self._epoch += 1</p>
</dd>
<dt>def begin(self):</dt><dd><p>“””
Saves the latest_checkpoint in case it gets superseded by another checkpoint.
Remember that when used with train_and_evaluate, the chief saves checkpoints
continuouly. The chief could save a checkpoint after evaluation started.
So saving the checkpoint at the beginning of evaluation ensures that we
later save the correct best checkpoint.
“””
super(EarlyStopHook, self).begin()
self._latest_checkpoint_path = tf.train.latest_checkpoint(self._checkpoint_dir)</p>
<p>assert self._latest_checkpoint_path, “expecting latest checkpoint”
# Backup to temporary directory
try:</p>
<blockquote>
<div><dl class="simple">
<dt>twml.util.backup_checkpoint(</dt><dd><p>checkpoint_path_prefix=self._latest_checkpoint_path,
backup_path=self._eval_checkpoint_path)</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>except twml.errors.CheckpointNotFoundError as ex:</dt><dd><p>msg = “Consider increasing ‘keep_checkpoint_max’ or ‘save_checkpoint_secs’”
raise twml.errors.CheckpointNotFoundError(str(ex) + “n” + msg)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>class MetricsUpdateHook(GetMetricsHook):</dt><dd><p>“””
A GetMetricsHook augmented with logic to map SessionRun events to metrics updates.
It is mainly used by <cite>TrackRun</cite> to persist model metrics via Model Repo.
“””</p>
<dl>
<dt>def __init__(self,</dt><dd><blockquote>
<div><p>get_estimator_spec_fn,
add_metrics_fn,
every_n_iter=None,
every_n_secs=None
):</p>
</div></blockquote>
<p>“””
Args:</p>
<blockquote>
<div><dl class="simple">
<dt>get_estimator_spec_fn:</dt><dd><p>function that returns the current EstimatorSpec.
The EstimatorSpec is used to obtain the current eval_metric_ops.</p>
</dd>
<dt>add_metrics_fn: <cite>function</cite> callback used to report metrics, called automatically</dt><dd><p>at the end of every epoch.</p>
</dd>
<dt>every_n_iter: <cite>int</cite>, log the metrics once every N local</dt><dd><p>steps taken in the current epoch.</p>
</dd>
<dt>every_n_secs: <cite>int</cite> or <cite>float</cite>, log the metrics once every N</dt><dd><p>seconds passed in the current epoch. Exactly one of <cite>every_n_iter</cite> and <cite>every_n_secs</cite>
should be provided.</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Raises:</dt><dd><dl class="simple">
<dt>ValueError: if <cite>every_n_iter</cite> is non-positive or if not exactly one of <cite>every_n_iter</cite> and</dt><dd><p><cite>every_n_secs</cite> is set when <cite>add_progress_metrics_fn</cite> is provided.</p>
</dd>
</dl>
</dd>
</dl>
<p>“””
only_log_at_end = (every_n_iter is None) and (every_n_secs is None)</p>
<dl>
<dt>if (not only_log_at_end and every_n_iter and every_n_secs):</dt><dd><dl class="simple">
<dt>raise ValueError(</dt><dd><p>‘exactly one of every_n_iter and every_n_secs must be provided’</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p># TODO: should have a minimum to avoid too many calls to ModelRepo?
if every_n_iter is not None and every_n_iter &lt;= 0:</p>
<blockquote>
<div><p>raise ValueError(“invalid every_n_iter=%s.” % every_n_iter)</p>
</div></blockquote>
<dl class="simple">
<dt>self._timer = (</dt><dd><p>NeverTriggerTimer() if only_log_at_end else
SecondOrStepTimer(every_secs=every_n_secs, every_steps=every_n_iter)</p>
</dd>
</dl>
<p>)</p>
<p>self._should_trigger = False
self._iter_count = 0</p>
<p>self._add_metrics_fn = add_metrics_fn</p>
<dl>
<dt>def get_metrics_fn():</dt><dd><p>“””
Function that returns the current EstimatorSpec.</p>
<blockquote>
<div><p>The EstimatorSpec is used to obtain the current eval_metric_ops.</p>
</div></blockquote>
<p>“””
estimator_spec = get_estimator_spec_fn()
eval_metric_ops = estimator_spec.eval_metric_ops
# get the value_op from the (value_op, update_op) value
return {k: v[0] for k, v in eval_metric_ops.items()}</p>
</dd>
</dl>
<p>super(MetricsUpdateHook, self).__init__(get_metrics_fn=get_metrics_fn)</p>
</dd>
<dt>def report_metrics(self):</dt><dd><p>“””
Triggers a metrics report.
“””
self._timer.update_last_triggered_step(self._iter_count)
if self.metric_values is not None:</p>
<blockquote>
<div><p>self._add_metrics_fn(self.metric_values)</p>
</div></blockquote>
</dd>
<dt>def begin(self):</dt><dd><p>“””
Triggered before each epoch.
“””
self._timer.reset()
self._iter_count = 0
return super(MetricsUpdateHook, self).begin()</p>
</dd>
<dt>def before_run(self, run_context):</dt><dd><p>“””
Triggered before each step.
“””
self._should_trigger = self._timer.should_trigger_for_step(self._iter_count)
return super(MetricsUpdateHook, self).before_run(run_context)</p>
</dd>
<dt>def after_run(self, run_context, run_values):</dt><dd><p>“””
Triggered after each step.
“””
if self._should_trigger:</p>
<blockquote>
<div><p>self.report_metrics()</p>
</div></blockquote>
<p>self._iter_count += 1
return super(MetricsUpdateHook, self).after_run(run_context, run_values)</p>
</dd>
<dt>def end(self, session):</dt><dd><p>“””
Triggered after each epoch.
“””
self.report_metrics()
return super(MetricsUpdateHook, self).end(session)</p>
</dd>
</dl>
</dd>
<dt>class EarlyStopDuration(tf.train.SessionRunHook):</dt><dd><p>“””
Hook that can be used to terminate a job (training or validation) after a certain duration.
The hook is fault tolerant, i.e., if a job is allotted 1 hour to run and fails after 45 minutes,
then it will only run for 15 minutes once restarted.</p>
<dl>
<dt>Args:</dt><dd><blockquote>
<div><dl class="simple">
<dt>max_duration:</dt><dd><p>A float. When this argument is defined, the job will automatically terminate after
<cite>max_duration</cite> seconds if it has not already compeleted.</p>
</dd>
<dt>overwrite:</dt><dd><p>A boolean. If set to True, this hook will overwrite the file containing the elapsed time
since the beginning of the job. In a distributed setting, this will be used so only one
job writes to the file while all others will have read access. In a distributed setting,
if all executors have this parameter set to False, then it just means that the hook will
not be fault tolerant. When restarted, the job will restart the clock from 0.</p>
</dd>
<dt>save_dir:</dt><dd><p>String. A directory (located on a file system that is Tensorflow compatible) where
we can store the file which contains the record of the elapsed time. This file is what makes
the hook faul tolerant.</p>
</dd>
<dt>exit_on_end:</dt><dd><p>when exit_on_end is True, twml.errors.EarlyStopError() is triggered to stop the job.
This is usually set to True to kill a validation job in a distributed setting.</p>
</dd>
</dl>
</div></blockquote>
<p>“””</p>
</dd>
<dt>def __init__(self, max_duration: float, exit_on_end: bool, save_dir: str, overwrite: bool):</dt><dd><p>self._overwrite = overwrite
self._save_dir = save_dir
self._exit_on_end = exit_on_end
self._max_duration = max_duration
self._last_time_check = datetime.now()</p>
<p># Initialize elapse time file
if overwrite:</p>
<blockquote>
<div><p>self.elapsed_time()</p>
</div></blockquote>
</dd>
</dl>
<p>&#64;property
def elapsed_file_path(self):</p>
<blockquote>
<div><p>return os.path.join(self._save_dir, “early_stop_duration.txt”)</p>
</div></blockquote>
<dl>
<dt>def early_stop(self) -&gt; bool:</dt><dd><p>return self.elapsed_time() &gt; self._max_duration</p>
</dd>
<dt>def elapsed_time(self) -&gt; float:</dt><dd><p># Recorded elapsed time is 0 unless it’s been recorded in a file already
recorded_elapsed_time = 0
if tf.io.gfile.exists(self.elapsed_file_path):</p>
<blockquote>
<div><dl class="simple">
<dt>with tf.io.gfile.GFile(self.elapsed_file_path, mode=”r”) as file:</dt><dd><p>recorded_elapsed_time = json.loads(file.read())[“elapsed_time”]</p>
</dd>
</dl>
</div></blockquote>
<p>elapsed_time = recorded_elapsed_time + (datetime.now() - self._last_time_check).total_seconds()
self._last_time_check = datetime.now()</p>
<dl>
<dt>if self._overwrite:</dt><dd><p># Record the actualized new elapsed time to the file
tf.io.gfile.makedirs(os.path.dirname(self.elapsed_file_path))
with tf.io.gfile.GFile(self.elapsed_file_path, mode=”w”) as file:</p>
<blockquote>
<div><dl class="simple">
<dt>record = {</dt><dd><p>“elapsed_time”: elapsed_time,
“max_duration”: self._max_duration</p>
</dd>
</dl>
<p>}
file.write(json.dumps(record, indent=2))</p>
</div></blockquote>
</dd>
</dl>
<p>return elapsed_time</p>
</dd>
<dt>def before_run(self, run_context: tf.estimator.SessionRunContext) -&gt; None:</dt><dd><dl>
<dt>if self.early_stop():</dt><dd><dl class="simple">
<dt>message = f”””</dt><dd><p>Stopping job which now exceeded the maximum duration of {self._max_duration} seconds.</p>
</dd>
</dl>
<p>“””
logging.info(message)
run_context.request_stop()</p>
<dl class="simple">
<dt>if self._exit_on_end:</dt><dd><p>raise twml.errors.EarlyStopError(message)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>class StopAtStepHook(tf.train.StopAtStepHook):</dt><dd><p>“””
Overrides <code class="docutils literal notranslate"><span class="pre">tf.train.StopAtStepHook</span></code> so that
a <code class="docutils literal notranslate"><span class="pre">stop_requested</span></code> property can be accessed to determine
if this hook requested a stop.
“””</p>
<dl class="simple">
<dt>def __init__(self, <a href="#id1"><span class="problematic" id="id2">*</span></a>args, <a href="#id3"><span class="problematic" id="id4">**</span></a>kwargs):</dt><dd><p>super(StopAtStepHook, self).__init__(<a href="#id5"><span class="problematic" id="id6">*</span></a>args, <a href="#id7"><span class="problematic" id="id8">**</span></a>kwargs)
self._stop_requested = False</p>
</dd>
</dl>
<p>&#64;property
def stop_requested(self):</p>
<blockquote>
<div><p>“”” true if this hook requested a stop “””
return self._stop_requested</p>
</div></blockquote>
<dl class="simple">
<dt>def after_run(self, run_context, run_values):</dt><dd><p>“”” sets self.stop_requested to true when requesting a stop “””
super(StopAtStepHook, self).after_run(run_context, run_values)
self._stop_requested = run_context.stop_requested</p>
</dd>
</dl>
</dd>
<dt>class StopIfExistsHook(tf.train.SessionRunHook):</dt><dd><p>“””
Hook that requests stop if a file exists.
This hook is used with the EarlyStopHook to implement
early-stopping for distributed training (tf.estimator.train_and_evaluate).
“””</p>
<dl>
<dt>def __init__(self, file_path):</dt><dd><p>“””
Arguments:</p>
<blockquote>
<div><dl class="simple">
<dt>file_path:</dt><dd><p>path to file. When this hook detects that the file exists,
it requests a stop, which effectively kills this worker.</p>
</dd>
</dl>
</div></blockquote>
<p>“””
self._file_path = file_path
self._stop_requested = False</p>
</dd>
<dt>def after_run(self, run_context, run_values):</dt><dd><dl class="simple">
<dt>if tf.io.gfile.exists(self._file_path):</dt><dd><p>logging.info(“Early-stopping file detected; requesting stop”)
run_context.request_stop()
self._stop_requested = True</p>
</dd>
</dl>
</dd>
</dl>
<p>&#64;property
def stop_requested(self):</p>
<blockquote>
<div><p>“”” true if this hook requested a stop “””
return self._stop_requested</p>
</div></blockquote>
</dd>
</dl>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../_sources/twml/twml/hooks.py.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>