<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>“””
This module contains utility functions for twml.
“””</p>
<p>import argparse
from datetime import datetime
import itertools
import json
import logging as _logging
import os
import re</p>
<p>from twitter.ml.common.resources import AuroraPath
from twitter.deepbird.hparam import HParams
from twitter.deepbird.io.util import (</p>
<blockquote>
<div><p>_get_feature_id,  # noqa: F401
feature_id,  # noqa: F401
preprocess_feature_regex,  # noqa: F401
preprocess_path,  # noqa: F401
sanitize_hdfs_path,  # noqa: F401
is_string,  # noqa: F401
list_files,  # noqa: F401
match_files,  # noqa: F401</p>
</div></blockquote>
<p>)
from twitter.deepbird.io.legacy.util import (</p>
<blockquote>
<div><p>batch_apply,  # noqa: F401
boolean_mask,  # noqa: F401
fixed_length_tensor,  # noqa: F401</p>
</div></blockquote>
<p>)
from twitter.deepbird.sparse.util import (</p>
<blockquote>
<div><p>convert_to_sparse,  # noqa: F401
limit_bits,  # noqa: F401</p>
</div></blockquote>
<p>)</p>
<p>from dateutil import rrule
from joblib import delayed, Parallel
from six import string_types</p>
<p>from absl import logging
from libtwml import CLIB, OPLIB  # noqa: F401
import tensorflow.compat.v1 as tf
from tensorflow.python.platform import tf_logging
import twml
from twml.feature_config import FeatureConfigBuilder</p>
<p># big_prime is less than 2**32
# This just needs to be co-prime with powers of 2
# any large prime is sufficient, but it’s not necessary.
HASHING_PRIME = 2479700537</p>
<dl>
<dt>def multiplicative_hash(input, hash_constant=HASHING_PRIME):</dt><dd><p>return input * hash_constant</p>
</dd>
<dt>def _return_tensors_from_checkpoint_folder(init_dir, model_name=None):</dt><dd><p>“””Returns tensors list from a checkpoint folder</p>
<dl>
<dt>Args:</dt><dd><p>init_dir: Name of the checkpoint directory.
model_name: the model which we will use to obtain the checkpoint</p>
<blockquote>
<div><p>(e.g. model.ckpt-50000) if set to None it will default to the
latest model saved in the checkpont file.</p>
</div></blockquote>
</dd>
</dl>
<p>“””
if model_name is None:</p>
<blockquote>
<div><p># gets the most recently generated model.cpkt file
model_path = tf.train.latest_checkpoint(init_dir)
if model_path is None:</p>
<blockquote>
<div><p>raise ValueError(“Could not find a valid model checkpoint inside the directory”)</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>model_path = os.path.join(init_dir, model_name)</p>
</dd>
</dl>
<p>reader = tf.train.NewCheckpointReader(model_path)
try:</p>
<blockquote>
<div><p>return (reader.debug_string().decode(“utf-8”))</p>
</div></blockquote>
<dl class="simple">
<dt>except OSError:</dt><dd><p>logging.error(‘Could not decode the string’)</p>
</dd>
</dl>
</dd>
<dt>def get_scope_dict(init_dir, incoming_scope_name, current_scope_name, model_name=None):</dt><dd><p>“””Returns tensors map from a checkpoint file.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>file_name:</dt><dd><p>Name of the checkpoint directory.</p>
</dd>
<dt>incoming_scope_name:</dt><dd><p>scope name of the previous phase</p>
</dd>
<dt>current_scope_name:</dt><dd><p>scope name of current phase</p>
</dd>
<dt>model_name:</dt><dd><p>the model which we will use to obtain the checkpoint
(e.g. model.ckpt-50000) if set to None it will default
to the latest model saved in the checkpoint file.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><dl class="simple">
<dt>init_map:</dt><dd><p>init_map which will be inputted to the checkpoint</p>
</dd>
</dl>
</dd>
</dl>
<p>“””
init_map = {}
reader_dump = _return_tensors_from_checkpoint_folder(init_dir=init_dir,</p>
<blockquote>
<div><p>model_name=model_name).splitlines()</p>
</div></blockquote>
<dl>
<dt>for member in reader_dump:</dt><dd><p># remove global_step since it is not necessary
if ‘global_step’ not in member:</p>
<blockquote>
<div><p>saved_variables = str(member.split(” “)[0])
saved_scope = saved_variables.rsplit(‘/’, 1)[0] + “/”
new_scope = saved_scope.replace(incoming_scope_name, current_scope_name, 1)
# create key in init_map
if saved_scope not in init_map.keys():  # pylint: disable=dict-keys-not-iterating</p>
<blockquote>
<div><p>init_map[saved_scope] = new_scope</p>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
<p>return init_map</p>
</dd>
<dt>def get_init_map(</dt><dd><blockquote>
<div><p>init_from_dir,
exclude_var_names=None,
exclude_name_scopes=None,
name_scope_to_remove=None,
name_scope_to_prepend=None):</p>
</div></blockquote>
<p>“””
Builds a map for initializing from a checkpoint (see tf.train.init_from_checkpoint).</p>
<p>It assumes that the latter part of the variable names are consistent between the checkpoint and
the new model, but their name_scopes may be different. If the checkpoint model has variable names
of the form old/scope/var/foo, and the corresponding variable names for the new model should be
my/new/scope/var/foo, then you should set name_scope_to_remove = ‘old/’ and
name_scope_to_prepend = ‘my/new/’.</p>
<p>This function can be used to</p>
<ol class="arabic simple">
<li><p>Generate an <code class="docutils literal notranslate"><span class="pre">init_map</span></code> map that can be passed to the <code class="docutils literal notranslate"><span class="pre">Trainer</span></code> init or</p></li>
<li><p>Used to generate an <code class="docutils literal notranslate"><span class="pre">init_map</span></code> directly inside <code class="docutils literal notranslate"><span class="pre">build_graph_fn</span></code>, in
which case it should be passed directly to <code class="docutils literal notranslate"><span class="pre">tf.train.init_from_checkpoint</span></code> inside
<code class="docutils literal notranslate"><span class="pre">build_graph_fn</span></code>, in which case you do not also need to specify the <code class="docutils literal notranslate"><span class="pre">init_map</span></code> argument to
the trainer.</p></li>
</ol>
<p>init_from_dir: Directory containing checkpoint
exclude_var_names: list[str]</p>
<blockquote>
<div><p>List of variables in the checkpoint that should be excluded from the map.</p>
</div></blockquote>
<dl class="simple">
<dt>exclude_name_scopes: list[str]</dt><dd><p>List of name_scopes in the checkpoint model that should be excluded from the map.</p>
</dd>
<dt>name_scope_to_remove: str</dt><dd><p>portion of name_scope for checkpoint variables that should not be included in variable names
for new model.</p>
</dd>
<dt>name_scope_to_prepend: str</dt><dd><p>name_scope to prepend to variable names in checkpoint to give variable names for new model.</p>
</dd>
</dl>
<dl class="simple">
<dt>dict</dt><dd><p>keys are variable names in the checkpoint and values are variable names in the new model,
into which the checkpoint parameters should be loaded.</p>
</dd>
</dl>
<p>“””
vars_to_restore = get_checkpoint_variable_names(</p>
<blockquote>
<div><p>init_from_dir,
exclude_var_names=exclude_var_names,
exclude_scopes=exclude_name_scopes,</p>
</div></blockquote>
<p>)</p>
<dl class="simple">
<dt>if name_scope_to_prepend is not None:</dt><dd><dl class="simple">
<dt>if not name_scope_to_prepend.endswith(‘/’):</dt><dd><p>name_scope_to_prepend += ‘/’</p>
</dd>
</dl>
</dd>
<dt>if name_scope_to_remove is not None:</dt><dd><dl class="simple">
<dt>if not name_scope_to_remove.endswith(‘/’):</dt><dd><p>name_scope_to_remove += ‘/’</p>
</dd>
</dl>
</dd>
</dl>
<p>init_map = {}</p>
<dl>
<dt>for var_name in vars_to_restore:</dt><dd><p>var_name_checkpoint = var_name</p>
<dl class="simple">
<dt>if name_scope_to_remove is not None:</dt><dd><p>var_name = var_name.replace(name_scope_to_remove, ‘’)</p>
</dd>
</dl>
<p>var_name_new_model = var_name</p>
<dl class="simple">
<dt>if name_scope_to_prepend is not None:</dt><dd><p>var_name_new_model = name_scope_to_prepend + var_name_new_model</p>
</dd>
</dl>
<p>init_map[var_name_checkpoint] = var_name_new_model</p>
</dd>
</dl>
<p>return init_map</p>
</dd>
<dt>def get_checkpoint_variable_names(model_dir, exclude_var_names=None, exclude_scopes=None):</dt><dd><p>“””
Gets a list of variable names from the latest checkpoint in model_dir.
Removes variables with scope defined by exclude_scopes, and/or with names defined by
exclude_var_names.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>model_dir (str): Directory containing checkpoint file for the pre-trained model
exclude_var_names (list): Optional variable names to exclude (can include full/partial scope)
exclude_scopes (list): Optional scopes to exclude</p>
</dd>
<dt>Returns:</dt><dd><p>list: variable names</p>
</dd>
</dl>
<p>“””
checkpoint_path = tf.train.latest_checkpoint(model_dir)
variables_and_shapes = tf.train.list_variables(checkpoint_path)</p>
<dl>
<dt>def _keep(name):</dt><dd><dl class="simple">
<dt>if exclude_scopes and any(name.startswith(exc_scope) for exc_scope in exclude_scopes):</dt><dd><p>return False</p>
</dd>
<dt>if exclude_var_names and any(name.endswith(exc_var) for exc_var in exclude_var_names):</dt><dd><p>return False</p>
</dd>
</dl>
<p>return True</p>
</dd>
</dl>
<p>names = [x[0] for x in variables_and_shapes if _keep(x[0])]</p>
<p>return names</p>
</dd>
<dt>def to_snake_case(name):</dt><dd><p>“””
Changes name to snake case
“””
intermediate = re.sub(‘(.)([A-Z][a-z0-9]+)’, r’1_2’, name)
insecure = re.sub(‘([a-z])([A-Z])’, r’1_2’, intermediate).lower()
# If the class is private the name starts with “_” which is not secure
# for creating scopes. We prefix the name with “private” in this case.
if insecure[0] != ‘_’:</p>
<blockquote>
<div><p>return insecure</p>
</div></blockquote>
<p>return ‘private’ + insecure</p>
</dd>
<dt>def copy_phase_inputs(init_dir, dest_dir):</dt><dd><p>“””Automatically copies the .json.tf from the init_dir to save_dir
so we can load multiple parameters at the same time.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>init_dir:</dt><dd><p>Name of the checkpoint directory.</p>
</dd>
<dt>dest_dir:</dt><dd><p>Name of the output directory.</p>
</dd>
</dl>
</dd>
</dl>
<p>“””
if init_dir is not None:</p>
<blockquote>
<div><p># we are using tf.io.gfile so we can use it with both local and hdfs paths
for files in tf.io.gfile.listdir(init_dir):</p>
<blockquote>
<div><dl>
<dt>if files.endswith(“.json.tf”):</dt><dd><p>src_file = os.path.join(init_dir, files)
dest_file = os.path.join(dest_dir, files)
if not tf.io.gfile.exists(dest_dir):</p>
<blockquote>
<div><p># creates the folder
try:</p>
<blockquote>
<div><p>tf.io.gfile.makedirs(dest_dir)</p>
</div></blockquote>
<p># to prevent racing condition
except OSError:</p>
<blockquote>
<div><dl class="simple">
<dt>if not tf.io.gfile.isdir(dest_dir):</dt><dd><p>raise</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p># dest_file may be old if it exists and
# dest_file gets copied several times in distributed training
tf.io.gfile.copy(src_file, dest_file, overwrite=True)</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
</dd>
<dt>def rehash_sparse_features_nbits(sp_a, nbits, hash_fn=multiplicative_hash):</dt><dd><p>“””
Rehash the feature ids of the sparse tensor,
and limit the output to n bits.</p>
<p>This is useful for making the distribution of
feature_ids more uniform, which may improve performance
in some situations.</p>
<p>This would typically be used on the output of
PercentileDiscretizer, since it assigns many
bins to low-valued output feature ids.</p>
<p>Input feature IDs should take values less than 2**32,
and nbits should be less than 32</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>sp_a:</dt><dd><p>a tf.SparseTensor object</p>
</dd>
<dt>nbits:</dt><dd><p>integer number of bits to mask output feature_ids</p>
</dd>
<dt>hash_fn:</dt><dd><p>Function that takes integer values and returns hashes of these values.
The output does not need to be masked to the desired number of bits,
as this masking will be taken care of. Default value = multiplicative_hash.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>a new tf.SparseTensor</p>
</dd>
</dl>
<p>“””</p>
<p>feature_ids = sp_a.indices[:, 1]
feature_ids = hash_fn(feature_ids)</p>
<p>sample_ids = sp_a.indices[:, 0]
values = sp_a.values
dense_shape = sp_a.dense_shape</p>
<p>indices = tf.stack([sample_ids, feature_ids], axis=1)</p>
<p>sp_a = tf.SparseTensor(indices, values, dense_shape)</p>
<p># note - we need 2**nbits &gt;= batch size
# otherwise, sample_ids will be squashed by the mask.
return limit_sparse_tensor_size(sp_a, nbits)</p>
</dd>
<dt>def convert_to_hparams(opt):</dt><dd><p>“””
Converts argparse.Namespace object to twitter.deepbird.hparam.hparam.HParams.
Note that tensorflow.contrib.training.HParams is gone in TF 2.x, and we forward ported
tensorflow.contrib.training.HParams to twitter.deepbird.hparam.hapram.HParams.</p>
<p>NOTE: If you are using estimators, please don’t call this method and directly pass python dict
to TensorFlow estimator. Starting TensorFlow 2.0, Estimator will only accept dicts.
“””</p>
<p># Convert to dict so we can iterate through it cleanly.
if isinstance(opt, argparse.Namespace):</p>
<blockquote>
<div><p>params_dict = vars(opt)</p>
</div></blockquote>
<dl class="simple">
<dt>elif isinstance(opt, dict):</dt><dd><p>params_dict = opt</p>
</dd>
<dt>elif isinstance(opt, HParams):</dt><dd><p>logging.warning(‘If you are using Estimator, please pass python dict directly to Estimator.’)
params_dict = opt.values()</p>
</dd>
<dt>else:</dt><dd><dl class="simple">
<dt>raise ValueError(“Input can not be of type %s. “</dt><dd><p>“It can be one of { argparse.Namespace, dict, ”
“twitter.deepbird.hparam.HParams}.”
% type(opt))</p>
</dd>
</dl>
</dd>
</dl>
<p>params = HParams()
# Hack to convert all parameters from hdfs:/// format to hdfs://default/
# Note: .items() makes a copy in python 2.7, but that is fine since the performance isn’t critical.
for key, val in params_dict.items():</p>
<blockquote>
<div><p>val = params_dict[key]
# Fix the path if the value is a string
if isinstance(val, str):</p>
<blockquote>
<div><p>params.add_hparam(key, sanitize_hdfs_path(val))</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>params.add_hparam(key, val)</p>
</dd>
</dl>
</div></blockquote>
<p>return params</p>
</dd>
<dt>def dynamic_partition(features, partitions, num_partitions=2, name=None):</dt><dd><p>“””
Partitions each of the tensor in features using the provided mask.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>features:</dt><dd><p>A single tensor or an iterable of tensors (list, tuple, dict)</p>
</dd>
<dt>partitions:</dt><dd><p>A bool or integer tensor representing the partitions.</p>
</dd>
</dl>
</dd>
</dl>
<p>Returns partitioned outputs as a list. Each element of the list is the same type as features.</p>
<dl class="simple">
<dt>This uses tf.dynamic_partition but adds the following niceties:</dt><dd><ul class="simple">
<li><p>features can be a list or dict of different tensor types.</p></li>
<li><p>only a partition tensor is used to partition all the feature tensors recursively.</p></li>
<li><p>the partition tensor is automatically converted into an integer tensor.</p></li>
<li><p>defaults to num_partitions == 2</p></li>
</ul>
</dd>
</dl>
<p>“””</p>
<dl class="simple">
<dt>if not isinstance(features, (dict, list, tuple, tf.Tensor)):</dt><dd><p>raise AssertionError(“features container must be a dict, list, or tuple, tf.Tensor”)</p>
</dd>
<dt>if isinstance(partitions, tf.Tensor):</dt><dd><p>partitions = tf.cast(partitions, tf.int32)</p>
</dd>
<dt>if isinstance(features, tf.Tensor):</dt><dd><p>return tf.dynamic_partition(features, partitions, num_partitions, name)</p>
</dd>
</dl>
<p>outputs = []
for _ in range(num_partitions):</p>
<blockquote>
<div><dl class="simple">
<dt>if isinstance(features, (tuple, list)):</dt><dd><p># Create an empty list of lists first, will be converted to right type afterwards.
outputs.append([None for _ in range(len(features))])</p>
</dd>
<dt>else:</dt><dd><p>outputs.append(dict())</p>
</dd>
</dl>
</div></blockquote>
<p>iterable = features.items() if isinstance(features, dict) else enumerate(features)</p>
<p># Handling partitions of nested classes handled here:
# Recursively call dynamic_partition for containers
for key, feature in iterable:</p>
<blockquote>
<div><p>name_key = None if name is None else name + “_” + str(key)
if isinstance(partitions, tf.Tensor):</p>
<blockquote>
<div><p>results = tf.dynamic_partition(feature, partitions, num_partitions, name_key)</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>results = tf.dynamic_partition(feature, partitions[key], num_partitions[key], name_key)
# Append the result to the proper output container</p>
</dd>
<dt>for idx, result in enumerate(results):</dt><dd><p>outputs[idx][key] = result</p>
</dd>
</dl>
</div></blockquote>
<p># if input is tuple, convert list of lists back to list of tuples
if isinstance(features, tuple):</p>
<blockquote>
<div><p>outputs = [type(features)(output) for output in outputs]</p>
</div></blockquote>
<p>return outputs</p>
</dd>
<dt>def write_file(filename, contents, encode=False):</dt><dd><p>‘’’
Optionally encodes contents and writes contents to a file.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>filename:</dt><dd><p>path to file where the contents will be saved.
Accepts HDFS and local paths.</p>
</dd>
<dt>contents:</dt><dd><p>contents to save to the file.
Must be a string when encode is False.</p>
</dd>
<dt>encode:</dt><dd><p>False | ‘json’. When encode=’json’, contents is encoded
with json.dumps.</p>
</dd>
</dl>
</dd>
</dl>
<p>‘’’
if encode == ‘json’:</p>
<blockquote>
<div><p>contents = json.dumps(contents)</p>
</div></blockquote>
<dl class="simple">
<dt>elif not is_string(contents):</dt><dd><p>raise ValueError(“Expecting string for encode=False”)</p>
</dd>
</dl>
<p>graph = tf.Graph()
with graph.as_default():</p>
<blockquote>
<div><p>write = tf.write_file(filename, contents)</p>
</div></blockquote>
<dl class="simple">
<dt>with tf.Session(graph=graph) as sess:</dt><dd><p>sess.run(write)</p>
</dd>
</dl>
</dd>
<dt>def read_file(filename, decode=False):</dt><dd><p>‘’’
Reads contents from a file and optionally decodes it.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>filename:</dt><dd><p>path to file where the contents will be loaded from.
Accepts HDFS and local paths.</p>
</dd>
<dt>decode:</dt><dd><p>False | ‘json’. When decode=’json’, contents is decoded
with json.loads. When False, contents is returned as is.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>contents</p>
</dd>
</dl>
<p>‘’’
graph = tf.Graph()
with graph.as_default():</p>
<blockquote>
<div><p>read = tf.read_file(filename)</p>
</div></blockquote>
<dl>
<dt>with tf.Session(graph=graph) as sess:</dt><dd><p>contents = (sess.run(read))
# particular version of TF and/or Python may or may not perform decoding step from utf-8 to str
if not isinstance(contents, str):</p>
<blockquote>
<div><p>contents = contents.decode()</p>
</div></blockquote>
</dd>
<dt>if decode == ‘json’:</dt><dd><p>contents = json.loads(contents)</p>
</dd>
</dl>
<p>return contents</p>
</dd>
<dt>def setup_tf_logging_formatter():</dt><dd><dl class="simple">
<dt>formatter = _logging.Formatter(</dt><dd><p>‘%(asctime)s [%(levelname)s] %(name)s: %(message)s’,
None)</p>
</dd>
</dl>
<p># Setting up absl logging verbosity
logging.set_verbosity(‘info’)
logging.set_stderrthreshold(‘info’)
logging.get_absl_handler().setFormatter(formatter)
tf.logging.set_verbosity(tf.logging.INFO)
# Set tensorflow logging handler format
if len(tf_logging.get_logger().handlers) &gt; 0:</p>
<blockquote>
<div><p>tf_logging.get_logger().handlers[0].setFormatter(formatter)</p>
</div></blockquote>
</dd>
<dt>def set_tensorflow_log_level(log_level):</dt><dd><p>“””
Sets tensorflow’s default logging level.</p>
<ol class="arabic simple" start="0">
<li><p>all logs are shown.</p></li>
<li><p>filter out INFO logs.</p></li>
<li><p>filter out WARNINGs and INFOs.</p></li>
<li><p>filter out ERRORs, WARNINGs, and INFOs.</p></li>
</ol>
<p>Note that tf.Print output are INFO logs, so setting log_level above 0 would hide
output from tf.Print.
“””
assert isinstance(log_level, int) and log_level &gt;= 0 and log_level &lt;= 3
os.environ[‘TF_CPP_MIN_LOG_LEVEL’] = str(log_level)</p>
</dd>
<dt>def weighted_average(values, weights):</dt><dd><p>“””
Compute a weighted average using the given values and weights.
E.g. this is usually used to compute a weighted loss given sample weights.
“””
return tf.reduce_sum(tf.multiply(values, weights)) / tf.reduce_sum(weights)</p>
</dd>
<dt>def backup_checkpoint(checkpoint_path_prefix,</dt><dd><blockquote>
<div><p>backup_path=’backup’,
empty_backup=True):</p>
</div></blockquote>
<p>“””
Creates a backup copy of a checkpoint in backup_dir.
This function is used by the Trainer for early-stopping.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>checkpoint_path_prefix:</dt><dd><p>Prefix of the path to the checkpoint files.</p>
</dd>
<dt>backup_path:</dt><dd><p>path to a directory where checkpoint files will be backed up.</p>
</dd>
<dt>empty_backup:</dt><dd><p>When True (the default), the current contents of the backup directory
are removed before the backup is performed.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>The number of backed up files.</p>
</dd>
</dl>
<p>“””
checkpoint_file_prefix = os.path.basename(checkpoint_path_prefix)</p>
<dl class="simple">
<dt>if tf.io.gfile.exists(backup_path) and empty_backup:</dt><dd><p>tf.io.gfile.rmtree(backup_path)</p>
</dd>
</dl>
<p>tf.io.gfile.mkdir(backup_path)</p>
<p>n_backup = 0
# copy all checkpoint files to backup directory (TODO use gfile.glob instead)
try:</p>
<blockquote>
<div><p>checkpoint_files = tf.io.gfile.glob(checkpoint_path_prefix + “*”)
if len(checkpoint_files) == 0:</p>
<blockquote>
<div><p>raise twml.errors.CheckpointNotFoundError(“%s not found” % checkpoint_path_prefix)</p>
</div></blockquote>
<dl>
<dt>for filename in checkpoint_files:</dt><dd><p>n_backup += 1
tf.io.gfile.copy(</p>
<blockquote>
<div><p>src=filename,
dst=os.path.join(backup_path, os.path.basename(filename))</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>except tf.errors.OpError as ex:</dt><dd><dl class="simple">
<dt>raise twml.errors.CheckpointNotFoundError(</dt><dd><p>f”{str(ex)}n {checkpoint_path_prefix} not found.”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p># tf.train.latest_checkpoint needs the ‘checkpoint’ file.
with tf.io.gfile.GFile(os.path.join(backup_path, ‘checkpoint’), ‘w’) as f:</p>
<blockquote>
<div><p>f.write(‘model_checkpoint_path: “%s”n’ % checkpoint_file_prefix)</p>
</div></blockquote>
<p>return n_backup</p>
</dd>
<dt>def set_only_checkpoint(source_path, dest_path, remove_source=True):</dt><dd><p>“””
Removes the checkpoint and model.ckpt* files from dest_path.
Moves the latest checkpoint from source_path to dest_path.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><dl class="simple">
<dt>source_path:</dt><dd><p>path to directory containing the latest checkpoint.
Should contain a valid checkpoint file and model.ckpt files.
For early-stopping, this should be the save_dir/best_checkpoint dir.</p>
</dd>
<dt>dest_path:</dt><dd><p>path to directory where the latest checkpoint files will be moved.
All its checkpoint and model.ckpt* files will be removed.
For early-stopping, this should be the save_dir.</p>
</dd>
<dt>remove_source:</dt><dd><p>When True (the default), deletes the source directory.
Note that even when False, its checkpoint files are moved to
dest_path anyway.
This deletes the source directory (and any remaining contents).</p>
</dd>
</dl>
</dd>
</dl>
<p>“””
# make it so that source_path checkpoint is the only checkpoint
source_path_prefix = tf.train.latest_checkpoint(source_path)
if source_path_prefix is not None:</p>
<blockquote>
<div><p># remove intermediate checkpoints
for filename in tf.io.gfile.listdir(dest_path):</p>
<blockquote>
<div><dl class="simple">
<dt>if filename.startswith(“model.ckpt”):</dt><dd><p>tf.io.gfile.Remove(os.path.join(dest_path, filename))</p>
</dd>
</dl>
</div></blockquote>
<p># move contents of source_path to dest_path
for filename in tf.io.gfile.listdir(source_path):</p>
<blockquote>
<div><dl class="simple">
<dt>tf.io.gfile.rename(</dt><dd><p>oldname=os.path.join(source_path, filename),
newname=os.path.join(dest_path, filename),
overwrite=True)  # overwrite “checkpoint” file</p>
</dd>
</dl>
</div></blockquote>
<p># delete the source_path dir
if remove_source:</p>
<blockquote>
<div><p>tf.io.gfile.rmtree(source_path)</p>
</div></blockquote>
</div></blockquote>
</dd>
<dt>def list_files_by_datetime(</dt><dd><p>base_path,
start_datetime,
end_datetime=None,
datetime_prefix_format=’%Y/%m/%d/%H’,
extension=’lzo’,
parallelism=1,
hour_resolution=1,
sort=False</p>
</dd>
<dt>):</dt><dd><p>“””List files matching <cite>base_path/dt_prefix_format/*.extension</cite> for the requested datetime range.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>base_path:</dt><dd><p>The base path. If <cite>None</cite>, returns <cite>None</cite>.</p>
</dd>
<dt>start_datetime:</dt><dd><p>A <cite>datetime.datetime</cite> or string representing the start of the range (inclusive).
If <cite>None</cite>, it returns <cite>list_files(base_path, extension, sort)</cite>.</p>
</dd>
<dt>end_datetime:</dt><dd><p>A <cite>datetime.datetime</cite> or string representing the end of the range (inclusive).
If <cite>None</cite>, assumed to be the same as start_datetime.</p>
</dd>
<dt>datetime_prefix_format:</dt><dd><p>Format compatible with <cite>datetime.datetime.strftime</cite>
(<a class="reference external" href="https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior">https://docs.python.org/2/library/datetime.html#strftime-and-strptime-behavior</a>).</p>
</dd>
<dt>extension:</dt><dd><p>The extension of the files composing the dataset (e.g. ‘lzo’).</p>
</dd>
<dt>parallelism:</dt><dd><p>The number of threads used to process list patterns (this is mostly useful
when dealing with filesystems such as HDFS in which listing files is a potentially expensive
operation).</p>
</dd>
<dt>hour_resolution:</dt><dd><p>The separation between consecutive hours. The default value is 1.</p>
</dd>
<dt>sort:</dt><dd><p>bool, whether to return a sorted list of files. Default False.</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A list with all the matching files.</p>
</dd>
<dt>Raises:</dt><dd><p>errors.OpError: If there are filesystem / directory listing errors.</p>
</dd>
</dl>
<p>“””
if hour_resolution is None:</p>
<blockquote>
<div><p>hour_resolution = 1</p>
</div></blockquote>
<dl class="simple">
<dt>if base_path is None:</dt><dd><p>return None</p>
</dd>
<dt>if start_datetime is None:</dt><dd><p>return list_files(base_path, extension, sort)</p>
</dd>
</dl>
<p># Do this in case people want to use a single day for training.
if end_datetime is None:</p>
<blockquote>
<div><p>end_datetime = start_datetime</p>
</div></blockquote>
<p>assert parallelism &gt; 0
assert start_datetime &lt;= end_datetime</p>
<dl class="simple">
<dt>if isinstance(start_datetime, str):</dt><dd><p>start_datetime = datetime.strptime(start_datetime, datetime_prefix_format)</p>
</dd>
<dt>if isinstance(end_datetime, str):</dt><dd><p>end_datetime = datetime.strptime(end_datetime, datetime_prefix_format)</p>
</dd>
</dl>
<p>assert isinstance(start_datetime, datetime)
assert isinstance(end_datetime, datetime)</p>
<p>base_path = preprocess_path(base_path)</p>
<dl class="simple">
<dt>def _handle_missing_globs(pattern):</dt><dd><dl class="simple">
<dt>try:</dt><dd><p>return tf.io.gfile.glob(pattern)</p>
</dd>
<dt>except tf.errors.NotFoundError as e:</dt><dd><p>tf.logging.warning(e.message)
return []</p>
</dd>
</dl>
</dd>
</dl>
<p># a set is used because there might be some repeated globs depending on dt_prefix_format
globs = {</p>
<blockquote>
<div><p>os.path.join(base_path, dt.strftime(datetime_prefix_format), ‘<a href="#id1"><span class="problematic" id="id2">*</span></a>.%s’ % extension)
for dt in rrule.rrule(</p>
<blockquote>
<div><p>freq=rrule.HOURLY, interval=hour_resolution, dtstart=start_datetime, until=end_datetime)</p>
</div></blockquote>
</div></blockquote>
<p>}
nested_files = Parallel(n_jobs=parallelism, backend=’threading’)(</p>
<blockquote>
<div><p>delayed(_handle_missing_globs)(p) for p in globs</p>
</div></blockquote>
<p>)
flattened_files = list(itertools.chain.from_iterable(nested_files))</p>
<dl>
<dt>if not flattened_files:</dt><dd><dl class="simple">
<dt>error_msg = “Files list is empty: base_path={base_path}, start_datetime={start_datetime}, end_datetime={end_datetime}”.format(</dt><dd><p>base_path=base_path, start_datetime=start_datetime, end_datetime=end_datetime</p>
</dd>
</dl>
<p>)
raise OSError(error_msg)</p>
</dd>
<dt>if sort:</dt><dd><p>flattened_files = sorted(flattened_files)</p>
</dd>
</dl>
<p>return flattened_files</p>
</dd>
<dt>def limit_sparse_tensor_size(sparse_tf, input_size_bits, mask_indices=True):</dt><dd><p>“””
Returns a <code class="docutils literal notranslate"><span class="pre">tf.SparseTensor</span></code> which is the input SparseTensor
limited to the specified input_size_bits</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>sparse_tf:</dt><dd><p>twml.SparseTensor or tf.SparseTensor</p>
</dd>
<dt>input_size_bits:</dt><dd><p>The number of bits allocated to the input size.
Input size will be power(2,input_size_bits).
Note that twml.limit_bits truncates any feature keys that
exceed the input size.</p>
</dd>
<dt>mask_indices:</dt><dd><p>If mask indices is False; only the shape is changed. Defaults to True.</p>
</dd>
</dl>
</dd>
</dl>
<p>“””
if isinstance(sparse_tf, twml.SparseTensor):</p>
<blockquote>
<div><p>sparse_tf = sparse_tf.to_tf()</p>
</div></blockquote>
<dl class="simple">
<dt>if not isinstance(sparse_tf, tf.SparseTensor):</dt><dd><dl class="simple">
<dt>raise TypeError(‘Input argument <cite>sparse_tf</cite> should either be of type’</dt><dd><p>‘twml.SparseTensor of tf.SparseTensor. Found type: {}’.
format(type(sparse_tf)))</p>
</dd>
</dl>
</dd>
<dt>if mask_indices:</dt><dd><p>indices = twml.limit_bits(sparse_tf.indices, input_size_bits)</p>
</dd>
<dt>else:</dt><dd><p>indices = sparse_tf.indices</p>
</dd>
</dl>
<p>dense_shape = tf.stack([sparse_tf.dense_shape[0], 1 &lt;&lt; input_size_bits])
return tf.SparseTensor(indices=indices, values=sparse_tf.values,</p>
<blockquote>
<div><p>dense_shape=dense_shape)</p>
</div></blockquote>
</dd>
<dt>def create_module_spec(mlp_fn, mode, params, drop_collections=None):</dt><dd><p>“””
Creates a standard tags_and_args which should be passed to the create_module_spec
spec = hub.create_module_spec(mlp_fn, tags_and_args=tags_and_args).</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>module_fn:</dt><dd><p>a function to build a graph for the Module.</p>
</dd>
<dt>mode:</dt><dd><p>mode in which the Estimator is run</p>
</dd>
<dt>params:</dt><dd><p>parameters passed to the Estimator</p>
</dd>
</dl>
</dd>
</dl>
<p>“””
import tensorflow_hub as hub # noqa: F402
tags_and_args = [(set(), {“params”: params, “mode”: mode}),  # serving graph</p>
<blockquote>
<div><p>({“train”}, {“params”: params, “mode”: mode})  # training graph
]</p>
</div></blockquote>
<p>spec = hub.create_module_spec(mlp_fn, tags_and_args=tags_and_args, drop_collections=drop_collections)
return spec</p>
</dd>
<dt>def change_name_scope_from_dir(init_scope_name, final_scope_name, save_dir):</dt><dd><p>“””
Changes the name of the saved scope to the desired name and saves it
to the same save_dir.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>init_scope_name:</dt><dd><p>initial scope name</p>
</dd>
<dt>final_scope_name:</dt><dd><p>desired (final) scope name</p>
</dd>
<dt>save_dir:</dt><dd><p>directory which the scopes are saved</p>
</dd>
</dl>
</dd>
<dt>In the follwing section we:</dt><dd><ul class="simple">
<li><p>Read all the variables from the latest checkpoint.</p></li>
<li><p>Make a copy of the variables with new name scope.</p></li>
<li><p>Store both sets of variables into the latest checkpoint.</p></li>
</ul>
</dd>
</dl>
<p>This essentially doubles up the size of the checkpoint.
But when a job is restarted after this part is done, the checkpoint size doubles again.
To avoid doing this, we create a copy in backup if a backup isn’t found.
This allows us always read (from backup) and write same sized checkpoint files.
“””</p>
<p># Create a backup_checkpoints dir
backup_dir = os.path.join(save_dir, “change_name_scope_backups”)
tf.io.gfile.makedirs(backup_dir)</p>
<p>latest_checkpoint = tf.train.latest_checkpoint(save_dir)</p>
<dl class="simple">
<dt>if latest_checkpoint is None:</dt><dd><p>raise OSError(“No checkpoints found in save_dir: %s” % save_dir)</p>
</dd>
</dl>
<p>latest_backup_checkpoint = tf.train.latest_checkpoint(backup_dir)</p>
<dl>
<dt>if (latest_backup_checkpoint is None or</dt><dd><blockquote>
<div><dl class="simple">
<dt>(os.path.basename(latest_checkpoint) !=</dt><dd><p>os.path.basename(latest_backup_checkpoint))):</p>
</dd>
</dl>
</div></blockquote>
<p>backup_checkpoint(latest_checkpoint, backup_dir, empty_backup=False)</p>
</dd>
</dl>
<p>variables = tf.train.list_variables(backup_dir)
with tf.Graph().as_default(), tf.Session().as_default() as sess:</p>
<blockquote>
<div><p>new_variables = []
for name, _ in variables:</p>
<blockquote>
<div><p>var = tf.train.load_variable(backup_dir, name)
# Append both the rename and the original variable
new_variables.append(</p>
<blockquote>
<div><p>tf.Variable(var, name=name.replace(init_scope_name, final_scope_name)))</p>
</div></blockquote>
<p>new_variables.append(tf.Variable(var, name=name))</p>
</div></blockquote>
<p># Save this to the checkpoint in the save_dir
saver = tf.train.Saver(new_variables)
sess.run(tf.global_variables_initializer())
saver.save(sess, latest_checkpoint)  # pylint: disable=no-member</p>
</div></blockquote>
</dd>
<dt>def hub_import(input, module, module_name, trainable=False):</dt><dd><p>“””
Loads exported hub module.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>input:</dt><dd><p>input to hub module</p>
</dd>
<dt>module:</dt><dd><p>module path</p>
</dd>
<dt>module_name:</dt><dd><p>signature of the exported hub module</p>
</dd>
</dl>
</dd>
</dl>
<p>“””
import tensorflow_hub as hub # noqa: F402
hub_module = hub.Module(module, trainable=trainable)
output = hub_module(input, signature=module_name)
return output</p>
</dd>
<dt>def _extract_hash_space_bits(feature_config):</dt><dd><p>“””
Extract Sparse Shapes for contrib.FeatureConfig.
Arguments:</p>
<blockquote>
<div><dl class="simple">
<dt>feature_config:</dt><dd><p>Feature Configuration of the type contrib.FeatureConfig</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><p>Dictionary of tensor names and hash space bits.</p>
</dd>
</dl>
<p>“””
if not isinstance(feature_config, twml.contrib.feature_config.FeatureConfig):</p>
<blockquote>
<div><p>fc_type = type(feature_config)
raise TypeError(f”Feature config must be of type contrib.FeatureConfig: {fc_type}”)</p>
</div></blockquote>
<p>sparse_shapes_dict = {}
for config in feature_config.sparse_extraction_configs:</p>
<blockquote>
<div><p>sparse_shapes_dict[config.output_name] = config.hash_space_bits</p>
</div></blockquote>
<p>return sparse_shapes_dict</p>
</dd>
<dt>def fix_shape_sparse(features, feature_config):</dt><dd><p>“””
Modifies the shape of features which are extracted using the hashing trick.
Features itself is changed by this function.
Arguments:</p>
<blockquote>
<div><dl class="simple">
<dt>features:</dt><dd><p>Feature dictionary extracted by the feature config</p>
</dd>
<dt>feature_config:</dt><dd><p>Feature Configuration of the type contrib.FeatureConfig</p>
</dd>
</dl>
</div></blockquote>
<p>“””
if not isinstance(feature_config, twml.contrib.feature_config.FeatureConfig):</p>
<blockquote>
<div><p>raise TypeError(f”Feature config must be of type contrib.FeatureConfig, currently of {type(feature_config)}”)</p>
</div></blockquote>
<p>sparse_shape = _extract_hash_space_bits(feature_config)
if not isinstance(features, dict):</p>
<blockquote>
<div><p>raise TypeError(f”features must be of dictionary type, it is of {type(features)} type”)</p>
</div></blockquote>
<dl class="simple">
<dt>for key in set(features) &amp; set(sparse_shape):</dt><dd><p>features[key] = limit_sparse_tensor_size(features[key], sparse_shape[key], mask_indices=False)</p>
</dd>
</dl>
</dd>
<dt>def touch_file_in_dir(directory, filename):</dt><dd><p>“””
Creates a file named filename in directory.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><p>filename: (str)
directory: (str)</p>
</dd>
</dl>
<p>“””
file_path = os.path.join(directory, filename)
with tf.io.gfile.GFile(file_path, “w”) as f:</p>
<blockquote>
<div><p>f.write(“”)</p>
</div></blockquote>
</dd>
<dt>def file_exist_in_dir(directory: str, filename: str) -&gt; bool:</dt><dd><p>file_path = os.path.join(directory, filename)
return tf.io.gfile.exists(file_path)</p>
</dd>
<dt>def copy_to_local(remote, local, filename, overwrite=False):</dt><dd><p>“””Function to file from remote directory to local directory.”””
assert “hdfs://” not in local
tf.io.gfile.makedirs(local)
return tf.io.gfile.copy(</p>
<blockquote>
<div><p>os.path.join(remote, filename),
os.path.join(local, filename),
overwrite=overwrite,</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>def copy_recursive(src, dst, overwrite=False):</dt><dd><p>“””
Function to copy a directory recursively.</p>
<dl class="simple">
<dt>Arguments:</dt><dd><p>src: Source directory.
dst: Destination directory.
overwrite: Specifies if files are to be overwritten if they exist.</p>
</dd>
</dl>
<p>“””</p>
<p>src = src.rstrip(“/”)
dst = dst.rstrip(“/”)</p>
<dl>
<dt>for dirname, subdirs, files in tf.io.gfile.walk(src):</dt><dd><p>dst_dirname = dirname.replace(src, dst)
tf.io.gfile.makedirs(dst_dirname)</p>
<dl>
<dt>for f in files:</dt><dd><p>src_f = os.path.join(dirname, f)
dst_f = os.path.join(dst_dirname, f)</p>
<p>tf.logging.info(f”Copying {src_f} to {dst_f}”)
tf.io.gfile.copy(src_f, dst_f, overwrite=overwrite)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>def delete_file_or_dir(path):</dt><dd><p>“””
Delete the file or directory given by <cite>path</cite>
Arguments:</p>
<blockquote>
<div><dl class="simple">
<dt>path:</dt><dd><p>string indicating path of file or directory to remove</p>
</dd>
</dl>
</div></blockquote>
<p>“””
if tf.io.gfile.isdir(path):</p>
<blockquote>
<div><p>tf.io.gfile.rmtree(path)</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>tf.io.gfile.remove(path)</p>
</dd>
</dl>
</dd>
<dt>def get_distributed_training_job_path():</dt><dd><p>“””
Function to get distributed training job path.
Note: distributed training has three jobs, one parameter server job,
one worker job and one evaluator job. All of these three jobs’ name
share a common base job name.
“””
job_path = AuroraPath(dc=os.environ.get(“TWML_JOB_CLUSTER”),</p>
<blockquote>
<div><p>role=os.environ.get(“TWML_JOB_ROLE”),
env=os.environ.get(“TWML_JOB_ENV”),
job_name=os.environ.get(“TWML_DISTRIBUTED_BASE_JOBNAME”))</p>
</div></blockquote>
<p>return job_path</p>
</dd>
<dt>def do_every_n_steps(action, num_steps):</dt><dd><p>“””
Execute a sequence of TensorFlow operations only once in a while.
Specifically, <cite>action</cite> is performed if <cite>global_step</cite> is a</p>
<blockquote>
<div><p>multiple of <cite>num_steps</cite></p>
</div></blockquote>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>action: callable to be performed at regular intervals. This callable</dt><dd><p>must return a TF op with no output tensors.</p>
</dd>
<dt>num_steps: period of performing the action, as measured</dt><dd><p>in number of training steps</p>
</dd>
</dl>
</dd>
<dt>Returns:</dt><dd><p>A TensorFlow op with no output tensors, like a tf.print() or tf.no_op().
You must use tf.control_dependencies() to execute the op.</p>
</dd>
</dl>
<p>“””
global_step = tf.train.get_or_create_global_step()
condition = tf.math.equal(tf.math.floormod(global_step, num_steps), 0)
return tf.cond(condition, action, lambda: tf.no_op())</p>
</dd>
</dl>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../_sources/twml/twml/util.py.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>