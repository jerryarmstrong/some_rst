<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../_static/doctools.js?v=888ff710"></script>
    <script src="../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>“””
This module contains custom tensorflow metrics used at Twitter.
Its components conform to conventions used by the <code class="docutils literal notranslate"><span class="pre">tf.metrics</span></code> module.</p>
<p>“””</p>
<p>from collections import OrderedDict
from functools import partial</p>
<p>import numpy as np
import tensorboard as tb
import tensorflow.compat.v1 as tf</p>
<p>CLAMP_EPSILON = 0.00001</p>
<dl>
<dt>def total_weight_metric(</dt><dd><blockquote>
<div><p>labels,
predictions,
weights=None,
metrics_collections=None,
updates_collections=None,
name=None):</p>
</div></blockquote>
<dl>
<dt>with tf.variable_scope(name, ‘total_weight’, (labels, predictions, weights)):</dt><dd><p>total_weight = _metric_variable(name=’total_weight’, shape=[], dtype=tf.float64)</p>
<dl class="simple">
<dt>if weights is None:</dt><dd><p>weights = tf.cast(tf.size(labels), total_weight.dtype, name=”default_weight”)</p>
</dd>
<dt>else:</dt><dd><p>weights = tf.cast(weights, total_weight.dtype)</p>
</dd>
</dl>
<p># add up the weights to get total weight of the eval set
update_total_weight = tf.assign_add(total_weight, tf.reduce_sum(weights), name=”update_op”)</p>
<p>value_op = tf.identity(total_weight)
update_op = tf.identity(update_total_weight)</p>
<dl class="simple">
<dt>if metrics_collections:</dt><dd><p>tf.add_to_collections(metrics_collections, value_op)</p>
</dd>
<dt>if updates_collections:</dt><dd><p>tf.add_to_collections(updates_collections, update_op)</p>
</dd>
</dl>
<p>return value_op, update_op</p>
</dd>
</dl>
</dd>
<dt>def num_samples_metric(</dt><dd><blockquote>
<div><p>labels,
predictions,
weights=None,
metrics_collections=None,
updates_collections=None,
name=None):</p>
</div></blockquote>
<dl>
<dt>with tf.variable_scope(name, ‘num_samples’, (labels, predictions, weights)):</dt><dd><p>num_samples = _metric_variable(name=’num_samples’, shape=[], dtype=tf.float64)
update_num_samples = tf.assign_add(num_samples, tf.cast(tf.size(labels), num_samples.dtype), name=”update_op”)</p>
<p>value_op = tf.identity(num_samples)
update_op = tf.identity(update_num_samples)</p>
<dl class="simple">
<dt>if metrics_collections:</dt><dd><p>tf.add_to_collections(metrics_collections, value_op)</p>
</dd>
<dt>if updates_collections:</dt><dd><p>tf.add_to_collections(updates_collections, update_op)</p>
</dd>
</dl>
<p>return value_op, update_op</p>
</dd>
</dl>
</dd>
<dt>def ctr(labels, predictions,</dt><dd><blockquote>
<div><p>weights=None,
metrics_collections=None,
updates_collections=None,
name=None):</p>
</div></blockquote>
<p># pylint: disable=unused-argument
“””
Compute the weighted average positive sample ratio based on labels
(i.e. weighted average percentage of positive labels).
The name <cite>ctr</cite> (click-through-rate) is from legacy.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>labels: the ground truth value.
predictions: the predicted values, whose shape must match labels. Ignored for CTR computation.
weights: optional weights, whose shape must match labels . Weight is 1 if not set.
metrics_collections: optional list of collections to add this metric into.
updates_collections: optional list of collections to add the associated update_op into.
name: an optional variable_scope name.</p>
</dd>
<dt>Return:</dt><dd><p>ctr: A <cite>Tensor</cite> representing positive sample ratio.
update_op: A update operation used to accumulate data into this metric.</p>
</dd>
</dl>
<p>“””
return tf.metrics.mean(</p>
<blockquote>
<div><p>values=labels,
weights=weights,
metrics_collections=metrics_collections,
updates_collections=updates_collections,
name=name)</p>
</div></blockquote>
</dd>
<dt>def predicted_ctr(labels, predictions,</dt><dd><blockquote>
<div><p>weights=None,
metrics_collections=None,
updates_collections=None,
name=None):</p>
</div></blockquote>
<p># pylint: disable=unused-argument
“””
Compute the weighted average positive ratio based on predictions,
(i.e. weighted averaged predicted positive probability).
The name <cite>ctr</cite> (click-through-rate) is from legacy.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>labels: the ground truth value.
predictions: the predicted values, whose shape must match labels. Ignored for CTR computation.
weights: optional weights, whose shape must match labels . Weight is 1 if not set.
metrics_collections: optional list of collections to add this metric into.
updates_collections: optional list of collections to add the associated update_op into.
name: an optional variable_scope name.</p>
</dd>
<dt>Return:</dt><dd><p>predicted_ctr: A <cite>Tensor</cite> representing the predicted positive ratio.
update_op: A update operation used to accumulate data into this metric.</p>
</dd>
</dl>
<p>“””
return tf.metrics.mean(</p>
<blockquote>
<div><p>values=predictions,
weights=weights,
metrics_collections=metrics_collections,
updates_collections=updates_collections,
name=name)</p>
</div></blockquote>
</dd>
<dt>def prediction_std_dev(labels, predictions,</dt><dd><blockquote>
<div><p>weights=None,
metrics_collections=None,
updates_collections=None,
name=None):</p>
</div></blockquote>
<p>“””
Compute the weighted standard deviation of the predictions.
Note - this is not a confidence interval metric.</p>
<dl class="simple">
<dt>Args:</dt><dd><p>labels: the ground truth value.
predictions: the predicted values, whose shape must match labels. Ignored for CTR computation.
weights: optional weights, whose shape must match labels . Weight is 1 if not set.
metrics_collections: optional list of collections to add this metric into.
updates_collections: optional list of collections to add the associated update_op into.
name: an optional variable_scope name.</p>
</dd>
<dt>Return:</dt><dd><p>metric value: A <cite>Tensor</cite> representing the value of the metric on the data accumulated so far.
update_op: A update operation used to accumulate data into this metric.</p>
</dd>
</dl>
<p>“””
with tf.variable_scope(name, ‘pred_std_dev’, (labels, predictions, weights)):</p>
<blockquote>
<div><p>labels = tf.cast(labels, tf.float64)
predictions = tf.cast(predictions, tf.float64)</p>
<dl class="simple">
<dt>if weights is None:</dt><dd><p>weights = tf.ones(shape=tf.shape(labels), dtype=tf.float64, name=”default_weight”)</p>
</dd>
<dt>else:</dt><dd><p>weights = tf.cast(weights, tf.float64)</p>
</dd>
</dl>
<p># State kept during streaming of examples
total_weighted_preds = _metric_variable(</p>
<blockquote>
<div><p>name=’total_weighted_preds’, shape=[], dtype=tf.float64)</p>
</div></blockquote>
<dl class="simple">
<dt>total_weighted_preds_sq = _metric_variable(</dt><dd><p>name=’total_weighted_preds_sq’, shape=[], dtype=tf.float64)</p>
</dd>
<dt>total_weights = _metric_variable(</dt><dd><p>name=’total_weights’, shape=[], dtype=tf.float64)</p>
</dd>
</dl>
<p># Update state
update_total_weighted_preds = tf.assign_add(total_weighted_preds, tf.reduce_sum(weights * predictions))
update_total_weighted_preds_sq = tf.assign_add(total_weighted_preds_sq, tf.reduce_sum(weights * predictions * predictions))
update_total_weights = tf.assign_add(total_weights, tf.reduce_sum(weights))</p>
<p># Compute output
def compute_output(tot_w, tot_wp, tot_wpp):</p>
<blockquote>
<div><p>return tf.math.sqrt(tot_wpp / tot_w - (tot_wp / tot_w) ** 2)</p>
</div></blockquote>
<p>std_dev_est = compute_output(total_weights, total_weighted_preds, total_weighted_preds_sq)
update_std_dev_est = compute_output(update_total_weights, update_total_weighted_preds, update_total_weighted_preds_sq)</p>
<dl class="simple">
<dt>if metrics_collections:</dt><dd><p>tf.add_to_collections(metrics_collections, std_dev_est)</p>
</dd>
<dt>if updates_collections:</dt><dd><p>tf.add_to_collections(updates_collections, update_std_dev_est)</p>
</dd>
</dl>
<p>return std_dev_est, update_std_dev_est</p>
</div></blockquote>
</dd>
<dt>def _get_arce_predictions(predictions, weights, label_weighted, labels,</dt><dd><blockquote>
<div><p>up_weight, deprecated_rce,
total_positive, update_total_positive):</p>
</div></blockquote>
<p>“””
Returns the ARCE predictions, total_positive, update_total_positive and weights
used by the rest of the twml.metrics.rce metric computation.
“””
predictions_weighted = tf.multiply(predictions, weights, name=”weighted_preds”)
label_weighted_comp = tf.subtract(tf.reduce_sum(weights), tf.reduce_sum(label_weighted))
pred_weight_comp = tf.subtract(tf.reduce_sum(weights), tf.reduce_sum(predictions_weighted))
normalizer_comp = label_weighted_comp / pred_weight_comp</p>
<dl>
<dt>if up_weight is False:</dt><dd><dl class="simple">
<dt>total_positive_unweighted = _metric_variable(</dt><dd><p>name=’total_positive_unweighted’, shape=[], dtype=tf.float32)</p>
</dd>
<dt>update_total_positive_unweighted = tf.assign_add(</dt><dd><p>total_positive_unweighted, tf.reduce_sum(labels),
name=”total_positive_unweighted_update”)</p>
</dd>
<dt>if deprecated_rce:</dt><dd><p>normalizer = tf.reduce_sum(labels) / tf.reduce_sum(label_weighted)</p>
</dd>
<dt>else:</dt><dd><p># sum of labels / sum of weighted labels
normalizer = update_total_positive_unweighted / update_total_positive</p>
</dd>
</dl>
<p>label_comp = tf.subtract(tf.to_float(tf.size(labels)), tf.reduce_sum(labels))
normalizer_comp = label_comp / label_weighted_comp</p>
<p># note that up_weight=True changes these for the rest of the twml.metric.rce computation
weights = tf.ones(shape=tf.shape(labels), dtype=tf.float32, name=”default_weight”)
total_positive = total_positive_unweighted
update_total_positive = update_total_positive_unweighted</p>
</dd>
<dt>else:</dt><dd><dl>
<dt>if deprecated_rce:</dt><dd><p>normalizer = tf.reduce_sum(label_weighted) / tf.reduce_sum(predictions_weighted)</p>
</dd>
<dt>else:</dt><dd><p># normalizer used for NRCE (and ARCE with up_weight=True)
total_prediction = _metric_variable(name=’total_prediction’, shape=[], dtype=tf.float32)</p>
<p># update the variable holding the sum of weighted predictions
update_total_prediction = tf.assign_add(</p>
<blockquote>
<div><p>total_prediction, tf.reduce_sum(predictions_weighted), name=”total_prediction_update”)</p>
</div></blockquote>
<p># this used to be tf.reduce_sum(label_weighted) / tf.reduce_sum(predictions_weighted)
# but it measure normalizer over batch was too flawed an approximation.
normalizer = update_total_positive / update_total_prediction</p>
</dd>
</dl>
</dd>
</dl>
<p>pred_comp = tf.subtract(tf.ones(shape=tf.shape(labels), dtype=tf.float32), predictions)
pred_comp_norm = tf.multiply(pred_comp, normalizer_comp, name=”normalized_predictions_comp”)
pred_num = tf.multiply(predictions, normalizer, name=”normalized_pred_numerator”)
pred_denom = tf.add(pred_num, pred_comp_norm, name=”normalized_pred_denominator”)
predictions = pred_num / pred_denom</p>
<p>return predictions, total_positive, update_total_positive, weights</p>
</dd>
<dt>def rce(labels, predictions,</dt><dd><blockquote>
<div><p>weights=None,
normalize=False,
arce=False,
up_weight=True,
metrics_collections=None,
updates_collections=None,
name=None,
deprecated_rce=False):</p>
</div></blockquote>
<p>“””
Compute the relative cross entropy (RCE).
The RCE is a relative measurement compared to the baseline model’s performance.
The baseline model always predicts average click-through-rate (CTR).
The RCE measures, in percentage, how much better the predictions are, compared
to the baseline model, in terms of cross entropy loss.</p>
<p>y = label; p = prediction;
binary cross entropy = y * log(p) + (1-y) * log(1-p)</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>labels:</dt><dd><p>the ground true value.</p>
</dd>
<dt>predictions:</dt><dd><p>the predicted values, whose shape must match labels.</p>
</dd>
<dt>weights:</dt><dd><p>optional weights, whose shape must match labels . Weight is 1 if not set.</p>
</dd>
<dt>normalize:</dt><dd><p>if set to true, produce NRCEs used at Twitter. (normalize preds by weights first)
NOTE: if you don’t understand what NRCE is, please don’t use it.</p>
</dd>
<dt>arce:</dt><dd><p>if set to true, produces <a class="reference external" href="http://go/arce">ARCE</a>.
This can only be activated if <cite>normalize=True</cite>.</p>
</dd>
<dt>up_weight:</dt><dd><p>if set to true, produces arce in the up_weighted space (considers CTR after up_weighting
data), while False gives arce in the original space (only considers CTR before up_weighting).
In the actual version, this flag can only be activated if arce is True.
Notice that the actual version of NRCE corresponds to up_weight=True.</p>
</dd>
<dt>metrics_collections:</dt><dd><p>optional list of collections to add this metric into.</p>
</dd>
<dt>updates_collections:</dt><dd><p>optional list of collections to add the associated update_op into.</p>
</dd>
<dt>name:</dt><dd><p>an optional variable_scope name.</p>
</dd>
<dt>deprecated_rce:</dt><dd><p>enables the previous NRCE/ARCE calculations which calculated some label metrics
on the batch instead of on all batches seen so far. Note that the older metric
calculation is less stable, especially for smaller batch sizes. You should probably
never have to set this to True.</p>
</dd>
</dl>
</dd>
<dt>Return:</dt><dd><dl class="simple">
<dt>rce_value:</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">Tensor</span></code> representing the RCE.</p>
</dd>
<dt>update_op:</dt><dd><p>A update operation used to accumulate data into this metric.</p>
</dd>
</dl>
</dd>
</dl>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Must have at least 1 positive and 1 negative sample accumulated,
or RCE will come out as NaN.</p>
</div>
<p>“””
with tf.variable_scope(name, ‘rce’, (labels, predictions, weights)):</p>
<blockquote>
<div><p>labels = tf.to_float(labels, name=”label_to_float”)
predictions = tf.to_float(predictions, name=”predictions_to_float”)</p>
<dl class="simple">
<dt>if weights is None:</dt><dd><p>weights = tf.ones(shape=tf.shape(labels), dtype=tf.float32, name=”default_weight”)</p>
</dd>
<dt>else:</dt><dd><p>weights = tf.to_float(weights, name=”weight_to_float”)</p>
</dd>
</dl>
<p>total_positive = _metric_variable(name=’total_positive’, shape=[], dtype=tf.float32)
total_loss = _metric_variable(name=’total_loss’, shape=[], dtype=tf.float32)
total_weight = _metric_variable(name=’total_weight’, shape=[], dtype=tf.float32)</p>
<p>label_weighted = tf.multiply(labels, weights, name=”weighted_label”)</p>
<dl>
<dt>update_total_positive = tf.assign_add(</dt><dd><p>total_positive, tf.reduce_sum(label_weighted), name=”total_pos_update”)</p>
</dd>
<dt>if arce:</dt><dd><dl class="simple">
<dt>if normalize is False:</dt><dd><p>raise ValueError(‘This configuration of parameters is not actually allowed’)</p>
</dd>
<dt>predictions, total_positive, update_total_positive, weights = _get_arce_predictions(</dt><dd><p>predictions=predictions, weights=weights, deprecated_rce=deprecated_rce,
label_weighted=label_weighted, labels=labels, up_weight=up_weight,
total_positive=total_positive, update_total_positive=update_total_positive)</p>
</dd>
</dl>
</dd>
<dt>elif normalize:</dt><dd><p>predictions_weighted = tf.multiply(predictions, weights, name=”weighted_preds”)</p>
<dl>
<dt>if deprecated_rce:</dt><dd><p>normalizer = tf.reduce_sum(label_weighted) / tf.reduce_sum(predictions_weighted)</p>
</dd>
<dt>else:</dt><dd><p>total_prediction = _metric_variable(name=’total_prediction’, shape=[], dtype=tf.float32)</p>
<p># update the variable holding the sum of weighted predictions
update_total_prediction = tf.assign_add(</p>
<blockquote>
<div><p>total_prediction, tf.reduce_sum(predictions_weighted), name=”total_prediction_update”)</p>
</div></blockquote>
<p># this used to be tf.reduce_sum(label_weighted) / tf.reduce_sum(predictions_weighted)
# but it measure normalizer over batch was too flawed an approximation.
normalizer = update_total_positive / update_total_prediction</p>
</dd>
</dl>
<p># NRCE
predictions = tf.multiply(predictions, normalizer, name=”normalized_predictions”)</p>
</dd>
</dl>
<p># clamp predictions to keep log(p) stable
clip_p = tf.clip_by_value(predictions, CLAMP_EPSILON, 1.0 - CLAMP_EPSILON, name=”clip_p”)
logloss = _binary_cross_entropy(pred=clip_p, target=labels, name=”logloss”)</p>
<p>logloss_weighted = tf.multiply(logloss, weights, name=”weighted_logloss”)</p>
<dl class="simple">
<dt>update_total_loss = tf.assign_add(</dt><dd><p>total_loss, tf.reduce_sum(logloss_weighted), name=”total_loss_update”)</p>
</dd>
<dt>update_total_weight = tf.assign_add(</dt><dd><p>total_weight, tf.reduce_sum(weights), name=”total_weight_update”)</p>
</dd>
</dl>
<p># metric value retrieval subgraph
ctr1 = tf.truediv(total_positive, total_weight, name=”ctr”)
# Note: we don’t have to keep running averages for computing baseline CE. Because the prediction
# is constant for every sample, we can simplify it to the formula below.
baseline_ce = _binary_cross_entropy(pred=ctr1, target=ctr1, name=”baseline_ce”)
pred_ce = tf.truediv(total_loss, total_weight, name=”pred_ce”)</p>
<dl class="simple">
<dt>rce_t = tf.multiply(</dt><dd><p>1.0 - tf.truediv(pred_ce, baseline_ce),
100,
name=”rce”)</p>
</dd>
</dl>
<p># metric update subgraph
ctr2 = tf.truediv(update_total_positive, update_total_weight, name=”ctr_update”)
# Note: we don’t have to keep running averages for computing baseline CE. Because the prediction
# is constant for every sample, we can simplify it to the formula below.
baseline_ce2 = _binary_cross_entropy(pred=ctr2, target=ctr2, name=”baseline_ce_update”)
pred_ce2 = tf.truediv(update_total_loss, update_total_weight, name=”pred_ce_update”)</p>
<dl class="simple">
<dt>update_op = tf.multiply(</dt><dd><p>1.0 - tf.truediv(pred_ce2, baseline_ce2),
100,
name=”update_op”)</p>
</dd>
<dt>if metrics_collections:</dt><dd><p>tf.add_to_collections(metrics_collections, rce_t)</p>
</dd>
<dt>if updates_collections:</dt><dd><p>tf.add_to_collections(updates_collections, update_op)</p>
</dd>
</dl>
<p>return rce_t, update_op</p>
</div></blockquote>
</dd>
<dt>def ce(p_true, p_est=None):</dt><dd><dl class="simple">
<dt>if p_est is None:</dt><dd><p>p_est = p_true</p>
</dd>
</dl>
<p>return _binary_cross_entropy(pred=p_est, target=p_true, name=None)</p>
</dd>
<dt>def rce_transform(outputs, labels, weights):</dt><dd><p>‘’’
Construct an OrderedDict of quantities to aggregate over eval batches
outputs, labels, weights are TensorFlow tensors, and are assumed to</p>
<blockquote>
<div><p>be of shape [N] for batch_size = N</p>
</div></blockquote>
<p>Each entry in the output OrderedDict should also be of shape [N]
‘’’
out_vals = OrderedDict()
out_vals[‘weighted_loss’] = weights * ce(p_true=labels, p_est=outputs)
out_vals[‘weighted_labels’] = labels * weights
out_vals[‘weight’] = weights
return out_vals</p>
</dd>
<dt>def rce_metric(aggregates):</dt><dd><p>‘’’
input <code class="docutils literal notranslate"><span class="pre">aggregates</span></code> is an OrderedDict with the same keys as those created</p>
<blockquote>
<div><p>by rce_transform(). The dict values are the aggregates (reduce_sum)
of the values produced by rce_transform(), and should be scalars.</p>
</div></blockquote>
<p>output is the value of RCE
‘’’
# cummulative weighted loss of model predictions
total_weighted_loss = aggregates[‘weighted_loss’]
total_weighted_labels = aggregates[‘weighted_labels’]
total_weight = aggregates[‘weight’]</p>
<p>model_average_loss = total_weighted_loss / total_weight
baseline_average_loss = ce(total_weighted_labels / total_weight)
return 100.0 * (1 - model_average_loss / baseline_average_loss)</p>
</dd>
<dt>def metric_std_err(labels, predictions,</dt><dd><blockquote>
<div><p>weights=None,
transform=rce_transform, metric=rce_metric,
metrics_collections=None,
updates_collections=None,
name=’rce_std_err’):</p>
</div></blockquote>
<p>“””
Compute the weighted standard error of the RCE metric on this eval set.
This can be used for confidence intervals and unpaired hypothesis tests.</p>
<dl>
<dt>Args:</dt><dd><p>labels: the ground truth value.
predictions: the predicted values, whose shape must match labels.
weights: optional weights, whose shape must match labels . Weight is 1 if not set.
transform: a function of the following form:</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">transform</span><span class="p">(</span><span class="n">outputs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
  <span class="n">out_vals</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
  <span class="o">...</span>
  <span class="k">return</span> <span class="n">out_vals</span>
</pre></div>
</div>
<p>where outputs, labels, and weights are all tensors of shape [eval_batch_size].
The returned OrderedDict() should have values that are tensors of shape  [eval_batch_size].
These will be aggregated across many batches in the eval dataset, to produce
one scalar value per key of out_vals.</p>
</div></blockquote>
<p>metric: a function of the following form</p>
<blockquote>
<div><div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">metric</span><span class="p">(</span><span class="n">aggregates</span><span class="p">):</span>
  <span class="o">...</span>
  <span class="k">return</span> <span class="n">metric_value</span>
</pre></div>
</div>
<p>where aggregates is an OrderedDict() having the same keys created by transform().
Each of the corresponding dict values is the reduce_sum of the values produced by
transform(), and is a TF scalar. The return value should be a scalar representing
the value of the desired metric.</p>
</div></blockquote>
<p>metrics_collections: optional list of collections to add this metric into.
updates_collections: optional list of collections to add the associated update_op into.
name: an optional variable_scope name.</p>
</dd>
<dt>Return:</dt><dd><p>metric value: A <cite>Tensor</cite> representing the value of the metric on the data accumulated so far.
update_op: A update operation used to accumulate data into this metric.</p>
</dd>
</dl>
<p>“””
with tf.variable_scope(name, ‘metric_std_err’, (labels, predictions, weights)):</p>
<blockquote>
<div><p>labels = tf.cast(labels, tf.float64)
predictions = tf.cast(predictions, tf.float64)</p>
<dl class="simple">
<dt>if weights is None:</dt><dd><p>weights = tf.ones_like(labels, dtype=tf.float64, name=”default_weight”)</p>
</dd>
<dt>else:</dt><dd><p>weights = tf.cast(weights, tf.float64)</p>
</dd>
</dl>
<p>labels = tf.reshape(labels, [-1])
predictions = tf.reshape(predictions, [-1])
predictions = tf.clip_by_value(predictions, CLAMP_EPSILON, 1.0 - CLAMP_EPSILON, name=”clip_p”)
weights = tf.reshape(weights, [-1])</p>
<p># first apply the supplied transform function to the output, label, weight data
# returns an OrderedDict of 1xN tensors for N input samples
# for each sample, compute f = transform(pred, l, w)
transformed = transform(predictions, labels, weights)</p>
<p># we track 3 types of aggregate information
# 1. total number of samples
# 2. aggregated transformed samples (moment1), i.e. sum(f)
# 3. aggregated crosses of transformed samples (moment2), i.e. sum(f*f^T)</p>
<p># count total number of samples
sample_count = _metric_variable(</p>
<blockquote>
<div><p>name=’sample_count’, shape=[], dtype=tf.int64)</p>
</div></blockquote>
<p>update_sample_count = tf.assign_add(sample_count, tf.size(labels, out_type=sample_count.dtype))</p>
<p># compose the ordered dict into a single vector
# so f can be treated as a single column vector rather than a collection of scalars
N = len(transformed)
transformed_vec = tf.stack(list(transformed.values()), axis=1)</p>
<p># compute and update transformed samples (1st order statistics)
# i.e. accumulate f into F as F += sum(f)
aggregates_1 = _metric_variable(</p>
<blockquote>
<div><p>name=’aggregates_1’, shape=[N], dtype=tf.float64)</p>
</div></blockquote>
<p>update_aggregates_1 = tf.assign_add(aggregates_1, tf.reduce_sum(transformed_vec, axis=0))</p>
<p># compute and update crossed transformed samples (2nd order statistics)
# i.e. accumulate f*f^T into F2 as F2 += sum(f*transpose(f))
aggregates_2 = _metric_variable(</p>
<blockquote>
<div><p>name=’aggregates_2’, shape=[N, N], dtype=tf.float64)</p>
</div></blockquote>
<dl class="simple">
<dt>moment_2_temp = (</dt><dd><p>tf.reshape(transformed_vec, shape=[-1, N, 1])
* tf.reshape(transformed_vec, shape=[-1, 1, N])</p>
</dd>
</dl>
<p>)
update_aggregates_2 = tf.assign_add(aggregates_2, tf.reduce_sum(moment_2_temp, axis=0))</p>
<dl>
<dt>def compute_output(agg_1, agg_2, samp_cnt):</dt><dd><p># decompose the aggregates back into a dict to pass to the user-supplied metric fn
aggregates_dict = OrderedDict()
for i, key in enumerate(transformed.keys()):</p>
<blockquote>
<div><p>aggregates_dict[key] = agg_1[i]</p>
</div></blockquote>
<p>metric_value = metric(aggregates_dict)</p>
<p># derivative of metric with respect to the 1st order aggregates
# i.e. d M(agg1) / d agg1
metric_prime = tf.gradients(metric_value, agg_1, stop_gradients=agg_1)</p>
<p># estimated covariance of agg_1
# cov(F) = sum(f*f^T) - (sum(f) * sum(f)^T) / N
#     = agg_2 - (agg_1 * agg_1^T) / N
N_covariance_estimate = agg_2 - (</p>
<blockquote>
<div><p>tf.reshape(agg_1, shape=[-1, 1])
&#64; tf.reshape(agg_1, shape=[1, -1])
/ tf.cast(samp_cnt, dtype=tf.float64)</p>
</div></blockquote>
<p>)</p>
<p># push N_covariance_estimate through a linearization of metric around agg_1
# metric var = transpose(d M(agg1) / d agg1) * cov(F) * (d M(agg1) / d agg1)
metric_variance = (</p>
<blockquote>
<div><p>tf.reshape(metric_prime, shape=[1, -1])
&#64; N_covariance_estimate
&#64; tf.reshape(metric_prime, shape=[-1, 1])</p>
</div></blockquote>
<p>)
# result should be a single element, but the matmul is 2D
metric_variance = metric_variance[0][0]
metric_stderr = tf.sqrt(metric_variance)
return metric_stderr</p>
</dd>
</dl>
<p>metric_stderr = compute_output(aggregates_1, aggregates_2, sample_count)
update_metric_stderr = compute_output(update_aggregates_1, update_aggregates_2, update_sample_count)</p>
<dl class="simple">
<dt>if metrics_collections:</dt><dd><p>tf.add_to_collections(metrics_collections, metric_stderr)</p>
</dd>
<dt>if updates_collections:</dt><dd><p>tf.add_to_collections(updates_collections, update_metric_stderr)</p>
</dd>
</dl>
<p>return metric_stderr, update_metric_stderr</p>
</div></blockquote>
</dd>
<dt>def lolly_nrce(labels, predictions,</dt><dd><blockquote>
<div><p>weights=None,
metrics_collections=None,
updates_collections=None,
name=None):</p>
</div></blockquote>
<p>“””
Compute the Lolly NRCE.</p>
<p>Note: As this NRCE calculation uses Taylor expansion, it becomes inaccurate when the ctr is large,
especially when the adjusted ctr goes above 1.0.</p>
<p>Calculation:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">NRCE</span><span class="p">:</span> <span class="n">lolly</span> <span class="n">NRCE</span>
<span class="n">BCE</span><span class="p">:</span> <span class="n">baseline</span> <span class="n">cross</span> <span class="n">entropy</span>
<span class="n">NCE</span><span class="p">:</span> <span class="n">normalized</span> <span class="n">cross</span> <span class="n">entropy</span>
<span class="n">CE</span><span class="p">:</span> <span class="n">cross</span> <span class="n">entropy</span>
<span class="n">y_i</span><span class="p">:</span> <span class="n">label</span> <span class="n">of</span> <span class="n">example</span> <span class="n">i</span>
<span class="n">p_i</span><span class="p">:</span> <span class="n">prediction</span> <span class="n">of</span> <span class="n">example</span> <span class="n">i</span>
<span class="n">y</span><span class="p">:</span> <span class="n">ctr</span>
<span class="n">p</span><span class="p">:</span> <span class="n">average</span> <span class="n">prediction</span>
<span class="n">a</span><span class="p">:</span> <span class="n">normalizer</span>

<span class="n">Assumes</span> <span class="nb">any</span> <span class="n">p_i</span> <span class="ow">and</span> <span class="n">a</span> <span class="o">*</span> <span class="n">p_i</span> <span class="ow">is</span> <span class="n">within</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">NRCE</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">NCE</span> <span class="o">/</span> <span class="n">BCE</span><span class="p">)</span> <span class="o">*</span> <span class="mi">100</span>
<span class="n">BCE</span> <span class="o">=</span> <span class="o">-</span> <span class="n">sum_i</span><span class="p">(</span><span class="n">y_i</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="p">))</span>
    <span class="o">=</span> <span class="o">-</span> <span class="p">(</span><span class="n">y</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y</span><span class="p">))</span>
<span class="n">a</span> <span class="o">=</span> <span class="n">y</span> <span class="o">/</span> <span class="n">p</span>
<span class="n">CE</span> <span class="o">=</span> <span class="o">-</span> <span class="n">sum_i</span><span class="p">(</span><span class="n">y_i</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">p_i</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_i</span><span class="p">))</span>
<span class="n">NCE</span> <span class="o">=</span> <span class="o">-</span> <span class="n">sum_i</span><span class="p">(</span><span class="n">y_i</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">a</span> <span class="o">*</span> <span class="n">p_i</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">p_i</span><span class="p">))</span>
    <span class="o">=</span> <span class="o">-</span> <span class="n">sum_i</span><span class="p">(</span><span class="n">y_i</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">p_i</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_i</span><span class="p">))</span>
      <span class="o">-</span> <span class="n">sum_i</span><span class="p">(</span><span class="n">y_i</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>
      <span class="o">+</span> <span class="n">sum_i</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">p_i</span><span class="p">))</span>
      <span class="o">-</span> <span class="n">sum_i</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">a</span> <span class="o">*</span> <span class="n">p_i</span><span class="p">))</span>
    <span class="o">~=</span> <span class="n">CE</span> <span class="o">-</span> <span class="n">sum_i</span><span class="p">(</span><span class="n">y_i</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
      <span class="o">+</span> <span class="n">sum_i</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span> <span class="n">sum_</span><span class="p">{</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">~</span><span class="mi">5</span><span class="p">}(</span><span class="n">p_i</span><span class="o">^</span><span class="n">j</span> <span class="o">/</span> <span class="n">j</span><span class="p">)))</span>
      <span class="o">-</span> <span class="n">sum_i</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span> <span class="n">sum_</span><span class="p">{</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">~</span><span class="mi">5</span><span class="p">}(</span><span class="n">a</span><span class="o">^</span><span class="n">j</span> <span class="o">*</span> <span class="n">p_i</span><span class="o">^</span><span class="n">j</span> <span class="o">/</span> <span class="n">j</span><span class="p">)))</span>
      <span class="c1"># Takes 5 items from the Taylor expansion, can be increased if needed</span>
      <span class="c1"># Error for each example is O(p_i^6)</span>
    <span class="o">=</span> <span class="n">CE</span> <span class="o">-</span> <span class="n">sum_i</span><span class="p">(</span><span class="n">y_i</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
      <span class="o">-</span> <span class="n">sum_</span><span class="p">{</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">~</span><span class="mi">5</span><span class="p">}(</span><span class="n">sum_i</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_i</span><span class="o">^</span><span class="n">j</span><span class="p">)</span> <span class="o">/</span> <span class="n">j</span><span class="p">)</span>
      <span class="o">+</span> <span class="n">sum_</span><span class="p">{</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">~</span><span class="mi">5</span><span class="p">}(</span><span class="n">sum_i</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_i</span><span class="o">^</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="o">^</span><span class="n">j</span> <span class="o">/</span> <span class="n">j</span><span class="p">)</span>
    <span class="o">=</span> <span class="n">CE</span> <span class="o">-</span> <span class="n">sum_i</span><span class="p">(</span><span class="n">y_i</span><span class="p">)</span> <span class="o">*</span> <span class="n">log</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
      <span class="o">+</span> <span class="n">sum_</span><span class="p">{</span><span class="n">j</span><span class="o">=</span><span class="mi">1</span><span class="o">~</span><span class="mi">5</span><span class="p">}(</span><span class="n">sum_i</span><span class="p">((</span><span class="mi">1</span> <span class="o">-</span> <span class="n">y_i</span><span class="p">)</span> <span class="o">*</span> <span class="n">p_i</span><span class="o">^</span><span class="n">j</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">a</span><span class="o">^</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">j</span><span class="p">)</span>
</pre></div>
</div>
<p>Thus we keep track of CE, sum_i(y_i), sum_i((1 - y_i) * p_i^j) for j=1~5.
We also keep track of p and y by sum_i(y_i), sum_i(p_i), sum_i(1) so that
we can get a at the end, which leads to this NRCE.</p>
<p>NRCE uses ctr and average pctr to normalize the pctrs.
It removes the impact of prediction error from RCE.
Usually NRCE is higher as the prediction error impact on RCE is negative.
Removing prediction error in our model can make RCE closer to NRCE and thus improve RCE.</p>
<p>In Lolly NRCE we use ctr and average pctr of the whole dataset.
We thus remove the dataset level error in NRCE calculation.
In this case, when we want to improve RCE to the level of NRCE,
it is achievable as dataset level prediction error is easy to remove by calibration.
Lolly NRCE is thus a good estimate about the potential gain by adding calibration.</p>
<p>In DBv2 NRCE, we use per-batch ctr and average pctr. We remove the batch level error.
This error is difficult to remove by modeling improvement,
at least not by simple calibration.
It thus cannot indicate the same opportunity as the Lolly NRCE does.</p>
<dl class="simple">
<dt>Args:</dt><dd><dl class="simple">
<dt>labels:</dt><dd><p>the ground true value.</p>
</dd>
<dt>predictions:</dt><dd><p>the predicted values, whose shape must match labels.</p>
</dd>
<dt>weights:</dt><dd><p>optional weights, whose shape must match labels . Weight is 1 if not set.</p>
</dd>
<dt>metrics_collections:</dt><dd><p>optional list of collections to add this metric into.</p>
</dd>
<dt>updates_collections:</dt><dd><p>optional list of collections to add the associated update_op into.</p>
</dd>
<dt>name:</dt><dd><p>an optional variable_scope name.</p>
</dd>
</dl>
</dd>
<dt>Return:</dt><dd><dl class="simple">
<dt>rce_value:</dt><dd><p>A <code class="docutils literal notranslate"><span class="pre">Tensor</span></code> representing the RCE.</p>
</dd>
<dt>update_op:</dt><dd><p>A update operation used to accumulate data into this metric.</p>
</dd>
</dl>
</dd>
<dt>Note: Must have at least 1 positive and 1 negative sample accumulated,</dt><dd><p>or NRCE will come out as NaN.</p>
</dd>
</dl>
<p>“””
with tf.variable_scope(name, “lolly_nrce”, (labels, predictions, weights)):</p>
<blockquote>
<div><p>labels = tf.to_float(labels, name=”label_to_float”)
predictions = tf.to_float(predictions, name=”predictions_to_float”)</p>
<dl class="simple">
<dt>if weights is None:</dt><dd><p>weights = tf.ones(shape=tf.shape(labels), dtype=tf.float32, name=”default_weight”)</p>
</dd>
<dt>else:</dt><dd><p>weights = tf.to_float(weights, name=”weight_to_float”)</p>
</dd>
</dl>
<p>positive_weights = tf.multiply(labels, weights, name=”positive_weights”)</p>
<p># clamp predictions to keep log(p) stable
clip_predictions = tf.clip_by_value(</p>
<blockquote>
<div><p>predictions,
CLAMP_EPSILON,
1.0 - CLAMP_EPSILON,
name=”clip_predictions”)</p>
</div></blockquote>
<dl class="simple">
<dt>weighted_predictions = tf.multiply(</dt><dd><p>predictions, weights,
name=”weighted_predictions”)</p>
</dd>
</dl>
<p>logloss = _binary_cross_entropy(pred=clip_predictions, target=labels, name=”logloss”)
weighted_logloss = tf.multiply(logloss, weights, name=”weighted_logloss”)</p>
<dl class="simple">
<dt>negatives = tf.subtract(</dt><dd><p>tf.ones(shape=tf.shape(labels), dtype=tf.float32),
labels,
name=”negatives”)</p>
</dd>
<dt>negative_predictions = tf.multiply(</dt><dd><p>predictions,
negatives,
name=”negative_predictions”)</p>
</dd>
<dt>weighted_negative_predictions = tf.multiply(</dt><dd><p>negative_predictions, weights,
name=”weighted_negative_predictions”)</p>
</dd>
<dt>negative_squared_predictions = tf.multiply(</dt><dd><p>negative_predictions,
negative_predictions,
name=”negative_squared_predictions”)</p>
</dd>
<dt>weighted_negative_squared_predictions = tf.multiply(</dt><dd><p>negative_squared_predictions, weights,
name=”weighted_negative_squared_predictions”)</p>
</dd>
<dt>negative_cubed_predictions = tf.multiply(</dt><dd><p>negative_squared_predictions,
negative_predictions,
name=”negative_cubed_predictions”)</p>
</dd>
<dt>weighted_negative_cubed_predictions = tf.multiply(</dt><dd><p>negative_cubed_predictions, weights,
name=”weighted_negative_cubed_predictions”)</p>
</dd>
<dt>negative_quartic_predictions = tf.multiply(</dt><dd><p>negative_cubed_predictions,
negative_predictions,
name=”negative_quartic_predictions”)</p>
</dd>
<dt>weighted_negative_quartic_predictions = tf.multiply(</dt><dd><p>negative_quartic_predictions, weights,
name=”weighted_negative_quartic_predictions”)</p>
</dd>
<dt>negative_quintic_predictions = tf.multiply(</dt><dd><p>negative_quartic_predictions,
negative_predictions,
name=”negative_quintic_predictions”)</p>
</dd>
<dt>weighted_negative_quintic_predictions = tf.multiply(</dt><dd><p>negative_quintic_predictions, weights,
name=”weighted_negative_quintic_predictions”)</p>
</dd>
</dl>
<p># Tracked stats
total_positive = _metric_variable(name=”total_positive”, shape=[], dtype=tf.float32)
total_weight = _metric_variable(name=”total_weight”, shape=[], dtype=tf.float32)</p>
<p>total_prediction = _metric_variable(name=”total_prediction”, shape=[], dtype=tf.float32)</p>
<dl class="simple">
<dt>total_negative_prediction = _metric_variable(</dt><dd><p>name=”total_negative_prediction”,
shape=[], dtype=tf.float32)</p>
</dd>
<dt>total_negative_squared_prediction = _metric_variable(</dt><dd><p>name=”total_negative_squared_prediction”,
shape=[], dtype=tf.float32)</p>
</dd>
<dt>total_negative_cubed_prediction = _metric_variable(</dt><dd><p>name=”total_negative_cubed_prediction”,
shape=[], dtype=tf.float32)</p>
</dd>
<dt>total_negative_quartic_prediction = _metric_variable(</dt><dd><p>name=”total_negative_quartic_prediction”,
shape=[], dtype=tf.float32)</p>
</dd>
<dt>total_negative_quintic_prediction = _metric_variable(</dt><dd><p>name=”total_negative_quintic_prediction”,
shape=[], dtype=tf.float32)</p>
</dd>
</dl>
<p>total_loss = _metric_variable(name=”total_loss”, shape=[], dtype=tf.float32)</p>
<p># Update tracked stats
update_total_positive = tf.assign_add(</p>
<blockquote>
<div><p>total_positive, tf.reduce_sum(positive_weights), name=”total_positive_update”)</p>
</div></blockquote>
<dl class="simple">
<dt>update_total_weight = tf.assign_add(</dt><dd><p>total_weight, tf.reduce_sum(weights), name=”total_weight_update”)</p>
</dd>
<dt>update_total_prediction = tf.assign_add(</dt><dd><p>total_prediction, tf.reduce_sum(weighted_predictions), name=”total_prediction_update”)</p>
</dd>
<dt>update_total_negative_prediction = tf.assign_add(</dt><dd><p>total_negative_prediction,
tf.reduce_sum(weighted_negative_predictions), name=”total_negative_prediction_update”)</p>
</dd>
<dt>update_total_negative_squared_prediction = tf.assign_add(</dt><dd><p>total_negative_squared_prediction,
tf.reduce_sum(weighted_negative_squared_predictions),
name=”total_negative_squared_prediction_update”)</p>
</dd>
<dt>update_total_negative_cubed_prediction = tf.assign_add(</dt><dd><p>total_negative_cubed_prediction,
tf.reduce_sum(weighted_negative_cubed_predictions),
name=”total_negative_cubed_prediction_update”)</p>
</dd>
<dt>update_total_negative_quartic_prediction = tf.assign_add(</dt><dd><p>total_negative_quartic_prediction,
tf.reduce_sum(weighted_negative_quartic_predictions),
name=”total_negative_quartic_prediction_update”)</p>
</dd>
<dt>update_total_negative_quintic_prediction = tf.assign_add(</dt><dd><p>total_negative_quintic_prediction,
tf.reduce_sum(weighted_negative_quintic_predictions),
name=”total_negative_quintic_prediction_update”)</p>
</dd>
<dt>update_total_loss = tf.assign_add(</dt><dd><p>total_loss, tf.reduce_sum(weighted_logloss), name=”total_loss_update”)</p>
</dd>
</dl>
<p># metric value retrieval subgraph
# ctr of this batch
positive_rate = tf.truediv(total_positive, total_weight, name=”positive_rate”)
# Note: we don’t have to keep running averages for computing baseline CE. Because the prediction
# is constant for every sample, we can simplify it to the formula below.
baseline_loss = _binary_cross_entropy(</p>
<blockquote>
<div><p>pred=positive_rate,
target=positive_rate,
name=”baseline_loss”)</p>
</div></blockquote>
<p># normalizing ratio for nrce
# calculated using total ctr and pctr so the last batch has the dataset ctr and pctr
normalizer = tf.truediv(total_positive, total_prediction, name=”normalizer”)
# Taylor expansion to calculate nl = - sum(y * log(p * a) + (1 - y) * log (1 - p * a))
# log(1 - p * a) = -sum_{i=1~+inf}(a^i * x^i / i)
# log(1 - p) = -sum_{i=1~+inf}(a^i * x^i / i)
normalized_loss = (</p>
<blockquote>
<div><p>total_loss -
total_positive * tf.log(normalizer) +
total_negative_prediction * (normalizer - 1) +
total_negative_squared_prediction * (normalizer * normalizer - 1) / 2 +
total_negative_cubed_prediction *
(normalizer * normalizer * normalizer - 1) / 3 +
total_negative_quartic_prediction *
(normalizer * normalizer * normalizer * normalizer - 1) / 4 +
total_negative_quintic_prediction *
(normalizer * normalizer * normalizer * normalizer * normalizer - 1) / 5)</p>
</div></blockquote>
<p># average normalized loss
avg_loss = tf.truediv(normalized_loss, total_weight, name=”avg_loss”)</p>
<dl class="simple">
<dt>nrce_t = tf.multiply(</dt><dd><p>1.0 - tf.truediv(avg_loss, baseline_loss),
100,
name=”lolly_nrce”)</p>
</dd>
</dl>
<p># metric update subgraph
update_positive_rate = tf.truediv(</p>
<blockquote>
<div><p>update_total_positive,
update_total_weight,
name=”update_positive_rate”)</p>
</div></blockquote>
<p># Note: we don’t have to keep running averages for computing baseline CE. Because the prediction
# is constant for every sample, we can simplify it to the formula below.
update_baseline_loss = _binary_cross_entropy(</p>
<blockquote>
<div><p>pred=update_positive_rate,
target=update_positive_rate,
name=”update_baseline_loss”)</p>
</div></blockquote>
<dl>
<dt>update_normalizer = tf.truediv(</dt><dd><p>update_total_positive,
update_total_prediction,
name=”update_normalizer”)</p>
</dd>
<dt>update_normalized_loss = (</dt><dd><p>update_total_loss -
update_total_positive * tf.log(update_normalizer) +
update_total_negative_prediction *
(update_normalizer - 1) +
update_total_negative_squared_prediction *
(update_normalizer * update_normalizer - 1) / 2 +
update_total_negative_cubed_prediction *
(update_normalizer * update_normalizer * update_normalizer - 1) / 3 +
update_total_negative_quartic_prediction *
(update_normalizer * update_normalizer * update_normalizer *</p>
<blockquote>
<div><p>update_normalizer - 1) / 4 +</p>
</div></blockquote>
<p>update_total_negative_quintic_prediction *
(update_normalizer * update_normalizer * update_normalizer *</p>
<blockquote>
<div><p>update_normalizer * update_normalizer - 1) / 5)</p>
</div></blockquote>
</dd>
<dt>update_avg_loss = tf.truediv(</dt><dd><p>update_normalized_loss,
update_total_weight,
name=”update_avg_loss”)</p>
</dd>
<dt>update_op = tf.multiply(</dt><dd><p>1.0 - tf.truediv(update_avg_loss, update_baseline_loss),
100,
name=”update_op”)</p>
</dd>
<dt>if metrics_collections:</dt><dd><p>tf.add_to_collections(metrics_collections, nrce_t)</p>
</dd>
<dt>if updates_collections:</dt><dd><p>tf.add_to_collections(updates_collections, update_op)</p>
</dd>
</dl>
<p>return nrce_t, update_op</p>
</div></blockquote>
</dd>
<dt>def _binary_cross_entropy(pred, target, name):</dt><dd><dl class="simple">
<dt>return - tf.add(</dt><dd><p>target * tf.log(pred),
(1.0 - target) * tf.log(1.0 - pred),
name=name)</p>
</dd>
</dl>
</dd>
</dl>
<p># Copied from metrics_impl.py with minor modifications.
# <a class="reference external" href="https://github.com/tensorflow/tensorflow/blob/v1.5.0/tensorflow/python/ops/metrics_impl.py#L39">https://github.com/tensorflow/tensorflow/blob/v1.5.0/tensorflow/python/ops/metrics_impl.py#L39</a>
def _metric_variable(shape, dtype, validate_shape=True, name=None):</p>
<blockquote>
<div><p>“””Create variable in <cite>GraphKeys.(LOCAL|METRIC_VARIABLES</cite>) collections.”””</p>
<dl class="simple">
<dt>return tf.Variable(</dt><dd><p>lambda: tf.zeros(shape, dtype),
trainable=False,
collections=[tf.GraphKeys.LOCAL_VARIABLES, tf.GraphKeys.METRIC_VARIABLES],
validate_shape=validate_shape,
name=name)</p>
</dd>
</dl>
</div></blockquote>
<p>PERCENTILES = np.linspace(0, 1, 101, dtype=np.float32)</p>
<p># metric_name: (metric, requires thresholded output)
SUPPORTED_BINARY_CLASS_METRICS = {</p>
<blockquote>
<div><p># TWML metrics
‘total_weight’: (total_weight_metric, False),
‘num_samples’: (num_samples_metric, False),
‘rce’: (rce, False),
‘rce_std_err’: (partial(metric_std_err, transform=rce_transform, metric=rce_metric, name=’rce_std_err’), False),
‘nrce’: (partial(rce, normalize=True), False),
‘lolly_nrce’: (lolly_nrce, False),
‘arce’: (partial(rce, normalize=True, arce=True), False),
‘arce_original’: (partial(rce, normalize=True, arce=True, up_weight=False), False),
# CTR measures positive sample ratio. This terminology is inherited from Ads.
‘ctr’: (ctr, False),
# predicted CTR measures predicted positive ratio.
‘predicted_ctr’: (predicted_ctr, False),
‘pred_std_dev’: (prediction_std_dev, False),
# thresholded metrics
‘accuracy’: (tf.metrics.accuracy, True),
‘precision’: (tf.metrics.precision, True),
‘recall’: (tf.metrics.recall, True),</p>
<p>‘false_positives’: (tf.metrics.false_positives, True),
‘false_negatives’: (tf.metrics.false_negatives, True),
‘true_positives’: (tf.metrics.true_positives, True),
‘true_negatives’: (tf.metrics.true_negatives, True),</p>
<p>‘precision_at_percentiles’: (partial(tf.metrics.precision_at_thresholds, thresholds=PERCENTILES), False),
‘recall_at_percentiles’: (partial(tf.metrics.recall_at_thresholds, thresholds=PERCENTILES), False),
‘false_positives_at_percentiles’: (partial(tf.metrics.false_positives_at_thresholds, thresholds=PERCENTILES), False),
‘false_negatives_at_percentiles’: (partial(tf.metrics.false_negatives_at_thresholds, thresholds=PERCENTILES), False),
‘true_positives_at_percentiles’: (partial(tf.metrics.true_positives_at_thresholds, thresholds=PERCENTILES), False),
‘true_negatives_at_percentiles’: (partial(tf.metrics.true_negatives_at_thresholds, thresholds=PERCENTILES), False),</p>
<p># tensorflow metrics
‘roc_auc’: (partial(tf.metrics.auc, curve=’ROC’,</p>
<blockquote>
<div><p>summation_method=’careful_interpolation’), False),</p>
</div></blockquote>
<dl class="simple">
<dt>‘pr_auc’: (partial(tf.metrics.auc, curve=’PR’,</dt><dd><p>summation_method=’careful_interpolation’), False),</p>
</dd>
</dl>
<p># tensorboard curves
‘pr_curve’: (tb.summary.v1.pr_curve_streaming_op, False),</p>
<p># deprecated metrics
‘deprecated_nrce’: (partial(rce, normalize=True, deprecated_rce=True), False),
‘deprecated_arce’: (partial(rce, normalize=True, arce=True, deprecated_rce=True), False),
‘deprecated_arce_original’: (partial(rce, normalize=True, arce=True,</p>
<blockquote>
<div><p>up_weight=False, deprecated_rce=True), False)</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
<p># default metrics provided by get_binary_class_metric_fn
DEFAULT_BINARY_CLASS_METRICS = [‘total_weight’, ‘num_samples’, ‘rce’, ‘rce_std_err’,</p>
<blockquote>
<div><p>‘nrce’, ‘arce’, ‘ctr’, ‘predicted_ctr’, ‘pred_std_dev’,
‘accuracy’, ‘precision’, ‘recall’, ‘roc_auc’, ‘pr_auc’]</p>
</div></blockquote>
<dl>
<dt>def get_binary_class_metric_fn(metrics=None):</dt><dd><p>“””
Returns a function having signature:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_eval_metric_ops</span><span class="p">(</span><span class="n">graph_output</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
  <span class="o">...</span>
  <span class="k">return</span> <span class="n">eval_metric_ops</span>
</pre></div>
</div>
<p>where the returned eval_metric_ops is a dict of common evaluation metric
Ops for binary classification. See <a class="reference external" href="https://www.tensorflow.org/api_docs/python/tf/estimator/EstimatorSpec">tf.estimator.EstimatorSpec</a>
for a description of eval_metric_ops. The graph_output is a the result
dict returned by build_graph. Labels and weights are tf.Tensors.</p>
<dl>
<dt>The following graph_output keys are recognized:</dt><dd><dl class="simple">
<dt>output:</dt><dd><p>the raw predictions between 0 and 1. Required.</p>
</dd>
<dt>threshold:</dt><dd><p>A value between 0 and 1 used to threshold the output into a hard_output.
Defaults to 0.5 when threshold and hard_output are missing.
Either threshold or hard_output can be provided, but not both.</p>
</dd>
<dt>hard_output:</dt><dd><p>A thresholded output. Either threshold or hard_output can be provided, but not both.</p>
</dd>
</dl>
</dd>
<dt>Args:</dt><dd><dl>
<dt>metrics (list of String):</dt><dd><p>a list of metrics of interest. E.g. [‘ctr’, ‘accuracy’, ‘rce’]
Element in the list can be a string from following supported metrics, or can be a tuple
with three items: metric name, metric function, bool for thresholded output.</p>
<p>These metrics are evaluated and reported to tensorboard <em>during the eval phases only</em>.
Supported metrics:</p>
<ul class="simple">
<li><p>ctr (same as positive sample ratio.)</p></li>
<li><p>rce (cross entropy loss compared to the baseline model of always predicting ctr)</p></li>
<li><p>nrce (normalized rce, do not use this one if you do not understand what it is)</p></li>
<li><p><a class="reference external" href="http://go/arce">arce</a> (a more recent proposed improvment over NRCE)</p></li>
<li><p>arce_original</p></li>
<li><p>lolly_nrce (NRCE as it is computed in Lolly, with Taylor expansion)</p></li>
<li><p>pr_auc</p></li>
<li><p>roc_auc</p></li>
<li><p>accuracy (percentage of predictions that are correct)</p></li>
<li><p>precision (true positives) / (true positives + false positives)</p></li>
<li><p>recall (true positives) / (true positives + false negatives)</p></li>
<li><p>pr_curve (precision-recall curve)</p></li>
<li><p>deprecated_arce (ARCE as it was calculated before a stability fix)</p></li>
<li><p>deprecated_nrce (NRCE as it was calculated before a stability fix)</p></li>
</ul>
<p>Example of metrics list with mixture of string and tuple:
metrics = [</p>
<blockquote>
<div><p>‘rce’,’nrce’,
‘roc_auc’,  # default roc_auc metric
(</p>
<blockquote>
<div><p>‘roc_auc_500’,  # give this metric a name
partial(tf.metrics.auc, curve=’ROC’, summation_method=’careful_interpolation’, num_thresholds=500),  # the metric fn
False,  # whether the metric requires thresholded output</p>
</div></blockquote>
<p>)]</p>
</div></blockquote>
<p>NOTE: When predicting rare events roc_auc can be underestimated. Increasing num_threshold
can reduce the underestimation. See go/roc-auc-pitfall for more details.</p>
<p>NOTE: accuracy / precision / recall apply to binary classification problems only.
I.e. a prediction is only considered correct if it matches the label. E.g. if the label
is 1.0, and the prediction is 0.99, it does not get credit.  If you want to use
precision / recall / accuracy metrics with soft predictions, you’ll need to threshold
your predictions into hard 0/1 labels.</p>
<p>When metrics is None (the default), it defaults to:
[rce, nrce, arce, ctr, predicted_ctr, accuracy, precision, recall, prauc, roc_auc],</p>
</dd>
</dl>
</dd>
</dl>
<p>“””
# pylint: disable=dict-keys-not-iterating
if metrics is None:</p>
<blockquote>
<div><p># remove expensive metrics by default for faster eval
metrics = list(DEFAULT_BINARY_CLASS_METRICS)</p>
</div></blockquote>
<dl>
<dt>def get_eval_metric_ops(graph_output, labels, weights):</dt><dd><p>“””
graph_output:</p>
<blockquote>
<div><p>dict that is returned by build_graph given input features.</p>
</div></blockquote>
<dl class="simple">
<dt>labels:</dt><dd><p>target labels associated to batch.</p>
</dd>
<dt>weights:</dt><dd><p>weights of the samples..</p>
</dd>
</dl>
<p>“””</p>
<p>eval_metric_ops = OrderedDict()</p>
<p>preds = graph_output[‘output’]</p>
<p>threshold = graph_output[‘threshold’] if ‘threshold’ in graph_output else 0.5</p>
<p>hard_preds = graph_output.get(‘hard_output’)
if hard_preds is None:</p>
<blockquote>
<div><p>hard_preds = tf.greater_equal(preds, threshold)</p>
</div></blockquote>
<p># add metrics to eval_metric_ops dict
for metric in metrics:</p>
<blockquote>
<div><dl>
<dt>if isinstance(metric, tuple) and len(metric) == 3:</dt><dd><p>metric_name, metric_factory, requires_threshold = metric
metric_name = metric_name.lower()</p>
</dd>
<dt>elif isinstance(metric, str):</dt><dd><p>metric_name = metric.lower()  # metric name are case insensitive.
metric_factory, requires_threshold = SUPPORTED_BINARY_CLASS_METRICS.get(metric_name)</p>
</dd>
<dt>else:</dt><dd><p>raise ValueError(“Metric should be either string or tuple of length 3.”)</p>
</dd>
<dt>if metric_name in eval_metric_ops:</dt><dd><p># avoid adding duplicate metrics.
continue</p>
</dd>
<dt>if metric_factory:</dt><dd><dl class="simple">
<dt>value_op, update_op = metric_factory(</dt><dd><p>labels=labels,
predictions=(hard_preds if requires_threshold else preds),
weights=weights, name=metric_name)</p>
</dd>
</dl>
<p>eval_metric_ops[metric_name] = (value_op, update_op)</p>
</dd>
<dt>else:</dt><dd><p>raise ValueError(‘Cannot find the metric named ‘ + metric_name)</p>
</dd>
</dl>
</div></blockquote>
<p>return eval_metric_ops</p>
</dd>
</dl>
<p>return get_eval_metric_ops</p>
</dd>
<dt>def get_multi_binary_class_metric_fn(metrics, classes=None, class_dim=1):</dt><dd><p>“””
Returns a function having signature:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_eval_metric_ops</span><span class="p">(</span><span class="n">graph_output</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
  <span class="o">...</span>
  <span class="k">return</span> <span class="n">eval_metric_ops</span>
</pre></div>
</div>
<p>where the returned eval_metric_ops is a dict of common evaluation metric
Ops for concatenated binary classifications. See <a class="reference external" href="https://www.tensorflow.org/api_docs/python/tf/estimator/EstimatorSpec">tf.estimator.EstimatorSpec</a>
for a description of eval_metric_ops. The graph_output is a the result
dict returned by build_graph. Labels and weights are tf.Tensors.</p>
<p>In multiple binary classification problems, the
<code class="docutils literal notranslate"><span class="pre">predictions</span></code> (that is, <code class="docutils literal notranslate"><span class="pre">graph_output['output']</span></code>)
are expected to have shape <code class="docutils literal notranslate"><span class="pre">batch_size</span> <span class="pre">x</span> <span class="pre">n_classes</span></code>,
where <code class="docutils literal notranslate"><span class="pre">n_classes</span></code> is the number of binary classification.
Binary classification at output[i] is expected to discriminate between <code class="docutils literal notranslate"><span class="pre">classes[i]</span></code> (1)
and NOT <code class="docutils literal notranslate"><span class="pre">classes[i]</span></code> (0). The labels should be of the same shape as <code class="docutils literal notranslate"><span class="pre">graph_output</span></code>
with binary values (0 or 1). The weights can be of size <code class="docutils literal notranslate"><span class="pre">batch_size</span></code> or
<code class="docutils literal notranslate"><span class="pre">batch_size</span> <span class="pre">x</span> <span class="pre">n_classes</span></code>. The <code class="docutils literal notranslate"><span class="pre">class_dim</span></code> contain separate probabilities,
and need to have separate metrics.</p>
<dl>
<dt>The following graph_output keys are recognized:</dt><dd><dl class="simple">
<dt>output:</dt><dd><p>the raw predictions between 0 and 1. Required.</p>
</dd>
<dt>threshold:</dt><dd><p>A value between 0 and 1 used to threshold the output into a hard_output.
Defaults to 0.5 when threshold and hard_output are missing.
Either threshold or hard_output can be provided, but not both.</p>
</dd>
<dt>hard_output:</dt><dd><p>A thresholded output. Either threshold or hard_output can be provided, but not both.</p>
</dd>
</dl>
</dd>
<dt>Args:</dt><dd><dl>
<dt>metrics (list of Metrics):</dt><dd><p>a list of metrics of interest. E.g. [‘ctr’, ‘accuracy’, ‘rce’]
Element in the list can be a string from following supported metrics, or can be a tuple
with three items: metric name, metric function, bool for thresholded output.</p>
<p>These metrics are evaluated and reported to tensorboard <em>during the eval phases only</em>.
Supported metrics:</p>
<ul class="simple">
<li><p>ctr (same as positive sample ratio.)</p></li>
<li><p>rce (cross entropy loss compared to the baseline model of always predicting ctr)</p></li>
<li><p>nrce (normalized rce, do not use this one if you do not understand what it is)</p></li>
<li><p>pr_auc</p></li>
<li><p>roc_auc</p></li>
<li><p>accuracy (percentage of predictions that are correct)</p></li>
<li><p>precision (true positives) / (true positives + false positives)</p></li>
<li><p>recall (true positives) / (true positives + false negatives)</p></li>
<li><p>pr_curve (precision-recall curve)</p></li>
</ul>
<p>Example of metrics list with mixture of string and tuple:
metrics = [</p>
<blockquote>
<div><p>‘rce’,’nrce’,
‘roc_auc’,  # default roc_auc metric
(</p>
<blockquote>
<div><p>‘roc_auc_500’,  # give this metric a name
partial(tf.metrics.auc, curve=’ROC’, summation_method=’careful_interpolation’, num_thresholds=500),  # the metric fn
False,  # whether the metric requires thresholded output</p>
</div></blockquote>
<p>)]</p>
</div></blockquote>
<p>NOTE: When prediction on rare events, roc_auc can be underestimated. Increase num_threshold
can reduce the underestimation. See go/roc-auc-pitfall for more details.</p>
<p>NOTE: accuracy / precision / recall apply to binary classification problems only.
I.e. a prediction is only considered correct if it matches the label. E.g. if the label
is 1.0, and the prediction is 0.99, it does not get credit.  If you want to use
precision / recall / accuracy metrics with soft predictions, you’ll need to threshold
your predictions into hard 0/1 labels.</p>
<p>When metrics is None (the default), it defaults to:
[rce, nrce, arce, ctr, predicted_ctr, accuracy, precision, recall, prauc, roc_auc],</p>
</dd>
<dt>classes (list of strings):</dt><dd><p>In case of multiple binary class models, the names for each class or label.
These are used to display metrics on tensorboard.
If these are not specified, the index in the class or label dimension is used, and you’ll
get metrics on tensorboard named like: accuracy_0, accuracy_1, etc.</p>
</dd>
<dt>class_dim (number):</dt><dd><p>Dimension of the classes in predictions. Defaults to 1, that is, batch_size x n_classes.</p>
</dd>
</dl>
</dd>
</dl>
<p>“””
# pylint: disable=invalid-name,dict-keys-not-iterating
if metrics is None:</p>
<blockquote>
<div><p># remove expensive metrics by default for faster eval
metrics = list(DEFAULT_BINARY_CLASS_METRICS)</p>
</div></blockquote>
<dl>
<dt>def get_eval_metric_ops(graph_output, labels, weights):</dt><dd><p>“””
graph_output:</p>
<blockquote>
<div><p>dict that is returned by build_graph given input features.</p>
</div></blockquote>
<dl class="simple">
<dt>labels:</dt><dd><p>target labels associated to batch.</p>
</dd>
<dt>weights:</dt><dd><p>weights of the samples..</p>
</dd>
</dl>
<p>“””</p>
<p>eval_metric_ops = OrderedDict()</p>
<p>preds = graph_output[‘output’]</p>
<p>threshold = graph_output[‘threshold’] if ‘threshold’ in graph_output else 0.5</p>
<p>hard_preds = graph_output.get(‘hard_output’)
if hard_preds is None:</p>
<blockquote>
<div><p>hard_preds = tf.greater_equal(preds, threshold)</p>
</div></blockquote>
<p>shape = labels.get_shape()
# basic sanity check: multi_metric dimension must exist
assert len(shape) &gt; class_dim, “Dimension specified by class_dim does not exist.”</p>
<p>num_labels = shape[class_dim]
# If we are doing multi-class / multi-label metric, the number of classes / labels must
# be know at graph construction time.  This dimension cannot have size None.
assert num_labels is not None, “The multi-metric dimension cannot be None.”
assert classes is None or len(classes) == num_labels, (</p>
<blockquote>
<div><p>“Number of classes must match the number of labels”)</p>
</div></blockquote>
<p>weights_shape = weights.get_shape() if weights is not None else None
if weights_shape is None:</p>
<blockquote>
<div><p>num_weights = None</p>
</div></blockquote>
<dl class="simple">
<dt>elif len(weights_shape) &gt; 1:</dt><dd><p>num_weights = weights_shape[class_dim]</p>
</dd>
<dt>else:</dt><dd><p>num_weights = 1</p>
</dd>
</dl>
<p>for i in range(num_labels):</p>
<blockquote>
<div><p># add metrics to eval_metric_ops dict
for metric in metrics:</p>
<blockquote>
<div><dl class="simple">
<dt>if isinstance(metric, tuple) and len(metric) == 3:</dt><dd><p>metric_name, metric_factory, requires_threshold = metric
metric_name = metric_name.lower()</p>
</dd>
<dt>elif isinstance(metric, str):</dt><dd><p>metric_name = metric.lower()  # metric name are case insensitive.
metric_factory, requires_threshold = SUPPORTED_BINARY_CLASS_METRICS.get(metric_name)</p>
</dd>
<dt>else:</dt><dd><p>raise ValueError(“Metric should be either string or tuple of length 3.”)</p>
</dd>
</dl>
<p>class_metric_name = metric_name + “_” + (classes[i] if classes is not None else str(i))</p>
<dl class="simple">
<dt>if class_metric_name in eval_metric_ops:</dt><dd><p># avoid adding duplicate metrics.
continue</p>
</dd>
</dl>
<p>class_labels = tf.gather(labels, indices=[i], axis=class_dim)
class_preds = tf.gather(preds, indices=[i], axis=class_dim)
class_hard_preds = tf.gather(hard_preds, indices=[i], axis=class_dim)</p>
<dl>
<dt>if num_weights is None:</dt><dd><p>class_weights = None</p>
</dd>
<dt>elif num_weights == num_labels:</dt><dd><p>class_weights = tf.gather(weights, indices=[i], axis=class_dim)</p>
</dd>
<dt>elif num_weights == 1:</dt><dd><p>class_weights = weights</p>
</dd>
<dt>else:</dt><dd><dl class="simple">
<dt>raise ValueError(“num_weights (%d) and num_labels (%d) do not match”</dt><dd><p>% (num_weights, num_labels))</p>
</dd>
</dl>
</dd>
<dt>if metric_factory:</dt><dd><dl class="simple">
<dt>value_op, update_op = metric_factory(</dt><dd><p>labels=class_labels,
predictions=(class_hard_preds if requires_threshold else class_preds),
weights=class_weights, name=class_metric_name)</p>
</dd>
</dl>
<p>eval_metric_ops[class_metric_name] = (value_op, update_op)</p>
</dd>
<dt>else:</dt><dd><p>raise ValueError(‘Cannot find the metric named ‘ + metric_name)</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>return eval_metric_ops</p>
</dd>
</dl>
<p>return get_eval_metric_ops</p>
</dd>
<dt>def _get_uncalibrated_metric_fn(calibrated_metric_fn, keep_weight=True):</dt><dd><p>“””
Returns a function having signature:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_eval_metric_ops</span><span class="p">(</span><span class="n">graph_output</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
  <span class="o">...</span>
  <span class="k">return</span> <span class="n">eval_metric_ops</span>
</pre></div>
</div>
<p>where the returned eval_metric_ops is a dict of common evaluation metric
Ops with uncalibrated output.</p>
<dl class="simple">
<dt>The following graph_output keys are recognized:</dt><dd><dl class="simple">
<dt>uncalibrated_output:</dt><dd><p>the uncalibrated raw predictions between 0 and 1. Required.</p>
</dd>
<dt>output:</dt><dd><p>the calibrated predictions between 0 and 1.</p>
</dd>
<dt>threshold:</dt><dd><p>A value between 0 and 1 used to threshold the output into a hard_output.
Defaults to 0.5 when threshold and hard_output are missing.
Either threshold or hard_output can be provided, but not both.</p>
</dd>
<dt>hard_output:</dt><dd><p>A thresholded output. Either threshold or hard_output can be provided, but not both.</p>
</dd>
</dl>
</dd>
<dt>Args:</dt><dd><p>calibrated_metric_fn: metrics function with calibration and weight.
keep_weight: Bool indicating whether we keep weight.</p>
</dd>
</dl>
<p>“””
metric_scope = ‘uncalibrated’ if keep_weight else ‘unweighted’</p>
<dl>
<dt>def get_eval_metric_ops(graph_output, labels, weights):</dt><dd><p>“””
graph_output:</p>
<blockquote>
<div><p>dict that is returned by build_graph given input features.</p>
</div></blockquote>
<dl class="simple">
<dt>labels:</dt><dd><p>target labels associated to batch.</p>
</dd>
<dt>weights:</dt><dd><p>weights of the samples..</p>
</dd>
</dl>
<p>“””
with tf.variable_scope(metric_scope):</p>
<blockquote>
<div><dl class="simple">
<dt>if ‘uncalibrated_output’ not in graph_output:</dt><dd><p>raise Exception(“Missing uncalibrated_output in graph_output!”)</p>
</dd>
</dl>
<p>un_calibrated_weights = weights if keep_weight else tf.ones_like(weights)
uncalibrated_output = {</p>
<blockquote>
<div><p>‘output’: graph_output[‘uncalibrated_output’],
‘threshold’: graph_output.get(‘threshold’, 0.5),
‘hard_output’: graph_output.get(‘hard_output’),
<a href="#id3"><span class="problematic" id="id4">**</span></a>{k: v for k, v in graph_output.items() if k not in [‘output’, ‘threshold’, ‘hard_output’]}</p>
</div></blockquote>
<p>}</p>
<p>eval_metrics_ops = calibrated_metric_fn(uncalibrated_output, labels, un_calibrated_weights)</p>
<p>renamed_metrics_ops = {f’{metric_scope}_{k}’: v for k, v in eval_metrics_ops.items()}
return renamed_metrics_ops</p>
</div></blockquote>
</dd>
</dl>
<p>return get_eval_metric_ops</p>
</dd>
<dt>def get_multi_binary_class_uncalibrated_metric_fn(</dt><dd><p>metrics, classes=None, class_dim=1, keep_weight=True):
“””
Returns a function having signature:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">get_eval_metric_ops</span><span class="p">(</span><span class="n">graph_output</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">weights</span><span class="p">):</span>
  <span class="o">...</span>
  <span class="k">return</span> <span class="n">eval_metric_ops</span>
</pre></div>
</div>
<p>where the returned eval_metric_ops is a dict of common evaluation metric
Ops for concatenated binary classifications without calibration.</p>
<p>Note: ‘uncalibrated_output’ is required key in graph_output.</p>
<p>The main use case for this function is:</p>
<p>1) To calculated roc-auc for rare event.
Calibrated prediction score for rare events will be concentrated near zero. As a result,
the roc-auc can be seriously underestimated with current implementation in tf.metric.auc.
Since roc-auc is invariant against calibration, we can directly use uncalibrated score for roc-auc.
For more details, please refer to: go/roc-auc-invariance.</p>
<p>2) To set keep_weight=False and get unweighted and uncalibrated metrics.
This is useful to eval how the model is fitted to its actual training data, since
often time the model is trained without weight.</p>
<dl>
<dt>Args:</dt><dd><dl>
<dt>metrics (list of String):</dt><dd><p>a list of metrics of interest. E.g. [‘ctr’, ‘accuracy’, ‘rce’]
Element in the list can be a string from supported metrics, or can be a tuple
with three items: metric name, metric function, bool for thresholded output.
These metrics are evaluated and reported to tensorboard <em>during the eval phases only</em>.</p>
<p>When metrics is None (the default), it defaults to:
[rce, nrce, arce, ctr, predicted_ctr, accuracy, precision, recall, prauc, roc_auc],</p>
</dd>
<dt>classes (list of strings):</dt><dd><p>In case of multiple binary class models, the names for each class or label.
These are used to display metrics on tensorboard.
If these are not specified, the index in the class or label dimension is used, and you’ll
get metrics on tensorboard named like: accuracy_0, accuracy_1, etc.</p>
</dd>
<dt>class_dim (number):</dt><dd><p>Dimension of the classes in predictions. Defaults to 1, that is, batch_size x n_classes.</p>
</dd>
<dt>keep_weight (bool):</dt><dd><p>Whether to keep weights for the metric.</p>
</dd>
</dl>
</dd>
</dl>
<p>“””</p>
<dl class="simple">
<dt>calibrated_metric_fn = get_multi_binary_class_metric_fn(</dt><dd><p>metrics, classes=classes, class_dim=class_dim)</p>
</dd>
</dl>
<p>return _get_uncalibrated_metric_fn(calibrated_metric_fn, keep_weight=keep_weight)</p>
</dd>
<dt>def combine_metric_fns(<a href="#id5"><span class="problematic" id="id6">*</span></a>fn_list):</dt><dd><p>“””
Combine multiple metric functions.
For example, we can combine metrics function generated by
get_multi_binary_class_metric_fn and get_multi_binary_class_uncalibrated_metric_fn.</p>
<dl class="simple">
<dt>Args:</dt><dd><p><a href="#id7"><span class="problematic" id="id8">*</span></a>fn_list: Multiple metric functions to be combined</p>
</dd>
<dt>Returns:</dt><dd><p>Combined metric function.</p>
</dd>
</dl>
<p>“””
def combined_metric_ops(<a href="#id9"><span class="problematic" id="id10">*</span></a>args, <a href="#id11"><span class="problematic" id="id12">**</span></a>kwargs):</p>
<blockquote>
<div><p>eval_metric_ops = OrderedDict()
for fn in fn_list:</p>
<blockquote>
<div><p>eval_metric_ops.update(fn(<a href="#id13"><span class="problematic" id="id14">*</span></a>args, <a href="#id15"><span class="problematic" id="id16">**</span></a>kwargs))</p>
</div></blockquote>
<p>return eval_metric_ops</p>
</div></blockquote>
<p>return combined_metric_ops</p>
</dd>
</dl>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../_sources/twml/twml/metrics.py.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>