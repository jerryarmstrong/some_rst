<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>import uuid</p>
<p>from tensorflow.compat.v1 import logging
import twml
import tensorflow.compat.v1 as tf</p>
<dl>
<dt>def write_list_to_hdfs_gfile(list_to_write, output_path):</dt><dd><p>“””Use tensorflow gfile to write a list to a location on hdfs”””
locname = “/tmp/{}”.format(str(uuid.uuid4()))
with open(locname, “w”) as f:</p>
<blockquote>
<div><dl class="simple">
<dt>for row in list_to_write:</dt><dd><p>f.write(“%sn” % row)</p>
</dd>
</dl>
</div></blockquote>
<p>tf.io.gfile.copy(locname, output_path, overwrite=False)</p>
</dd>
<dt>def decode_str_or_unicode(str_or_unicode):</dt><dd><p>return str_or_unicode.decode() if hasattr(str_or_unicode, ‘decode’) else str_or_unicode</p>
</dd>
<dt>def longest_common_prefix(strings, split_character):</dt><dd><p>“””
Args:</p>
<blockquote>
<div><p>string (list&lt;str&gt;): The list of strings to find the longest common prefix of
split_character (str): If not None, require that the return string end in this character or</p>
<blockquote>
<div><p>be the length of the entire string</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>Returns:</dt><dd><p>The string corresponding to the longest common prefix</p>
</dd>
</dl>
<p>“””
sorted_strings = sorted(strings)
s1, s2 = sorted_strings[0], sorted_strings[-1]
if s1 == s2:</p>
<blockquote>
<div><p># If the strings are the same, just return the full string
out = s1</p>
</div></blockquote>
<dl>
<dt>else:</dt><dd><p># If the strings are not the same, return the longest common prefix optionally ending in split_character
ix = 0
for i in range(min(len(s1), len(s2))):</p>
<blockquote>
<div><dl class="simple">
<dt>if s1[i] != s2[i]:</dt><dd><p>break</p>
</dd>
<dt>if split_character is None or s1[i] == split_character:</dt><dd><p>ix = i + 1</p>
</dd>
</dl>
</div></blockquote>
<p>out = s1[:ix]</p>
</dd>
</dl>
<p>return out</p>
</dd>
<dt>def _expand_prefix(fname, prefix, split_character):</dt><dd><dl>
<dt>if len(fname) == len(prefix):</dt><dd><p># If the prefix is already the full feature, just take the feature name
out = fname</p>
</dd>
<dt>elif split_character is None:</dt><dd><p># Advance the prefix by one character
out = fname[:len(prefix) + 1]</p>
</dd>
<dt>else:</dt><dd><p># Advance the prefix to the next instance of split_character or the end of the string
for ix in range(len(prefix), len(fname)):</p>
<blockquote>
<div><dl class="simple">
<dt>if fname[ix] == split_character:</dt><dd><p>break</p>
</dd>
</dl>
</div></blockquote>
<p>out = fname[:ix + 1]</p>
</dd>
</dl>
<p>return out</p>
</dd>
<dt>def _get_feature_types_from_records(records, fnames):</dt><dd><p># This method gets the types of the features in fnames by looking at the datarecords themselves.
#   The reason why we do this rather than extract the feature types from the feature_config is
#   that the feature naming conventions in the feature_config are different from those in the
#   datarecords.
fids = [twml.feature_id(fname)[0] for fname in fnames]
feature_to_type = {}
for record in records:</p>
<blockquote>
<div><dl>
<dt>for feature_type, values in record.__dict__.items():</dt><dd><dl>
<dt>if values is not None:</dt><dd><p>included_ids = set(values)
for fname, fid in zip(fnames, fids):</p>
<blockquote>
<div><dl class="simple">
<dt>if fid in included_ids:</dt><dd><p>feature_to_type[fname] = feature_type</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>return feature_to_type</p>
</dd>
<dt>def _get_metrics_hook(trainer):</dt><dd><dl class="simple">
<dt>def get_metrics_fn(trainer=trainer):</dt><dd><p>return {k: v[0]for k, v in trainer.current_estimator_spec.eval_metric_ops.items()}</p>
</dd>
</dl>
<p>return twml.hooks.GetMetricsHook(get_metrics_fn=get_metrics_fn)</p>
</dd>
<dt>def _get_feature_name_from_config(feature_config):</dt><dd><p>“””Extract the names of the features on a feature config object
“””
decoded_feature_names = []
for f in feature_config.get_feature_spec()[‘features’].values():</p>
<blockquote>
<div><dl class="simple">
<dt>try:</dt><dd><p>fname = decode_str_or_unicode(f[‘featureName’])</p>
</dd>
<dt>except UnicodeEncodeError as e:</dt><dd><p>logging.error(“Encountered decoding exception when decoding %s: %s” % (f, e))</p>
</dd>
</dl>
<p>decoded_feature_names.append(fname)</p>
</div></blockquote>
<p>return decoded_feature_names</p>
</dd>
</dl>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../_sources/twml/twml/contrib/feature_importances/helpers.py.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>