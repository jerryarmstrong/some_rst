<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>“””Utility functions to create FeatureConfig objects from feature_spec.yaml files”””
import os
import re</p>
<p>import tensorflow.compat.v1 as tf
import yaml
from twml.feature_config import FeatureConfigBuilder
from twml.contrib.feature_config import FeatureConfigBuilder as FeatureConfigBuilderV2</p>
<dl>
<dt>def _get_config_version(config_dict):</dt><dd><p>doc = config_dict
supported_classes = {</p>
<blockquote>
<div><p>“twml.FeatureConfig”: “v1”,
“twml.contrib.FeatureConfig”: “v2”</p>
</div></blockquote>
<p>}
if “class” not in doc:</p>
<blockquote>
<div><p>raise ValueError(“‘class’ key not found”)</p>
</div></blockquote>
<dl class="simple">
<dt>if doc[“class”] not in supported_classes.keys():</dt><dd><dl class="simple">
<dt>raise ValueError(“Class %s not supported. Supported clases are %s”</dt><dd><p>% (doc[“class”], supported_classes.keys()))</p>
</dd>
</dl>
</dd>
</dl>
<p>return supported_classes[doc[“class”]]</p>
</dd>
<dt>def _validate_config_dict_v1(config_dict):</dt><dd><p>“””
Validate spec exported by twml.FeatureConfig
“””
doc = config_dict</p>
<dl class="simple">
<dt>def malformed_error(msg):</dt><dd><p>raise ValueError(“twml.FeatureConfig: Malformed feature_spec. %s” % msg)</p>
</dd>
<dt>if doc[“class”] != “twml.FeatureConfig”:</dt><dd><p>malformed_error(“‘class’ is not twml.FeatureConfig”)</p>
</dd>
<dt>if “format” not in doc:</dt><dd><p>malformed_error(“‘format’ key not found”)</p>
</dd>
</dl>
<p># validate spec exported by twml.FeatureConfig
if doc[“format”] == “exported”:</p>
<blockquote>
<div><p>dict_keys = [“features”, “labels”, “weight”, “tensors”, “sparse_tensors”]
for key in dict_keys:</p>
<blockquote>
<div><dl class="simple">
<dt>if key not in doc:</dt><dd><p>malformed_error(”’%s’ key not found” % key)</p>
</dd>
<dt>if type(doc[key]) != dict:</dt><dd><p>malformed_error(”’%s’ is not a dict” % key)</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>if “filters” not in doc:</dt><dd><p>malformed_error(“‘filters’ key not found”)</p>
</dd>
<dt>elif type(doc[“filters”]) != list:</dt><dd><p>malformed_error(“‘filters’ is not a list”)</p>
</dd>
</dl>
</div></blockquote>
<p># validate spec provided by modeler
elif doc[“format”] == “manual”:</p>
<blockquote>
<div><p>raise NotImplementedError(“Manual config support not yet implemented”)</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>malformed_error(“‘format’ must be ‘exported’ or ‘manual’”)</p>
</dd>
</dl>
</dd>
<dt>def _validate_config_dict_v2(config_dict):</dt><dd><p>“””
Validate spec exported by twml.contrib.FeatureConfig
“””
doc = config_dict</p>
<dl class="simple">
<dt>def malformed_error(msg):</dt><dd><p>raise ValueError(“twml.contrib.FeatureConfig: Malformed feature_spec. %s” % msg)</p>
</dd>
<dt>if doc[“class”] != “twml.contrib.FeatureConfig”:</dt><dd><p>malformed_error(“‘class’ is not twml.contrib.FeatureConfig”)</p>
</dd>
<dt>if “format” not in doc:</dt><dd><p>malformed_error(“‘format key not found’”)</p>
</dd>
</dl>
<p># validate spec exported by twml.contrib.FeatureConfig (basic validation only)
if doc[“format”] == “exported”:</p>
<blockquote>
<div><p>dict_keys = [“features”, “labels”, “weight”, “tensors”, “sparseTensors”, “discretizeConfig”]
for key in dict_keys:</p>
<blockquote>
<div><dl class="simple">
<dt>if key not in doc:</dt><dd><p>malformed_error(”’%s’ key not found” % key)</p>
</dd>
<dt>if type(doc[key]) != dict:</dt><dd><p>malformed_error(”’%s’ is not a dict” % key)</p>
</dd>
</dl>
</div></blockquote>
<p>list_keys = [“sparseFeatureGroups”, “denseFeatureGroups”, “denseFeatures”, “images”, “filters”]
for key in list_keys:</p>
<blockquote>
<div><dl class="simple">
<dt>if key not in doc:</dt><dd><p>malformed_error(”’%s’ key not found” % key)</p>
</dd>
<dt>if type(doc[key]) != list:</dt><dd><p>malformed_error(”’%s’ is not a list” % key)</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p># validate spec provided by modeler
elif doc[“format”] == “manual”:</p>
<blockquote>
<div><p>raise NotImplementedError(“Manual config support not yet implemented”)</p>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><p>malformed_error(“‘format’ must be ‘exported’ or ‘manual’”)</p>
</dd>
</dl>
</dd>
<dt>def _create_feature_config_v1(config_dict, data_spec_path):</dt><dd><p>fc_builder = FeatureConfigBuilder(data_spec_path)</p>
<dl>
<dt>if config_dict[“format”] == “exported”:</dt><dd><p># add features
for feature_info in config_dict[“features”].values():</p>
<blockquote>
<div><p>feature_name = re.escape(feature_info[“featureName”])
feature_group = feature_info[“featureGroup”]
fc_builder.add_feature(feature_name, feature_group)</p>
</div></blockquote>
<p># add labels
labels = []
for label_info in config_dict[“labels”].values():</p>
<blockquote>
<div><p>labels.append(label_info[“featureName”])</p>
</div></blockquote>
<p>fc_builder.add_labels(labels)
# feature filters
for feature_name in config_dict[“filters”]:</p>
<blockquote>
<div><p>fc_builder.add_filter(feature_name)</p>
</div></blockquote>
<p># weight
if config_dict[“weight”]:</p>
<blockquote>
<div><p>weight_feature = list(config_dict[“weight”].values())[0][“featureName”]
fc_builder.define_weight(weight_feature)</p>
</div></blockquote>
</dd>
<dt>else:</dt><dd><p>raise ValueError(“Format ‘%s’ not implemented” % config_dict[“format”])</p>
</dd>
</dl>
<p>return fc_builder.build()</p>
</dd>
<dt>def _create_feature_config_v2(config_dict, data_spec_path):</dt><dd><p>fc_builder = FeatureConfigBuilderV2(data_spec_path)</p>
<dl>
<dt>if config_dict[“format”] == “exported”:</dt><dd><p># add sparse group extraction configs
for sparse_group in config_dict[“sparseFeatureGroups”]:</p>
<blockquote>
<div><p>fids = sparse_group[“features”].keys()
fnames = [sparse_group[“features”][fid][“featureName”] for fid in fids]
fc_builder.extract_features_as_hashed_sparse(</p>
<blockquote>
<div><p>feature_regexes=[re.escape(fname) for fname in fnames],
output_tensor_name=sparse_group[“outputName”],
hash_space_size_bits=sparse_group[“hashSpaceBits”],
discretize_num_bins=sparse_group[“discretize”][“numBins”],
discretize_output_size_bits=sparse_group[“discretize”][“outputSizeBits”],
discretize_type=sparse_group[“discretize”][“type”],
type_filter=sparse_group[“filterType”])</p>
</div></blockquote>
</div></blockquote>
<p># add dense group extraction configs
for dense_group in config_dict[“denseFeatureGroups”]:</p>
<blockquote>
<div><p>fids = dense_group[“features”].keys()
fnames = [dense_group[“features”][fid][“featureName”] for fid in fids]
fc_builder.extract_feature_group(</p>
<blockquote>
<div><p>feature_regexes=[re.escape(fname) for fname in fnames],
group_name=dense_group[“outputName”],
type_filter=dense_group[“filterType”],
default_value=dense_group[“defaultValue”])</p>
</div></blockquote>
</div></blockquote>
<p># add dense feature configs
for dense_features in config_dict[“denseFeatures”]:</p>
<blockquote>
<div><p>fids = dense_features[“features”].keys()
fnames = [dense_features[“features”][fid][“featureName”] for fid in fids]
default_value = dense_features[“defaultValue”]
if len(fnames) == 1 and type(default_value) != dict:</p>
<blockquote>
<div><dl class="simple">
<dt>fc_builder.extract_feature(</dt><dd><p>feature_name=re.escape(fnames[0]),
expected_shape=dense_features[“expectedShape”],
default_value=dense_features[“defaultValue”])</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>else:</dt><dd><dl class="simple">
<dt>fc_builder.extract_features(</dt><dd><p>feature_regexes=[re.escape(fname) for fname in fnames],
default_value_map=dense_features[“defaultValue”])</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p># add image feature configs
for image in config_dict[“images”]:</p>
<blockquote>
<div><dl class="simple">
<dt>fc_builder.extract_image(</dt><dd><p>feature_name=image[“featureName”],
preprocess=image[“preprocess”],
out_type=tf.as_dtype(image[“outType”].lower()),
channels=image[“channels”],
default_image=image[“defaultImage”],</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p># add other tensor features (non-image)
tensor_fnames = []
image_fnames = [img[“featureName”] for img in config_dict[“images”]]
for tensor_fname in config_dict[“tensors”]:</p>
<blockquote>
<div><dl class="simple">
<dt>if tensor_fname not in image_fnames:</dt><dd><p>tensor_fnames.append(tensor_fname)</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>for sparse_tensor_fname in config_dict[“sparseTensors”]:</dt><dd><p>tensor_fnames.append(sparse_tensor_fname)</p>
</dd>
</dl>
<p>fc_builder.extract_tensors(tensor_fnames)</p>
<p># add labels
labels = []
for label_info in config_dict[“labels”].values():</p>
<blockquote>
<div><p>labels.append(label_info[“featureName”])</p>
</div></blockquote>
<p>fc_builder.add_labels(labels)</p>
</dd>
<dt>else:</dt><dd><p>raise ValueError(“Format ‘%s’ not implemented” % config_dict[“format”])</p>
</dd>
</dl>
<p>return fc_builder.build()</p>
</dd>
<dt>def create_feature_config_from_dict(config_dict, data_spec_path):</dt><dd><p>“””
Create a FeatureConfig object from a feature spec dict.
“””
config_version = _get_config_version(config_dict)
if config_version == “v1”:</p>
<blockquote>
<div><p>_validate_config_dict_v1(config_dict)
feature_config = _create_feature_config_v1(config_dict, data_spec_path)</p>
</div></blockquote>
<dl class="simple">
<dt>elif config_version == “v2”:</dt><dd><p>_validate_config_dict_v2(config_dict)
feature_config = _create_feature_config_v2(config_dict, data_spec_path)</p>
</dd>
<dt>else:</dt><dd><p>raise ValueError(“version not supported”)</p>
</dd>
</dl>
<p>return feature_config</p>
</dd>
<dt>def create_feature_config(config_path, data_spec_path):</dt><dd><p>“””
Create a FeatureConfig object from a feature_spec.yaml file.
“””
_, ext = os.path.splitext(config_path)
if ext not in [‘.yaml’, ‘.yml’]:</p>
<blockquote>
<div><p>raise ValueError(“create_feature_config_from_yaml: Only .yaml/.yml supported”)</p>
</div></blockquote>
<dl class="simple">
<dt>with tf.io.gfile.GFile(config_path, mode=’r’) as fs:</dt><dd><p>config_dict = yaml.safe_load(fs)</p>
</dd>
</dl>
<p>return create_feature_config_from_dict(config_dict, data_spec_path)</p>
</dd>
</dl>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../_sources/twml/twml/contrib/feature_config_parsers.py.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>