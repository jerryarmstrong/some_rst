<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../../" id="documentation_options" src="../../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.follow_recommendations.common.base</p>
<p>import com.twitter.finagle.stats.NullStatsReceiver
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.follow_recommendations.common.models.FilterReason
import com.twitter.stitch.Arrow
import com.twitter.stitch.Stitch</p>
<p>trait Predicate[-Q] {</p>
<blockquote>
<div><p>def apply(item: Q): Stitch[PredicateResult]
def arrow: Arrow[Q, PredicateResult] = Arrow.apply(apply)</p>
<p>def map[K](mapper: K =&gt; Q): Predicate[K] = Predicate(arrow.contramap(mapper))</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>check the predicate results for a batch of items for convenience.</p></li>
<li></li>
<li><p>mark it as final to avoid potential abuse usage</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>final def batch(items: Seq[Q]): Stitch[Seq[PredicateResult]] = {</dt><dd><p>this.arrow.traverse(items)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Syntax sugar for functions which take in 2 inputs as a tuple.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>def apply[Q1, Q2](item1: Q1, item2: Q2)(implicit ev: ((Q1, Q2)) =&gt; Q): Stitch[PredicateResult] = {</dt><dd><p>apply((item1, item2))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Runs the predicates in sequence. The returned predicate will return true iff both the predicates return true.</p></li>
<li><p>ie. it is an AND operation</p></li>
<li></li>
<li><p>We short-circuit the evaluation, ie we don’t evaluate the 2nd predicate if the 1st is false</p></li>
<li></li>
<li><p>&#64;param p predicate to run in sequence</p></li>
<li></li>
<li><p>&#64;return a new predicate object that represents the logical AND of both predicates</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>def andThen[Q1 &lt;: Q](p: Predicate[Q1]): Predicate[Q1] = {</dt><dd><dl>
<dt>Predicate({ query: Q1 =&gt;</dt><dd><dl class="simple">
<dt>apply(query).flatMap {</dt><dd><p>case PredicateResult.Valid =&gt; p(query)
case PredicateResult.Invalid(reasons) =&gt; Stitch.value(PredicateResult.Invalid(reasons))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>})</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Creates a predicate which runs the current &amp; given predicate in sequence.</p></li>
<li><p>The returned predicate will return true if either current or given predicate returns true.</p></li>
<li><p>That is, given predicate will be only run if current predicate returns false.</p></li>
<li></li>
<li><p>&#64;param p predicate to run in sequence</p></li>
<li></li>
<li><p>&#64;return new predicate object that represents the logical OR of both predicates.</p></li>
<li><p>if both are invalid, the reason would be the set of all invalid reasons.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>def or[Q1 &lt;: Q](p: Predicate[Q1]): Predicate[Q1] = {</dt><dd><dl>
<dt>Predicate({ query: Q1 =&gt;</dt><dd><dl>
<dt>apply(query).flatMap {</dt><dd><p>case PredicateResult.Valid =&gt; Stitch.value(PredicateResult.Valid)
case PredicateResult.Invalid(reasons) =&gt;</p>
<blockquote>
<div><dl>
<dt>p(query).flatMap {</dt><dd><p>case PredicateResult.Valid =&gt; Stitch.value(PredicateResult.Valid)
case PredicateResult.Invalid(newReasons) =&gt;</p>
<blockquote>
<div><p>Stitch.value(PredicateResult.Invalid(reasons ++ newReasons))</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>})</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/*</dt><dd><ul class="simple">
<li><p>Runs the predicate only if the provided predicate is valid, otherwise returns valid.</p></li>
<li><p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p></li>
</ul>
</dd>
<dt>def gate[Q1 &lt;: Q](gatingPredicate: Predicate[Q1]): Predicate[Q1] = {</dt><dd><dl>
<dt>Predicate { query: Q1 =&gt;</dt><dd><dl>
<dt>gatingPredicate(query).flatMap { result =&gt;</dt><dd><dl class="simple">
<dt>if (result == PredicateResult.Valid) {</dt><dd><p>apply(query)</p>
</dd>
<dt>} else {</dt><dd><p>Stitch.value(PredicateResult.Valid)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def observe(statsReceiver: StatsReceiver): Predicate[Q] = Predicate(</dt><dd><p>StatsUtil.profilePredicateResult(this.arrow, statsReceiver))</p>
</dd>
<dt>def convertToFailOpenWithResultType(resultType: PredicateResult): Predicate[Q] = {</dt><dd><dl>
<dt>Predicate { query: Q =&gt;</dt><dd><dl class="simple">
<dt>apply(query).handle {</dt><dd><dl class="simple">
<dt>case _: Exception =&gt;</dt><dd><p>resultType</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>class TruePredicate[Q] extends Predicate[Q] {</dt><dd><p>override def apply(item: Q): Stitch[PredicateResult] = Predicate.AlwaysTrueStitch</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>class FalsePredicate[Q](reason: FilterReason) extends Predicate[Q] {</dt><dd><p>val InvalidResult = Stitch.value(PredicateResult.Invalid(Set(reason)))
override def apply(item: Q): Stitch[PredicateResult] = InvalidResult</p>
</dd>
</dl>
<p>}</p>
<p>object Predicate {</p>
<blockquote>
<div><p>val AlwaysTrueStitch = Stitch.value(PredicateResult.Valid)</p>
<p>val NumBatchesStat = “num_batches_stats”
val NumBatchesCount = “num_batches”</p>
<dl>
<dt>def apply[Q](func: Q =&gt; Stitch[PredicateResult]): Predicate[Q] = new Predicate[Q] {</dt><dd><p>override def apply(item: Q): Stitch[PredicateResult] = func(item)</p>
<p>override val arrow: Arrow[Q, PredicateResult] = Arrow(func)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def apply[Q](outerArrow: Arrow[Q, PredicateResult]): Predicate[Q] = new Predicate[Q] {</dt><dd><p>override def apply(item: Q): Stitch[PredicateResult] = arrow(item)</p>
<p>override val arrow: Arrow[Q, PredicateResult] = outerArrow</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Given some items, this function</p></li>
<li><ol class="arabic simple">
<li><p>chunks them up in groups</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>lazily applies a predicate on each group</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="3">
<li><p>filters based on the predicate</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="4">
<li><p>takes first numToTake items.</p></li>
</ol>
</li>
<li></li>
<li><p>If numToTake is satisfied, then any later predicates are not called.</p></li>
<li></li>
<li><p>&#64;param items     items of type Q</p></li>
<li><p>&#64;param predicate predicate that determines whether an item is acceptable</p></li>
<li><p>&#64;param batchSize batch size to call the predicate with</p></li>
<li><p>&#64;param numToTake max number of items to return</p></li>
<li><p>&#64;param stats stats receiver</p></li>
<li><p>&#64;tparam Q type of item</p></li>
<li></li>
<li><p>&#64;return a future of K items</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>def batchFilterTake[Q](</dt><dd><p>items: Seq[Q],
predicate: Predicate[Q],
batchSize: Int,
numToTake: Int,
stats: StatsReceiver</p>
</dd>
</dl>
<p>): Stitch[Seq[Q]] = {</p>
<blockquote>
<div><dl>
<dt>def take(</dt><dd><p>input: Iterator[Stitch[Seq[Q]]],
prev: Seq[Q],
takeSize: Int,
numOfBatch: Int</p>
</dd>
<dt>): Stitch[(Seq[Q], Int)] = {</dt><dd><dl>
<dt>if (input.hasNext) {</dt><dd><p>val currFut = input.next()
currFut.flatMap { curr =&gt;</p>
<blockquote>
<div><p>val taken = curr.take(takeSize)
val combined = prev ++ taken
if (taken.size &lt; takeSize)</p>
<blockquote>
<div><p>take(input, combined, takeSize - taken.size, numOfBatch + 1)</p>
</div></blockquote>
<p>else Stitch.value((combined, numOfBatch + 1))</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>Stitch.value((prev, numOfBatch))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>val batchedItems = items.view.grouped(batchSize)
val batchedFutures = batchedItems.map { batch =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>Stitch.traverse(batch)(predicate.apply).map { conds =&gt;</dt><dd><p>(batch.zip(conds)).withFilter(_._2.value).map(_._1)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
take(batchedFutures, Nil, numToTake, 0).map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (filtered: Seq[Q], numOfBatch: Int) =&gt;</dt><dd><p>stats.stat(NumBatchesStat).add(numOfBatch)
stats.counter(NumBatchesCount).incr(numOfBatch)
filtered</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>filter a list of items based on the predicate</p></li>
<li></li>
<li><p>&#64;param items a list of items</p></li>
<li><p>&#64;param predicate predicate of the item</p></li>
<li><p>&#64;tparam Q item type</p></li>
<li><p>&#64;return the list of items that satisfy the predicate</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>def filter[Q](items: Seq[Q], predicate: Predicate[Q]): Stitch[Seq[Q]] = {</dt><dd><dl>
<dt>predicate.batch(items).map { results =&gt;</dt><dd><dl class="simple">
<dt>items.zip(results).collect {</dt><dd><p>case (item, PredicateResult.Valid) =&gt; item</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>filter a list of items based on the predicate given the target</p></li>
<li></li>
<li><p>&#64;param target target item</p></li>
<li><p>&#64;param items a list of items</p></li>
<li><p>&#64;param predicate predicate of the (target, item) pair</p></li>
<li><p>&#64;tparam Q item type</p></li>
<li><p>&#64;return the list of items that satisfy the predicate given the target</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>def filter[T, Q](target: T, items: Seq[Q], predicate: Predicate[(T, Q)]): Stitch[Seq[Q]] = {</dt><dd><dl>
<dt>predicate.batch(items.map(i =&gt; (target, i))).map { results =&gt;</dt><dd><dl class="simple">
<dt>items.zip(results).collect {</dt><dd><p>case (item, PredicateResult.Valid) =&gt; item</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns a predicate, where an element is true iff it that element is true for all input predicates.</p></li>
<li><p>ie. it is an AND operation</p></li>
<li></li>
<li><p>This is done concurrently.</p></li>
<li></li>
<li><p>&#64;param predicates list of predicates</p></li>
<li><p>&#64;tparam Q Type parameter</p></li>
<li></li>
<li><p>&#64;return new predicate object that is the logical “and” of the input predicates</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>def andConcurrently[Q](predicates: Seq[Predicate[Q]]): Predicate[Q] = {</dt><dd><dl>
<dt>Predicate { query: Q =&gt;</dt><dd><dl>
<dt>Stitch.traverse(predicates)(p =&gt; p(query)).map { predicateResults =&gt;</dt><dd><dl>
<dt>val allInvalid = predicateResults</dt><dd><dl class="simple">
<dt>.collect {</dt><dd><dl class="simple">
<dt>case PredicateResult.Invalid(reason) =&gt;</dt><dd><p>reason</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>if (allInvalid.isEmpty) {</dt><dd><p>PredicateResult.Valid</p>
</dd>
<dt>} else {</dt><dd><p>val allInvalidReasons = allInvalid.reduce(_ ++ _)
PredicateResult.Invalid(allInvalidReasons)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>applies the underlying predicate when the param is on.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>abstract class GatedPredicateBase[Q](</dt><dd><p>underlyingPredicate: Predicate[Q],
stats: StatsReceiver = NullStatsReceiver)</p>
<blockquote>
<div><p>extends Predicate[Q] {</p>
</div></blockquote>
<p>def gate(item: Q): Boolean</p>
<p>val underlyingPredicateTotal = stats.counter(“underlying_total”)
val underlyingPredicateValid = stats.counter(“underlying_valid”)
val underlyingPredicateInvalid = stats.counter(“underlying_invalid”)
val notGatedCounter = stats.counter(“not_gated”)</p>
<p>val ValidStitch: Stitch[PredicateResult.Valid.type] = Stitch.value(PredicateResult.Valid)</p>
<dl>
<dt>override def apply(item: Q): Stitch[PredicateResult] = {</dt><dd><dl class="simple">
<dt>if (gate(item)) {</dt><dd><p>underlyingPredicateTotal.incr()
underlyingPredicate(item)</p>
</dd>
<dt>} else {</dt><dd><p>notGatedCounter.incr()
ValidStitch</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../../_sources/follow-recommendations-service/common/src/main/scala/com/twitter/follow_recommendations/common/base/Predicate.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>