<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../../" id="documentation_options" src="../../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.follow_recommendations.flows.post_nux_ml</p>
<p>import com.twitter.conversions.DurationOps._
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.follow_recommendations.common.base.EnrichedCandidateSource._
import com.twitter.follow_recommendations.common.base._
import com.twitter.follow_recommendations.common.models.CandidateUser
import com.twitter.follow_recommendations.common.models.FilterReason
import com.twitter.follow_recommendations.common.predicates.dismiss.DismissedCandidatePredicate
import com.twitter.follow_recommendations.common.predicates.gizmoduck.GizmoduckPredicate
import com.twitter.follow_recommendations.common.transforms.ranker_id.RandomRankerIdTransform
import com.twitter.follow_recommendations.common.predicates.sgs.InvalidTargetCandidateRelationshipTypesPredicate
import com.twitter.follow_recommendations.common.predicates.sgs.RecentFollowingPredicate
import com.twitter.follow_recommendations.common.predicates.CandidateParamPredicate
import com.twitter.follow_recommendations.common.predicates.CandidateSourceParamPredicate
import com.twitter.follow_recommendations.common.predicates.CuratedCompetitorListPredicate
import com.twitter.follow_recommendations.common.predicates.ExcludedUserIdPredicate
import com.twitter.follow_recommendations.common.predicates.InactivePredicate
import com.twitter.follow_recommendations.common.predicates.PreviouslyRecommendedUserIdsPredicate
import com.twitter.follow_recommendations.common.predicates.user_activity.NonNearZeroUserActivityPredicate
import com.twitter.follow_recommendations.common.transforms.dedup.DedupTransform
import com.twitter.follow_recommendations.common.transforms.modify_social_proof.ModifySocialProofTransform
import com.twitter.follow_recommendations.common.transforms.tracking_token.TrackingTokenTransform
import com.twitter.follow_recommendations.common.transforms.weighted_sampling.SamplingTransform
import com.twitter.follow_recommendations.configapi.candidates.CandidateUserParamsFactory
import com.twitter.follow_recommendations.configapi.params.GlobalParams
import com.twitter.follow_recommendations.configapi.params.GlobalParams.EnableGFSSocialProofTransform
import com.twitter.follow_recommendations.utils.CandidateSourceHoldbackUtil
import com.twitter.product_mixer.core.functional_component.candidate_source.CandidateSource
import com.twitter.product_mixer.core.model.common.identifier.CandidateSourceIdentifier
import com.twitter.timelines.configapi.Params
import com.twitter.util.Duration</p>
<p>import javax.inject.Inject
import javax.inject.Singleton
import com.twitter.follow_recommendations.common.clients.socialgraph.SocialGraphClient
import com.twitter.follow_recommendations.common.predicates.hss.HssPredicate
import com.twitter.follow_recommendations.common.predicates.sgs.InvalidRelationshipPredicate
import com.twitter.follow_recommendations.common.transforms.modify_social_proof.RemoveAccountProofTransform
import com.twitter.follow_recommendations.logging.FrsLogger
import com.twitter.follow_recommendations.models.RecommendationFlowData
import com.twitter.follow_recommendations.utils.RecommendationFlowBaseSideEffectsUtil
import com.twitter.product_mixer.core.model.common.identifier.RecommendationPipelineIdentifier
import com.twitter.product_mixer.core.quality_factor.BoundsWithDefault
import com.twitter.product_mixer.core.quality_factor.LinearLatencyQualityFactor
import com.twitter.product_mixer.core.quality_factor.LinearLatencyQualityFactorConfig
import com.twitter.product_mixer.core.quality_factor.LinearLatencyQualityFactorObserver
import com.twitter.product_mixer.core.quality_factor.QualityFactorObserver
import com.twitter.stitch.Stitch</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>We use this flow for all post-nux display locations that would use a machine-learning-based-ranker</p></li>
<li><p>eg HTL, Sidebar, etc</p></li>
<li><p>Note that the RankedPostNuxFlow is used primarily for scribing/data collection, and doesn’t</p></li>
<li><p>incorporate all of the other components in a flow (candidate source generation, predicates etc)</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
</dl>
<p>&#64;Singleton
class PostNuxMlFlow &#64;Inject() (</p>
<blockquote>
<div><p>postNuxMlCandidateSourceRegistry: PostNuxMlCandidateSourceRegistry,
postNuxMlCombinedRankerBuilder: PostNuxMlCombinedRankerBuilder[PostNuxMlRequest],
curatedCompetitorListPredicate: CuratedCompetitorListPredicate,
gizmoduckPredicate: GizmoduckPredicate,
sgsPredicate: InvalidTargetCandidateRelationshipTypesPredicate,
hssPredicate: HssPredicate,
invalidRelationshipPredicate: InvalidRelationshipPredicate,
recentFollowingPredicate: RecentFollowingPredicate,
nonNearZeroUserActivityPredicate: NonNearZeroUserActivityPredicate,
inactivePredicate: InactivePredicate,
dismissedCandidatePredicate: DismissedCandidatePredicate,
previouslyRecommendedUserIdsPredicate: PreviouslyRecommendedUserIdsPredicate,
modifySocialProofTransform: ModifySocialProofTransform,
removeAccountProofTransform: RemoveAccountProofTransform,
trackingTokenTransform: TrackingTokenTransform,
randomRankerIdTransform: RandomRankerIdTransform,
candidateParamsFactory: CandidateUserParamsFactory[PostNuxMlRequest],
samplingTransform: SamplingTransform,
frsLogger: FrsLogger,
baseStatsReceiver: StatsReceiver)</p>
<blockquote>
<div><p>extends RecommendationFlow[PostNuxMlRequest, CandidateUser]
with RecommendationFlowBaseSideEffectsUtil[PostNuxMlRequest, CandidateUser]
with CandidateSourceHoldbackUtil {</p>
</div></blockquote>
<dl class="simple">
<dt>override protected val targetEligibility: Predicate[PostNuxMlRequest] =</dt><dd><p>new ParamPredicate[PostNuxMlRequest](PostNuxMlParams.TargetEligibility)</p>
</dd>
</dl>
<p>override val statsReceiver: StatsReceiver = baseStatsReceiver.scope(“post_nux_ml_flow”)</p>
<dl>
<dt>override val qualityFactorObserver: Option[QualityFactorObserver] = {</dt><dd><dl>
<dt>val config = LinearLatencyQualityFactorConfig(</dt><dd><dl class="simple">
<dt>qualityFactorBounds =</dt><dd><p>BoundsWithDefault(minInclusive = 0.1, maxInclusive = 1.0, default = 1.0),</p>
</dd>
</dl>
<p>initialDelay = 60.seconds,
targetLatency = 700.milliseconds,
targetLatencyPercentile = 95.0,
delta = 0.001</p>
</dd>
</dl>
<p>)
val qualityFactor = LinearLatencyQualityFactor(config)
val observer = LinearLatencyQualityFactorObserver(qualityFactor)
statsReceiver.provideGauge(“quality_factor”)(qualityFactor.currentValue.toFloat)
Some(observer)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override protected def updateTarget(request: PostNuxMlRequest): Stitch[PostNuxMlRequest] = {</dt><dd><dl class="simple">
<dt>Stitch.value(</dt><dd><p>request.copy(qualityFactor = qualityFactorObserver.map(_.qualityFactor.currentValue))</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private[post_nux_ml] def getCandidateSourceIdentifiers(</dt><dd><p>params: Params</p>
</dd>
<dt>): Set[CandidateSourceIdentifier] = {</dt><dd><p>PostNuxMlFlowCandidateSourceWeights.getWeights(params).keySet</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override protected def candidateSources(</dt><dd><p>request: PostNuxMlRequest</p>
</dd>
<dt>): Seq[CandidateSource[PostNuxMlRequest, CandidateUser]] = {</dt><dd><p>val identifiers = getCandidateSourceIdentifiers(request.params)
val selected: Set[CandidateSource[PostNuxMlRequest, CandidateUser]] =</p>
<blockquote>
<div><p>postNuxMlCandidateSourceRegistry.select(identifiers)</p>
</div></blockquote>
<p>val budget: Duration = request.params(PostNuxMlParams.FetchCandidateSourceBudget)
filterCandidateSources(</p>
<blockquote>
<div><p>request,
selected.map(c =&gt; c.failOpenWithin(budget, statsReceiver)).toSeq)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override protected val preRankerCandidateFilter: Predicate[(PostNuxMlRequest, CandidateUser)] = {</dt><dd><p>val stats = statsReceiver.scope(“pre_ranker”)</p>
<dl>
<dt>object excludeNearZeroUserPredicate</dt><dd><blockquote>
<div><dl class="simple">
<dt>extends GatedPredicateBase[(PostNuxMlRequest, CandidateUser)](</dt><dd><p>nonNearZeroUserActivityPredicate,
stats.scope(“exclude_near_zero_predicate”)</p>
</dd>
</dl>
<p>) {</p>
</div></blockquote>
<dl class="simple">
<dt>override def gate(item: (PostNuxMlRequest, CandidateUser)): Boolean =</dt><dd><p>item._1.params(PostNuxMlParams.ExcludeNearZeroCandidates)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>object invalidRelationshipGatedPredicate</dt><dd><blockquote>
<div><dl class="simple">
<dt>extends GatedPredicateBase[(PostNuxMlRequest, CandidateUser)](</dt><dd><p>invalidRelationshipPredicate,
stats.scope(“invalid_relationship_predicate”)</p>
</dd>
</dl>
<p>) {</p>
</div></blockquote>
<dl class="simple">
<dt>override def gate(item: (PostNuxMlRequest, CandidateUser)): Boolean =</dt><dd><p>item._1.params(PostNuxMlParams.EnableInvalidRelationshipPredicate)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>ExcludedUserIdPredicate</dt><dd><p>.observe(stats.scope(“exclude_user_id_predicate”))
.andThen(</p>
<blockquote>
<div><p>recentFollowingPredicate.observe(stats.scope(“recent_following_predicate”))</p>
</div></blockquote>
<p>)
.andThen(</p>
<blockquote>
<div><p>dismissedCandidatePredicate.observe(stats.scope(“dismissed_candidate_predicate”))</p>
</div></blockquote>
<p>)
.andThen(</p>
<blockquote>
<div><dl class="simple">
<dt>previouslyRecommendedUserIdsPredicate.observe(</dt><dd><p>stats.scope(“previously_recommended_user_ids_predicate”))</p>
</dd>
</dl>
</div></blockquote>
<p>)
.andThen(</p>
<blockquote>
<div><p>invalidRelationshipGatedPredicate.observe(stats.scope(“invalid_relationship_predicate”))</p>
</div></blockquote>
<p>)
.andThen(</p>
<blockquote>
<div><p>excludeNearZeroUserPredicate.observe(stats.scope(“exclude_near_zero_user_state”))</p>
</div></blockquote>
<p>)
.observe(stats.scope(“overall_pre_ranker_candidate_filter”))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override protected def selectRanker(</dt><dd><p>request: PostNuxMlRequest</p>
</dd>
<dt>): Ranker[PostNuxMlRequest, CandidateUser] = {</dt><dd><dl class="simple">
<dt>postNuxMlCombinedRankerBuilder.build(</dt><dd><p>request,
PostNuxMlFlowCandidateSourceWeights.getWeights(request.params))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override protected val postRankerTransform: Transform[PostNuxMlRequest, CandidateUser] = {</dt><dd><dl>
<dt>new DedupTransform[PostNuxMlRequest, CandidateUser]</dt><dd><p>.observe(statsReceiver.scope(“dedupping”))
.andThen(</p>
<blockquote>
<div><dl class="simple">
<dt>samplingTransform</dt><dd><p>.gated(PostNuxMlParams.SamplingTransformEnabled)
.observe(statsReceiver.scope(“samplingtransform”)))</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override protected val validateCandidates: Predicate[(PostNuxMlRequest, CandidateUser)] = {</dt><dd><p>val stats = statsReceiver.scope(“validate_candidates”)
val competitorPredicate =</p>
<blockquote>
<div><p>curatedCompetitorListPredicate.map[(PostNuxMlRequest, CandidateUser)](_._2)</p>
</div></blockquote>
<dl class="simple">
<dt>val producerHoldbackPredicate = new CandidateParamPredicate[CandidateUser](</dt><dd><p>GlobalParams.KeepUserCandidate,
FilterReason.CandidateSideHoldback</p>
</dd>
<dt>).map[(PostNuxMlRequest, CandidateUser)] {</dt><dd><p>case (request, user) =&gt; candidateParamsFactory(user, request)</p>
</dd>
</dl>
<p>}
val pymkProducerHoldbackPredicate = new CandidateSourceParamPredicate(</p>
<blockquote>
<div><p>GlobalParams.KeepSocialUserCandidate,
FilterReason.CandidateSideHoldback,
CandidateSourceHoldbackUtil.SocialCandidateSourceIds</p>
</div></blockquote>
<dl class="simple">
<dt>).map[(PostNuxMlRequest, CandidateUser)] {</dt><dd><p>case (request, user) =&gt; candidateParamsFactory(user, request)</p>
</dd>
</dl>
<p>}
val sgsPredicateStats = stats.scope(“sgs_predicate”)
object sgsGatedPredicate</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>extends GatedPredicateBase[(PostNuxMlRequest, CandidateUser)](</dt><dd><p>sgsPredicate.observe(sgsPredicateStats),
sgsPredicateStats</p>
</dd>
</dl>
<p>) {</p>
</div></blockquote>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>When SGS predicate is turned off, only query SGS exists API for (user, candidate, relationship)</p></li>
<li><p>when the user’s number of invalid relationships exceeds the threshold during request</p></li>
<li><p>building step. This is to minimize load to SGS and underlying Flock DB.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>override def gate(item: (PostNuxMlRequest, CandidateUser)): Boolean =</dt><dd><dl class="simple">
<dt>item._1.params(PostNuxMlParams.EnableSGSPredicate) ||</dt><dd><dl class="simple">
<dt>SocialGraphClient.enablePostRankerSgsPredicate(</dt><dd><p>item._1.invalidRelationshipUserIds.getOrElse(Set.empty).size)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>val hssPredicateStats = stats.scope(“hss_predicate”)
object hssGatedPredicate</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>extends GatedPredicateBase[(PostNuxMlRequest, CandidateUser)](</dt><dd><p>hssPredicate.observe(hssPredicateStats),
hssPredicateStats</p>
</dd>
</dl>
<p>) {</p>
</div></blockquote>
<dl class="simple">
<dt>override def gate(item: (PostNuxMlRequest, CandidateUser)): Boolean =</dt><dd><p>item._1.params(PostNuxMlParams.EnableHssPredicate)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl>
<dt>Predicate</dt><dd><dl>
<dt>.andConcurrently[(PostNuxMlRequest, CandidateUser)](</dt><dd><dl class="simple">
<dt>Seq(</dt><dd><p>competitorPredicate.observe(stats.scope(“curated_competitor_predicate”)),
gizmoduckPredicate.observe(stats.scope(“gizmoduck_predicate”)),
sgsGatedPredicate,
hssGatedPredicate,
inactivePredicate.observe(stats.scope(“inactive_predicate”)),</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)
// to avoid dilutions, we need to apply the receiver holdback predicates at the very last step
.andThen(pymkProducerHoldbackPredicate.observe(stats.scope(“pymk_receiver_side_holdback”)))
.andThen(producerHoldbackPredicate.observe(stats.scope(“receiver_side_holdback”)))
.observe(stats.scope(“overall_validate_candidates”))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override protected val transformResults: Transform[PostNuxMlRequest, CandidateUser] = {</dt><dd><dl class="simple">
<dt>modifySocialProofTransform</dt><dd><p>.gated(EnableGFSSocialProofTransform)
.andThen(trackingTokenTransform)
.andThen(randomRankerIdTransform.gated(PostNuxMlParams.LogRandomRankerId))
.andThen(removeAccountProofTransform.gated(PostNuxMlParams.EnableRemoveAccountProofTransform))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override protected def resultsConfig(request: PostNuxMlRequest): RecommendationResultsConfig = {</dt><dd><dl class="simple">
<dt>RecommendationResultsConfig(</dt><dd><p>request.maxResults.getOrElse(request.params(PostNuxMlParams.ResultSizeParam)),
request.params(PostNuxMlParams.BatchSizeParam)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def applySideEffects(</dt><dd><p>target: PostNuxMlRequest,
candidateSources: Seq[CandidateSource[PostNuxMlRequest, CandidateUser]],
candidatesFromCandidateSources: Seq[CandidateUser],
mergedCandidates: Seq[CandidateUser],
filteredCandidates: Seq[CandidateUser],
rankedCandidates: Seq[CandidateUser],
transformedCandidates: Seq[CandidateUser],
truncatedCandidates: Seq[CandidateUser],
results: Seq[CandidateUser]</p>
</dd>
<dt>): Stitch[Unit] = {</dt><dd><dl>
<dt>frsLogger.logRecommendationFlowData[PostNuxMlRequest](</dt><dd><p>target,
RecommendationFlowData[PostNuxMlRequest](</p>
<blockquote>
<div><p>target,
PostNuxMlFlow.identifier,
candidateSources,
candidatesFromCandidateSources,
mergedCandidates,
filteredCandidates,
rankedCandidates,
transformedCandidates,
truncatedCandidates,
results</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)
super.applySideEffects(</p>
<blockquote>
<div><p>target,
candidateSources,
candidatesFromCandidateSources,
mergedCandidates,
filteredCandidates,
rankedCandidates,
transformedCandidates,
truncatedCandidates,
results</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>object PostNuxMlFlow {</dt><dd><p>val identifier = RecommendationPipelineIdentifier(“PostNuxMlFlow”)</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../../_sources/follow-recommendations-service/server/src/main/scala/com/twitter/follow_recommendations/flows/post_nux_ml/PostNuxMlFlow.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>