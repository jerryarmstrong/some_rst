<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.home_mixer.module</p>
<p>import com.google.inject.Provides
import com.twitter.bijection.Injection
import com.twitter.bijection.scrooge.BinaryScalaCodec
import com.twitter.bijection.scrooge.CompactScalaCodec
import com.twitter.bijection.thrift.ThriftCodec
import com.twitter.conversions.DurationOps._
import com.twitter.finagle.mtls.authentication.ServiceIdentifier
import com.twitter.home_mixer.param.HomeMixerInjectionNames._
import com.twitter.home_mixer.util.InjectionTransformerImplicits._
import com.twitter.home_mixer.util.LanguageUtil
import com.twitter.home_mixer.util.TensorFlowUtil
import com.twitter.inject.TwitterModule
import com.twitter.manhattan.v1.{thriftscala =&gt; mh}
import com.twitter.ml.api.{thriftscala =&gt; ml}
import com.twitter.ml.featurestore.lib.UserId
import com.twitter.ml.featurestore.{thriftscala =&gt; fs}
import com.twitter.onboarding.relevance.features.{thriftjava =&gt; rf}
import com.twitter.product_mixer.shared_library.manhattan_client.ManhattanClientBuilder
import com.twitter.scalding_internal.multiformat.format.keyval.KeyValInjection.ScalaBinaryThrift
import com.twitter.search.common.constants.{thriftscala =&gt; scc}
import com.twitter.service.metastore.gen.{thriftscala =&gt; smg}
import com.twitter.servo.cache._
import com.twitter.servo.manhattan.ManhattanKeyValueRepository
import com.twitter.servo.repository.CachingKeyValueRepository
import com.twitter.servo.repository.ChunkingStrategy
import com.twitter.servo.repository.KeyValueRepository
import com.twitter.servo.repository.Repository
import com.twitter.servo.repository.keysAsQuery
import com.twitter.servo.util.Transformer
import com.twitter.storage.client.manhattan.bijections.Bijections
import com.twitter.storehaus_internal.manhattan.ManhattanClusters
import com.twitter.timelines.author_features.v1.{thriftjava =&gt; af}
import com.twitter.timelines.suggests.common.dense_data_record.{thriftscala =&gt; ddr}
import com.twitter.user_session_store.{thriftscala =&gt; uss_scala}
import com.twitter.user_session_store.{thriftjava =&gt; uss}
import com.twitter.util.Duration
import com.twitter.util.Try
import java.nio.ByteBuffer
import javax.inject.Named
import javax.inject.Singleton
import org.apache.thrift.protocol.TCompactProtocol
import org.apache.thrift.transport.TMemoryInputTransport
import org.apache.thrift.transport.TTransport</p>
<p>object ManhattanFeatureRepositoryModule extends TwitterModule {</p>
<blockquote>
<div><p>private val DEFAULT_RPC_CHUNK_SIZE = 50</p>
<p>private val ThriftEntityIdInjection = ScalaBinaryThrift(fs.EntityId)</p>
<dl>
<dt>private val FeatureStoreUserIdKeyTransformer = new Transformer[Long, ByteBuffer] {</dt><dd><dl class="simple">
<dt>override def to(userId: Long): Try[ByteBuffer] = {</dt><dd><p>Try(ByteBuffer.wrap(ThriftEntityIdInjection.apply(UserId(userId).toThrift)))</p>
</dd>
</dl>
<p>}
override def from(b: ByteBuffer): Try[Long] = ???</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private val FloatTensorTransformer = new Transformer[ByteBuffer, ml.FloatTensor] {</dt><dd><dl class="simple">
<dt>override def to(input: ByteBuffer): Try[ml.FloatTensor] = {</dt><dd><p>val floatTensor = TensorFlowUtil.embeddingByteBufferToFloatTensor(input)
Try(floatTensor)</p>
</dd>
</dl>
<p>}</p>
<p>override def from(b: ml.FloatTensor): Try[ByteBuffer] = ???</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private val LanguageTransformer = new Transformer[ByteBuffer, Seq[scc.ThriftLanguage]] {</dt><dd><dl class="simple">
<dt>override def to(input: ByteBuffer): Try[Seq[scc.ThriftLanguage]] = {</dt><dd><dl class="simple">
<dt>Try.fromScala(</dt><dd><dl class="simple">
<dt>Bijections</dt><dd><p>.BinaryScalaInjection(smg.UserLanguages)
.andThen(Bijections.byteBuffer2Buf.inverse)
.invert(input).map(LanguageUtil.computeLanguages(_)))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>override def from(b: Seq[scc.ThriftLanguage]): Try[ByteBuffer] = ???</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private val LongKeyTransformer = Injection</dt><dd><p>.connect[Long, Array[Byte]]
.toByteBufferTransformer()</p>
</dd>
</dl>
<p>// manhattan clients</p>
<p>&#64;Provides
&#64;Singleton
&#64;Named(ManhattanApolloClient)
def providesManhattanApolloClient(</p>
<blockquote>
<div><p>serviceIdentifier: ServiceIdentifier</p>
</div></blockquote>
<dl>
<dt>): mh.ManhattanCoordinator.MethodPerEndpoint = {</dt><dd><dl>
<dt>ManhattanClientBuilder</dt><dd><dl class="simple">
<dt>.buildManhattanV1FinagleClient(</dt><dd><p>ManhattanClusters.apollo,
serviceIdentifier</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>&#64;Provides
&#64;Singleton
&#64;Named(ManhattanAthenaClient)
def providesManhattanAthenaClient(</p>
<blockquote>
<div><p>serviceIdentifier: ServiceIdentifier</p>
</div></blockquote>
<dl>
<dt>): mh.ManhattanCoordinator.MethodPerEndpoint = {</dt><dd><dl>
<dt>ManhattanClientBuilder</dt><dd><dl class="simple">
<dt>.buildManhattanV1FinagleClient(</dt><dd><p>ManhattanClusters.athena,
serviceIdentifier</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>&#64;Provides
&#64;Singleton
&#64;Named(ManhattanOmegaClient)
def providesManhattanOmegaClient(</p>
<blockquote>
<div><p>serviceIdentifier: ServiceIdentifier</p>
</div></blockquote>
<dl>
<dt>): mh.ManhattanCoordinator.MethodPerEndpoint = {</dt><dd><dl>
<dt>ManhattanClientBuilder</dt><dd><dl class="simple">
<dt>.buildManhattanV1FinagleClient(</dt><dd><p>ManhattanClusters.omega,
serviceIdentifier</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>&#64;Provides
&#64;Singleton
&#64;Named(ManhattanStarbuckClient)
def providesManhattanStarbuckClient(</p>
<blockquote>
<div><p>serviceIdentifier: ServiceIdentifier</p>
</div></blockquote>
<dl>
<dt>): mh.ManhattanCoordinator.MethodPerEndpoint = {</dt><dd><dl>
<dt>ManhattanClientBuilder</dt><dd><dl class="simple">
<dt>.buildManhattanV1FinagleClient(</dt><dd><p>ManhattanClusters.starbuck,
serviceIdentifier</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>// non-cached manhattan repositories</p>
<p>&#64;Provides
&#64;Singleton
&#64;Named(MetricCenterUserCountingFeatureRepository)
def providesMetricCenterUserCountingFeatureRepository(</p>
<blockquote>
<div><p>&#64;Named(ManhattanStarbuckClient) client: mh.ManhattanCoordinator.MethodPerEndpoint</p>
</div></blockquote>
<p>): KeyValueRepository[Seq[Long], Long, rf.MCUserCountingFeatures] = {</p>
<blockquote>
<div><dl class="simple">
<dt>val valueTransformer = ThriftCodec</dt><dd><p>.toBinary[rf.MCUserCountingFeatures]
.toByteBufferTransformer()
.flip</p>
</dd>
<dt>batchedManhattanKeyValueRepository[Long, rf.MCUserCountingFeatures](</dt><dd><p>client = client,
keyTransformer = LongKeyTransformer,
valueTransformer = valueTransformer,
appId = “wtf_ml”,
dataset = “mc_user_counting_features_v0_starbuck”,
timeoutInMillis = 100</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A repository of the offline aggregate feature metadata necessary to decode</p></li>
<li><p>DenseCompactDataRecords.</p></li>
<li></li>
<li><p>This repository is expected to virtually always pick up the metadata form the local cache with</p></li>
<li><p>nearly 0 latency.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
</dl>
<p>&#64;Provides
&#64;Singleton
&#64;Named(TimelineAggregateMetadataRepository)
def providesTimelineAggregateMetadataRepository(</p>
<blockquote>
<div><p>&#64;Named(ManhattanAthenaClient) client: mh.ManhattanCoordinator.MethodPerEndpoint</p>
</div></blockquote>
<p>): Repository[Int, Option[ddr.DenseFeatureMetadata]] = {</p>
<blockquote>
<div><dl>
<dt>val keyTransformer = Injection</dt><dd><p>.connect[Int, Array[Byte]]
.toByteBufferTransformer()</p>
</dd>
<dt>val valueTransformer = new Transformer[ByteBuffer, ddr.DenseFeatureMetadata] {</dt><dd><p>private val compactProtocolFactory = new TCompactProtocol.Factory</p>
<dl class="simple">
<dt>def to(buffer: ByteBuffer): Try[ddr.DenseFeatureMetadata] = Try {</dt><dd><p>val transport = transportFromByteBuffer(buffer)
ddr.DenseFeatureMetadata.decode(compactProtocolFactory.getProtocol(transport))</p>
</dd>
</dl>
<p>}</p>
<p>// Encoding intentionally not implemented as it is never used
def from(metadata: ddr.DenseFeatureMetadata): Try[ByteBuffer] = ???</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val inProcessCache: Cache[Int, Cached[ddr.DenseFeatureMetadata]] = InProcessLruCacheFactory(</dt><dd><p>ttl = Duration.fromMinutes(20),
lruSize = 30</p>
</dd>
</dl>
<p>).apply(serializer = Transformer(_ =&gt; ???, _ =&gt; ???)) // Serialization is not necessary here.</p>
<dl class="simple">
<dt>val keyValueRepository = new ManhattanKeyValueRepository(</dt><dd><p>client = client,
keyTransformer = keyTransformer,
valueTransformer = valueTransformer,
appId = “timelines_dense_aggregates_encoding_metadata”, // Expected QPS is negligible.
dataset = “user_session_dense_feature_metadata”,
timeoutInMillis = 100</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>KeyValueRepository</dt><dd><dl>
<dt>.singular(</dt><dd><dl class="simple">
<dt>new CachingKeyValueRepository[Seq[Int], Int, ddr.DenseFeatureMetadata](</dt><dd><p>keyValueRepository,
new NonLockingCache(inProcessCache),
keysAsQuery[Int]</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>&#64;Provides
&#64;Singleton
&#64;Named(RealGraphFeatureRepository)
def providesRealGraphFeatureRepository(</p>
<blockquote>
<div><p>&#64;Named(ManhattanAthenaClient) client: mh.ManhattanCoordinator.MethodPerEndpoint</p>
</div></blockquote>
<dl>
<dt>): Repository[Long, Option[uss_scala.UserSession]] = {</dt><dd><p>val valueTransformer = CompactScalaCodec(uss_scala.UserSession).toByteBufferTransformer().flip</p>
<dl>
<dt>KeyValueRepository.singular(</dt><dd><dl class="simple">
<dt>new ManhattanKeyValueRepository(</dt><dd><p>client = client,
keyTransformer = LongKeyTransformer,
valueTransformer = valueTransformer,
appId = “real_graph”,
dataset = “split_real_graph_features”,
timeoutInMillis = 100,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<p>// cached manhattan repositories</p>
<p>&#64;Provides
&#64;Singleton
&#64;Named(AuthorFeatureRepository)
def providesAuthorFeatureRepository(</p>
<blockquote>
<div><p>&#64;Named(ManhattanAthenaClient) client: mh.ManhattanCoordinator.MethodPerEndpoint,
&#64;Named(HomeAuthorFeaturesCacheClient) cacheClient: Memcache</p>
</div></blockquote>
<p>): KeyValueRepository[Seq[Long], Long, af.AuthorFeatures] = {</p>
<blockquote>
<div><dl class="simple">
<dt>val valueInjection = ThriftCodec</dt><dd><p>.toCompact[af.AuthorFeatures]</p>
</dd>
<dt>val keyValueRepository = batchedManhattanKeyValueRepository(</dt><dd><p>client = client,
keyTransformer = LongKeyTransformer,
valueTransformer = valueInjection.toByteBufferTransformer().flip,
appId = “timelines_author_feature_store_athena”,
dataset = “timelines_author_features”,
timeoutInMillis = 100</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>val remoteCacheRepo = buildMemCachedRepository(</dt><dd><p>keyValueRepository = keyValueRepository,
cacheClient = cacheClient,
cachePrefix = “AuthorFeatureHydrator”,
ttl = 12.hours,
valueInjection = valueInjection)</p>
</dd>
<dt>buildInProcessCachedRepository(</dt><dd><p>keyValueRepository = remoteCacheRepo,
ttl = 15.minutes,
size = 8000,
valueInjection = valueInjection</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>}</p>
<p>&#64;Provides
&#64;Singleton
&#64;Named(TwhinAuthorFollowFeatureRepository)
def providesTwhinAuthorFollowFeatureRepository(</p>
<blockquote>
<div><p>&#64;Named(ManhattanApolloClient) client: mh.ManhattanCoordinator.MethodPerEndpoint,
&#64;Named(TwhinAuthorFollowFeatureCacheClient) cacheClient: Memcache</p>
</div></blockquote>
<dl>
<dt>): KeyValueRepository[Seq[Long], Long, ml.FloatTensor] = {</dt><dd><dl>
<dt>val keyValueRepository =</dt><dd><dl class="simple">
<dt>batchedManhattanKeyValueRepository(</dt><dd><p>client = client,
keyTransformer = FeatureStoreUserIdKeyTransformer,
valueTransformer = FloatTensorTransformer,
appId = “ml_features_apollo”,
dataset = “twhin_author_follow_embedding_fsv1__v1_thrift__embedding”,
timeoutInMillis = 100</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val valueInjection: Injection[ml.FloatTensor, Array[Byte]] =</dt><dd><p>BinaryScalaCodec(ml.FloatTensor)</p>
</dd>
<dt>buildMemCachedRepository(</dt><dd><p>keyValueRepository = keyValueRepository,
cacheClient = cacheClient,
cachePrefix = “twhinAuthorFollows”,
ttl = 24.hours,
valueInjection = valueInjection</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Provides
&#64;Singleton
&#64;Named(UserLanguagesRepository)
def providesUserLanguagesFeatureRepository(</p>
<blockquote>
<div><p>&#64;Named(ManhattanStarbuckClient) client: mh.ManhattanCoordinator.MethodPerEndpoint</p>
</div></blockquote>
<dl>
<dt>): KeyValueRepository[Seq[Long], Long, Seq[scc.ThriftLanguage]] = {</dt><dd><dl class="simple">
<dt>batchedManhattanKeyValueRepository(</dt><dd><p>client = client,
keyTransformer = LongKeyTransformer,
valueTransformer = LanguageTransformer,
appId = “user_metadata”,
dataset = “languages”,
timeoutInMillis = 70</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Provides
&#64;Singleton
&#64;Named(TwhinUserFollowFeatureRepository)
def providesTwhinUserFollowFeatureRepository(</p>
<blockquote>
<div><p>&#64;Named(ManhattanApolloClient) client: mh.ManhattanCoordinator.MethodPerEndpoint</p>
</div></blockquote>
<dl>
<dt>): KeyValueRepository[Seq[Long], Long, ml.FloatTensor] = {</dt><dd><dl class="simple">
<dt>batchedManhattanKeyValueRepository(</dt><dd><p>client = client,
keyTransformer = FeatureStoreUserIdKeyTransformer,
valueTransformer = FloatTensorTransformer,
appId = “ml_features_apollo”,
dataset = “twhin_user_follow_embedding_fsv1__v1_thrift__embedding”,
timeoutInMillis = 100</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Provides
&#64;Singleton
&#64;Named(TimelineAggregatePartARepository)
def providesTimelineAggregatePartARepository(</p>
<blockquote>
<div><p>&#64;Named(ManhattanApolloClient) client: mh.ManhattanCoordinator.MethodPerEndpoint,</p>
</div></blockquote>
<dl>
<dt>): Repository[Long, Option[uss.UserSession]] =</dt><dd><dl class="simple">
<dt>timelineAggregateRepository(</dt><dd><p>mhClient = client,
mhDataset = “timelines_aggregates_v2_features_by_user_part_a_apollo”,
mhAppId = “timelines_aggregates_v2_features_by_user_part_a_apollo”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>&#64;Provides
&#64;Singleton
&#64;Named(TimelineAggregatePartBRepository)
def providesTimelineAggregatePartBRepository(</p>
<blockquote>
<div><p>&#64;Named(ManhattanApolloClient) client: mh.ManhattanCoordinator.MethodPerEndpoint,</p>
</div></blockquote>
<dl>
<dt>): Repository[Long, Option[uss.UserSession]] =</dt><dd><dl class="simple">
<dt>timelineAggregateRepository(</dt><dd><p>mhClient = client,
mhDataset = “timelines_aggregates_v2_features_by_user_part_b_apollo”,
mhAppId = “timelines_aggregates_v2_features_by_user_part_b_apollo”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>&#64;Provides
&#64;Singleton
&#64;Named(TwhinUserEngagementFeatureRepository)
def providesTwhinUserEngagementFeatureRepository(</p>
<blockquote>
<div><p>&#64;Named(ManhattanApolloClient) client: mh.ManhattanCoordinator.MethodPerEndpoint</p>
</div></blockquote>
<p>): KeyValueRepository[Seq[Long], Long, ml.FloatTensor] = {</p>
<blockquote>
<div><dl class="simple">
<dt>batchedManhattanKeyValueRepository(</dt><dd><p>client = client,
keyTransformer = FeatureStoreUserIdKeyTransformer,
valueTransformer = FloatTensorTransformer,
appId = “ml_features_apollo”,
dataset = “twhin_user_engagement_embedding_fsv1__v1_thrift__embedding”,
timeoutInMillis = 100</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private def buildMemCachedRepository[K, V](</dt><dd><p>keyValueRepository: KeyValueRepository[Seq[K], K, V],
cacheClient: Memcache,
cachePrefix: String,
ttl: Duration,
valueInjection: Injection[V, Array[Byte]]</p>
</dd>
<dt>): CachingKeyValueRepository[Seq[K], K, V] = {</dt><dd><dl class="simple">
<dt>val cachedSerializer = CachedSerializer.binary(</dt><dd><p>valueInjection.toByteArrayTransformer()</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>val cache = MemcacheCacheFactory(</dt><dd><p>cacheClient,
ttl,
PrefixKeyTransformerFactory(cachePrefix)</p>
</dd>
</dl>
<p>)[K, Cached[V]](cachedSerializer)</p>
<dl class="simple">
<dt>new CachingKeyValueRepository(</dt><dd><p>keyValueRepository,
new NonLockingCache(cache),
keysAsQuery[K]</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def buildInProcessCachedRepository[K, V](</dt><dd><p>keyValueRepository: KeyValueRepository[Seq[K], K, V],
ttl: Duration,
size: Int,
valueInjection: Injection[V, Array[Byte]]</p>
</dd>
<dt>): CachingKeyValueRepository[Seq[K], K, V] = {</dt><dd><dl class="simple">
<dt>val cachedSerializer = CachedSerializer.binary(</dt><dd><p>valueInjection.toByteArrayTransformer()</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>val cache = InProcessLruCacheFactory(</dt><dd><p>ttl = ttl,
lruSize = size</p>
</dd>
</dl>
<p>)[K, Cached[V]](cachedSerializer)</p>
<dl class="simple">
<dt>new CachingKeyValueRepository(</dt><dd><p>keyValueRepository,
new NonLockingCache(cache),
keysAsQuery[K]</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def batchedManhattanKeyValueRepository[K, V](</dt><dd><p>client: mh.ManhattanCoordinator.MethodPerEndpoint,
keyTransformer: Transformer[K, ByteBuffer],
valueTransformer: Transformer[ByteBuffer, V],
appId: String,
dataset: String,
timeoutInMillis: Int,
chunkSize: Int = DEFAULT_RPC_CHUNK_SIZE</p>
</dd>
<dt>): KeyValueRepository[Seq[K], K, V] =</dt><dd><dl>
<dt>KeyValueRepository.chunked(</dt><dd><dl class="simple">
<dt>new ManhattanKeyValueRepository(</dt><dd><p>client = client,
keyTransformer = keyTransformer,
valueTransformer = valueTransformer,
appId = appId,
dataset = dataset,
timeoutInMillis = timeoutInMillis</p>
</dd>
</dl>
<p>),
chunker = ChunkingStrategy.equalSize(chunkSize)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>private def transportFromByteBuffer(buffer: ByteBuffer): TTransport =</dt><dd><dl class="simple">
<dt>new TMemoryInputTransport(</dt><dd><p>buffer.array(),
buffer.arrayOffset() + buffer.position(),
buffer.remaining())</p>
</dd>
</dl>
</dd>
<dt>private def timelineAggregateRepository(</dt><dd><p>mhClient: mh.ManhattanCoordinator.MethodPerEndpoint,
mhDataset: String,
mhAppId: String</p>
</dd>
<dt>): Repository[Long, Option[uss.UserSession]] = {</dt><dd><dl>
<dt>val valueInjection = ThriftCodec</dt><dd><p>.toCompact[uss.UserSession]</p>
</dd>
<dt>KeyValueRepository.singular(</dt><dd><dl class="simple">
<dt>new ManhattanKeyValueRepository(</dt><dd><p>client = mhClient,
keyTransformer = LongKeyTransformer,
valueTransformer = valueInjection.toByteBufferTransformer().flip,
appId = mhAppId,
dataset = mhDataset,
timeoutInMillis = 100</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/home-mixer/server/src/main/scala/com/twitter/home_mixer/module/ManhattanFeatureRepositoryModule.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>