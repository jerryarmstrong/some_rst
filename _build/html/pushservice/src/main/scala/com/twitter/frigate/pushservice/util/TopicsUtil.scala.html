<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.frigate.pushservice.util</p>
<p>import com.twitter.contentrecommender.thriftscala.DisplayLocation
import com.twitter.finagle.stats.Stat
import com.twitter.frigate.common.base.TargetUser
import com.twitter.frigate.common.predicate.CommonOutNetworkTweetCandidatesSourcePredicates.authorNotBeingFollowedPredicate
import com.twitter.frigate.common.store.interests.InterestsLookupRequestWithContext
import com.twitter.frigate.pushservice.model.PushTypes.Target
import com.twitter.frigate.pushservice.model.PushTypes
import com.twitter.frigate.pushservice.store.UttEntityHydrationQuery
import com.twitter.frigate.pushservice.store.UttEntityHydrationStore
import com.twitter.hermit.predicate.Predicate
import com.twitter.hermit.predicate.socialgraph.RelationEdge
import com.twitter.interests.thriftscala.InterestRelationType
import com.twitter.interests.thriftscala.InterestRelationship
import com.twitter.interests.thriftscala.InterestedInInterestLookupContext
import com.twitter.interests.thriftscala.InterestedInInterestModel
import com.twitter.interests.thriftscala.ProductId
import com.twitter.interests.thriftscala.UserInterest
import com.twitter.interests.thriftscala.UserInterestData
import com.twitter.interests.thriftscala.UserInterests
import com.twitter.interests.thriftscala.{TopicListingViewerContext =&gt; TopicListingViewerContextCR}
import com.twitter.stitch.tweetypie.TweetyPie.TweetyPieResult
import com.twitter.storehaus.ReadableStore
import com.twitter.timelines.configapi.Param
import com.twitter.topiclisting.TopicListingViewerContext
import com.twitter.topiclisting.utt.LocalizedEntity
import com.twitter.tsp.thriftscala.TopicListingSetting
import com.twitter.tsp.thriftscala.TopicSocialProofRequest
import com.twitter.tsp.thriftscala.TopicSocialProofResponse
import com.twitter.tsp.thriftscala.TopicWithScore
import com.twitter.util.Future
import scala.collection.Map</p>
<dl class="simple">
<dt>case class TweetWithTopicProof(</dt><dd><p>tweetId: Long,
topicId: Long,
authorId: Option[Long],
score: Double,
tweetyPieResult: TweetyPieResult,
topicListingSetting: String,
algorithmCR: Option[String],
isOON: Boolean)</p>
</dd>
</dl>
<p>object TopicsUtil {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Obtains the Localized Entities for the provided SC Entity IDs</p></li>
<li><p>&#64;param target                  The target user for which we’re obtaining candidates</p></li>
<li><p>&#64;param semanticCoreEntityIds   The seq. of entity ids for which we would like to obtain the Localized Entities</p></li>
<li><p>&#64;param uttEntityHydrationStore Store to query the actual LocalizedEntities</p></li>
<li><p>&#64;return                        A Future Map consisting of the entity id as the key and LocalizedEntity as the value</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>def getLocalizedEntityMap(</dt><dd><p>target: Target,
semanticCoreEntityIds: Set[Long],
uttEntityHydrationStore: UttEntityHydrationStore</p>
</dd>
<dt>): Future[Map[Long, LocalizedEntity]] = {</dt><dd><dl>
<dt>buildTopicListingViewerContext(target)</dt><dd><dl>
<dt>.flatMap { topicListingViewerContext =&gt;</dt><dd><p>val query = UttEntityHydrationQuery(topicListingViewerContext, semanticCoreEntityIds.toSeq)
val localizedTopicEntitiesFut =</p>
<blockquote>
<div><p>uttEntityHydrationStore.getLocalizedTopicEntities(query).map(_.flatten)</p>
</div></blockquote>
<dl>
<dt>localizedTopicEntitiesFut.map { localizedTopicEntities =&gt;</dt><dd><dl class="simple">
<dt>localizedTopicEntities.map { localizedTopicEntity =&gt;</dt><dd><p>localizedTopicEntity.entityId -&gt; localizedTopicEntity</p>
</dd>
</dl>
<p>}.toMap</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Fetch explict followed interests i.e Topics for targetUser</p></li>
<li></li>
<li><p>&#64;param targetUser: [[Target]] object representing a user eligible for MagicRecs notification</p></li>
<li><p>&#64;return: list of all Topics(Interests) Followed by targetUser</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>def getTopicsFollowedByUser(</dt><dd><p>targetUser: Target,
interestsWithLookupContextStore: ReadableStore[</p>
<blockquote>
<div><p>InterestsLookupRequestWithContext,
UserInterests</p>
</div></blockquote>
<p>],
followedTopicsStats: Stat</p>
</dd>
<dt>): Future[Option[Seq[UserInterest]]] = {</dt><dd><dl>
<dt>buildTopicListingViewerContext(targetUser).flatMap { topicListingViewerContext =&gt;</dt><dd><p>// explicit interests relation query
val explicitInterestsLookupRequest = InterestsLookupRequestWithContext(</p>
<blockquote>
<div><p>targetUser.targetId,
Some(</p>
<blockquote>
<div><dl class="simple">
<dt>InterestedInInterestLookupContext(</dt><dd><p>explicitContext = None,
inferredContext = None,
productId = Some(ProductId.Followable),
topicListingViewerContext = Some(topicListingViewerContext.toThrift),
disableExplicit = None,
disableImplicit = Some(true)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>)</p>
<p>// filter explicit follow relationships from response
interestsWithLookupContextStore.get(explicitInterestsLookupRequest).map {</p>
<blockquote>
<div><dl>
<dt>_.flatMap { userInterests =&gt;</dt><dd><dl>
<dt>val followedTopics = userInterests.interests.map {</dt><dd><dl>
<dt>_.filter {</dt><dd><dl>
<dt>case UserInterest(_, Some(interestData)) =&gt;</dt><dd><dl>
<dt>interestData match {</dt><dd><dl>
<dt>case UserInterestData.InterestedIn(interestedIn) =&gt;</dt><dd><dl>
<dt>interestedIn.exists {</dt><dd><dl>
<dt>case InterestedInInterestModel.ExplicitModel(explicitModel) =&gt;</dt><dd><dl>
<dt>explicitModel match {</dt><dd><dl class="simple">
<dt>case InterestRelationship.V1(v1) =&gt;</dt><dd><p>v1.relation == InterestRelationType.Followed</p>
</dd>
</dl>
<p>case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>case _ =&gt; false // interestData unavailable</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
followedTopicsStats.add(followedTopics.getOrElse(Seq.empty[UserInterest]).size)
followedTopics</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li></li>
<li><p>&#64;param target : [[Target]] object respresenting MagicRecs user</p></li>
<li></li>
<li><p>&#64;return: [[TopicListingViewerContext]] for querying topics</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>def buildTopicListingViewerContext(target: Target): Future[TopicListingViewerContext] = {</dt><dd><dl>
<dt>Future.join(target.inferredUserDeviceLanguage, target.countryCode, target.targetUser).map {</dt><dd><dl>
<dt>case (inferredLanguage, countryCode, userInfo) =&gt;</dt><dd><dl class="simple">
<dt>TopicListingViewerContext(</dt><dd><p>userId = Some(target.targetId),
guestId = None,
deviceId = None,
clientApplicationId = None,
userAgent = None,
languageCode = inferredLanguage,
countryCode = countryCode,
userRoles = userInfo.flatMap(_.roles.map(_.roles.toSet))</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li></li>
<li><p>&#64;param target : [[Target]] object respresenting MagicRecs user</p></li>
<li></li>
<li><p>&#64;return: [[TopicListingViewerContext]] for querying topics</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>def buildTopicListingViewerContextForCR(target: Target): Future[TopicListingViewerContextCR] = {</dt><dd><p>TopicsUtil.buildTopicListingViewerContext(target).map(_.toThrift)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li></li>
<li><p>&#64;param target : [[Target]] object respresenting MagicRecs user</p></li>
<li><p>&#64;param tweets : [[Seq[TweetyPieResult]]] object representing Tweets to get TSP for</p></li>
<li><p>&#64;param topicSocialProofServiceStore: [[ReadableStore[TopicSocialProofRequest, TopicSocialProofResponse]]]</p></li>
<li><p>&#64;param edgeStore: [[ReadableStore[RelationEdge, Boolean]]]]</p></li>
<li></li>
<li><p>&#64;return: [[Future[Seq[TweetWithTopicProof]]]] Tweets with topic proof</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>def getTopicSocialProofs(</dt><dd><p>inputTarget: Target,
tweets: Seq[TweetyPieResult],
topicSocialProofServiceStore: ReadableStore[TopicSocialProofRequest, TopicSocialProofResponse],
edgeStore: ReadableStore[RelationEdge, Boolean],
scoreThresholdParam: Param[Double]</p>
</dd>
<dt>): Future[Seq[TweetWithTopicProof]] = {</dt><dd><dl>
<dt>buildTopicListingViewerContextForCR(inputTarget).flatMap { topicListingContext =&gt;</dt><dd><p>val tweetIds: Set[Long] = tweets.map(_.tweet.id).toSet
val tweetIdsToTweetyPie = tweets.map(tp =&gt; tp.tweet.id -&gt; tp).toMap
val topicSocialProofRequest =</p>
<blockquote>
<div><dl class="simple">
<dt>TopicSocialProofRequest(</dt><dd><p>inputTarget.targetId,
tweetIds,
DisplayLocation.MagicRecsRecommendTopicTweets,
TopicListingSetting.Followable,
topicListingContext)</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>topicSocialProofServiceStore</dt><dd><dl>
<dt>.get(topicSocialProofRequest).flatMap {</dt><dd><dl>
<dt>case Some(topicSocialProofResponse) =&gt;</dt><dd><dl>
<dt>val topicProofCandidates = topicSocialProofResponse.socialProofs.collect {</dt><dd><dl>
<dt>case (tweetId, topicsWithScore)</dt><dd><blockquote>
<div><dl class="simple">
<dt>if topicsWithScore.nonEmpty &amp;&amp; topicsWithScore</dt><dd><p>.maxBy(_.score).score &gt;= inputTarget
.params(scoreThresholdParam) =&gt;</p>
</dd>
</dl>
</div></blockquote>
<p>// Get the topic with max score if there are any topics returned
val topicWithScore = topicsWithScore.maxBy(_.score)
TweetWithTopicProof(</p>
<blockquote>
<div><p>tweetId,
topicWithScore.topicId,
tweetIdsToTweetyPie(tweetId).tweet.coreData.map(_.userId),
topicWithScore.score,
tweetIdsToTweetyPie(tweetId),
topicWithScore.topicFollowType.map(_.name).getOrElse(“”),
topicWithScore.algorithmType.map(_.name),
isOON = true</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}.toSeq</p>
<p>hydrateTopicProofCandidatesWithEdgeStore(inputTarget, topicProofCandidates, edgeStore)</p>
</dd>
</dl>
<p>case _ =&gt; Future.value(Seq.empty[TweetWithTopicProof])</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Obtain TopicWithScores for provided tweet candidates and target</p></li>
<li><p>&#64;param target   target user</p></li>
<li><p>&#64;param Tweets   tweet candidates represented in a (tweetId, TweetyPieResult) map</p></li>
<li><p>&#64;param topicSocialProofServiceStore store to query topic social proof</p></li>
<li><p>&#64;param enableTopicAnnotation whether to enable topic annotation</p></li>
<li><p>&#64;param topicScoreThreshold  threshold for topic score</p></li>
<li><p>&#64;return a (tweetId, TopicWithScore) map where the topic with highest topic score (if exists) is chosen</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>def getTopicsWithScoreMap(</dt><dd><p>target: PushTypes.Target,
Tweets: Map[Long, Option[TweetyPieResult]],
topicSocialProofServiceStore: ReadableStore[TopicSocialProofRequest, TopicSocialProofResponse],
enableTopicAnnotation: Boolean,
topicScoreThreshold: Double</p>
</dd>
</dl>
<p>): Future[Option[Map[Long, TopicWithScore]]] = {</p>
<blockquote>
<div><dl>
<dt>if (enableTopicAnnotation) {</dt><dd><dl>
<dt>TopicsUtil</dt><dd><dl>
<dt>.buildTopicListingViewerContextForCR(target).flatMap { topicListingContext =&gt;</dt><dd><p>val tweetIds = Tweets.keySet
val topicSocialProofRequest =</p>
<blockquote>
<div><dl class="simple">
<dt>TopicSocialProofRequest(</dt><dd><p>target.targetId,
tweetIds,
DisplayLocation.MagicRecsRecommendTopicTweets,
TopicListingSetting.Followable,
topicListingContext)</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>topicSocialProofServiceStore</dt><dd><dl>
<dt>.get(topicSocialProofRequest).map {</dt><dd><dl>
<dt>_.map { topicSocialProofResponse =&gt;</dt><dd><dl>
<dt>topicSocialProofResponse.socialProofs</dt><dd><dl>
<dt>.collect {</dt><dd><dl>
<dt>case (tweetId, topicsWithScore)</dt><dd><blockquote>
<div><dl class="simple">
<dt>if topicsWithScore.nonEmpty &amp;&amp; Tweets(tweetId).nonEmpty</dt><dd><p>&amp;&amp; topicsWithScore.maxBy(_.score).score &gt;= topicScoreThreshold =&gt;</p>
</dd>
</dl>
</div></blockquote>
<p>tweetId -&gt; topicsWithScore.maxBy(_.score)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
<dt>} else {</dt><dd><p>Future.None</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Obtain LocalizedEntities for provided tweet candidates and target</p></li>
<li><p>&#64;param target target user</p></li>
<li><p>&#64;param Tweets tweet candidates represented in a (tweetId, TweetyPieResult) map</p></li>
<li><p>&#64;param uttEntityHydrationStore store to query the actual LocalizedEntities</p></li>
<li><p>&#64;param topicSocialProofServiceStore store to query topic social proof</p></li>
<li><p>&#64;param enableTopicAnnotation whether to enable topic annotation</p></li>
<li><p>&#64;param topicScoreThreshold threshold for topic score</p></li>
<li><p>&#64;return a (tweetId, LocalizedEntity Option) Future map that stores Localized Entity (can be empty) for given tweetId</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>def getTweetIdLocalizedEntityMap(</dt><dd><p>target: PushTypes.Target,
Tweets: Map[Long, Option[TweetyPieResult]],
uttEntityHydrationStore: UttEntityHydrationStore,
topicSocialProofServiceStore: ReadableStore[TopicSocialProofRequest, TopicSocialProofResponse],
enableTopicAnnotation: Boolean,
topicScoreThreshold: Double</p>
</dd>
</dl>
<p>): Future[Map[Long, Option[LocalizedEntity]]] = {</p>
<blockquote>
<div><dl>
<dt>val topicWithScoreMap = getTopicsWithScoreMap(</dt><dd><p>target,
Tweets,
topicSocialProofServiceStore,
enableTopicAnnotation,
topicScoreThreshold)</p>
</dd>
<dt>topicWithScoreMap.flatMap { topicWithScores =&gt;</dt><dd><dl>
<dt>topicWithScores match {</dt><dd><dl>
<dt>case Some(topics) =&gt;</dt><dd><p>val topicIds = topics.collect { case (_, topic) =&gt; topic.topicId }.toSet
val LocalizedEntityMapFut =</p>
<blockquote>
<div><p>getLocalizedEntityMap(target, topicIds, uttEntityHydrationStore)</p>
</div></blockquote>
<dl>
<dt>LocalizedEntityMapFut.map { LocalizedEntityMap =&gt;</dt><dd><dl class="simple">
<dt>topics.map {</dt><dd><dl class="simple">
<dt>case (tweetId, topic) =&gt;</dt><dd><p>tweetId -&gt; LocalizedEntityMap.get(topic.topicId)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>case _ =&gt; Future.value(Map[Long, Option[LocalizedEntity]]())</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Hydrate TweetWithTopicProof candidates with isOON field info,</p></li>
<li><p>based on the following relationship between target user and candidate author in edgeStore</p></li>
<li><p>&#64;return TweetWithTopicProof candidates with isOON field populated</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>def hydrateTopicProofCandidatesWithEdgeStore(</dt><dd><p>inputTarget: TargetUser,
topicProofCandidates: Seq[TweetWithTopicProof],
edgeStore: ReadableStore[RelationEdge, Boolean],</p>
</dd>
<dt>): Future[Seq[TweetWithTopicProof]] = {</dt><dd><p>// IDs of all authors of TopicProof candidates that are OON with respect to inputTarget
val validOONAuthorIdsFut =</p>
<blockquote>
<div><dl class="simple">
<dt>Predicate.filter(</dt><dd><p>topicProofCandidates.flatMap(_.authorId).distinct,
authorNotBeingFollowedPredicate(inputTarget, edgeStore))</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>validOONAuthorIdsFut.map { validOONAuthorIds =&gt;</dt><dd><dl class="simple">
<dt>topicProofCandidates.map(candidate =&gt; {</dt><dd><dl class="simple">
<dt>candidate.copy(isOON =</dt><dd><p>candidate.authorId.isDefined &amp;&amp; validOONAuthorIds.contains(candidate.authorId.get))</p>
</dd>
</dl>
</dd>
</dl>
<p>})</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/pushservice/src/main/scala/com/twitter/frigate/pushservice/util/TopicsUtil.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>