<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.frigate.pushservice.refresh_handler</p>
<p>import com.twitter.finagle.stats.Counter
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.frigate.common.base.CandidateDetails
import com.twitter.frigate.common.base.CandidateResult
import com.twitter.frigate.common.base.CandidateSource
import com.twitter.frigate.common.base.FetchRankFlowWithHydratedCandidates
import com.twitter.frigate.common.base.Invalid
import com.twitter.frigate.common.base.OK
import com.twitter.frigate.common.base.Response
import com.twitter.frigate.common.base.Result
import com.twitter.frigate.common.base.Stats.track
import com.twitter.frigate.common.base.Stats.trackSeq
import com.twitter.frigate.common.logger.MRLogger
import com.twitter.frigate.pushservice.model.PushTypes.PushCandidate
import com.twitter.frigate.pushservice.model.PushTypes.RawCandidate
import com.twitter.frigate.pushservice.model.PushTypes.Target
import com.twitter.frigate.pushservice.adaptor.LoggedOutPushCandidateSourceGenerator
import com.twitter.frigate.pushservice.predicate.LoggedOutPreRankingPredicates
import com.twitter.frigate.pushservice.predicate.LoggedOutTargetPredicates
import com.twitter.frigate.pushservice.rank.LoggedOutRanker
import com.twitter.frigate.pushservice.take.LoggedOutRefreshForPushNotifier
import com.twitter.frigate.pushservice.scriber.MrRequestScribeHandler
import com.twitter.frigate.pushservice.target.LoggedOutPushTargetUserBuilder
import com.twitter.frigate.pushservice.thriftscala.LoggedOutRequest
import com.twitter.frigate.pushservice.thriftscala.LoggedOutResponse
import com.twitter.frigate.pushservice.thriftscala.PushContext
import com.twitter.hermit.predicate.NamedPredicate
import com.twitter.hermit.predicate.Predicate
import com.twitter.hermit.predicate.SequentialPredicate
import com.twitter.util.Future</p>
<dl>
<dt>class LoggedOutRefreshForPushHandler(</dt><dd><p>val loPushTargetUserBuilder: LoggedOutPushTargetUserBuilder,
val loPushCandidateSourceGenerator: LoggedOutPushCandidateSourceGenerator,
candidateHydrator: PushCandidateHydrator,
val loRanker: LoggedOutRanker,
val loRfphNotifier: LoggedOutRefreshForPushNotifier,
loMrRequestScriberNode: String</p>
</dd>
<dt>)(</dt><dd><dl class="simple">
<dt>globalStats: StatsReceiver)</dt><dd><p>extends FetchRankFlowWithHydratedCandidates[Target, RawCandidate, PushCandidate] {</p>
</dd>
</dl>
<p>val log = MRLogger(“LORefreshForPushHandler”)
implicit val statsReceiver: StatsReceiver =</p>
<blockquote>
<div><p>globalStats.scope(“LORefreshForPushHandler”)</p>
</div></blockquote>
<p>private val loggedOutBuildStats = statsReceiver.scope(“logged_out_build_target”)
private val loggedOutProcessStats = statsReceiver.scope(“logged_out_process”)
private val loggedOutNotifyStats = statsReceiver.scope(“logged_out_notify”)
private val loCandidateHydrationStats: StatsReceiver =</p>
<blockquote>
<div><p>statsReceiver.scope(“logged_out_candidate_hydration”)</p>
</div></blockquote>
<dl class="simple">
<dt>val mrLORequestCandidateScribeStats =</dt><dd><p>statsReceiver.scope(“mr_logged_out_request_scribe_candidates”)</p>
</dd>
<dt>val mrRequestScribeHandler =</dt><dd><p>new MrRequestScribeHandler(loMrRequestScriberNode, statsReceiver.scope(“lo_mr_request_scribe”))</p>
</dd>
</dl>
<p>val loMrRequestTargetScribeStats = statsReceiver.scope(“lo_mr_request_scribe_target”)</p>
<dl class="simple">
<dt>lazy val loCandSourceEligibleCounter: Counter =</dt><dd><p>loCandidateStats.counter(“logged_out_cand_source_eligible”)</p>
</dd>
<dt>lazy val loCandSourceNotEligibleCounter: Counter =</dt><dd><p>loCandidateStats.counter(“logged_out_cand_source_not_eligible”)</p>
</dd>
</dl>
<p>lazy val allCandidatesCounter: Counter = statsReceiver.counter(“all_logged_out_candidates”)
val allCandidatesFilteredPreRank = filterStats.counter(“all_logged_out_candidates_filtered”)</p>
<dl class="simple">
<dt>override def targetPredicates(target: Target): List[Predicate[Target]] = List(</dt><dd><p>LoggedOutTargetPredicates.targetFatiguePredicate(),
LoggedOutTargetPredicates.loggedOutRecsHoldbackPredicate()</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>override def isTargetValid(target: Target): Future[Result] = {</dt><dd><dl>
<dt>val resultFut =</dt><dd><dl>
<dt>if (target.skipFilters) {</dt><dd><p>Future.value(OK)</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>predicateSeq(target).track(Seq(target)).map { resultArr =&gt;</dt><dd><p>trackTargetPredStats(resultArr(0))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>track(targetStats)(resultFut)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override def rank(</dt><dd><p>target: Target,
candidateDetails: Seq[CandidateDetails[PushCandidate]]</p>
</dd>
<dt>): Future[Seq[CandidateDetails[PushCandidate]]] = {</dt><dd><p>loRanker.rank(candidateDetails)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override def validCandidates(</dt><dd><p>target: Target,
candidates: Seq[PushCandidate]</p>
</dd>
<dt>): Future[Seq[Result]] = {</dt><dd><p>Future.value(candidates.map { c =&gt; OK })</p>
</dd>
</dl>
<p>}</p>
<p>override def desiredCandidateCount(target: Target): Int = 1</p>
<dl>
<dt>private val loggedOutPreRankingPredicates =</dt><dd><p>LoggedOutPreRankingPredicates(filterStats.scope(“logged_out_predicates”))</p>
</dd>
<dt>private val loggedOutPreRankingPredicateChain =</dt><dd><p>new SequentialPredicate[PushCandidate](loggedOutPreRankingPredicates)</p>
</dd>
<dt>override def filter(</dt><dd><p>target: Target,
candidates: Seq[CandidateDetails[PushCandidate]]</p>
</dd>
<dt>): Future[</dt><dd><p>(Seq[CandidateDetails[PushCandidate]], Seq[CandidateResult[PushCandidate, Result]])</p>
</dd>
<dt>] = {</dt><dd><p>val predicateChain = loggedOutPreRankingPredicateChain
predicateChain</p>
<blockquote>
<div><p>.track(candidates.map(_.candidate))
.map { results =&gt;</p>
<blockquote>
<div><dl>
<dt>val resultForPreRankingFiltering =</dt><dd><dl>
<dt>results</dt><dd><p>.zip(candidates)
.foldLeft(</p>
<blockquote>
<div><dl class="simple">
<dt>(</dt><dd><p>Seq.empty[CandidateDetails[PushCandidate]],
Seq.empty[CandidateResult[PushCandidate, Result]]</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>) {</dt><dd><dl>
<dt>case ((goodCandidates, filteredCandidates), (result, candidateDetails)) =&gt;</dt><dd><dl>
<dt>result match {</dt><dd><dl>
<dt>case None =&gt;</dt><dd><p>(goodCandidates :+ candidateDetails, filteredCandidates)</p>
</dd>
<dt>case Some(pred: NamedPredicate[_]) =&gt;</dt><dd><p>val r = Invalid(Some(pred.name))
(</p>
<blockquote>
<div><p>goodCandidates,
filteredCandidates :+ CandidateResult[PushCandidate, Result](</p>
<blockquote>
<div><p>candidateDetails.candidate,
candidateDetails.source,
r</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>case Some(_) =&gt;</dt><dd><p>val r = Invalid(Some(“Filtered by un-named predicate”))
(</p>
<blockquote>
<div><p>goodCandidates,
filteredCandidates :+ CandidateResult[PushCandidate, Result](</p>
<blockquote>
<div><p>candidateDetails.candidate,
candidateDetails.source,
r</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
<dt>resultForPreRankingFiltering match {</dt><dd><dl class="simple">
<dt>case (validCandidates, _) if validCandidates.isEmpty &amp;&amp; candidates.nonEmpty =&gt;</dt><dd><p>allCandidatesFilteredPreRank.incr()</p>
</dd>
</dl>
<p>case _ =&gt; ()</p>
</dd>
</dl>
<p>}
resultForPreRankingFiltering</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def candidateSources(</dt><dd><p>target: Target</p>
</dd>
<dt>): Future[Seq[CandidateSource[Target, RawCandidate]]] = {</dt><dd><dl>
<dt>Future</dt><dd><dl>
<dt>.collect(loPushCandidateSourceGenerator.sources.map { cs =&gt;</dt><dd><dl>
<dt>cs.isCandidateSourceAvailable(target).map { isEligible =&gt;</dt><dd><dl class="simple">
<dt>if (isEligible) {</dt><dd><p>loCandSourceEligibleCounter.incr()
Some(cs)</p>
</dd>
<dt>} else {</dt><dd><p>loCandSourceNotEligibleCounter.incr()
None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}).map(_.flatten)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def process(</dt><dd><p>target: Target,
externalCandidates: Seq[RawCandidate] = Nil</p>
</dd>
<dt>): Future[Response[PushCandidate, Result]] = {</dt><dd><dl>
<dt>isTargetValid(target).flatMap {</dt><dd><dl>
<dt>case OK =&gt;</dt><dd><dl>
<dt>for {</dt><dd><p>candidatesFromSources &lt;- trackSeq(fetchStats)(fetchCandidates(target))
externalCandidateDetails = externalCandidates.map(</p>
<blockquote>
<div><p>CandidateDetails(_, “logged_out_refresh_for_push_handler_external_candidates”))</p>
</div></blockquote>
<p>allCandidates = candidatesFromSources ++ externalCandidateDetails
hydratedCandidatesWithCopy &lt;-</p>
<blockquote>
<div><p>trackSeq(loCandidateHydrationStats)(hydrateCandidates(allCandidates))</p>
</div></blockquote>
<dl class="simple">
<dt>(candidates, preRankingFilteredCandidates) &lt;-</dt><dd><p>track(filterStats)(filter(target, hydratedCandidatesWithCopy))</p>
</dd>
</dl>
<p>rankedCandidates &lt;- trackSeq(rankingStats)(rank(target, candidates))
allTakeCandidateResults &lt;- track(takeStats)(</p>
<blockquote>
<div><p>take(target, rankedCandidates, desiredCandidateCount(target))</p>
</div></blockquote>
<p>)
_ &lt;- track(mrLORequestCandidateScribeStats)(</p>
<blockquote>
<div><dl class="simple">
<dt>mrRequestScribeHandler.scribeForCandidateFiltering(</dt><dd><p>target,
hydratedCandidatesWithCopy,
preRankingFilteredCandidates,
rankedCandidates,
rankedCandidates,
rankedCandidates,
allTakeCandidateResults</p>
</dd>
</dl>
<p>))</p>
</div></blockquote>
</dd>
<dt>} yield {</dt><dd><dl class="simple">
<dt>val takeCandidateResults = allTakeCandidateResults.filterNot { candResult =&gt;</dt><dd><p>candResult.result == MoreThanDesiredCandidates</p>
</dd>
</dl>
<p>}
val allCandidateResults = takeCandidateResults ++ preRankingFilteredCandidates
allCandidatesCounter.incr(allCandidateResults.size)
Response(OK, allCandidateResults)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>case result: Result =&gt;</dt><dd><dl>
<dt>for (_ &lt;- track(loMrRequestTargetScribeStats)(</dt><dd><blockquote>
<div><p>mrRequestScribeHandler.scribeForTargetFiltering(target, result))) yield {</p>
</div></blockquote>
<p>Response(result, Nil)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def buildTarget(</dt><dd><p>guestId: Long,
inputPushContext: Option[PushContext]</p>
</dd>
<dt>): Future[Target] =</dt><dd><p>loPushTargetUserBuilder.buildTarget(guestId, inputPushContext)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Hydrate candidate by querying downstream services</p></li>
<li></li>
<li><p>&#64;param candidates - candidates</p></li>
<li></li>
<li><p>&#64;return - hydrated candidates</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>override def hydrateCandidates(</dt><dd><p>candidates: Seq[CandidateDetails[RawCandidate]]</p>
</dd>
</dl>
<p>): Future[Seq[CandidateDetails[PushCandidate]]] = candidateHydrator(candidates)</p>
<p>override def batchForCandidatesCheck(target: Target): Int = 1</p>
<dl>
<dt>def refreshAndSend(request: LoggedOutRequest): Future[LoggedOutResponse] = {</dt><dd><dl>
<dt>for {</dt><dd><dl class="simple">
<dt>target &lt;- track(loggedOutBuildStats)(</dt><dd><p>loPushTargetUserBuilder.buildTarget(request.guestId, request.context))</p>
</dd>
</dl>
<p>response &lt;- track(loggedOutProcessStats)(process(target, externalCandidates = Seq.empty))
loggedOutRefreshResponse &lt;-</p>
<blockquote>
<div><p>track(loggedOutNotifyStats)(loRfphNotifier.checkResponseAndNotify(response))</p>
</div></blockquote>
</dd>
<dt>} yield {</dt><dd><p>loggedOutRefreshResponse</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/pushservice/src/main/scala/com/twitter/frigate/pushservice/refresh_handler/LoggedOutRefreshForPushHandler.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>