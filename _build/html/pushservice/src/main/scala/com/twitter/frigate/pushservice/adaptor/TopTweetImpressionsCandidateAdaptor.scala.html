<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.frigate.pushservice.adaptor</p>
<p>import com.twitter.conversions.DurationOps._
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.frigate.common.base.CandidateSource
import com.twitter.frigate.common.base.CandidateSourceEligible
import com.twitter.frigate.common.base.TopTweetImpressionsCandidate
import com.twitter.frigate.common.store.RecentTweetsQuery
import com.twitter.frigate.common.util.SnowflakeUtils
import com.twitter.frigate.pushservice.model.PushTypes.RawCandidate
import com.twitter.frigate.pushservice.model.PushTypes.Target
import com.twitter.frigate.pushservice.params.{PushFeatureSwitchParams =&gt; FS}
import com.twitter.frigate.pushservice.store.TweetImpressionsStore
import com.twitter.frigate.pushservice.util.PushDeviceUtil
import com.twitter.stitch.tweetypie.TweetyPie.TweetyPieResult
import com.twitter.storehaus.FutureOps
import com.twitter.storehaus.ReadableStore
import com.twitter.util.Future</p>
<dl>
<dt>case class TweetImpressionsCandidate(</dt><dd><p>tweetId: Long,
tweetyPieResultOpt: Option[TweetyPieResult],
impressionsCountOpt: Option[Long])</p>
</dd>
<dt>case class TopTweetImpressionsCandidateAdaptor(</dt><dd><p>recentTweetsFromTflockStore: ReadableStore[RecentTweetsQuery, Seq[Seq[Long]]],
tweetyPieStore: ReadableStore[Long, TweetyPieResult],
tweetyPieStoreNoVF: ReadableStore[Long, TweetyPieResult],
tweetImpressionsStore: TweetImpressionsStore,
globalStats: StatsReceiver)</p>
<blockquote>
<div><p>extends CandidateSource[Target, RawCandidate]
with CandidateSourceEligible[Target, RawCandidate] {</p>
</div></blockquote>
<p>private val stats = globalStats.scope(“TopTweetImpressionsAdaptor”)
private val tweetImpressionsCandsStat = stats.stat(“top_tweet_impressions_cands_dist”)</p>
<p>private val eligibleUsersCounter = stats.counter(“eligible_users”)
private val noneligibleUsersCounter = stats.counter(“noneligible_users”)
private val meetsMinTweetsRequiredCounter = stats.counter(“meets_min_tweets_required”)
private val belowMinTweetsRequiredCounter = stats.counter(“below_min_tweets_required”)
private val aboveMaxInboundFavoritesCounter = stats.counter(“above_max_inbound_favorites”)
private val meetsImpressionsRequiredCounter = stats.counter(“meets_impressions_required”)
private val belowImpressionsRequiredCounter = stats.counter(“below_impressions_required”)
private val meetsFavoritesThresholdCounter = stats.counter(“meets_favorites_threshold”)
private val aboveFavoritesThresholdCounter = stats.counter(“above_favorites_threshold”)
private val emptyImpressionsMapCounter = stats.counter(“empty_impressions_map”)</p>
<p>private val tflockResultsStat = stats.stat(“tflock”, “results”)
private val emptyTflockResult = stats.counter(“tflock”, “empty_result”)
private val nonEmptyTflockResult = stats.counter(“tflock”, “non_empty_result”)</p>
<p>private val originalTweetsStat = stats.stat(“tweets”, “original_tweets”)
private val retweetsStat = stats.stat(“tweets”, “retweets”)
private val allRetweetsOnlyCounter = stats.counter(“tweets”, “all_retweets_only”)
private val allOriginalTweetsOnlyCounter = stats.counter(“tweets”, “all_original_tweets_only”)</p>
<p>private val emptyTweetypieMap = stats.counter(“”, “empty_tweetypie_map”)
private val emptyTweetyPieResult = stats.stat(“”, “empty_tweetypie_result”)
private val allEmptyTweetypieResults = stats.counter(“”, “all_empty_tweetypie_results”)</p>
<dl class="simple">
<dt>private val eligibleUsersAfterImpressionsFilter =</dt><dd><p>stats.counter(“eligible_users_after_impressions_filter”)</p>
</dd>
<dt>private val eligibleUsersAfterFavoritesFilter =</dt><dd><p>stats.counter(“eligible_users_after_favorites_filter”)</p>
</dd>
<dt>private val eligibleUsersWithEligibleTweets =</dt><dd><p>stats.counter(“eligible_users_with_eligible_tweets”)</p>
</dd>
</dl>
<p>private val eligibleTweetCands = stats.stat(“eligible_tweet_cands”)
private val getCandsRequestCounter =</p>
<blockquote>
<div><p>stats.counter(“top_tweet_impressions_get_request”)</p>
</div></blockquote>
<p>override val name: String = this.getClass.getSimpleName</p>
<dl>
<dt>override def get(inputTarget: Target): Future[Option[Seq[RawCandidate]]] = {</dt><dd><p>getCandsRequestCounter.incr()
val eligibleCandidatesFut = getTweetImpressionsCandidates(inputTarget)
eligibleCandidatesFut.map { eligibleCandidates =&gt;</p>
<blockquote>
<div><dl>
<dt>if (eligibleCandidates.nonEmpty) {</dt><dd><p>eligibleUsersWithEligibleTweets.incr()
eligibleTweetCands.add(eligibleCandidates.size)
val candidate = getMostImpressionsTweet(eligibleCandidates)
Some(</p>
<blockquote>
<div><dl class="simple">
<dt>Seq(</dt><dd><dl class="simple">
<dt>generateTopTweetImpressionsCandidate(</dt><dd><p>inputTarget,
candidate.tweetId,
candidate.tweetyPieResultOpt,
candidate.impressionsCountOpt.getOrElse(0L))))</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>} else None</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getTweetImpressionsCandidates(</dt><dd><p>inputTarget: Target</p>
</dd>
<dt>): Future[Seq[TweetImpressionsCandidate]] = {</dt><dd><p>val originalTweets = getRecentOriginalTweetsForUser(inputTarget)
originalTweets.flatMap { tweetyPieResultsMap =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>val numDaysSearchForOriginalTweets =</dt><dd><p>inputTarget.params(FS.TopTweetImpressionsOriginalTweetsNumDaysSearch)</p>
</dd>
<dt>val moreRecentTweetIds =</dt><dd><p>getMoreRecentTweetIds(tweetyPieResultsMap.keySet.toSeq, numDaysSearchForOriginalTweets)</p>
</dd>
</dl>
<p>val isEligible = isEligibleUser(inputTarget, tweetyPieResultsMap, moreRecentTweetIds)
if (isEligible) filterByEligibility(inputTarget, tweetyPieResultsMap, moreRecentTweetIds)
else Future.Nil</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getRecentOriginalTweetsForUser(</dt><dd><p>targetUser: Target</p>
</dd>
<dt>): Future[Map[Long, TweetyPieResult]] = {</dt><dd><dl>
<dt>val tweetyPieResultsMapFut = getTflockStoreResults(targetUser).flatMap { recentTweetIds =&gt;</dt><dd><dl class="simple">
<dt>FutureOps.mapCollect((targetUser.params(FS.EnableVFInTweetypie) match {</dt><dd><p>case true =&gt; tweetyPieStore
case false =&gt; tweetyPieStoreNoVF</p>
</dd>
</dl>
<p>}).multiGet(recentTweetIds.toSet))</p>
</dd>
</dl>
<p>}
tweetyPieResultsMapFut.map { tweetyPieResultsMap =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>if (tweetyPieResultsMap.isEmpty) {</dt><dd><p>emptyTweetypieMap.incr()
Map.empty</p>
</dd>
</dl>
<p>} else removeRetweets(tweetyPieResultsMap)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getTflockStoreResults(targetUser: Target): Future[Seq[Long]] = {</dt><dd><p>val maxResults = targetUser.params(FS.TopTweetImpressionsRecentTweetsByAuthorStoreMaxResults)
val maxAge = targetUser.params(FS.TopTweetImpressionsTotalFavoritesLimitNumDaysSearch)
val recentTweetsQuery =</p>
<blockquote>
<div><dl class="simple">
<dt>RecentTweetsQuery(</dt><dd><p>userIds = Seq(targetUser.targetId),
maxResults = maxResults,
maxAge = maxAge.days</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>recentTweetsFromTflockStore</dt><dd><dl>
<dt>.get(recentTweetsQuery).map {</dt><dd><dl>
<dt>case Some(tweetIdsAll) =&gt;</dt><dd><p>val tweetIds = tweetIdsAll.headOption.getOrElse(Seq.empty)
val numTweets = tweetIds.size
if (numTweets &gt; 0) {</p>
<blockquote>
<div><p>tflockResultsStat.add(numTweets)
nonEmptyTflockResult.incr()</p>
</div></blockquote>
<p>} else emptyTflockResult.incr()
tweetIds</p>
</dd>
</dl>
<p>case _ =&gt; Nil</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def removeRetweets(</dt><dd><p>tweetyPieResultsMap: Map[Long, Option[TweetyPieResult]]</p>
</dd>
<dt>): Map[Long, TweetyPieResult] = {</dt><dd><dl class="simple">
<dt>val nonEmptyTweetyPieResults: Map[Long, TweetyPieResult] = tweetyPieResultsMap.collect {</dt><dd><p>case (key, Some(value)) =&gt; (key, value)</p>
</dd>
</dl>
<p>}
emptyTweetyPieResult.add(tweetyPieResultsMap.size - nonEmptyTweetyPieResults.size)</p>
<dl>
<dt>if (nonEmptyTweetyPieResults.nonEmpty) {</dt><dd><dl class="simple">
<dt>val originalTweets = nonEmptyTweetyPieResults.filter {</dt><dd><dl class="simple">
<dt>case (_, tweetyPieResult) =&gt;</dt><dd><p>tweetyPieResult.sourceTweet.isEmpty</p>
</dd>
</dl>
</dd>
</dl>
<p>}
val numOriginalTweets = originalTweets.size
val numRetweets = nonEmptyTweetyPieResults.size - originalTweets.size
originalTweetsStat.add(numOriginalTweets)
retweetsStat.add(numRetweets)
if (numRetweets == 0) allOriginalTweetsOnlyCounter.incr()
if (numOriginalTweets == 0) allRetweetsOnlyCounter.incr()
originalTweets</p>
</dd>
<dt>} else {</dt><dd><p>allEmptyTweetypieResults.incr()
Map.empty</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getMoreRecentTweetIds(</dt><dd><p>tweetIds: Seq[Long],
numDays: Int</p>
</dd>
<dt>): Seq[Long] = {</dt><dd><dl class="simple">
<dt>tweetIds.filter { tweetId =&gt;</dt><dd><p>SnowflakeUtils.isRecent(tweetId, numDays.days)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def isEligibleUser(</dt><dd><p>inputTarget: Target,
tweetyPieResults: Map[Long, TweetyPieResult],
recentTweetIds: Seq[Long]</p>
</dd>
<dt>): Boolean = {</dt><dd><p>val minNumTweets = inputTarget.params(FS.TopTweetImpressionsMinNumOriginalTweets)
lazy val totalFavoritesLimit =</p>
<blockquote>
<div><p>inputTarget.params(FS.TopTweetImpressionsTotalInboundFavoritesLimit)</p>
</div></blockquote>
<dl>
<dt>if (recentTweetIds.size &gt;= minNumTweets) {</dt><dd><p>meetsMinTweetsRequiredCounter.incr()
val isUnderLimit = isUnderTotalInboundFavoritesLimit(tweetyPieResults, totalFavoritesLimit)
if (isUnderLimit) eligibleUsersCounter.incr()
else {</p>
<blockquote>
<div><p>aboveMaxInboundFavoritesCounter.incr()
noneligibleUsersCounter.incr()</p>
</div></blockquote>
<p>}
isUnderLimit</p>
</dd>
<dt>} else {</dt><dd><p>belowMinTweetsRequiredCounter.incr()
noneligibleUsersCounter.incr()
false</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private def getFavoriteCounts(</dt><dd><p>tweetyPieResult: TweetyPieResult</p>
</dd>
</dl>
<p>): Long = tweetyPieResult.tweet.counts.flatMap(_.favoriteCount).getOrElse(0L)</p>
<dl class="simple">
<dt>private def isUnderTotalInboundFavoritesLimit(</dt><dd><p>tweetyPieResults: Map[Long, TweetyPieResult],
totalFavoritesLimit: Long</p>
</dd>
<dt>): Boolean = {</dt><dd><p>val favoritesIterator = tweetyPieResults.valuesIterator.map(getFavoriteCounts)
val totalInboundFavorites = favoritesIterator.sum
totalInboundFavorites &lt;= totalFavoritesLimit</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def filterByEligibility(</dt><dd><p>inputTarget: Target,
tweetyPieResults: Map[Long, TweetyPieResult],
tweetIds: Seq[Long]</p>
</dd>
<dt>): Future[Seq[TweetImpressionsCandidate]] = {</dt><dd><p>lazy val minNumImpressions: Long = inputTarget.params(FS.TopTweetImpressionsMinRequired)
lazy val maxNumLikes: Long = inputTarget.params(FS.TopTweetImpressionsMaxFavoritesPerTweet)
for {</p>
<blockquote>
<div><p>filteredImpressionsMap &lt;- getFilteredImpressionsMap(tweetIds, minNumImpressions)
tweetIdsFilteredByFavorites &lt;-</p>
<blockquote>
<div><p>getTweetIdsFilteredByFavorites(filteredImpressionsMap.keySet, tweetyPieResults, maxNumLikes)</p>
</div></blockquote>
</div></blockquote>
<dl>
<dt>} yield {</dt><dd><p>if (filteredImpressionsMap.nonEmpty) eligibleUsersAfterImpressionsFilter.incr()
if (tweetIdsFilteredByFavorites.nonEmpty) eligibleUsersAfterFavoritesFilter.incr()</p>
<dl class="simple">
<dt>val candidates = tweetIdsFilteredByFavorites.map { tweetId =&gt;</dt><dd><dl class="simple">
<dt>TweetImpressionsCandidate(</dt><dd><p>tweetId,
tweetyPieResults.get(tweetId),
filteredImpressionsMap.get(tweetId))</p>
</dd>
</dl>
</dd>
</dl>
<p>}
tweetImpressionsCandsStat.add(candidates.length)
candidates</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getFilteredImpressionsMap(</dt><dd><p>tweetIds: Seq[Long],
minNumImpressions: Long</p>
</dd>
<dt>): Future[Map[Long, Long]] = {</dt><dd><dl>
<dt>getImpressionsCounts(tweetIds).map { impressionsMap =&gt;</dt><dd><p>if (impressionsMap.isEmpty) emptyImpressionsMapCounter.incr()
impressionsMap.filter {</p>
<blockquote>
<div><dl>
<dt>case (_, numImpressions) =&gt;</dt><dd><p>val isValid = numImpressions &gt;= minNumImpressions
if (isValid) {</p>
<blockquote>
<div><p>meetsImpressionsRequiredCounter.incr()</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>belowImpressionsRequiredCounter.incr()</p>
</dd>
</dl>
<p>}
isValid</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getTweetIdsFilteredByFavorites(</dt><dd><p>filteredTweetIds: Set[Long],
tweetyPieResults: Map[Long, TweetyPieResult],
maxNumLikes: Long</p>
</dd>
<dt>): Future[Seq[Long]] = {</dt><dd><dl>
<dt>val filteredByFavoritesTweetIds = filteredTweetIds.filter { tweetId =&gt;</dt><dd><p>val tweetyPieResultOpt = tweetyPieResults.get(tweetId)
val isValid = tweetyPieResultOpt.exists { tweetyPieResult =&gt;</p>
<blockquote>
<div><p>getFavoriteCounts(tweetyPieResult) &lt;= maxNumLikes</p>
</div></blockquote>
<p>}
if (isValid) meetsFavoritesThresholdCounter.incr()
else aboveFavoritesThresholdCounter.incr()
isValid</p>
</dd>
</dl>
<p>}
Future(filteredByFavoritesTweetIds.toSeq)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getMostImpressionsTweet(</dt><dd><p>filteredResults: Seq[TweetImpressionsCandidate]</p>
</dd>
<dt>): TweetImpressionsCandidate = {</dt><dd><dl class="simple">
<dt>val maxImpressions: Long = filteredResults.map {</dt><dd><p>_.impressionsCountOpt.getOrElse(0L)</p>
</dd>
</dl>
<p>}.max</p>
<dl class="simple">
<dt>val mostImpressionsCandidates: Seq[TweetImpressionsCandidate] =</dt><dd><p>filteredResults.filter(_.impressionsCountOpt.getOrElse(0L) == maxImpressions)</p>
</dd>
</dl>
<p>mostImpressionsCandidates.maxBy(_.tweetId)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getImpressionsCounts(</dt><dd><p>tweetIds: Seq[Long]</p>
</dd>
<dt>): Future[Map[Long, Long]] = {</dt><dd><dl class="simple">
<dt>val impressionCountMap = tweetIds.map { tweetId =&gt;</dt><dd><dl class="simple">
<dt>tweetId -&gt; tweetImpressionsStore</dt><dd><p>.getCounts(tweetId).map(_.getOrElse(0L))</p>
</dd>
</dl>
</dd>
</dl>
<p>}.toMap
Future.collect(impressionCountMap)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def generateTopTweetImpressionsCandidate(</dt><dd><p>inputTarget: Target,
_tweetId: Long,
result: Option[TweetyPieResult],
_impressionsCount: Long</p>
</dd>
<dt>): RawCandidate = {</dt><dd><dl class="simple">
<dt>new RawCandidate with TopTweetImpressionsCandidate {</dt><dd><p>override val target: Target = inputTarget
override val tweetId: Long = _tweetId
override val tweetyPieResult: Option[TweetyPieResult] = result
override val impressionsCount: Long = _impressionsCount</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override def isCandidateSourceAvailable(target: Target): Future[Boolean] = {</dt><dd><dl class="simple">
<dt>val enabledTopTweetImpressionsNotification =</dt><dd><p>target.params(FS.EnableTopTweetImpressionsNotification)</p>
</dd>
<dt>PushDeviceUtil</dt><dd><p>.isRecommendationsEligible(target).map(_ &amp;&amp; enabledTopTweetImpressionsNotification)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/pushservice/src/main/scala/com/twitter/frigate/pushservice/adaptor/TopTweetImpressionsCandidateAdaptor.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>