<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../../" id="documentation_options" src="../../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.frigate.pushservice.model.candidate</p>
<p>import com.twitter.frigate.common.base.FeatureMap
import com.twitter.frigate.common.rec_types.RecTypes
import com.twitter.frigate.pushservice.model.PushTypes.PushCandidate
import com.twitter.frigate.pushservice.ml.HydrationContextBuilder
import com.twitter.frigate.pushservice.ml.PushMLModelScorer
import com.twitter.frigate.pushservice.params.PushFeatureSwitchParams
import com.twitter.frigate.pushservice.params.PushMLModel
import com.twitter.frigate.pushservice.params.WeightedOpenOrNtabClickModel
import com.twitter.nrel.hydration.push.HydrationContext
import com.twitter.timelines.configapi.FSParam
import com.twitter.util.Future
import java.util.concurrent.ConcurrentHashMap
import scala.collection.concurrent.{Map =&gt; CMap}
import scala.collection.convert.decorateAsScala._</p>
<p>trait MLScores {</p>
<blockquote>
<div><p>self: PushCandidate =&gt;</p>
<p>lazy val candidateHydrationContext: Future[HydrationContext] = HydrationContextBuilder.build(self)</p>
<p>def weightedOpenOrNtabClickModelScorer: PushMLModelScorer</p>
<p>// Used to store the scores and avoid duplicate prediction
private val qualityModelScores: CMap[</p>
<blockquote>
<div><p>(PushMLModel.Value, WeightedOpenOrNtabClickModel.ModelNameType),
Future[Option[Double]]</p>
</div></blockquote>
<dl>
<dt>] =</dt><dd><dl class="simple">
<dt>new ConcurrentHashMap[(PushMLModel.Value, WeightedOpenOrNtabClickModel.ModelNameType), Future[</dt><dd><p>Option[Double]</p>
</dd>
</dl>
<p>]]().asScala</p>
</dd>
<dt>def populateQualityModelScore(</dt><dd><p>pushMLModel: PushMLModel.Value,
modelVersion: WeightedOpenOrNtabClickModel.ModelNameType,
prob: Future[Option[Double]]</p>
</dd>
<dt>) = {</dt><dd><p>val modelAndVersion = (pushMLModel, modelVersion)
if (!qualityModelScores.contains(modelAndVersion)) {</p>
<blockquote>
<div><p>qualityModelScores += modelAndVersion -&gt; prob</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// The ML scores that also depend on other candidates and are only available after all candidates are processed
// For example, the likelihood info for Importance Sampling
private lazy val crossCandidateMlScores: CMap[String, Double] =</p>
<blockquote>
<div><p>new ConcurrentHashMap[String, Double]().asScala</p>
</div></blockquote>
<dl>
<dt>def populateCrossCandidateMlScores(scoreName: String, score: Double): Unit = {</dt><dd><dl>
<dt>if (crossCandidateMlScores.contains(scoreName)) {</dt><dd><dl class="simple">
<dt>throw new Exception(</dt><dd><dl class="simple">
<dt>s”$scoreName has been populated in the CrossCandidateMlScores!n” +</dt><dd><p>s”Existing crossCandidateMlScores are ${crossCandidateMlScores}n”</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}
crossCandidateMlScores += scoreName -&gt; score</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getMLModelScore(</dt><dd><p>pushMLModel: PushMLModel.Value,
modelVersion: WeightedOpenOrNtabClickModel.ModelNameType</p>
</dd>
<dt>): Future[Option[Double]] = {</dt><dd><dl>
<dt>qualityModelScores.getOrElseUpdate(</dt><dd><p>(pushMLModel, modelVersion),
weightedOpenOrNtabClickModelScorer</p>
<blockquote>
<div><p>.singlePredicationForModelVersion(modelVersion, self, Some(pushMLModel))</p>
</div></blockquote>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getMLModelScoreWithoutUpdate(</dt><dd><p>pushMLModel: PushMLModel.Value,
modelVersion: WeightedOpenOrNtabClickModel.ModelNameType</p>
</dd>
<dt>): Future[Option[Double]] = {</dt><dd><dl class="simple">
<dt>qualityModelScores.getOrElse(</dt><dd><p>(pushMLModel, modelVersion),
Future.None</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getWeightedOpenOrNtabClickModelScore(</dt><dd><p>weightedOONCModelParam: FSParam[WeightedOpenOrNtabClickModel.ModelNameType]</p>
</dd>
<dt>): Future[Option[Double]] = {</dt><dd><dl class="simple">
<dt>getMLModelScore(</dt><dd><p>PushMLModel.WeightedOpenOrNtabClickProbability,
target.params(weightedOONCModelParam)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/* After we unify the ranking and filtering models, we follow the iteration process below</dt><dd><blockquote>
<div><p>When improving the WeightedOONC model,
1) Run experiment which only replace the ranking model
2) Make decisions according to the experiment results
3) Use the ranking model for filtering
4) Adjust percentile thresholds if necessary</p>
</div></blockquote>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>lazy val mrWeightedOpenOrNtabClickRankingProbability: Future[Option[Double]] =</dt><dd><dl class="simple">
<dt>target.rankingModelParam.flatMap { modelParam =&gt;</dt><dd><p>getWeightedOpenOrNtabClickModelScore(modelParam)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>def getBigFilteringScore(</dt><dd><p>pushMLModel: PushMLModel.Value,
modelVersion: WeightedOpenOrNtabClickModel.ModelNameType</p>
</dd>
<dt>): Future[Option[Double]] = {</dt><dd><dl>
<dt>mrWeightedOpenOrNtabClickRankingProbability.flatMap {</dt><dd><dl>
<dt>case Some(rankingScore) =&gt;</dt><dd><p>// Adds ranking score to feature map (we must ensure the feature key is also in the feature context)
mergeFeatures(</p>
<blockquote>
<div><dl class="simple">
<dt>FeatureMap(</dt><dd><p>numericFeatures = Map(“scribe.WeightedOpenOrNtabClickProbability” -&gt; rankingScore)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>)
getMLModelScore(pushMLModel, modelVersion)</p>
</dd>
</dl>
<p>case _ =&gt; Future.None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getWeightedOpenOrNtabClickScoreForScribing(): Seq[Future[Map[String, Double]]] = {</dt><dd><dl>
<dt>Seq(</dt><dd><dl class="simple">
<dt>mrWeightedOpenOrNtabClickRankingProbability.map {</dt><dd><p>case Some(score) =&gt; Map(PushMLModel.WeightedOpenOrNtabClickProbability.toString -&gt; score)
case _ =&gt; Map.empty[String, Double]</p>
</dd>
</dl>
<p>},
Future</p>
<blockquote>
<div><dl>
<dt>.join(</dt><dd><p>target.rankingModelParam,
mrWeightedOpenOrNtabClickRankingProbability</p>
</dd>
<dt>).map {</dt><dd><dl class="simple">
<dt>case (rankingModelParam, Some(score)) =&gt;</dt><dd><p>Map(target.params(rankingModelParam).toString -&gt; score)</p>
</dd>
</dl>
<p>case _ =&gt; Map.empty[String, Double]</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getNsfwScoreForScribing(): Seq[Future[Map[String, Double]]] = {</dt><dd><dl class="simple">
<dt>val nsfwScoreFut = getMLModelScoreWithoutUpdate(</dt><dd><p>PushMLModel.HealthNsfwProbability,
target.params(PushFeatureSwitchParams.BqmlHealthModelTypeParam))</p>
</dd>
<dt>Seq(nsfwScoreFut.map { nsfwScoreOpt =&gt;</dt><dd><dl class="simple">
<dt>nsfwScoreOpt</dt><dd><dl class="simple">
<dt>.map(nsfwScore =&gt; Map(PushMLModel.HealthNsfwProbability.toString -&gt; nsfwScore)).getOrElse(</dt><dd><p>Map.empty[String, Double])</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>})</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getBigFilteringSupervisedScoresForScribing(): Seq[Future[Map[String, Double]]] = {</dt><dd><dl>
<dt>if (target.params(</dt><dd><blockquote>
<div><p>PushFeatureSwitchParams.EnableMrRequestScribingBigFilteringSupervisedScores)) {</p>
</div></blockquote>
<dl>
<dt>Seq(</dt><dd><dl>
<dt>mrBigFilteringSupervisedSendingScore.map {</dt><dd><dl class="simple">
<dt>case Some(score) =&gt;</dt><dd><p>Map(PushMLModel.BigFilteringSupervisedSendingModel.toString -&gt; score)</p>
</dd>
</dl>
<p>case _ =&gt; Map.empty[String, Double]</p>
</dd>
</dl>
<p>},
mrBigFilteringSupervisedWithoutSendingScore.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case Some(score) =&gt;</dt><dd><p>Map(PushMLModel.BigFilteringSupervisedWithoutSendingModel.toString -&gt; score)</p>
</dd>
</dl>
<p>case _ =&gt; Map.empty[String, Double]</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>} else Seq.empty[Future[Map[String, Double]]]</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getBigFilteringRLScoresForScribing(): Seq[Future[Map[String, Double]]] = {</dt><dd><dl>
<dt>if (target.params(PushFeatureSwitchParams.EnableMrRequestScribingBigFilteringRLScores)) {</dt><dd><dl>
<dt>Seq(</dt><dd><dl class="simple">
<dt>mrBigFilteringRLSendingScore.map {</dt><dd><p>case Some(score) =&gt; Map(PushMLModel.BigFilteringRLSendingModel.toString -&gt; score)
case _ =&gt; Map.empty[String, Double]</p>
</dd>
</dl>
<p>},
mrBigFilteringRLWithoutSendingScore.map {</p>
<blockquote>
<div><p>case Some(score) =&gt; Map(PushMLModel.BigFilteringRLWithoutSendingModel.toString -&gt; score)
case _ =&gt; Map.empty[String, Double]</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>} else Seq.empty[Future[Map[String, Double]]]</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def buildModelScoresSeqForScribing(): Seq[Future[Map[String, Double]]] = {</dt><dd><dl class="simple">
<dt>getWeightedOpenOrNtabClickScoreForScribing() ++</dt><dd><p>getBigFilteringSupervisedScoresForScribing() ++
getBigFilteringRLScoresForScribing() ++
getNsfwScoreForScribing()</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>lazy val mrBigFilteringSupervisedSendingScore: Future[Option[Double]] =</dt><dd><dl class="simple">
<dt>getBigFilteringScore(</dt><dd><p>PushMLModel.BigFilteringSupervisedSendingModel,
target.params(PushFeatureSwitchParams.BigFilteringSupervisedSendingModelParam)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>lazy val mrBigFilteringSupervisedWithoutSendingScore: Future[Option[Double]] =</dt><dd><dl class="simple">
<dt>getBigFilteringScore(</dt><dd><p>PushMLModel.BigFilteringSupervisedWithoutSendingModel,
target.params(PushFeatureSwitchParams.BigFilteringSupervisedWithoutSendingModelParam)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>lazy val mrBigFilteringRLSendingScore: Future[Option[Double]] =</dt><dd><dl class="simple">
<dt>getBigFilteringScore(</dt><dd><p>PushMLModel.BigFilteringRLSendingModel,
target.params(PushFeatureSwitchParams.BigFilteringRLSendingModelParam)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>lazy val mrBigFilteringRLWithoutSendingScore: Future[Option[Double]] =</dt><dd><dl class="simple">
<dt>getBigFilteringScore(</dt><dd><p>PushMLModel.BigFilteringRLWithoutSendingModel,
target.params(PushFeatureSwitchParams.BigFilteringRLWithoutSendingModelParam)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>lazy val mrWeightedOpenOrNtabClickFilteringProbability: Future[Option[Double]] =</dt><dd><dl class="simple">
<dt>getWeightedOpenOrNtabClickModelScore(</dt><dd><p>target.filteringModelParam</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>lazy val mrQualityUprankingProbability: Future[Option[Double]] =</dt><dd><dl class="simple">
<dt>getMLModelScore(</dt><dd><p>PushMLModel.FilteringProbability,
target.params(PushFeatureSwitchParams.QualityUprankingModelTypeParam)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>lazy val mrNsfwScore: Future[Option[Double]] =</dt><dd><dl class="simple">
<dt>getMLModelScoreWithoutUpdate(</dt><dd><p>PushMLModel.HealthNsfwProbability,
target.params(PushFeatureSwitchParams.BqmlHealthModelTypeParam)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>// MR quality upranking param
private val qualityUprankingBoost: String = “QualityUprankingBoost”
private val producerQualityUprankingBoost: String = “ProducerQualityUprankingBoost”
private val qualityUprankingInfo: CMap[String, Double] =</p>
<blockquote>
<div><p>new ConcurrentHashMap[String, Double]().asScala</p>
</div></blockquote>
<dl>
<dt>lazy val mrQualityUprankingBoost: Option[Double] =</dt><dd><p>qualityUprankingInfo.get(qualityUprankingBoost)</p>
</dd>
<dt>lazy val mrProducerQualityUprankingBoost: Option[Double] =</dt><dd><p>qualityUprankingInfo.get(producerQualityUprankingBoost)</p>
</dd>
<dt>def setQualityUprankingBoost(boost: Double) =</dt><dd><dl class="simple">
<dt>if (qualityUprankingInfo.contains(qualityUprankingBoost)) {</dt><dd><p>qualityUprankingInfo(qualityUprankingBoost) = boost</p>
</dd>
<dt>} else {</dt><dd><p>qualityUprankingInfo += qualityUprankingBoost -&gt; boost</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>def setProducerQualityUprankingBoost(boost: Double) =</dt><dd><dl class="simple">
<dt>if (qualityUprankingInfo.contains(producerQualityUprankingBoost)) {</dt><dd><p>qualityUprankingInfo(producerQualityUprankingBoost) = boost</p>
</dd>
<dt>} else {</dt><dd><p>qualityUprankingInfo += producerQualityUprankingBoost -&gt; boost</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>private lazy val mrModelScoresFut: Future[Map[String, Double]] = {</dt><dd><dl>
<dt>if (self.target.isLoggedOutUser) {</dt><dd><p>Future.value(Map.empty[String, Double])</p>
</dd>
<dt>} else {</dt><dd><dl>
<dt>Future</dt><dd><dl>
<dt>.collectToTry {</dt><dd><p>buildModelScoresSeqForScribing()</p>
</dd>
<dt>}.map { scoreTrySeq =&gt;</dt><dd><dl>
<dt>scoreTrySeq</dt><dd><dl class="simple">
<dt>.collect {</dt><dd><p>case result if result.isReturn =&gt; result.get()</p>
</dd>
</dl>
<p>}.reduce(_ ++ _)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// Internal model scores (scores that are independent of other candidates) for scribing
lazy val modelScores: Future[Map[String, Double]] =</p>
<blockquote>
<div><dl>
<dt>target.dauProbability.flatMap { dauProbabilityOpt =&gt;</dt><dd><dl>
<dt>val dauProbScoreMap = dauProbabilityOpt</dt><dd><dl class="simple">
<dt>.map(_.probability).map { dauProb =&gt;</dt><dd><p>PushMLModel.DauProbability.toString -&gt; dauProb</p>
</dd>
</dl>
<p>}.toMap</p>
</dd>
</dl>
<p>// Avoid unnecessary MR model scribing
if (target.isDarkWrite) {</p>
<blockquote>
<div><p>mrModelScoresFut.map(dauProbScoreMap ++ _)</p>
</div></blockquote>
<dl>
<dt>} else if (RecTypes.isSendHandlerType(commonRecType) &amp;&amp; !RecTypes</dt><dd><blockquote>
<div><p>.sendHandlerTypesUsingMrModel(commonRecType)) {</p>
</div></blockquote>
<p>Future.value(dauProbScoreMap)</p>
</dd>
<dt>} else {</dt><dd><p>mrModelScoresFut.map(dauProbScoreMap ++ _)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>// We will scribe both internal ML scores and cross-Candidate scores
def getModelScoresforScribing(): Future[Map[String, Double]] = {</p>
<blockquote>
<div><dl>
<dt>if (RecTypes.notEligibleForModelScoreTracking(commonRecType) || self.target.isLoggedOutUser) {</dt><dd><p>Future.value(Map.empty[String, Double])</p>
</dd>
<dt>} else {</dt><dd><dl>
<dt>modelScores.map { internalScores =&gt;</dt><dd><dl>
<dt>if (internalScores.keySet.intersect(crossCandidateMlScores.keySet).nonEmpty) {</dt><dd><dl class="simple">
<dt>throw new Exception(</dt><dd><dl class="simple">
<dt>“crossCandidateMlScores overlap internalModelScoresn” +</dt><dd><p>s”internalScores keySet: ${internalScores.keySet}n” +
s”crossCandidateScores keySet: ${crossCandidateMlScores.keySet}n”</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<p>internalScores ++ crossCandidateMlScores</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../../_sources/pushservice/src/main/scala/com/twitter/frigate/pushservice/model/candidate/MLScores.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>