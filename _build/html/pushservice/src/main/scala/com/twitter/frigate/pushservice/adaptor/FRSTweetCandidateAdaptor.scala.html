<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.frigate.pushservice.adaptor</p>
<p>import com.twitter.cr_mixer.thriftscala.FrsTweetRequest
import com.twitter.cr_mixer.thriftscala.NotificationsContext
import com.twitter.cr_mixer.thriftscala.Product
import com.twitter.cr_mixer.thriftscala.ProductContext
import com.twitter.finagle.stats.Counter
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.frigate.common.base.CandidateSource
import com.twitter.frigate.common.base.CandidateSourceEligible
import com.twitter.frigate.common.base._
import com.twitter.frigate.common.predicate.CommonOutNetworkTweetCandidatesSourcePredicates.filterOutReplyTweet
import com.twitter.frigate.pushservice.model.PushTypes.RawCandidate
import com.twitter.frigate.pushservice.model.PushTypes.Target
import com.twitter.frigate.pushservice.params.PushFeatureSwitchParams
import com.twitter.frigate.pushservice.store.CrMixerTweetStore
import com.twitter.frigate.pushservice.store.UttEntityHydrationStore
import com.twitter.frigate.pushservice.util.MediaCRT
import com.twitter.frigate.pushservice.util.PushAdaptorUtil
import com.twitter.frigate.pushservice.util.PushDeviceUtil
import com.twitter.frigate.pushservice.util.TopicsUtil
import com.twitter.frigate.thriftscala.CommonRecommendationType
import com.twitter.hermit.constants.AlgorithmFeedbackTokens
import com.twitter.hermit.model.Algorithm.Algorithm
import com.twitter.hermit.model.Algorithm.CrowdSearchAccounts
import com.twitter.hermit.model.Algorithm.ForwardEmailBook
import com.twitter.hermit.model.Algorithm.ForwardPhoneBook
import com.twitter.hermit.model.Algorithm.ReverseEmailBookIbis
import com.twitter.hermit.model.Algorithm.ReversePhoneBook
import com.twitter.hermit.store.tweetypie.UserTweet
import com.twitter.product_mixer.core.thriftscala.ClientContext
import com.twitter.stitch.tweetypie.TweetyPie.TweetyPieResult
import com.twitter.storehaus.ReadableStore
import com.twitter.tsp.thriftscala.TopicSocialProofRequest
import com.twitter.tsp.thriftscala.TopicSocialProofResponse
import com.twitter.util.Future</p>
<dl>
<dt>object FRSAlgorithmFeedbackTokenUtil {</dt><dd><dl class="simple">
<dt>private val crtsByAlgoToken = Map(</dt><dd><p>getAlgorithmToken(ReverseEmailBookIbis) -&gt; CommonRecommendationType.ReverseAddressbookTweet,
getAlgorithmToken(ReversePhoneBook) -&gt; CommonRecommendationType.ReverseAddressbookTweet,
getAlgorithmToken(ForwardEmailBook) -&gt; CommonRecommendationType.ForwardAddressbookTweet,
getAlgorithmToken(ForwardPhoneBook) -&gt; CommonRecommendationType.ForwardAddressbookTweet,
getAlgorithmToken(CrowdSearchAccounts) -&gt; CommonRecommendationType.CrowdSearchTweet</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>def getAlgorithmToken(algorithm: Algorithm): Int = {</dt><dd><p>AlgorithmFeedbackTokens.AlgorithmToFeedbackTokenMap(algorithm)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def getCRTForAlgoToken(algorithmToken: Int): Option[CommonRecommendationType] = {</dt><dd><p>crtsByAlgoToken.get(algorithmToken)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class FRSTweetCandidateAdaptor(</dt><dd><p>crMixerTweetStore: CrMixerTweetStore,
tweetyPieStore: ReadableStore[Long, TweetyPieResult],
tweetyPieStoreNoVF: ReadableStore[Long, TweetyPieResult],
userTweetTweetyPieStore: ReadableStore[UserTweet, TweetyPieResult],
uttEntityHydrationStore: UttEntityHydrationStore,
topicSocialProofServiceStore: ReadableStore[TopicSocialProofRequest, TopicSocialProofResponse],
globalStats: StatsReceiver)</p>
<blockquote>
<div><p>extends CandidateSource[Target, RawCandidate]
with CandidateSourceEligible[Target, RawCandidate] {</p>
</div></blockquote>
<p>private val stats = globalStats.scope(this.getClass.getSimpleName)
private val crtStats = stats.scope(“CandidateDistribution”)
private val totalRequests = stats.counter(“total_requests”)</p>
<p>// Candidate Distribution stats
private val reverseAddressbookCounter = crtStats.counter(“reverse_addressbook”)
private val forwardAddressbookCounter = crtStats.counter(“forward_addressbook”)
private val frsTweetCounter = crtStats.counter(“frs_tweet”)
private val nonReplyTweetsCounter = stats.counter(“non_reply_tweets”)
private val crtToCounterMapping: Map[CommonRecommendationType, Counter] = Map(</p>
<blockquote>
<div><p>CommonRecommendationType.ReverseAddressbookTweet -&gt; reverseAddressbookCounter,
CommonRecommendationType.ForwardAddressbookTweet -&gt; forwardAddressbookCounter,
CommonRecommendationType.FrsTweet -&gt; frsTweetCounter</p>
</div></blockquote>
<p>)</p>
<p>private val emptyTweetyPieResult = stats.stat(“empty_tweetypie_result”)</p>
<p>private[this] val numberReturnedCandidates = stats.stat(“returned_candidates_from_earlybird”)
private[this] val numberCandidateWithTopic: Counter = stats.counter(“num_can_with_topic”)
private[this] val numberCandidateWithoutTopic: Counter = stats.counter(“num_can_without_topic”)</p>
<p>private val userTweetTweetyPieStoreCounter = stats.counter(“user_tweet_tweetypie_store”)</p>
<p>override val name: String = this.getClass.getSimpleName</p>
<dl>
<dt>private def filterInvalidTweets(</dt><dd><p>tweetIds: Seq[Long],
target: Target</p>
</dd>
<dt>): Future[Map[Long, TweetyPieResult]] = {</dt><dd><dl>
<dt>val resMap = {</dt><dd><dl>
<dt>if (target.params(PushFeatureSwitchParams.EnableF1FromProtectedTweetAuthors)) {</dt><dd><p>userTweetTweetyPieStoreCounter.incr()
val keys = tweetIds.map { tweetId =&gt;</p>
<blockquote>
<div><p>UserTweet(tweetId, Some(target.targetId))</p>
</div></blockquote>
<p>}
userTweetTweetyPieStore</p>
<blockquote>
<div><dl class="simple">
<dt>.multiGet(keys.toSet).map {</dt><dd><dl class="simple">
<dt>case (userTweet, resultFut) =&gt;</dt><dd><p>userTweet.tweetId -&gt; resultFut</p>
</dd>
</dl>
</dd>
</dl>
<p>}.toMap</p>
</div></blockquote>
</dd>
<dt>} else {</dt><dd><dl>
<dt>(if (target.params(PushFeatureSwitchParams.EnableVFInTweetypie)) {</dt><dd><blockquote>
<div><p>tweetyPieStore</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>tweetyPieStoreNoVF</p>
</dd>
</dl>
<p>}).multiGet(tweetIds.toSet)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>Future.collect(resMap).map { tweetyPieResultMap =&gt;</dt><dd><p>// Filter out replies and generate earlybird candidates only for non-empty tweetypie result
val cands = filterOutReplyTweet(tweetyPieResultMap, nonReplyTweetsCounter).collect {</p>
<blockquote>
<div><dl class="simple">
<dt>case (id: Long, Some(result)) =&gt;</dt><dd><p>id -&gt; result</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>emptyTweetyPieResult.add(tweetyPieResultMap.size - cands.size)
cands</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private def buildRawCandidates(</dt><dd><p>target: Target,
ebCandidates: Seq[FRSTweetCandidate]</p>
</dd>
</dl>
<p>): Future[Option[Seq[RawCandidate with TweetCandidate]]] = {</p>
<blockquote>
<div><p>val enableTopic = target.params(PushFeatureSwitchParams.EnableFrsTweetCandidatesTopicAnnotation)
val topicScoreThre =</p>
<blockquote>
<div><p>target.params(PushFeatureSwitchParams.FrsTweetCandidatesTopicScoreThreshold)</p>
</div></blockquote>
<dl class="simple">
<dt>val ebTweets = ebCandidates.map { ebCandidate =&gt;</dt><dd><p>ebCandidate.tweetId -&gt; ebCandidate.tweetyPieResult</p>
</dd>
</dl>
<p>}.toMap</p>
<dl class="simple">
<dt>val tweetIdLocalizedEntityMapFut = TopicsUtil.getTweetIdLocalizedEntityMap(</dt><dd><p>target,
ebTweets,
uttEntityHydrationStore,
topicSocialProofServiceStore,
enableTopic,
topicScoreThre</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>Future.join(target.deviceInfo, tweetIdLocalizedEntityMapFut).map {</dt><dd><dl>
<dt>case (Some(deviceInfo), tweetIdLocalizedEntityMap) =&gt;</dt><dd><dl>
<dt>val candidates = ebCandidates</dt><dd><dl>
<dt>.map { ebCandidate =&gt;</dt><dd><p>val crt = ebCandidate.commonRecType
crtToCounterMapping.get(crt).foreach(_.incr())</p>
<p>val tweetId = ebCandidate.tweetId
val localizedEntityOpt = {</p>
<blockquote>
<div><dl>
<dt>if (tweetIdLocalizedEntityMap</dt><dd><blockquote>
<div><p>.contains(tweetId) &amp;&amp; tweetIdLocalizedEntityMap.contains(
tweetId) &amp;&amp; deviceInfo.isTopicsEligible) {</p>
</div></blockquote>
<p>tweetIdLocalizedEntityMap(tweetId)</p>
</dd>
<dt>} else {</dt><dd><p>None</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>PushAdaptorUtil.generateOutOfNetworkTweetCandidates(</dt><dd><p>inputTarget = target,
id = ebCandidate.tweetId,
mediaCRT = MediaCRT(</p>
<blockquote>
<div><p>crt,
crt,
crt</p>
</div></blockquote>
<p>),
result = ebCandidate.tweetyPieResult,
localizedEntity = localizedEntityOpt)</p>
</dd>
</dl>
</dd>
<dt>}.filter { candidate =&gt;</dt><dd><p>// If user only has the topic setting enabled, filter out all non-topic cands
deviceInfo.isRecommendationsEligible || (deviceInfo.isTopicsEligible &amp;&amp; candidate.semanticCoreEntityId.nonEmpty)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>candidates.map { candidate =&gt;</dt><dd><dl class="simple">
<dt>if (candidate.semanticCoreEntityId.nonEmpty) {</dt><dd><p>numberCandidateWithTopic.incr()</p>
</dd>
<dt>} else {</dt><dd><p>numberCandidateWithoutTopic.incr()</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>numberReturnedCandidates.add(candidates.length)
Some(candidates)</p>
</dd>
</dl>
<p>case _ =&gt; Some(Seq.empty)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>def getTweetCandidatesFromCrMixer(</dt><dd><p>inputTarget: Target,
showAllResultsFromFrs: Boolean,</p>
</dd>
<dt>): Future[Option[Seq[RawCandidate with TweetCandidate]]] = {</dt><dd><dl>
<dt>Future</dt><dd><dl>
<dt>.join(</dt><dd><p>inputTarget.seenTweetIds,
inputTarget.pushRecItems,
inputTarget.countryCode,
inputTarget.targetLanguage).flatMap {
case (seenTweetIds, pastRecItems, countryCode, language) =&gt;</p>
<blockquote>
<div><p>val pastUserRecs = pastRecItems.userIds.toSeq
val request = FrsTweetRequest(</p>
<blockquote>
<div><dl class="simple">
<dt>clientContext = ClientContext(</dt><dd><p>userId = Some(inputTarget.targetId),
countryCode = countryCode,
languageCode = language</p>
</dd>
</dl>
<p>),
product = Product.Notifications,
productContext = Some(ProductContext.NotificationsContext(NotificationsContext())),
excludedUserIds = Some(pastUserRecs),
excludedTweetIds = Some(seenTweetIds)</p>
</div></blockquote>
<p>)
crMixerTweetStore.getFRSTweetCandidates(request).flatMap {</p>
<blockquote>
<div><dl>
<dt>case Some(response) =&gt;</dt><dd><p>val tweetIds = response.tweets.map(_.tweetId)
val validTweets = filterInvalidTweets(tweetIds, inputTarget)
validTweets.flatMap { tweetypieMap =&gt;</p>
<blockquote>
<div><dl>
<dt>val ebCandidates = response.tweets</dt><dd><dl>
<dt>.map { frsTweet =&gt;</dt><dd><p>val candidateTweetId = frsTweet.tweetId
val resultFromTweetyPie = tweetypieMap.get(candidateTweetId)
new FRSTweetCandidate {</p>
<blockquote>
<div><p>override val tweetId = candidateTweetId
override val features = None
override val tweetyPieResult = resultFromTweetyPie
override val feedbackToken = frsTweet.frsPrimarySource
override val commonRecType: CommonRecommendationType = feedbackToken</p>
<blockquote>
<div><dl class="simple">
<dt>.flatMap(token =&gt;</dt><dd><p>FRSAlgorithmFeedbackTokenUtil.getCRTForAlgoToken(token)).getOrElse(
CommonRecommendationType.FrsTweet)</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>}</p>
</dd>
<dt>}.filter { ebCandidate =&gt;</dt><dd><p>showAllResultsFromFrs || ebCandidate.commonRecType == CommonRecommendationType.ReverseAddressbookTweet</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>numberReturnedCandidates.add(ebCandidates.length)
buildRawCandidates(</p>
<blockquote>
<div><p>inputTarget,
ebCandidates</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>case _ =&gt; Future.None</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def get(inputTarget: Target): Future[Option[Seq[RawCandidate with TweetCandidate]]] = {</dt><dd><p>totalRequests.incr()
val enableResultsFromFrs =</p>
<blockquote>
<div><p>inputTarget.params(PushFeatureSwitchParams.EnableResultFromFrsCandidates)</p>
</div></blockquote>
<p>getTweetCandidatesFromCrMixer(inputTarget, enableResultsFromFrs)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def isCandidateSourceAvailable(target: Target): Future[Boolean] = {</dt><dd><p>lazy val enableFrsCandidates = target.params(PushFeatureSwitchParams.EnableFrsCandidates)
PushDeviceUtil.isRecommendationsEligible(target).flatMap { isEnabledForRecosSetting =&gt;</p>
<blockquote>
<div><dl>
<dt>PushDeviceUtil.isTopicsEligible(target).map { topicSettingEnabled =&gt;</dt><dd><dl class="simple">
<dt>val isEnabledForTopics =</dt><dd><dl class="simple">
<dt>topicSettingEnabled &amp;&amp; target.params(</dt><dd><p>PushFeatureSwitchParams.EnableFrsTweetCandidatesTopicSetting)</p>
</dd>
</dl>
</dd>
</dl>
<p>(isEnabledForRecosSetting || isEnabledForTopics) &amp;&amp; enableFrsCandidates</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/pushservice/src/main/scala/com/twitter/frigate/pushservice/adaptor/FRSTweetCandidateAdaptor.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>