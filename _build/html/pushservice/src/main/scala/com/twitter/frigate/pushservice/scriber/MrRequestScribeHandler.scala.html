<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.frigate.pushservice.scriber</p>
<p>import com.twitter.bijection.Base64String
import com.twitter.bijection.Injection
import com.twitter.bijection.scrooge.BinaryScalaCodec
import com.twitter.core_workflows.user_model.thriftscala.{UserState =&gt; ThriftUserState}
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.finagle.tracing.Trace
import com.twitter.frigate.common.base.CandidateDetails
import com.twitter.frigate.common.base.CandidateResult
import com.twitter.frigate.common.base.Invalid
import com.twitter.frigate.common.base.OK
import com.twitter.frigate.common.base.Result
import com.twitter.frigate.common.rec_types.RecTypes
import com.twitter.frigate.data_pipeline.features_common.PushQualityModelFeatureContext
import com.twitter.frigate.pushservice.model.PushTypes.PushCandidate
import com.twitter.frigate.pushservice.model.PushTypes.Target
import com.twitter.frigate.pushservice.params.PushFeatureSwitchParams
import com.twitter.frigate.pushservice.params.PushParams
import com.twitter.frigate.scribe.thriftscala.CandidateFilteredOutStep
import com.twitter.frigate.scribe.thriftscala.CandidateRequestInfo
import com.twitter.frigate.scribe.thriftscala.MrRequestScribe
import com.twitter.frigate.scribe.thriftscala.TargetUserInfo
import com.twitter.frigate.thriftscala.FrigateNotification
import com.twitter.frigate.thriftscala.TweetNotification
import com.twitter.frigate.thriftscala.{SocialContextAction =&gt; TSocialContextAction}
import com.twitter.logging.Logger
import com.twitter.ml.api.DataRecord
import com.twitter.ml.api.Feature
import com.twitter.ml.api.FeatureType
import com.twitter.ml.api.util.SRichDataRecord
import com.twitter.ml.api.util.ScalaToJavaDataRecordConversions
import com.twitter.nrel.heavyranker.PushPredictionHelper
import com.twitter.util.Future
import com.twitter.util.Time
import java.util.UUID
import scala.collection.mutable</p>
<p>class MrRequestScribeHandler(mrRequestScriberNode: String, stats: StatsReceiver) {</p>
<blockquote>
<div><p>private val mrRequestScribeLogger = Logger(mrRequestScriberNode)</p>
<dl class="simple">
<dt>private val mrRequestScribeTargetFilteringStats =</dt><dd><p>stats.counter(“MrRequestScribeHandler_target_filtering”)</p>
</dd>
<dt>private val mrRequestScribeCandidateFilteringStats =</dt><dd><p>stats.counter(“MrRequestScribeHandler_candidate_filtering”)</p>
</dd>
<dt>private val mrRequestScribeInvalidStats =</dt><dd><p>stats.counter(“MrRequestScribeHandler_invalid_filtering”)</p>
</dd>
<dt>private val mrRequestScribeUnsupportedFeatureTypeStats =</dt><dd><p>stats.counter(“MrRequestScribeHandler_unsupported_feature_type”)</p>
</dd>
<dt>private val mrRequestScribeNotIncludedFeatureStats =</dt><dd><p>stats.counter(“MrRequestScribeHandler_not_included_features”)</p>
</dd>
<dt>private final val MrRequestScribeInjection: Injection[MrRequestScribe, String] = BinaryScalaCodec(</dt><dd><p>MrRequestScribe</p>
</dd>
</dl>
<p>) andThen Injection.connect[Array[Byte], Base64String, String]</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li></li>
<li><p>&#64;param target : Target user id</p></li>
<li><p>&#64;param result : Result for target filtering</p></li>
<li></li>
<li><p>&#64;return</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>def scribeForTargetFiltering(target: Target, result: Result): Future[Option[MrRequestScribe]] = {</dt><dd><dl>
<dt>if (target.isLoggedOutUser || !enableTargetFilteringScribing(target)) {</dt><dd><p>Future.None</p>
</dd>
<dt>} else {</dt><dd><dl>
<dt>val predicate = result match {</dt><dd><p>case Invalid(reason) =&gt; reason
case _ =&gt;</p>
<blockquote>
<div><p>mrRequestScribeInvalidStats.incr()
throw new IllegalStateException(“Invalid reason for Target Filtering “ + result)</p>
</div></blockquote>
</dd>
</dl>
<p>}
buildScribeThrift(target, predicate, None).map { targetFilteredScribe =&gt;</p>
<blockquote>
<div><p>writeAtTargetFilteringStep(target, targetFilteredScribe)
Some(targetFilteredScribe)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li></li>
<li><p>&#64;param target                       : Target user id</p></li>
<li><p>&#64;param hydratedCandidates           : Candidates hydrated with details: impressionId, frigateNotification and source</p></li>
<li><p>&#64;param preRankingFilteredCandidates : Candidates result filtered out at preRanking filtering step</p></li>
<li><p>&#64;param rankedCandidates             : Sorted candidates details ranked by ranking step</p></li>
<li><p>&#64;param rerankedCandidates           : Sorted candidates details ranked by reranking step</p></li>
<li><p>&#64;param restrictFilteredCandidates   : Candidates details filtered out at restrict step</p></li>
<li><p>&#64;param allTakeCandidateResults      : Candidates results at take step, include the candidates we take and the candidates filtered out at take step [with different result]</p></li>
<li></li>
<li><p>&#64;return</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>def scribeForCandidateFiltering(</dt><dd><p>target: Target,
hydratedCandidates: Seq[CandidateDetails[PushCandidate]],
preRankingFilteredCandidates: Seq[CandidateResult[PushCandidate, Result]],
rankedCandidates: Seq[CandidateDetails[PushCandidate]],
rerankedCandidates: Seq[CandidateDetails[PushCandidate]],
restrictFilteredCandidates: Seq[CandidateDetails[PushCandidate]],
allTakeCandidateResults: Seq[CandidateResult[PushCandidate, Result]]</p>
</dd>
<dt>): Future[Seq[MrRequestScribe]] = {</dt><dd><dl>
<dt>if (target.isLoggedOutUser || target.isEmailUser) {</dt><dd><p>Future.Nil</p>
</dd>
<dt>} else if (enableCandidateFilteringScribing(target)) {</dt><dd><dl class="simple">
<dt>val hydrateFeature =</dt><dd><dl class="simple">
<dt>target.params(PushFeatureSwitchParams.EnableMrRequestScribingWithFeatureHydrating) ||</dt><dd><p>target.scribeFeatureForRequestScribe</p>
</dd>
</dl>
</dd>
<dt>val candidateRequestInfoSeq = generateCandidatesScribeInfo(</dt><dd><p>hydratedCandidates,
preRankingFilteredCandidates,
rankedCandidates,
rerankedCandidates,
restrictFilteredCandidates,
allTakeCandidateResults,
isFeatureHydratingEnabled = hydrateFeature</p>
</dd>
</dl>
<p>)
val flattenStructure =</p>
<blockquote>
<div><p>target.params(PushFeatureSwitchParams.EnableFlattenMrRequestScribing) || hydrateFeature</p>
</div></blockquote>
<dl>
<dt>candidateRequestInfoSeq.flatMap { candidateRequestInfos =&gt;</dt><dd><dl>
<dt>if (flattenStructure) {</dt><dd><dl>
<dt>Future.collect {</dt><dd><dl>
<dt>candidateRequestInfos.map { candidateRequestInfo =&gt;</dt><dd><dl>
<dt>buildScribeThrift(target, None, Some(Seq(candidateRequestInfo)))</dt><dd><dl class="simple">
<dt>.map { mrRequestScribe =&gt;</dt><dd><p>writeAtCandidateFilteringStep(target, mrRequestScribe)
mrRequestScribe</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><dl>
<dt>buildScribeThrift(target, None, Some(candidateRequestInfos))</dt><dd><dl class="simple">
<dt>.map { mrRequestScribe =&gt;</dt><dd><p>writeAtCandidateFilteringStep(target, mrRequestScribe)
Seq(mrRequestScribe)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>} else Future.Nil</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def buildScribeThrift(</dt><dd><p>target: Target,
targetFilteredOutPredicate: Option[String],
candidatesRequestInfo: Option[Seq[CandidateRequestInfo]]</p>
</dd>
<dt>): Future[MrRequestScribe] = {</dt><dd><dl>
<dt>Future</dt><dd><dl>
<dt>.join(</dt><dd><p>target.targetUserState,
generateTargetFeatureScribeInfo(target),
target.targetUser).map {
case (userStateOption, targetFeatureOption, gizmoduckUserOpt) =&gt;</p>
<blockquote>
<div><p>val userState = userStateOption.map(userState =&gt; ThriftUserState(userState.id))
val targetFeatures =</p>
<blockquote>
<div><p>targetFeatureOption.map(ScalaToJavaDataRecordConversions.javaDataRecord2ScalaDataRecord)</p>
</div></blockquote>
<p>val traceId = Trace.id.traceId.toLong</p>
<dl>
<dt>MrRequestScribe(</dt><dd><p>requestId = UUID.randomUUID.toString.replaceAll(“-”, “”),
scribedTimeMs = Time.now.inMilliseconds,
targetUserId = target.targetId,
targetUserInfo = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>TargetUserInfo(</dt><dd><p>userState,
features = targetFeatures,
userType = gizmoduckUserOpt.map(_.userType))</p>
</dd>
</dl>
</div></blockquote>
<p>),
targetFilteredOutPredicate = targetFilteredOutPredicate,
candidates = candidatesRequestInfo,
traceId = Some(traceId)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def generateTargetFeatureScribeInfo(</dt><dd><p>target: Target</p>
</dd>
<dt>): Future[Option[DataRecord]] = {</dt><dd><dl>
<dt>val featureList =</dt><dd><p>target.params(PushFeatureSwitchParams.TargetLevelFeatureListForMrRequestScribing)</p>
</dd>
<dt>if (featureList.nonEmpty) {</dt><dd><dl>
<dt>PushPredictionHelper</dt><dd><dl>
<dt>.getDataRecordFromTargetFeatureMap(</dt><dd><p>target.targetId,
target.featureMap,
stats</p>
</dd>
<dt>).map { dataRecord =&gt;</dt><dd><dl>
<dt>val richRecord =</dt><dd><p>new SRichDataRecord(dataRecord, PushQualityModelFeatureContext.featureContext)</p>
</dd>
<dt>val selectedRecord =</dt><dd><p>SRichDataRecord(new DataRecord(), PushQualityModelFeatureContext.featureContext)</p>
</dd>
<dt>featureList.map { featureName =&gt;</dt><dd><dl>
<dt>val feature: Feature[_] = {</dt><dd><dl>
<dt>try {</dt><dd><p>PushQualityModelFeatureContext.featureContext.getFeature(featureName)</p>
</dd>
<dt>} catch {</dt><dd><dl>
<dt>case _: Exception =&gt;</dt><dd><p>mrRequestScribeNotIncludedFeatureStats.incr()
throw new IllegalStateException(</p>
<blockquote>
<div><p>“Scribing features not included in FeatureContext: “ + featureName)</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>richRecord.getFeatureValueOpt(feature).foreach { featureVal =&gt;</dt><dd><dl class="simple">
<dt>feature.getFeatureType() match {</dt><dd><dl class="simple">
<dt>case FeatureType.BINARY =&gt;</dt><dd><dl class="simple">
<dt>selectedRecord.setFeatureValue(</dt><dd><p>feature.asInstanceOf[Feature[Boolean]],
featureVal.asInstanceOf[Boolean])</p>
</dd>
</dl>
</dd>
<dt>case FeatureType.CONTINUOUS =&gt;</dt><dd><dl class="simple">
<dt>selectedRecord.setFeatureValue(</dt><dd><p>feature.asInstanceOf[Feature[Double]],
featureVal.asInstanceOf[Double])</p>
</dd>
</dl>
</dd>
<dt>case FeatureType.STRING =&gt;</dt><dd><dl class="simple">
<dt>selectedRecord.setFeatureValue(</dt><dd><p>feature.asInstanceOf[Feature[String]],
featureVal.asInstanceOf[String])</p>
</dd>
</dl>
</dd>
<dt>case FeatureType.DISCRETE =&gt;</dt><dd><dl class="simple">
<dt>selectedRecord.setFeatureValue(</dt><dd><p>feature.asInstanceOf[Feature[Long]],
featureVal.asInstanceOf[Long])</p>
</dd>
</dl>
</dd>
<dt>case _ =&gt;</dt><dd><p>mrRequestScribeUnsupportedFeatureTypeStats.incr()</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
Some(selectedRecord.getRecord)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>} else Future.None</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def generateCandidatesScribeInfo(</dt><dd><p>hydratedCandidates: Seq[CandidateDetails[PushCandidate]],
preRankingFilteredCandidates: Seq[CandidateResult[PushCandidate, Result]],
rankedCandidates: Seq[CandidateDetails[PushCandidate]],
rerankedCandidates: Seq[CandidateDetails[PushCandidate]],
restrictFilteredCandidates: Seq[CandidateDetails[PushCandidate]],
allTakeCandidateResults: Seq[CandidateResult[PushCandidate, Result]],
isFeatureHydratingEnabled: Boolean</p>
</dd>
<dt>): Future[Seq[CandidateRequestInfo]] = {</dt><dd><p>val candidatesMap = new mutable.HashMap[String, CandidateRequestInfo]</p>
<dl>
<dt>hydratedCandidates.foreach { hydratedCandidate =&gt;</dt><dd><p>val frgNotif = hydratedCandidate.candidate.frigateNotification
val simplifiedTweetNotificationOpt = frgNotif.tweetNotification.map { tweetNotification =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>TweetNotification(</dt><dd><p>tweetNotification.tweetId,
Seq.empty[TSocialContextAction],
tweetNotification.tweetAuthorId)</p>
</dd>
</dl>
</div></blockquote>
<p>}
val simplifiedFrigateNotification = FrigateNotification(</p>
<blockquote>
<div><p>frgNotif.commonRecommendationType,
frgNotif.notificationDisplayLocation,
tweetNotification = simplifiedTweetNotificationOpt</p>
</div></blockquote>
<p>)
candidatesMap(hydratedCandidate.candidate.impressionId) = CandidateRequestInfo(</p>
<blockquote>
<div><p>candidateId = “”,
candidateSource = hydratedCandidate.source.substring(</p>
<blockquote>
<div><p>0,
Math.min(6, hydratedCandidate.source.length)</p>
</div></blockquote>
<p>),
frigateNotification = Some(simplifiedFrigateNotification),
modelScore = None,
rankPosition = None,
rerankPosition = None,
features = None,
isSent = Some(false)</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>preRankingFilteredCandidates.foreach { preRankingFilteredCandidateResult =&gt;</dt><dd><dl>
<dt>candidatesMap(preRankingFilteredCandidateResult.candidate.impressionId) =</dt><dd><dl>
<dt>candidatesMap(preRankingFilteredCandidateResult.candidate.impressionId)</dt><dd><dl>
<dt>.copy(</dt><dd><dl>
<dt>candidateFilteredOutPredicate = preRankingFilteredCandidateResult.result match {</dt><dd><p>case Invalid(reason) =&gt; reason
case _ =&gt; {</p>
<blockquote>
<div><p>mrRequestScribeInvalidStats.incr()
throw new IllegalStateException(</p>
<blockquote>
<div><p>“Invalid reason for Candidate Filtering “ + preRankingFilteredCandidateResult.result)</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>},
candidateFilteredOutStep = Some(CandidateFilteredOutStep.PreRankFiltering)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>for {</dt><dd><dl>
<dt>_ &lt;- Future.collectToTry {</dt><dd><dl>
<dt>rankedCandidates.zipWithIndex.map {</dt><dd><dl>
<dt>case (rankedCandidateDetail, index) =&gt;</dt><dd><dl class="simple">
<dt>val modelScoresFut = {</dt><dd><p>val crt = rankedCandidateDetail.candidate.commonRecType
if (RecTypes.notEligibleForModelScoreTracking.contains(crt)) Future.None
else rankedCandidateDetail.candidate.modelScores.map(Some(_))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>modelScoresFut.map { modelScores =&gt;</dt><dd><dl>
<dt>candidatesMap(rankedCandidateDetail.candidate.impressionId) =</dt><dd><dl class="simple">
<dt>candidatesMap(rankedCandidateDetail.candidate.impressionId).copy(</dt><dd><p>rankPosition = Some(index),
modelScore = modelScores</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>_ = rerankedCandidates.zipWithIndex.foreach {</dt><dd><dl>
<dt>case (rerankedCandidateDetail, index) =&gt; {</dt><dd><dl>
<dt>candidatesMap(rerankedCandidateDetail.candidate.impressionId) =</dt><dd><dl class="simple">
<dt>candidatesMap(rerankedCandidateDetail.candidate.impressionId).copy(</dt><dd><p>rerankPosition = Some(index)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>_ &lt;- Future.collectToTry {</dt><dd><dl>
<dt>rerankedCandidates.map { rerankedCandidateDetail =&gt;</dt><dd><dl>
<dt>if (isFeatureHydratingEnabled) {</dt><dd><dl>
<dt>PushPredictionHelper</dt><dd><dl>
<dt>.getDataRecord(</dt><dd><p>rerankedCandidateDetail.candidate.target.targetHydrationContext,
rerankedCandidateDetail.candidate.target.featureMap,
rerankedCandidateDetail.candidate.candidateHydrationContext,
rerankedCandidateDetail.candidate.candidateFeatureMap(),
stats</p>
</dd>
<dt>).map { features =&gt;</dt><dd><dl>
<dt>candidatesMap(rerankedCandidateDetail.candidate.impressionId) =</dt><dd><dl class="simple">
<dt>candidatesMap(rerankedCandidateDetail.candidate.impressionId).copy(</dt><dd><dl class="simple">
<dt>features = Some(</dt><dd><p>ScalaToJavaDataRecordConversions.javaDataRecord2ScalaDataRecord(features))</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>} else Future.Unit</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>_ = restrictFilteredCandidates.foreach { restrictFilteredCandidateDetatil =&gt;</dt><dd><dl class="simple">
<dt>candidatesMap(restrictFilteredCandidateDetatil.candidate.impressionId) =</dt><dd><dl class="simple">
<dt>candidatesMap(restrictFilteredCandidateDetatil.candidate.impressionId)</dt><dd><p>.copy(candidateFilteredOutStep = Some(CandidateFilteredOutStep.Restrict))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>_ = allTakeCandidateResults.foreach { allTakeCandidateResult =&gt;</dt><dd><dl>
<dt>allTakeCandidateResult.result match {</dt><dd><dl>
<dt>case OK =&gt;</dt><dd><dl class="simple">
<dt>candidatesMap(allTakeCandidateResult.candidate.impressionId) =</dt><dd><p>candidatesMap(allTakeCandidateResult.candidate.impressionId).copy(isSent = Some(true))</p>
</dd>
</dl>
</dd>
<dt>case Invalid(reason) =&gt;</dt><dd><dl class="simple">
<dt>candidatesMap(allTakeCandidateResult.candidate.impressionId) =</dt><dd><dl class="simple">
<dt>candidatesMap(allTakeCandidateResult.candidate.impressionId).copy(</dt><dd><p>candidateFilteredOutPredicate = reason,
candidateFilteredOutStep = Some(CandidateFilteredOutStep.PostRankFiltering))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>case _ =&gt;</dt><dd><p>mrRequestScribeInvalidStats.incr()
throw new IllegalStateException(</p>
<blockquote>
<div><p>“Invalid reason for Candidate Filtering “ + allTakeCandidateResult.result)</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>} yield candidatesMap.values.toSeq</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private def enableTargetFilteringScribing(target: Target): Boolean = {</dt><dd><dl class="simple">
<dt>target.params(PushParams.EnableMrRequestScribing) &amp;&amp; target.params(</dt><dd><p>PushFeatureSwitchParams.EnableMrRequestScribingForTargetFiltering)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private def enableCandidateFilteringScribing(target: Target): Boolean = {</dt><dd><dl class="simple">
<dt>target.params(PushParams.EnableMrRequestScribing) &amp;&amp; target.params(</dt><dd><p>PushFeatureSwitchParams.EnableMrRequestScribingForCandidateFiltering)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private def writeAtTargetFilteringStep(target: Target, mrRequestScribe: MrRequestScribe) = {</dt><dd><p>logToScribe(mrRequestScribe)
mrRequestScribeTargetFilteringStats.incr()</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private def writeAtCandidateFilteringStep(target: Target, mrRequestScribe: MrRequestScribe) = {</dt><dd><p>logToScribe(mrRequestScribe)
mrRequestScribeCandidateFilteringStats.incr()</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private def logToScribe(mrRequestScribe: MrRequestScribe): Unit = {</dt><dd><p>val logEntry: String = MrRequestScribeInjection(mrRequestScribe)
mrRequestScribeLogger.info(logEntry)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/pushservice/src/main/scala/com/twitter/frigate/pushservice/scriber/MrRequestScribeHandler.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>