<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.frigate.pushservice.util</p>
<p>import com.twitter.finagle.stats.StatsReceiver
import com.twitter.frigate.common.rec_types.RecTypes
import com.twitter.frigate.pushservice.model.PushTypes.PushCandidate
import com.twitter.frigate.pushservice.params.PushConstants
import com.twitter.frigate.pushservice.params.{PushFeatureSwitchParams =&gt; FS}
import com.twitter.ibis2.lib.util.JsonMarshal
import com.twitter.util.Future
import com.twitter.util.Time</p>
<p>object CopyUtil {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Get a list of history feature copy alone with metadata in the look back period, the metadata</p></li>
<li><p>can be used to calculate number of copy pushed after the current feature copy</p></li>
<li><p>&#64;param candidate the candidate to be pushed to the user</p></li>
<li><p>&#64;return Future[Seq((..,))], which is a seq of the history FEATURE copy along with</p></li>
<li><p>metadata within the look back period. In the tuple, the 4 elements represents:</p></li>
<li><ol class="arabic simple">
<li><p>Timestamp of the past feature copy</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>Option[Seq()] of copy feature names of the past copy</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="3">
<li><p>Index of the particular feature copy in look back history if normal copy presents</p></li>
</ol>
</li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>private def getPastCopyFeaturesList(</dt><dd><p>candidate: PushCandidate</p>
</dd>
<dt>): Future[Seq[(Time, Option[Seq[String]], Int)]] = {</dt><dd><p>val target = candidate.target</p>
<dl>
<dt>target.history.map { targetHistory =&gt;</dt><dd><p>val historyLookbackDuration = target.params(FS.CopyFeaturesHistoryLookbackDuration)
val notificationHistoryInLookbackDuration = targetHistory.sortedHistory</p>
<blockquote>
<div><dl class="simple">
<dt>.takeWhile {</dt><dd><p>case (notifTimestamp, _) =&gt; historyLookbackDuration.ago &lt; notifTimestamp</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>notificationHistoryInLookbackDuration.zipWithIndex</dt><dd><dl>
<dt>.filter {</dt><dd><dl>
<dt>case ((_, notification), _) =&gt;</dt><dd><dl class="simple">
<dt>notification.copyFeatures match {</dt><dd><p>case Some(copyFeatures) =&gt; copyFeatures.nonEmpty
case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.collect {</p>
<blockquote>
<div><dl class="simple">
<dt>case ((timestamp, notification), notificationIndex) =&gt;</dt><dd><p>(timestamp, notification.copyFeatures, notificationIndex)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getPastCopyFeaturesListForF1(</dt><dd><p>candidate: PushCandidate</p>
</dd>
<dt>): Future[Seq[(Time, Option[Seq[String]], Int)]] = {</dt><dd><p>val target = candidate.target
target.history.map { targetHistory =&gt;</p>
<blockquote>
<div><p>val historyLookbackDuration = target.params(FS.CopyFeaturesHistoryLookbackDuration)
val notificationHistoryInLookbackDuration = targetHistory.sortedHistory</p>
<blockquote>
<div><dl class="simple">
<dt>.takeWhile {</dt><dd><p>case (notifTimestamp, _) =&gt; historyLookbackDuration.ago &lt; notifTimestamp</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>notificationHistoryInLookbackDuration.zipWithIndex</dt><dd><dl>
<dt>.filter {</dt><dd><dl>
<dt>case ((_, notification), _) =&gt;</dt><dd><dl>
<dt>notification.copyFeatures match {</dt><dd><dl class="simple">
<dt>case Some(copyFeatures) =&gt;</dt><dd><p>RecTypes.isF1Type(notification.commonRecommendationType) &amp;&amp; copyFeatures.nonEmpty</p>
</dd>
</dl>
<p>case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.collect {</p>
<blockquote>
<div><dl class="simple">
<dt>case ((timestamp, notification), notificationIndex) =&gt;</dt><dd><p>(timestamp, notification.copyFeatures, notificationIndex)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getPastCopyFeaturesListForOON(</dt><dd><p>candidate: PushCandidate</p>
</dd>
<dt>): Future[Seq[(Time, Option[Seq[String]], Int)]] = {</dt><dd><p>val target = candidate.target
target.history.map { targetHistory =&gt;</p>
<blockquote>
<div><p>val historyLookbackDuration = target.params(FS.CopyFeaturesHistoryLookbackDuration)
val notificationHistoryInLookbackDuration = targetHistory.sortedHistory</p>
<blockquote>
<div><dl class="simple">
<dt>.takeWhile {</dt><dd><p>case (notifTimestamp, _) =&gt; historyLookbackDuration.ago &lt; notifTimestamp</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>notificationHistoryInLookbackDuration.zipWithIndex</dt><dd><dl>
<dt>.filter {</dt><dd><dl>
<dt>case ((_, notification), _) =&gt;</dt><dd><dl>
<dt>notification.copyFeatures match {</dt><dd><dl class="simple">
<dt>case Some(copyFeatures) =&gt;</dt><dd><p>!RecTypes.isF1Type(notification.commonRecommendationType) &amp;&amp; copyFeatures.nonEmpty</p>
</dd>
</dl>
<p>case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.collect {</p>
<blockquote>
<div><dl class="simple">
<dt>case ((timestamp, notification), notificationIndex) =&gt;</dt><dd><p>(timestamp, notification.copyFeatures, notificationIndex)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
private def getEmojiFeaturesMap(</p>
<blockquote>
<div><p>candidate: PushCandidate,
copyFeatureHistory: Seq[(Time, Option[Seq[String]], Int)],
lastHTLVisitTimestamp: Option[Long],
stats: StatsReceiver</p>
</div></blockquote>
<dl>
<dt>): Map[String, String] = {</dt><dd><dl>
<dt>val (emojiFatigueDuration, emojiFatigueNumOfPushes) = {</dt><dd><dl class="simple">
<dt>if (RecTypes.isF1Type(candidate.commonRecType)) {</dt><dd><dl class="simple">
<dt>(</dt><dd><p>candidate.target.params(FS.F1EmojiCopyFatigueDuration),
candidate.target.params(FS.F1EmojiCopyNumOfPushesFatigue))</p>
</dd>
</dl>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>(</dt><dd><p>candidate.target.params(FS.OonEmojiCopyFatigueDuration),
candidate.target.params(FS.OonEmojiCopyNumOfPushesFatigue))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val scopedStats = stats</dt><dd><dl class="simple">
<dt>.scope(“getEmojiFeaturesMap”).scope(candidate.commonRecType.toString).scope(</dt><dd><p>emojiFatigueDuration.toString)</p>
</dd>
</dl>
</dd>
</dl>
<p>val addedEmojiCopyFeature = scopedStats.counter(“added_emoji”)
val fatiguedEmojiCopyFeature = scopedStats.counter(“no_emoji”)</p>
<p>val copyFeatureType = PushConstants.EmojiFeatureNameForIbis2ModelValues</p>
<dl class="simple">
<dt>val durationFatigueCarryFunc = () =&gt;</dt><dd><p>isUnderDurationFatigue(copyFeatureHistory, copyFeatureType, emojiFatigueDuration)</p>
</dd>
</dl>
<p>val enableHTLBasedFatigueBasicRule = candidate.target.params(FS.EnableHTLBasedFatigueBasicRule)
val minDuration = candidate.target.params(FS.MinFatigueDurationSinceLastHTLVisit)
val lastHTLVisitBasedNonFatigueWindow =</p>
<blockquote>
<div><p>candidate.target.params(FS.LastHTLVisitBasedNonFatigueWindow)</p>
</div></blockquote>
<dl>
<dt>val htlBasedCopyFatigueCarryFunc = () =&gt;</dt><dd><p>isUnderHTLBasedFatigue(lastHTLVisitTimestamp, minDuration, lastHTLVisitBasedNonFatigueWindow)</p>
</dd>
<dt>val isUnderFatigue = getIsUnderFatigue(</dt><dd><dl class="simple">
<dt>Seq(</dt><dd><p>(durationFatigueCarryFunc, true),
(htlBasedCopyFatigueCarryFunc, enableHTLBasedFatigueBasicRule),</p>
</dd>
</dl>
<p>),
scopedStats</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>if (!isUnderFatigue) {</dt><dd><p>addedEmojiCopyFeature.incr()
Map(PushConstants.EmojiFeatureNameForIbis2ModelValues -&gt; “true”)</p>
</dd>
<dt>} else {</dt><dd><p>fatiguedEmojiCopyFeature.incr()
Map.empty[String, String]</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getTargetFeaturesMap(</dt><dd><p>candidate: PushCandidate,
copyFeatureHistory: Seq[(Time, Option[Seq[String]], Int)],
lastHTLVisitTimestamp: Option[Long],
stats: StatsReceiver</p>
</dd>
<dt>): Map[String, String] = {</dt><dd><dl>
<dt>val targetFatigueDuration = {</dt><dd><dl class="simple">
<dt>if (RecTypes.isF1Type(candidate.commonRecType)) {</dt><dd><p>candidate.target.params(FS.F1TargetCopyFatigueDuration)</p>
</dd>
<dt>} else {</dt><dd><p>candidate.target.params(FS.OonTargetCopyFatigueDuration)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val scopedStats = stats</dt><dd><dl class="simple">
<dt>.scope(“getTargetFeaturesMap”).scope(candidate.commonRecType.toString).scope(</dt><dd><p>targetFatigueDuration.toString)</p>
</dd>
</dl>
</dd>
</dl>
<p>val addedTargetCopyFeature = scopedStats.counter(“added_target”)
val fatiguedTargetCopyFeature = scopedStats.counter(“no_target”)</p>
<p>val featureCopyType = PushConstants.TargetFeatureNameForIbis2ModelValues
val durationFatigueCarryFunc = () =&gt;</p>
<blockquote>
<div><p>isUnderDurationFatigue(copyFeatureHistory, featureCopyType, targetFatigueDuration)</p>
</div></blockquote>
<p>val enableHTLBasedFatigueBasicRule = candidate.target.params(FS.EnableHTLBasedFatigueBasicRule)
val minDuration = candidate.target.params(FS.MinFatigueDurationSinceLastHTLVisit)
val lastHTLVisitBasedNonFatigueWindow =</p>
<blockquote>
<div><p>candidate.target.params(FS.LastHTLVisitBasedNonFatigueWindow)</p>
</div></blockquote>
<dl>
<dt>val htlBasedCopyFatigueCarryFunc = () =&gt;</dt><dd><p>isUnderHTLBasedFatigue(lastHTLVisitTimestamp, minDuration, lastHTLVisitBasedNonFatigueWindow)</p>
</dd>
<dt>val isUnderFatigue = getIsUnderFatigue(</dt><dd><dl class="simple">
<dt>Seq(</dt><dd><p>(durationFatigueCarryFunc, true),
(htlBasedCopyFatigueCarryFunc, enableHTLBasedFatigueBasicRule),</p>
</dd>
</dl>
<p>),
scopedStats</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>if (!isUnderFatigue) {</dt><dd><p>addedTargetCopyFeature.incr()
Map(PushConstants.TargetFeatureNameForIbis2ModelValues -&gt; “true”)</p>
</dd>
</dl>
<p>} else {</p>
<blockquote>
<div><p>fatiguedTargetCopyFeature.incr()
Map.empty[String, String]</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>type FatigueRuleFlag = Boolean
type FatigueRuleFunc = () =&gt; Boolean</p>
<dl>
<dt>def getIsUnderFatigue(</dt><dd><p>fatigueRulesWithFlags: Seq[(FatigueRuleFunc, FatigueRuleFlag)],
statsReceiver: StatsReceiver,</p>
</dd>
<dt>): Boolean = {</dt><dd><p>val defaultFatigue = true
val finalFatigueRes =</p>
<blockquote>
<div><dl>
<dt>fatigueRulesWithFlags.zipWithIndex.foldLeft(defaultFatigue)(</dt><dd><dl>
<dt>(fatigueSoFar, fatigueRuleFuncWithFlagAndIndex) =&gt; {</dt><dd><p>val ((fatigueRuleFunc, flag), index) = fatigueRuleFuncWithFlagAndIndex
val funcScopedStats = statsReceiver.scope(s”fatigueFunction${index}”)
if (flag) {</p>
<blockquote>
<div><p>val shouldFatigueForTheRule = fatigueRuleFunc()
funcScopedStats.scope(s”eval_${shouldFatigueForTheRule}”).counter().incr()
val f = fatigueSoFar &amp;&amp; shouldFatigueForTheRule
f</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>fatigueSoFar</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>})</p>
</dd>
</dl>
</div></blockquote>
<p>statsReceiver.scope(s”final_fatigue_${finalFatigueRes}”).counter().incr()
finalFatigueRes</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def isUnderDurationFatigue(</dt><dd><p>copyFeatureHistory: Seq[(Time, Option[Seq[String]], Int)],
copyFeatureType: String,
fatigueDuration: com.twitter.util.Duration,</p>
</dd>
<dt>): Boolean = {</dt><dd><dl>
<dt>copyFeatureHistory.exists {</dt><dd><dl class="simple">
<dt>case (notifTimestamp, Some(copyFeatures), _) if copyFeatures.contains(copyFeatureType) =&gt;</dt><dd><p>notifTimestamp &gt; fatigueDuration.ago</p>
</dd>
</dl>
<p>case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def isUnderHTLBasedFatigue(</dt><dd><p>lastHTLVisitTimestamp: Option[Long],
minDurationSinceLastHTLVisit: com.twitter.util.Duration,
lastHTLVisitBasedNonFatigueWindow: com.twitter.util.Duration,</p>
</dd>
<dt>): Boolean = {</dt><dd><p>val lastHTLVisit = lastHTLVisitTimestamp.map(t =&gt; Time.fromMilliseconds(t)).getOrElse(Time.now)
val first = Time.now &lt; (lastHTLVisit + minDurationSinceLastHTLVisit)
val second =</p>
<blockquote>
<div><p>Time.now &gt; (lastHTLVisit + minDurationSinceLastHTLVisit + lastHTLVisitBasedNonFatigueWindow)</p>
</div></blockquote>
<p>first || second</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getOONCBasedFeature(</dt><dd><p>candidate: PushCandidate,
stats: StatsReceiver</p>
</dd>
<dt>): Future[Map[String, String]] = {</dt><dd><p>val target = candidate.target
val metric = stats.scope(“getOONCBasedFeature”)
if (target.params(FS.EnableOONCBasedCopy)) {</p>
<blockquote>
<div><dl>
<dt>candidate.mrWeightedOpenOrNtabClickRankingProbability.map {</dt><dd><dl>
<dt>case Some(score) if score &gt;= target.params(FS.HighOONCThresholdForCopy) =&gt;</dt><dd><p>metric.counter(“high_OONC”).incr()
metric.counter(FS.HighOONCTweetFormat.toString).incr()
Map(</p>
<blockquote>
<div><dl>
<dt>“whole_template” -&gt; JsonMarshal.toJson(</dt><dd><dl class="simple">
<dt>Map(</dt><dd><p>target.params(FS.HighOONCTweetFormat).toString -&gt; true</p>
</dd>
</dl>
<p>)))</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>case Some(score) if score &lt;= target.params(FS.LowOONCThresholdForCopy) =&gt;</dt><dd><p>metric.counter(“low_OONC”).incr()
metric.counter(FS.LowOONCThresholdForCopy.toString).incr()
Map(</p>
<blockquote>
<div><dl>
<dt>“whole_template” -&gt; JsonMarshal.toJson(</dt><dd><dl class="simple">
<dt>Map(</dt><dd><p>target.params(FS.LowOONCTweetFormat).toString -&gt; true</p>
</dd>
</dl>
<p>)))</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>case _ =&gt;</dt><dd><p>metric.counter(“not_in_OONC_range”).incr()
Map.empty[String, String]</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>Future.value(Map.empty[String, String])</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getCopyFeatures(</dt><dd><p>candidate: PushCandidate,
stats: StatsReceiver,</p>
</dd>
<dt>): Future[Map[String, String]] = {</dt><dd><dl>
<dt>if (candidate.target.isLoggedOutUser) {</dt><dd><p>Future.value(Map.empty[String, String])</p>
</dd>
<dt>} else {</dt><dd><p>val featureMaps = getCopyBodyFeatures(candidate, stats)
for {</p>
<blockquote>
<div><p>titleFeat &lt;- getCopyTitleFeatures(candidate, stats)
nsfwFeat &lt;- getNsfwCopyFeatures(candidate, stats)
ooncBasedFeature &lt;- getOONCBasedFeature(candidate, stats)</p>
</div></blockquote>
<dl class="simple">
<dt>} yield {</dt><dd><p>titleFeat ++ featureMaps ++ nsfwFeat ++ ooncBasedFeature</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getCopyTitleFeatures(</dt><dd><p>candidate: PushCandidate,
stats: StatsReceiver</p>
</dd>
<dt>): Future[Map[String, String]] = {</dt><dd><p>val scopedStats = stats.scope(“CopyUtil”).scope(“getCopyTitleFeatures”)</p>
<p>val target = candidate.target</p>
<dl>
<dt>if ((RecTypes.isSimClusterBasedType(candidate.commonRecType) &amp;&amp; target.params(</dt><dd><blockquote>
<div><p>FS.EnableCopyFeaturesForOon)) || (RecTypes.isF1Type(candidate.commonRecType) &amp;&amp; target
.params(FS.EnableCopyFeaturesForF1))) {</p>
</div></blockquote>
<p>val enableTargetAndEmojiSplitFatigue = target.params(FS.EnableTargetAndEmojiSplitFatigue)
val isTargetF1Type = RecTypes.isF1Type(candidate.commonRecType)</p>
<dl class="simple">
<dt>val copyFeatureHistoryFuture = if (enableTargetAndEmojiSplitFatigue &amp;&amp; isTargetF1Type) {</dt><dd><p>getPastCopyFeaturesListForF1(candidate)</p>
</dd>
<dt>} else if (enableTargetAndEmojiSplitFatigue &amp;&amp; !isTargetF1Type) {</dt><dd><p>getPastCopyFeaturesListForOON(candidate)</p>
</dd>
<dt>} else {</dt><dd><p>getPastCopyFeaturesList(candidate)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>Future</dt><dd><dl>
<dt>.join(</dt><dd><p>copyFeatureHistoryFuture,
target.lastHTLVisitTimestamp,</p>
</dd>
<dt>).map {</dt><dd><dl>
<dt>case (copyFeatureHistory, lastHTLVisitTimestamp) =&gt;</dt><dd><dl>
<dt>val emojiFeatures = {</dt><dd><dl>
<dt>if ((RecTypes.isF1Type(candidate.commonRecType) &amp;&amp; target.params(</dt><dd><blockquote>
<div><p>FS.EnableEmojiInF1Copy))</p>
</div></blockquote>
<dl class="simple">
<dt>|| RecTypes.isSimClusterBasedType(candidate.commonRecType) &amp;&amp; target.params(</dt><dd><p>FS.EnableEmojiInOonCopy)) {</p>
</dd>
<dt>getEmojiFeaturesMap(</dt><dd><p>candidate,
copyFeatureHistory,
lastHTLVisitTimestamp,
scopedStats)</p>
</dd>
</dl>
</dd>
</dl>
<p>} else Map.empty[String, String]</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val targetFeatures = {</dt><dd><dl>
<dt>if ((RecTypes.isF1Type(candidate.commonRecType) &amp;&amp; target.params(</dt><dd><blockquote>
<div><p>FS.EnableTargetInF1Copy)) || (RecTypes.isSimClusterBasedType(
candidate.commonRecType) &amp;&amp; target.params(FS.EnableTargetInOonCopy))) {</p>
</div></blockquote>
<dl class="simple">
<dt>getTargetFeaturesMap(</dt><dd><p>candidate,
copyFeatureHistory,
lastHTLVisitTimestamp,
scopedStats)</p>
</dd>
</dl>
</dd>
</dl>
<p>} else Map.empty[String, String]</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val baseCopyFeaturesMap =</dt><dd><dl class="simple">
<dt>if (emojiFeatures.nonEmpty || targetFeatures.nonEmpty)</dt><dd><p>Map(PushConstants.EnableCopyFeaturesForIbis2ModelValues -&gt; “true”)</p>
</dd>
</dl>
<p>else Map.empty[String, String]</p>
</dd>
</dl>
<p>baseCopyFeaturesMap ++ emojiFeatures ++ targetFeatures</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>Map.empty[String, String]</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>} else Future.value(Map.empty[String, String])</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getCopyBodyTruncateFeatures(</dt><dd><p>candidate: PushCandidate,</p>
</dd>
<dt>): Map[String, String] = {</dt><dd><dl class="simple">
<dt>if (candidate.target.params(FS.EnableIosCopyBodyTruncate)) {</dt><dd><p>Map(“enable_body_truncate_ios” -&gt; “true”)</p>
</dd>
<dt>} else {</dt><dd><p>Map.empty[String, String]</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getNsfwCopyFeatures(</dt><dd><p>candidate: PushCandidate,
stats: StatsReceiver</p>
</dd>
<dt>): Future[Map[String, String]] = {</dt><dd><p>val scopedStats = stats.scope(“CopyUtil”).scope(“getNsfwCopyBodyFeatures”)
val hasNsfwScoreF1Counter = scopedStats.counter(“f1_has_nsfw_score”)
val hasNsfwScoreOonCounter = scopedStats.counter(“oon_has_nsfw_score”)
val noNsfwScoreCounter = scopedStats.counter(“no_nsfw_score”)
val nsfwScoreF1 = scopedStats.stat(“f1_nsfw_score”)
val nsfwScoreOon = scopedStats.stat(“oon_nsfw_score”)
val isNsfwF1Counter = scopedStats.counter(“is_f1_nsfw”)
val isNsfwOonCounter = scopedStats.counter(“is_oon_nsfw”)</p>
<p>val target = candidate.target
val nsfwScoreFut = if (target.params(FS.EnableNsfwCopy)) {</p>
<blockquote>
<div><p>candidate.mrNsfwScore</p>
</div></blockquote>
<p>} else Future.None</p>
<dl>
<dt>nsfwScoreFut.map {</dt><dd><dl>
<dt>case Some(nsfwScore) =&gt;</dt><dd><dl>
<dt>if (RecTypes.isF1Type(candidate.commonRecType)) {</dt><dd><p>hasNsfwScoreF1Counter.incr()
nsfwScoreF1.add(nsfwScore.toFloat * 10000)
if (nsfwScore &gt; target.params(FS.NsfwScoreThresholdForF1Copy)) {</p>
<blockquote>
<div><p>isNsfwF1Counter.incr()
Map(“is_f1_nsfw” -&gt; “true”)</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>Map.empty[String, String]</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else if (RecTypes.isOutOfNetworkTweetRecType(candidate.commonRecType)) {</dt><dd><p>nsfwScoreOon.add(nsfwScore.toFloat * 10000)
hasNsfwScoreOonCounter.incr()
if (nsfwScore &gt; target.params(FS.NsfwScoreThresholdForOONCopy)) {</p>
<blockquote>
<div><p>isNsfwOonCounter.incr()
Map(“is_oon_nsfw” -&gt; “true”)</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>Map.empty[String, String]</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>Map.empty[String, String]</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>noNsfwScoreCounter.incr()
Map.empty[String, String]</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getCopyBodyFeatures(</dt><dd><p>candidate: PushCandidate,
stats: StatsReceiver</p>
</dd>
<dt>): Map[String, String] = {</dt><dd><p>val target = candidate.target
val scopedStats = stats.scope(“CopyUtil”).scope(“getCopyBodyFeatures”)</p>
<dl>
<dt>val copyBodyFeatures = {</dt><dd><dl>
<dt>if (RecTypes.isF1Type(candidate.commonRecType) &amp;&amp; target.params(FS.EnableF1CopyBody)) {</dt><dd><p>scopedStats.counter(“f1BodyExpEnabled”).incr()
Map(PushConstants.CopyBodyExpIbisModelValues -&gt; “true”)</p>
</dd>
<dt>} else if (RecTypes.isOutOfNetworkTweetRecType(candidate.commonRecType) &amp;&amp; target.params(</dt><dd><blockquote>
<div><p>FS.EnableOONCopyBody)) {</p>
</div></blockquote>
<p>scopedStats.counter(“oonBodyExpEnabled”).incr()
Map(PushConstants.CopyBodyExpIbisModelValues -&gt; “true”)</p>
</dd>
<dt>} else</dt><dd><p>Map.empty[String, String]</p>
</dd>
</dl>
</dd>
</dl>
<p>}
val copyBodyTruncateFeatures = getCopyBodyTruncateFeatures(candidate)
copyBodyFeatures ++ copyBodyTruncateFeatures</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/pushservice/src/main/scala/com/twitter/frigate/pushservice/util/CopyUtil.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>