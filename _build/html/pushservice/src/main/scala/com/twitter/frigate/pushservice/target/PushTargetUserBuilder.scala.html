<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.frigate.pushservice.target</p>
<p>import com.twitter.abdecider.LoggingABDecider
import com.twitter.conversions.DurationOps._
import com.twitter.decider.Decider
import com.twitter.discovery.common.configapi.ConfigParamsBuilder
import com.twitter.discovery.common.configapi.ExperimentOverride
import com.twitter.featureswitches.Recipient
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.frigate.common.base._
import com.twitter.frigate.common.history._
import com.twitter.frigate.common.logger.MRLogger
import com.twitter.frigate.common.store.FeedbackRequest
import com.twitter.frigate.common.store.PushRecItemsKey
import com.twitter.frigate.common.store.deviceinfo.DeviceInfo
import com.twitter.frigate.common.store.interests.UserId
import com.twitter.frigate.common.util._
import com.twitter.frigate.data_pipeline.features_common.MrRequestContextForFeatureStore
import com.twitter.frigate.data_pipeline.thriftscala.UserHistoryValue
import com.twitter.frigate.dau_model.thriftscala.DauProbability
import com.twitter.frigate.pushcap.thriftscala.PushcapInfo
import com.twitter.frigate.pushcap.thriftscala.PushcapUserHistory
import com.twitter.frigate.pushservice.model.PushTypes.Target
import com.twitter.frigate.pushservice.ml.HydrationContextBuilder
import com.twitter.frigate.pushservice.ml.PushMLModelScorer
import com.twitter.frigate.pushservice.params.PushFeatureSwitchParams
import com.twitter.frigate.pushservice.params.PushParams
import com.twitter.frigate.pushservice.store.LabeledPushRecsStoreKey
import com.twitter.frigate.pushservice.store.OnlineUserHistoryKey
import com.twitter.frigate.pushservice.util.NsfwInfo
import com.twitter.frigate.pushservice.util.NsfwPersonalizationUtil
import com.twitter.frigate.pushservice.util.PushAppPermissionUtil
import com.twitter.frigate.pushservice.util.PushCapUtil.getMinimumRestrictedPushcapInfo
import com.twitter.frigate.pushservice.thriftscala.PushContext
import com.twitter.frigate.pushservice.thriftscala.RequestSource
import com.twitter.frigate.thriftscala.SecondaryAccountsByUserState
import com.twitter.frigate.thriftscala.UserForPushTargeting
import com.twitter.frigate.user_states.thriftscala.MRUserHmmState
import com.twitter.frigate.user_states.thriftscala.{UserState =&gt; MrUserState}
import com.twitter.frontpage.stream.util.SnowflakeUtil
import com.twitter.geoduck.common.thriftscala.Place
import com.twitter.geoduck.service.thriftscala.LocationResponse
import com.twitter.gizmoduck.thriftscala.User
import com.twitter.hermit.model.user_state.UserState
import com.twitter.hermit.model.user_state.UserState.UserState
import com.twitter.hermit.stp.thriftscala.STPResult
import com.twitter.ibis.thriftscala.ContentRecData
import com.twitter.interests.thriftscala.InterestId
import com.twitter.notificationservice.feedback.thriftscala.FeedbackInteraction
import com.twitter.notificationservice.genericfeedbackstore.FeedbackPromptValue
import com.twitter.notificationservice.genericfeedbackstore.GenericFeedbackStore
import com.twitter.notificationservice.genericfeedbackstore.GenericFeedbackStoreException
import com.twitter.notificationservice.model.service.DismissMenuFeedbackAction
import com.twitter.notificationservice.scribe.manhattan.GenericNotificationsFeedbackRequest
import com.twitter.notificationservice.thriftscala.CaretFeedbackDetails
import com.twitter.nrel.heavyranker.FeatureHydrator
import com.twitter.nrel.hydration.push.HydrationContext
import com.twitter.permissions_storage.thriftscala.AppPermission
import com.twitter.rux.common.strato.thriftscala.UserTargetingProperty
import com.twitter.scio.nsfw_user_segmentation.thriftscala.NSFWUserSegmentation
import com.twitter.service.metastore.gen.thriftscala.Location
import com.twitter.service.metastore.gen.thriftscala.UserLanguages
import com.twitter.stitch.Stitch
import com.twitter.stitch.tweetypie.TweetyPie.TweetyPieResult
import com.twitter.storehaus.ReadableStore
import com.twitter.timelines.configapi
import com.twitter.timelines.real_graph.thriftscala.{RealGraphFeatures =&gt; RealGraphFeaturesUnion}
import com.twitter.timelines.real_graph.v1.thriftscala.RealGraphFeatures
import com.twitter.ubs.thriftscala.SellerApplicationState
import com.twitter.ubs.thriftscala.SellerTrack
import com.twitter.user_session_store.thriftscala.UserSession
import com.twitter.util.Duration
import com.twitter.util.Future
import com.twitter.util.Time
import com.twitter.wtf.scalding.common.thriftscala.UserFeatures</p>
<dl>
<dt>case class PushTargetUserBuilder(</dt><dd><p>historyStore: PushServiceHistoryStore,
emailHistoryStore: PushServiceHistoryStore,
labeledPushRecsStore: ReadableStore[LabeledPushRecsStoreKey, UserHistoryValue],
onlineUserHistoryStore: ReadableStore[OnlineUserHistoryKey, UserHistoryValue],
pushRecItemsStore: ReadableStore[PushRecItemsKey, RecItems],
userStore: ReadableStore[Long, User],
pushInfoStore: ReadableStore[Long, UserForPushTargeting],
userCountryStore: ReadableStore[Long, Location],
userUtcOffsetStore: ReadableStore[Long, Duration],
dauProbabilityStore: ReadableStore[Long, DauProbability],
nsfwConsumerStore: ReadableStore[Long, NSFWUserSegmentation],
userFeatureStore: ReadableStore[Long, UserFeatures],
userTargetingPropertyStore: ReadableStore[Long, UserTargetingProperty],
mrUserStateStore: ReadableStore[Long, MRUserHmmState],
tweetImpressionStore: ReadableStore[Long, Seq[Long]],
ntabCaretFeedbackStore: ReadableStore[GenericNotificationsFeedbackRequest, Seq[</p>
<blockquote>
<div><p>CaretFeedbackDetails</p>
</div></blockquote>
<p>]],
genericFeedbackStore: ReadableStore[FeedbackRequest, Seq[FeedbackPromptValue]],
genericNotificationFeedbackStore: GenericFeedbackStore,
timelinesUserSessionStore: ReadableStore[Long, UserSession],
cachedTweetyPieStore: ReadableStore[Long, TweetyPieResult],
strongTiesStore: ReadableStore[Long, STPResult],
userHTLLastVisitStore: ReadableStore[Long, Seq[Long]],
userLanguagesStore: ReadableStore[Long, UserLanguages],
inputDecider: Decider,
inputAbDecider: LoggingABDecider,
realGraphScoresTop500InStore: ReadableStore[Long, Map[Long, Double]],
recentFollowsStore: ReadableStore[Long, Seq[Long]],
resurrectedUserStore: ReadableStore[Long, String],
configParamsBuilder: ConfigParamsBuilder,
optOutUserInterestsStore: ReadableStore[UserId, Seq[InterestId]],
deviceInfoStore: ReadableStore[Long, DeviceInfo],
pushcapDynamicPredictionStore: ReadableStore[Long, PushcapUserHistory],
appPermissionStore: ReadableStore[(Long, (String, String)), AppPermission],
optoutModelScorer: PushMLModelScorer,
inlineActionHistoryStore: ReadableStore[Long, Seq[(Long, String)]],
featureHydrator: FeatureHydrator,
openAppUserStore: ReadableStore[Long, Boolean],
openedPushByHourAggregatedStore: ReadableStore[Long, Map[Int, Int]],
geoduckStoreV2: ReadableStore[Long, LocationResponse],
superFollowEligibilityUserStore: ReadableStore[Long, Boolean],
superFollowApplicationStatusStore: ReadableStore[(Long, SellerTrack), SellerApplicationState]</p>
</dd>
<dt>)(</dt><dd><p>globalStatsReceiver: StatsReceiver) {</p>
<p>implicit val statsReceiver: StatsReceiver = globalStatsReceiver</p>
<p>private val log = MRLogger(“PushTargetUserBuilder”)
private val recentFollowscounter = statsReceiver.counter(“query_recent_follows”)
private val isModelTrainingDataCounter =</p>
<blockquote>
<div><p>statsReceiver.scope(“TargetUserBuilder”).counter(“is_model_training”)</p>
</div></blockquote>
<p>private val feedbackStoreGenerationErr = statsReceiver.counter(“feedback_store_generation_error”)
private val newSignUpUserStats = statsReceiver.counter(“new_signup_user”)
private val pushcapSelectionStat = statsReceiver.scope(“pushcap_modeling”)
private val dormantUserCount = statsReceiver.counter(“dormant_user_counter”)
private val optoutModelStat = statsReceiver.scope(“optout_modeling”)
private val placeFoundStat = statsReceiver.scope(“geoduck_v2”).stat(“places_found”)
private val placesNotFound = statsReceiver.scope(“geoduck_v2”).counter(“places_not_found”)
// Email history store stats
private val emailHistoryStats = statsReceiver.scope(“email_tweet_history”)
private val emptyEmailHistoryCounter = emailHistoryStats.counter(“empty”)
private val nonEmptyEmailHistoryCounter = emailHistoryStats.counter(“non_empty”)</p>
<p>private val MagicRecsCategory = “MagicRecs”
private val MomentsViaMagicRecsCategory = “MomentsViaMagicRecs”
private val MomentsCategory = “Moments”</p>
<dl>
<dt>def buildTarget(</dt><dd><p>userId: Long,
inputPushContext: Option[PushContext],
forcedFeatureValues: Option[Map[String, configapi.FeatureValue]] = None</p>
</dd>
<dt>): Future[Target] = {</dt><dd><dl class="simple">
<dt>val historyStoreKeyContext = HistoryStoreKeyContext(</dt><dd><p>userId,
inputPushContext.flatMap(_.useMemcacheForHistory).getOrElse(false)</p>
</dd>
</dl>
<p>)
Future</p>
<blockquote>
<div><dl>
<dt>.join(</dt><dd><p>userStore.get(userId),
deviceInfoStore.get(userId),
pushInfoStore.get(userId),
historyStore.get(historyStoreKeyContext, Some(30.days)),
emailHistoryStore.get(</p>
<blockquote>
<div><p>HistoryStoreKeyContext(userId, useStoreB = false),
Some(7.days) // we only keep 7 days of email tweet history</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>).flatMap {</dt><dd><dl>
<dt>case (userOpt, deviceInfoOpt, userForPushTargetingInfoOpt, notifHistory, emailHistory) =&gt;</dt><dd><dl>
<dt>getCustomFSFields(</dt><dd><p>userId,
userOpt,
deviceInfoOpt,
userForPushTargetingInfoOpt,
notifHistory,
inputPushContext.flatMap(_.requestSource)).map { customFSField =&gt;
new Target {</p>
<blockquote>
<div><p>override lazy val stats: StatsReceiver = statsReceiver</p>
<p>override val targetId: Long = userId</p>
<p>override val targetUser: Future[Option[User]] = Future.value(userOpt)</p>
<dl>
<dt>override val isEmailUser: Boolean =</dt><dd><dl class="simple">
<dt>inputPushContext.flatMap(_.requestSource) match {</dt><dd><p>case Some(source) if source == RequestSource.Email =&gt; true
case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>override val pushContext = inputPushContext</p>
<p>override def globalStats: StatsReceiver = globalStatsReceiver</p>
<dl class="simple">
<dt>override lazy val abDecider: ABDeciderWithOverride =</dt><dd><p>ABDeciderWithOverride(inputAbDecider, ddgOverrideOption)</p>
</dd>
<dt>override lazy val pushRecItems: Future[RecItems] =</dt><dd><dl class="simple">
<dt>pushRecItemsStore</dt><dd><p>.get(PushRecItemsKey(historyStoreKeyContext, history))
.map(_.getOrElse(RecItems.empty))</p>
</dd>
</dl>
</dd>
</dl>
<p>// List of past tweet candidates sent in the past through email with timestamp
override lazy val emailRecItems: Future[Seq[(Time, Long)]] = {</p>
<blockquote>
<div><dl>
<dt>Future.value {</dt><dd><dl>
<dt>emailHistory.sortedEmailHistory.flatMap {</dt><dd><dl>
<dt>case (timeStamp, notification) =&gt;</dt><dd><dl>
<dt>notification.contentRecsNotification</dt><dd><dl>
<dt>.map { notification =&gt;</dt><dd><dl>
<dt>notification.recommendations.contentRecCollections.flatMap {</dt><dd><dl>
<dt>contentRecs =&gt;</dt><dd><dl>
<dt>contentRecs.contentRecModules.flatMap { contentRecModule =&gt;</dt><dd><dl class="simple">
<dt>contentRecModule.recData match {</dt><dd><dl class="simple">
<dt>case ContentRecData.TweetRec(tweetRec) =&gt;</dt><dd><p>nonEmptyEmailHistoryCounter.incr()
Seq(tweetRec.tweetId)</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>emptyEmailHistoryCounter.incr()
Nil</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>}.getOrElse {</dt><dd><p>emptyEmailHistoryCounter.incr()
Nil</p>
</dd>
</dl>
<p>}.map(timeStamp -&gt; _)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>override lazy val history: Future[History] = Future.value(notifHistory)</p>
<dl class="simple">
<dt>override lazy val pushTargeting: Future[Option[UserForPushTargeting]] =</dt><dd><p>Future.value(userForPushTargetingInfoOpt)</p>
</dd>
</dl>
<p>override lazy val decider: Decider = inputDecider</p>
<dl class="simple">
<dt>override lazy val location: Future[Option[Location]] =</dt><dd><p>userCountryStore.get(userId)</p>
</dd>
<dt>override lazy val deviceInfo: Future[Option[DeviceInfo]] =</dt><dd><p>Future.value(deviceInfoOpt)</p>
</dd>
<dt>override lazy val targetLanguage: Future[Option[String]] = targetUser map { userOpt =&gt;</dt><dd><p>userOpt.flatMap(_.account.map(_.language))</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override lazy val targetAgeInYears: Future[Option[Int]] =</dt><dd><p>Future.value(customFSField.userAge)</p>
</dd>
<dt>override lazy val metastoreLanguages: Future[Option[UserLanguages]] =</dt><dd><p>userLanguagesStore.get(targetId)</p>
</dd>
<dt>override lazy val utcOffset: Future[Option[Duration]] =</dt><dd><p>userUtcOffsetStore.get(targetId)</p>
</dd>
<dt>override lazy val userFeatures: Future[Option[UserFeatures]] =</dt><dd><p>userFeatureStore.get(targetId)</p>
</dd>
<dt>override lazy val targetUserState: Future[Option[UserState]] =</dt><dd><dl class="simple">
<dt>Future.value(</dt><dd><dl class="simple">
<dt>customFSField.userState</dt><dd><p>.flatMap(userState =&gt; UserState.valueOf(userState)))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>override lazy val targetMrUserState: Future[Option[MrUserState]] =</dt><dd><dl class="simple">
<dt>Future.value(</dt><dd><dl class="simple">
<dt>customFSField.mrUserState</dt><dd><p>.flatMap(mrUserState =&gt; MrUserState.valueOf(mrUserState)))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>override lazy val accountStateWithDeviceInfo: Future[</dt><dd><p>Option[SecondaryAccountsByUserState]</p>
</dd>
</dl>
<p>] = Future.None</p>
<dl class="simple">
<dt>override lazy val dauProbability: Future[Option[DauProbability]] = {</dt><dd><p>dauProbabilityStore.get(targetId)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override lazy val labeledPushRecsHydrated: Future[Option[UserHistoryValue]] =</dt><dd><p>labeledPushRecsStore.get(LabeledPushRecsStoreKey(this, historyStoreKeyContext))</p>
</dd>
<dt>override lazy val onlineLabeledPushRecs: Future[Option[UserHistoryValue]] =</dt><dd><dl>
<dt>labeledPushRecsHydrated.flatMap { labeledPushRecs =&gt;</dt><dd><dl>
<dt>history.flatMap { history =&gt;</dt><dd><dl class="simple">
<dt>onlineUserHistoryStore.get(</dt><dd><p>OnlineUserHistoryKey(targetId, labeledPushRecs, Some(history))</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override lazy val tweetImpressionResults: Future[Seq[Long]] =</dt><dd><dl>
<dt>tweetImpressionStore.get(targetId).map {</dt><dd><dl class="simple">
<dt>case Some(impressionList) =&gt;</dt><dd><p>impressionList</p>
</dd>
</dl>
<p>case _ =&gt; Nil</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override lazy val realGraphFeatures: Future[Option[RealGraphFeatures]] =</dt><dd><dl>
<dt>timelinesUserSessionStore.get(targetId).map { userSessionOpt =&gt;</dt><dd><dl>
<dt>userSessionOpt.flatMap { userSession =&gt;</dt><dd><dl class="simple">
<dt>userSession.realGraphFeatures.collect {</dt><dd><dl class="simple">
<dt>case RealGraphFeaturesUnion.V1(rGFeatures) =&gt;</dt><dd><p>rGFeatures</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override lazy val stpResult: Future[Option[STPResult]] =</dt><dd><p>strongTiesStore.get(targetId)</p>
</dd>
<dt>override lazy val lastHTLVisitTimestamp: Future[Option[Long]] =</dt><dd><dl>
<dt>userHTLLastVisitStore.get(targetId).map {</dt><dd><dl class="simple">
<dt>case Some(lastVisitTimestamps) if lastVisitTimestamps.nonEmpty =&gt;</dt><dd><p>Some(lastVisitTimestamps.max)</p>
</dd>
</dl>
<p>case _ =&gt; None</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override lazy val caretFeedbacks: Future[Option[Seq[CaretFeedbackDetails]]] = {</dt><dd><p>val scribeHistoryLookbackPeriod = 365.days
val now = Time.now
val request = GenericNotificationsFeedbackRequest(</p>
<blockquote>
<div><p>userId = targetId,
eventStartTimestamp = now - scribeHistoryLookbackPeriod,
eventEndTimestamp = now,
filterCategory =</p>
<blockquote>
<div><p>Some(Set(MagicRecsCategory, MomentsViaMagicRecsCategory, MomentsCategory)),</p>
</div></blockquote>
<dl class="simple">
<dt>filterFeedbackActionText =</dt><dd><p>Some(Set(DismissMenuFeedbackAction.FeedbackActionTextSeeLessOften))</p>
</dd>
</dl>
</div></blockquote>
<p>)
ntabCaretFeedbackStore.get(request)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override lazy val notificationFeedbacks: Future[</dt><dd><p>Option[Seq[FeedbackPromptValue]]</p>
</dd>
<dt>] = {</dt><dd><p>val scribeHistoryLookbackPeriod = 30.days
val now = Time.now
val request = FeedbackRequest(</p>
<blockquote>
<div><p>userId = targetId,
oldestTimestamp = scribeHistoryLookbackPeriod.ago,
newestTimestamp = Time.now,
feedbackInteraction = FeedbackInteraction.Feedback</p>
</div></blockquote>
<p>)
genericFeedbackStore.get(request)</p>
</dd>
</dl>
<p>}</p>
<p>// DEPRECATED: Use notificationFeedbacks instead.
// This method will increase latency dramatically.
override lazy val promptFeedbacks: Stitch[Seq[FeedbackPromptValue]] = {</p>
<blockquote>
<div><p>val scribeHistoryLookbackPeriod = 7.days</p>
<dl>
<dt>genericNotificationFeedbackStore</dt><dd><dl>
<dt>.getAll(</dt><dd><p>userId = targetId,
oldestTimestamp = scribeHistoryLookbackPeriod.ago,
newestTimestamp = Time.now,
feedbackInteraction = FeedbackInteraction.Feedback</p>
</dd>
<dt>).handle {</dt><dd><dl class="simple">
<dt>case _: GenericFeedbackStoreException =&gt; {</dt><dd><p>feedbackStoreGenerationErr.incr()
Seq.empty[FeedbackPromptValue]</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>override lazy val optOutUserInterests: Future[Option[Seq[InterestId]]] = {</dt><dd><p>optOutUserInterestsStore.get(targetId)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private val experimentOverride = ddgOverrideOption.map {</dt><dd><dl class="simple">
<dt>case DDGOverride(Some(exp), Some(bucket)) =&gt;</dt><dd><p>Set(ExperimentOverride(exp, bucket))</p>
</dd>
</dl>
<p>case _ =&gt; Set.empty[ExperimentOverride]</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val signupCountryCode =</dt><dd><p>Future.value(userOpt.flatMap(_.safety.flatMap(_.signupCountryCode)))</p>
</dd>
<dt>override lazy val params: configapi.Params = {</dt><dd><dl>
<dt>val fsRecipient = Recipient(</dt><dd><p>userId = Some(targetId),
userRoles = userOpt.flatMap(_.roles.map(_.roles.toSet)),
clientApplicationId = deviceInfoOpt.flatMap(_.guessedPrimaryClientAppId),
userAgent = deviceInfoOpt.flatMap(_.guessedPrimaryDeviceUserAgent),
countryCode =</p>
<blockquote>
<div><p>userOpt.flatMap(_.account.flatMap(_.countryCode.map(_.toUpperCase))),</p>
</div></blockquote>
<p>customFields = Some(customFSField.fsMap),
signupCountryCode =</p>
<blockquote>
<div><p>userOpt.flatMap(_.safety.flatMap(_.signupCountryCode.map(_.toUpperCase))),</p>
</div></blockquote>
<dl class="simple">
<dt>languageCode = deviceInfoOpt.flatMap {</dt><dd><p>_.deviceLanguages.flatMap(IbisAppPushDeviceSettingsUtil.inferredDeviceLanguage)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>configParamsBuilder.build(</dt><dd><p>userId = Some(targetId),
experimentOverrides = experimentOverride,
featureRecipient = Some(fsRecipient),
forcedFeatureValues = forcedFeatureValues.getOrElse(Map.empty),</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override lazy val mrRequestContextForFeatureStore =</dt><dd><p>MrRequestContextForFeatureStore(targetId, params, isModelTrainingData)</p>
</dd>
<dt>override lazy val dynamicPushcap: Future[Option[PushcapInfo]] = {</dt><dd><p>// Get the pushcap from the pushcap model prediction store
if (params(PushParams.EnableModelBasedPushcapAssignments)) {</p>
<blockquote>
<div><dl>
<dt>val originalPushcapInfoFut =</dt><dd><dl class="simple">
<dt>PushCapUtil.getPushcapFromUserHistory(</dt><dd><p>userId,
pushcapDynamicPredictionStore,
params(FeatureSwitchParams.PushcapModelType),
params(FeatureSwitchParams.PushcapModelPredictionVersion),
pushcapSelectionStat</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>// Modify the push cap info if there is a restricted min value for predicted push caps.
val restrictedPushcap = params(PushFeatureSwitchParams.RestrictedMinModelPushcap)
originalPushcapInfoFut.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case Some(originalPushcapInfo) =&gt;</dt><dd><dl class="simple">
<dt>Some(</dt><dd><dl class="simple">
<dt>getMinimumRestrictedPushcapInfo(</dt><dd><p>restrictedPushcap,
originalPushcapInfo,
pushcapSelectionStat))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>case _ =&gt; None</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>} else Future.value(None)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override lazy val targetHydrationContext: Future[HydrationContext] =</dt><dd><p>HydrationContextBuilder.build(this)</p>
</dd>
<dt>override lazy val featureMap: Future[FeatureMap] =</dt><dd><dl class="simple">
<dt>targetHydrationContext.flatMap { hydrationContext =&gt;</dt><dd><dl class="simple">
<dt>featureHydrator.hydrateTarget(</dt><dd><p>hydrationContext,
this.params,
this.mrRequestContextForFeatureStore)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override lazy val globalOptoutProbabilities: Seq[Future[Option[Double]]] = {</dt><dd><dl class="simple">
<dt>params(PushFeatureSwitchParams.GlobalOptoutModelParam).map { model_id =&gt;</dt><dd><dl class="simple">
<dt>optoutModelScorer</dt><dd><p>.singlePredictionForTargetLevel(model_id, targetId, featureMap)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override lazy val bucketOptoutProbability: Future[Option[Double]] = {</dt><dd><dl>
<dt>Future</dt><dd><dl>
<dt>.collect(globalOptoutProbabilities).map {</dt><dd><dl>
<dt>_.zip(params(PushFeatureSwitchParams.GlobalOptoutThresholdParam))</dt><dd><dl class="simple">
<dt>.exists {</dt><dd><p>case (Some(score), threshold) =&gt; score &gt;= threshold
case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
<dt>}.flatMap {</dt><dd><dl class="simple">
<dt>case true =&gt;</dt><dd><dl class="simple">
<dt>optoutModelScorer.singlePredictionForTargetLevel(</dt><dd><p>params(PushFeatureSwitchParams.BucketOptoutModelParam),
targetId,
featureMap)</p>
</dd>
</dl>
</dd>
</dl>
<p>case _ =&gt; Future.None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override lazy val optoutAdjustedPushcap: Future[Option[Short]] = {</dt><dd><dl>
<dt>if (params(PushFeatureSwitchParams.EnableOptoutAdjustedPushcap)) {</dt><dd><dl>
<dt>bucketOptoutProbability.map {</dt><dd><dl>
<dt>case Some(score) =&gt;</dt><dd><dl>
<dt>val idx = params(PushFeatureSwitchParams.BucketOptoutSlotThresholdParam)</dt><dd><p>.indexWhere(score &lt;= _)</p>
</dd>
<dt>if (idx &gt;= 0) {</dt><dd><dl class="simple">
<dt>val pushcap =</dt><dd><p>params(PushFeatureSwitchParams.BucketOptoutSlotPushcapParam)(idx).toShort</p>
</dd>
</dl>
<p>optoutModelStat.scope(“adjusted_pushcap”).counter(f”$pushcap”).incr()
if (pushcap &gt;= 0) Some(pushcap)
else None</p>
</dd>
</dl>
<p>} else None</p>
</dd>
</dl>
<p>case _ =&gt; None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>} else Future.None</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override lazy val seedsWithWeight: Future[Option[Map[Long, Double]]] = {</dt><dd><dl>
<dt>Future</dt><dd><dl class="simple">
<dt>.join(</dt><dd><p>realGraphScoresTop500InStore.get(userId),
targetUserState,
targetUser</p>
</dd>
</dl>
<p>)
.flatMap {</p>
<blockquote>
<div><dl>
<dt>case (seedSetOpt, userState, gizmoduckUser) =&gt;</dt><dd><p>val seedSet = seedSetOpt.getOrElse(Map.empty[Long, Double])</p>
<p>//If new sign_up or New user, combine recent_follows with real graph seedset
val isNewUserEnabled = {</p>
<blockquote>
<div><p>val isNewerThan7days = customFSField.daysSinceSignup &lt;= 7
val isNewUserState = userState.contains(UserState.New)
isNewUserState || isNewSignup || isNewerThan7days</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>val nonSeedSetFollowsFut = gizmoduckUser match {</dt><dd><dl class="simple">
<dt>case Some(user) if isNewUserEnabled =&gt;</dt><dd><p>recentFollowscounter.incr()
recentFollowsStore.get(user.id)</p>
</dd>
<dt>case Some(user) if this.isModelTrainingData =&gt;</dt><dd><p>recentFollowscounter.incr()
isModelTrainingDataCounter.incr()
recentFollowsStore.get(user.id)</p>
</dd>
</dl>
<p>case _ =&gt; Future.None</p>
</dd>
</dl>
<p>}
nonSeedSetFollowsFut.map { nonSeedSetFollows =&gt;</p>
<blockquote>
<div><dl>
<dt>Some(</dt><dd><dl class="simple">
<dt>SeedsetUtil.combineRecentFollowsWithWeightedSeedset(</dt><dd><p>seedSet,
nonSeedSetFollows.getOrElse(Nil)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def magicFanoutReasonHistory30Days: Future[MagicFanoutReasonHistory] =</dt><dd><p>history.map(history =&gt; MagicFanoutReasonHistory(history))</p>
</dd>
<dt>override val isNewSignup: Boolean =</dt><dd><p>pushContext.flatMap(_.isFromNewUserLoopProcessor).getOrElse(false)</p>
</dd>
<dt>override lazy val resurrectionDate: Future[Option[String]] =</dt><dd><p>Future.value(customFSField.reactivationDate)</p>
</dd>
<dt>override lazy val isResurrectedUser: Boolean =</dt><dd><p>customFSField.daysSinceReactivation.isDefined</p>
</dd>
<dt>override lazy val timeSinceResurrection: Option[Duration] =</dt><dd><p>customFSField.daysSinceReactivation.map(Duration.fromDays)</p>
</dd>
<dt>override lazy val appPermissions: Future[Option[AppPermission]] =</dt><dd><dl class="simple">
<dt>PushAppPermissionUtil.getAppPermission(</dt><dd><p>userId,
PushAppPermissionUtil.AddressBookPermissionKey,
deviceInfo,
appPermissionStore)</p>
</dd>
</dl>
</dd>
<dt>override lazy val inlineActionHistory: Future[Seq[(Long, String)]] = {</dt><dd><dl>
<dt>inlineActionHistoryStore</dt><dd><dl class="simple">
<dt>.get(userId).map {</dt><dd><p>case Some(sortedInlineActionHistory) =&gt; sortedInlineActionHistory
case _ =&gt; Seq.empty</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>lazy val isOpenAppExperimentUser: Future[Boolean] =</dt><dd><p>openAppUserStore.get(userId).map(_.contains(true))</p>
</dd>
<dt>override lazy val openedPushByHourAggregated: Future[Option[Map[Int, Int]]] =</dt><dd><p>openedPushByHourAggregatedStore.get(userId)</p>
</dd>
<dt>override lazy val places: Future[Seq[Place]] = {</dt><dd><dl>
<dt>geoduckStoreV2</dt><dd><p>.get(targetId)
.map(_.flatMap(_.places))
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case Some(placeSeq) if placeSeq.nonEmpty =&gt;</dt><dd><p>placeFoundStat.add(placeSeq.size)
placeSeq</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>placesNotFound.incr()
Seq.empty</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override val isBlueVerified: Future[Option[Boolean]] =</dt><dd><p>Future.value(userOpt.flatMap(_.safety.flatMap(_.isBlueVerified)))</p>
</dd>
<dt>override val isVerified: Future[Option[Boolean]] =</dt><dd><p>Future.value(userOpt.flatMap(_.safety.map(_.verified)))</p>
</dd>
<dt>override lazy val isSuperFollowCreator: Future[Option[Boolean]] =</dt><dd><p>superFollowEligibilityUserStore.get(targetId)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Provide general way to add needed FS for target user, and package them in CustomFSFields.</p></li>
<li><p>Custom Fields is a powerful feature that allows Feature Switch library users to define and</p></li>
<li><p>match against any arbitrary fields.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">**</span></a>/</p>
</dd>
<dt>private def getCustomFSFields(</dt><dd><p>userId: Long,
userOpt: Option[User],
deviceInfo: Option[DeviceInfo],
userForPushTargetingInfo: Option[UserForPushTargeting],
notifHistory: History,
requestSource: Option[RequestSource]</p>
</dd>
<dt>): Future[CustomFSFields] = {</dt><dd><p>val reactivationDateFutOpt: Future[Option[String]] = resurrectedUserStore.get(userId)
val reactivationTimeFutOpt: Future[Option[Time]] =</p>
<blockquote>
<div><p>reactivationDateFutOpt.map(_.map(dateStr =&gt; DateUtil.dateStrToTime(dateStr)))</p>
</div></blockquote>
<dl class="simple">
<dt>val isReactivatedUserFut: Future[Boolean] = reactivationTimeFutOpt.map { timeOpt =&gt;</dt><dd><dl class="simple">
<dt>timeOpt</dt><dd><p>.exists { time =&gt; Time.now - time &lt; 30.days }</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val daysSinceReactivationFut: Future[Option[Int]] =</dt><dd><p>reactivationTimeFutOpt.map(_.map(time =&gt; Time.now.since(time).inDays))</p>
</dd>
</dl>
<p>val daysSinceSignup: Int = (Time.now - SnowflakeUtil.timeFromId(userId)).inDays
if (daysSinceSignup &lt; 14) newSignUpUserStats.incr()</p>
<p>val targetAgeInYears = userOpt.flatMap(_.extendedProfile.flatMap(_.ageInYears))</p>
<dl>
<dt>val lastLoginFut: Future[Option[Long]] =</dt><dd><dl>
<dt>userHTLLastVisitStore.get(userId).map {</dt><dd><dl>
<dt>case Some(lastHTLVisitTimes) =&gt;</dt><dd><p>val latestHTLVisitTime = lastHTLVisitTimes.max
userForPushTargetingInfo.flatMap(</p>
<blockquote>
<div><dl class="simple">
<dt>_.lastActiveOnAppTimestamp</dt><dd><p>.map(_.max(latestHTLVisitTime)).orElse(Some(latestHTLVisitTime)))</p>
</dd>
</dl>
</div></blockquote>
</dd>
<dt>case None =&gt;</dt><dd><p>userForPushTargetingInfo.flatMap(_.lastActiveOnAppTimestamp)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>val daysSinceLoginFut = lastLoginFut.map {</dt><dd><dl>
<dt>_.map { lastLoginTimestamp =&gt;</dt><dd><p>val timeSinceLogin = Time.now - Time.fromMilliseconds(lastLoginTimestamp)
if (timeSinceLogin.inDays &gt; 21) {</p>
<blockquote>
<div><p>dormantUserCount.incr()</p>
</div></blockquote>
<p>}
timeSinceLogin.inDays</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>/* Could add more custom FS here <a href="#id3"><span class="problematic" id="id4">*</span></a>/
val userNSFWInfoFut: Future[Option[NsfwInfo]] =</p>
<blockquote>
<div><dl class="simple">
<dt>nsfwConsumerStore</dt><dd><p>.get(userId).map(_.map(nsfwUserSegmentation =&gt; NsfwInfo(nsfwUserSegmentation)))</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>val userStateFut: Future[Option[String]] = userFeatureStore.get(userId).map { userFeaturesOpt =&gt;</dt><dd><dl class="simple">
<dt>userFeaturesOpt.flatMap { uFeats =&gt;</dt><dd><p>uFeats.userState.map(uState =&gt; uState.name)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val mrUserStateFut: Future[Option[String]] =</dt><dd><dl>
<dt>mrUserStateStore.get(userId).map { mrUserStateOpt =&gt;</dt><dd><dl class="simple">
<dt>mrUserStateOpt.flatMap { mrUserState =&gt;</dt><dd><p>mrUserState.userState.map(_.name)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>Future</dt><dd><dl>
<dt>.join(</dt><dd><p>reactivationDateFutOpt,
isReactivatedUserFut,
userStateFut,
mrUserStateFut,
daysSinceLoginFut,
daysSinceReactivationFut,
userNSFWInfoFut</p>
</dd>
<dt>).map {</dt><dd><dl>
<dt>case (</dt><dd><blockquote>
<div><p>reactivationDate,
isReactivatedUser,
userState,
mrUserState,
daysSinceLogin,
daysSinceReactivation,
userNSFWInfo) =&gt;</p>
</div></blockquote>
<dl class="simple">
<dt>val numDaysReceivedPushInLast30Days: Int =</dt><dd><p>notifHistory.history.keys.map(_.inDays).toSet.size</p>
</dd>
</dl>
<p>NsfwPersonalizationUtil.computeNsfwUserStats(userNSFWInfo)</p>
<dl class="simple">
<dt>CustomFSFields(</dt><dd><p>isReactivatedUser,
daysSinceSignup,
numDaysReceivedPushInLast30Days,
daysSinceLogin,
daysSinceReactivation,
userOpt,
userState,
mrUserState,
reactivationDate,
requestSource.map(_.name),
targetAgeInYears,
userNSFWInfo,
deviceInfo</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/pushservice/src/main/scala/com/twitter/frigate/pushservice/target/PushTargetUserBuilder.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>