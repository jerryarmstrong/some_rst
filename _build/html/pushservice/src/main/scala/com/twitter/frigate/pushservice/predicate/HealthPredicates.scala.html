<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.frigate.pushservice.predicate</p>
<p>import com.twitter.abuse.detection.scoring.thriftscala.TweetScoringRequest
import com.twitter.abuse.detection.scoring.thriftscala.TweetScoringResponse
import com.twitter.abuse.detection.scoring.thriftscala.{Model =&gt; TweetHealthModel}
import com.twitter.finagle.stats.Counter
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.frigate.common.base._
import com.twitter.frigate.common.rec_types.RecTypes
import com.twitter.frigate.pushservice.model.PushTypes.PushCandidate
import com.twitter.frigate.pushservice.params.NsfwTextDetectionModel
import com.twitter.frigate.pushservice.params.PushConstants
import com.twitter.frigate.pushservice.params.PushFeatureSwitchParams
import com.twitter.frigate.pushservice.util.CandidateHydrationUtil
import com.twitter.frigate.pushservice.util.CandidateUtil
import com.twitter.frigate.pushservice.util.MediaAnnotationsUtil
import com.twitter.frigate.thriftscala.UserMediaRepresentation
import com.twitter.hermit.predicate.NamedPredicate
import com.twitter.hermit.predicate.Predicate
import com.twitter.hss.api.thriftscala.UserHealthSignal._
import com.twitter.hss.api.thriftscala.SignalValue
import com.twitter.hss.api.thriftscala.UserHealthSignalResponse
import com.twitter.storehaus.ReadableStore
import com.twitter.util.Future
import com.twitter.util.Time</p>
<p>object HealthPredicates {</p>
<blockquote>
<div><dl>
<dt>private val NsfwTextDetectionModelMap: Map[NsfwTextDetectionModel.Value, TweetHealthModel] =</dt><dd><dl class="simple">
<dt>Map(</dt><dd><p>NsfwTextDetectionModel.ProdModel -&gt; TweetHealthModel.PnsfwTweetText,
NsfwTextDetectionModel.RetrainedModel -&gt; TweetHealthModel.ExperimentalHealthModelScore1,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>private def tweetIsSupportedLanguage(</dt><dd><p>candidate: PushCandidate,
supportedLanguages: Set[String]</p>
</dd>
<dt>): Boolean = {</dt><dd><dl class="simple">
<dt>val tweetLanguage =</dt><dd><p>candidate.categoricalFeatures.getOrElse(“RecTweet.TweetyPieResult.Language”, “”)</p>
</dd>
</dl>
<p>supportedLanguages.contains(tweetLanguage)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def tweetHealthSignalScorePredicate(</dt><dd><p>tweetHealthScoreStore: ReadableStore[TweetScoringRequest, TweetScoringResponse],
applyToQuoteTweet: Boolean = false</p>
</dd>
<dt>)(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate with TweetCandidate with TweetDetails] = {</dt><dd><p>val name = “<a href="#id1"><span class="problematic" id="id2">tweet_health_signal_store_applyToQuoteTweet_</span></a>” + applyToQuoteTweet.toString
val scopedStatsReceiver = stats.scope(name)
val numCandidatesStats = scopedStatsReceiver.scope(“num_candidates”)
val numCandidatesMediaNsfwScoreStats = numCandidatesStats.scope(“media_nsfw_score”)</p>
<dl>
<dt>Predicate</dt><dd><dl>
<dt>.fromAsync { candidate: PushCandidate with TweetCandidate with TweetDetails =&gt;</dt><dd><p>numCandidatesStats.counter(“all”).incr()
val target = candidate.target
val tweetIdOpt = if (!applyToQuoteTweet) {</p>
<blockquote>
<div><p>Some(candidate.tweetId)</p>
</div></blockquote>
<p>} else candidate.tweetyPieResult.flatMap(_.quotedTweet.map(_.id))</p>
<dl>
<dt>tweetIdOpt match {</dt><dd><dl>
<dt>case Some(tweetId) =&gt;</dt><dd><dl>
<dt>val pMediaNsfwRequest =</dt><dd><p>TweetScoringRequest(tweetId, TweetHealthModel.ExperimentalHealthModelScore4)</p>
</dd>
<dt>tweetHealthScoreStore.get(pMediaNsfwRequest).map {</dt><dd><dl>
<dt>case Some(tweetScoringResponse) =&gt;</dt><dd><p>numCandidatesMediaNsfwScoreStats.counter(“non_empty”).incr()
val pMediaNsfwScore = tweetScoringResponse.score</p>
<dl class="simple">
<dt>if (!applyToQuoteTweet) {</dt><dd><dl class="simple">
<dt>candidate</dt><dd><p>.cacheExternalScore(“NsfwMediaProbability”, Future.value(Some(pMediaNsfwScore)))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val pMediaNsfwShouldBucket =</dt><dd><dl class="simple">
<dt>pMediaNsfwScore &gt; target.params(</dt><dd><p>PushFeatureSwitchParams.PnsfwTweetMediaBucketingThreshold)</p>
</dd>
</dl>
</dd>
<dt>if (CandidateUtil.shouldApplyHealthQualityFilters(</dt><dd><blockquote>
<div><p>candidate) &amp;&amp; pMediaNsfwShouldBucket) {</p>
</div></blockquote>
<p>numCandidatesMediaNsfwScoreStats.counter(“bucketed”).incr()
if (target.params(PushFeatureSwitchParams.PnsfwTweetMediaFilterOonOnly)</p>
<blockquote>
<div><p>&amp;&amp; !RecTypes.isOutOfNetworkTweetRecType(candidate.commonRecType)) {
true</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><dl>
<dt>val pMediaNsfwScoreThreshold =</dt><dd><dl class="simple">
<dt>if (applyToQuoteTweet)</dt><dd><p>target.params(PushFeatureSwitchParams.PnsfwQuoteTweetThreshold)</p>
</dd>
<dt>else if (candidate.hasPhoto)</dt><dd><p>target.params(PushFeatureSwitchParams.PnsfwTweetImageThreshold)</p>
</dd>
</dl>
<p>else target.params(PushFeatureSwitchParams.PnsfwTweetMediaThreshold)</p>
</dd>
<dt>candidate.cachePredicateInfo(</dt><dd><p>name + “_nsfwMedia”,
pMediaNsfwScore,
pMediaNsfwScoreThreshold,
pMediaNsfwScore &gt; pMediaNsfwScoreThreshold)</p>
</dd>
<dt>if (pMediaNsfwScore &gt; pMediaNsfwScoreThreshold) {</dt><dd><p>numCandidatesMediaNsfwScoreStats.counter(“filtered”).incr()
false</p>
</dd>
</dl>
<p>} else true</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>} else true</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>numCandidatesMediaNsfwScoreStats.counter(“empty”).incr()
if (candidate.hasPhoto || candidate.hasVideo) {</p>
<blockquote>
<div><p>numCandidatesMediaNsfwScoreStats.counter(“media_tweet_with_empty_score”).incr()</p>
</div></blockquote>
<p>}
true</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>case _ =&gt; Future.True</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.withStats(stats.scope(s”predicate_$name”))
.withName(name)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def healthSignalScoreSpammyTweetPredicate(</dt><dd><p>tweetHealthScoreStore: ReadableStore[TweetScoringRequest, TweetScoringResponse]</p>
</dd>
<dt>)(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate with TweetCandidate with TweetDetails] = {</dt><dd><p>val name = “health_signal_store_spammy_tweet”
val statsScope = stats.scope(name)
val allCandidatesCounter = statsScope.counter(“all_candidates”)
val eligibleCandidatesCounter = statsScope.counter(“eligible_candidates”)
val oonCandidatesCounter = statsScope.counter(“oon_candidates”)
val inCandidatesCounter = statsScope.counter(“in_candidates”)
val bucketedCandidatesCounter = statsScope.counter(“num_bucketed”)
val nonEmptySpamScoreCounter = statsScope.counter(“non_empty_spam_score”)
val filteredOonCandidatesCounter = statsScope.counter(“num_filtered_oon”)
val filteredInCandidatesCounter = statsScope.counter(“num_filtered_in”)</p>
<dl>
<dt>Predicate</dt><dd><dl>
<dt>.fromAsync { candidate: PushCandidate with TweetCandidate with TweetDetails =&gt;</dt><dd><p>allCandidatesCounter.incr()
val crt = candidate.commonRecType
val isOonCandidate = RecTypes.isOutOfNetworkTweetRecType(crt) ||</p>
<blockquote>
<div><p>RecTypes.outOfNetworkTopicTweetTypes.contains(crt)</p>
</div></blockquote>
<dl class="simple">
<dt>if (isOonCandidate) {</dt><dd><p>oonCandidatesCounter.incr()</p>
</dd>
</dl>
<p>}
val target = candidate.target
if (target.params(PushFeatureSwitchParams.EnableSpammyTweetFilter)) {</p>
<blockquote>
<div><p>eligibleCandidatesCounter.incr()
val tweetSpamScore =</p>
<blockquote>
<div><p>TweetScoringRequest(candidate.tweetId, TweetHealthModel.SpammyTweetContent)</p>
</div></blockquote>
<dl>
<dt>tweetHealthScoreStore.get(tweetSpamScore).map {</dt><dd><dl>
<dt>case (Some(tweetScoringResponse)) =&gt;</dt><dd><p>nonEmptySpamScoreCounter.incr()
val candidateSpamScore = tweetScoringResponse.score</p>
<dl>
<dt>candidate</dt><dd><p>.cacheExternalScore(“SpammyTweetScore”, Future.value(Some(candidateSpamScore)))</p>
</dd>
<dt>val tweetSpamShouldBucket =</dt><dd><dl class="simple">
<dt>candidateSpamScore &gt; target.params(</dt><dd><p>PushFeatureSwitchParams.SpammyTweetBucketingThreshold)</p>
</dd>
</dl>
</dd>
<dt>if (CandidateUtil.shouldApplyHealthQualityFilters(</dt><dd><blockquote>
<div><p>candidate) &amp;&amp; tweetSpamShouldBucket) {</p>
</div></blockquote>
<p>bucketedCandidatesCounter.incr()
if (isOonCandidate) {</p>
<blockquote>
<div><dl class="simple">
<dt>val spamScoreThreshold =</dt><dd><p>target.params(PushFeatureSwitchParams.SpammyTweetOonThreshold)</p>
</dd>
<dt>if (candidateSpamScore &gt; spamScoreThreshold) {</dt><dd><p>filteredOonCandidatesCounter.incr()
false</p>
</dd>
</dl>
<p>} else true</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>inCandidatesCounter.incr()
val spamScoreThreshold =</p>
<blockquote>
<div><p>target.params(PushFeatureSwitchParams.SpammyTweetInThreshold)</p>
</div></blockquote>
<dl class="simple">
<dt>if (candidateSpamScore &gt; spamScoreThreshold) {</dt><dd><p>filteredInCandidatesCounter.incr()
false</p>
</dd>
</dl>
<p>} else true</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>} else true</p>
</dd>
</dl>
<p>case _ =&gt; true</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>} else Future.True</p>
</dd>
</dl>
<p>}
.withStats(stats.scope(s”predicate_$name”))
.withName(name)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def healthSignalScorePnsfwTweetTextPredicate(</dt><dd><p>tweetHealthScoreStore: ReadableStore[TweetScoringRequest, TweetScoringResponse]</p>
</dd>
<dt>)(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate with TweetCandidate] = {</dt><dd><p>val name = “health_signal_store_pnsfw_tweet_text”
val statsScope = stats.scope(name)
val allCandidatesCounter = statsScope.counter(“all_candidates”)
val nonEmptyNsfwTextScoreNum = statsScope.counter(“non_empty_nsfw_text_score”)
val filteredCounter = statsScope.counter(“num_filtered”)
val lowScoreCounter = statsScope.counter(“low_score_count”)</p>
<dl>
<dt>Predicate</dt><dd><dl>
<dt>.fromAsync { candidate: PushCandidate with TweetCandidate =&gt;</dt><dd><p>val target = candidate.target
val predEnabled =</p>
<blockquote>
<div><p>target.params(PushFeatureSwitchParams.EnableHealthSignalStorePnsfwTweetTextPredicate)</p>
</div></blockquote>
<dl>
<dt>if (CandidateUtil.shouldApplyHealthQualityFilters(</dt><dd><blockquote>
<div><p>candidate) &amp;&amp; predEnabled &amp;&amp; tweetIsSupportedLanguage(candidate, Set(“”))) {</p>
</div></blockquote>
<p>allCandidatesCounter.incr()
val pnsfwTextRequest =</p>
<blockquote>
<div><p>TweetScoringRequest(candidate.tweetId, TweetHealthModel.PnsfwTweetText)</p>
</div></blockquote>
<dl>
<dt>tweetHealthScoreStore.get(pnsfwTextRequest).flatMap {</dt><dd><dl>
<dt>case Some(tweetScoringResponse) =&gt; {</dt><dd><p>nonEmptyNsfwTextScoreNum.incr()
if (tweetScoringResponse.score &lt; 1e-8) {</p>
<blockquote>
<div><p>lowScoreCounter.incr()</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>candidate</dt><dd><dl class="simple">
<dt>.cacheExternalScore(</dt><dd><p>“NsfwTextProbability-en”,
Future.value(Some(tweetScoringResponse.score)))</p>
</dd>
</dl>
</dd>
</dl>
<p>val threshold = target.params(PushFeatureSwitchParams.PnsfwTweetTextThreshold)
candidate.cachePredicateInfo(</p>
<blockquote>
<div><p>name,
tweetScoringResponse.score,
threshold,
tweetScoringResponse.score &gt; threshold)</p>
</div></blockquote>
<dl class="simple">
<dt>if (tweetScoringResponse.score &gt; threshold) {</dt><dd><p>filteredCounter.incr()
Future.False</p>
</dd>
</dl>
<p>} else Future.True</p>
</dd>
</dl>
<p>}
case _ =&gt; Future.True</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>} else Future.True</p>
</dd>
</dl>
<p>}
.withStats(stats.scope(s”predicate_$name”))
.withName(name)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def healthSignalScoreMultilingualPnsfwTweetTextPredicate(</dt><dd><p>tweetHealthScoreStore: ReadableStore[TweetScoringRequest, TweetScoringResponse]</p>
</dd>
<dt>)(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate with TweetCandidate] = {</dt><dd><p>val name = “health_signal_store_multilingual_pnsfw_tweet_text”
val statsScope = stats.scope(name)</p>
<p>val allLanguagesIdentifier = “all”
val languagesSelectedForStats =</p>
<blockquote>
<div><p>Set(“”) + allLanguagesIdentifier</p>
</div></blockquote>
<dl class="simple">
<dt>val candidatesCounterMap: Map[String, Counter] = languagesSelectedForStats.map { lang =&gt;</dt><dd><p>lang -&gt; statsScope.counter(f”candidates_$lang”)</p>
</dd>
</dl>
<p>}.toMap
val nonEmptyHealthScoreMap: Map[String, Counter] = languagesSelectedForStats.map { lang =&gt;</p>
<blockquote>
<div><p>lang -&gt; statsScope.counter(f”non_empty_health_score_$lang”)</p>
</div></blockquote>
<p>}.toMap
val emptyHealthScoreMap: Map[String, Counter] = languagesSelectedForStats.map { lang =&gt;</p>
<blockquote>
<div><p>lang -&gt; statsScope.counter(f”empty_health_score_$lang”)</p>
</div></blockquote>
<p>}.toMap
val bucketedCounterMap: Map[String, Counter] = languagesSelectedForStats.map { lang =&gt;</p>
<blockquote>
<div><p>lang -&gt; statsScope.counter(f”num_candidates_bucketed_$lang”)</p>
</div></blockquote>
<p>}.toMap
val filteredCounterMap: Map[String, Counter] = languagesSelectedForStats.map { lang =&gt;</p>
<blockquote>
<div><p>lang -&gt; statsScope.counter(f”num_filtered_$lang”)</p>
</div></blockquote>
<p>}.toMap
val lowScoreCounterMap: Map[String, Counter] = languagesSelectedForStats.map { lang =&gt;</p>
<blockquote>
<div><p>lang -&gt; statsScope.counter(f”low_score_count_$lang”)</p>
</div></blockquote>
<p>}.toMap</p>
<p>val wrongBucketingModelCounter = statsScope.counter(“wrong_bucketing_model_count”)
val wrongDetectionModelCounter = statsScope.counter(“wrong_detection_model_count”)</p>
<dl>
<dt>def increaseCounterForLanguage(counterMap: Map[String, Counter], language: String): Unit = {</dt><dd><dl class="simple">
<dt>counterMap.get(allLanguagesIdentifier) match {</dt><dd><p>case Some(counter) =&gt; counter.incr()
case _ =&gt;</p>
</dd>
</dl>
<p>}
counterMap.get(language) match {</p>
<blockquote>
<div><p>case Some(counter) =&gt; counter.incr()
case _ =&gt;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>Predicate</dt><dd><dl>
<dt>.fromAsync { candidate: PushCandidate with TweetCandidate =&gt;</dt><dd><p>val target = candidate.target</p>
<p>val languageFeatureName = “RecTweet.TweetyPieResult.Language”</p>
<dl>
<dt>lazy val isPredicateEnabledForTarget = target.params(</dt><dd><p>PushFeatureSwitchParams.EnableHealthSignalStoreMultilingualPnsfwTweetTextPredicate)</p>
</dd>
<dt>lazy val targetNsfwTextDetectionModel: NsfwTextDetectionModel.Value =</dt><dd><p>target.params(PushFeatureSwitchParams.MultilingualPnsfwTweetTextModel)</p>
</dd>
<dt>lazy val targetPredicateSupportedLanguageSeq: Seq[String] =</dt><dd><p>target.params(PushFeatureSwitchParams.MultilingualPnsfwTweetTextSupportedLanguages)</p>
</dd>
<dt>lazy val bucketingModelSeq: Seq[NsfwTextDetectionModel.Value] =</dt><dd><p>target.params(PushFeatureSwitchParams.MultilingualPnsfwTweetTextBucketingModelList)</p>
</dd>
<dt>lazy val bucketingThresholdPerLanguageSeq: Seq[Double] =</dt><dd><p>target.params(PushFeatureSwitchParams.MultilingualPnsfwTweetTextBucketingThreshold)</p>
</dd>
<dt>lazy val filteringThresholdPerLanguageSeq: Seq[Double] =</dt><dd><p>target.params(PushFeatureSwitchParams.MultilingualPnsfwTweetTextFilteringThreshold)</p>
</dd>
<dt>if (CandidateUtil.shouldApplyHealthQualityFilters(</dt><dd><blockquote>
<div><p>candidate) &amp;&amp; isPredicateEnabledForTarget) {</p>
</div></blockquote>
<dl class="simple">
<dt>val candidateLanguage =</dt><dd><p>candidate.categoricalFeatures.getOrElse(languageFeatureName, “”)</p>
</dd>
<dt>val indexOfCandidateLanguage =</dt><dd><p>targetPredicateSupportedLanguageSeq.indexOf(candidateLanguage)</p>
</dd>
</dl>
<p>val isCandidateLanguageSupported = indexOfCandidateLanguage &gt;= 0</p>
<dl>
<dt>if (isCandidateLanguageSupported) {</dt><dd><p>increaseCounterForLanguage(candidatesCounterMap, candidateLanguage)</p>
<dl>
<dt>val bucketingModelScoreMap: Map[NsfwTextDetectionModel.Value, Future[Option[Double]]] =</dt><dd><dl>
<dt>bucketingModelSeq.map { modelName =&gt;</dt><dd><dl>
<dt>NsfwTextDetectionModelMap.get(modelName) match {</dt><dd><dl>
<dt>case Some(targetNsfwTextDetectionModel) =&gt;</dt><dd><dl class="simple">
<dt>val pnsfwTweetTextRequest: TweetScoringRequest =</dt><dd><p>TweetScoringRequest(candidate.tweetId, targetNsfwTextDetectionModel)</p>
</dd>
<dt>val scoreOptFut: Future[Option[Double]] =</dt><dd><p>tweetHealthScoreStore.get(pnsfwTweetTextRequest).map(_.map(_.score))</p>
</dd>
<dt>candidate</dt><dd><p>.cacheExternalScore(“NsfwTextProbability”, scoreOptFut)</p>
</dd>
</dl>
<p>modelName -&gt; scoreOptFut</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>wrongBucketingModelCounter.incr()
modelName -&gt; Future.None</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}.toMap</p>
</dd>
<dt>val candidateLanguageBucketingThreshold =</dt><dd><p>bucketingThresholdPerLanguageSeq(indexOfCandidateLanguage)</p>
</dd>
<dt>val userShouldBeBucketedFut: Future[Boolean] =</dt><dd><dl>
<dt>Future</dt><dd><dl>
<dt>.collect(bucketingModelScoreMap.map {</dt><dd><dl>
<dt>case (_, modelScoreOptFut) =&gt;</dt><dd><dl class="simple">
<dt>modelScoreOptFut.map {</dt><dd><dl class="simple">
<dt>case Some(score) =&gt;</dt><dd><p>increaseCounterForLanguage(nonEmptyHealthScoreMap, candidateLanguage)
score &gt; candidateLanguageBucketingThreshold</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>increaseCounterForLanguage(emptyHealthScoreMap, candidateLanguage)
false</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}.toSeq).map(_.contains(true))</p>
</dd>
</dl>
</dd>
<dt>val candidateShouldBeFilteredFut: Future[Boolean] = userShouldBeBucketedFut.flatMap {</dt><dd><dl>
<dt>userShouldBeBucketed =&gt;</dt><dd><dl>
<dt>if (userShouldBeBucketed) {</dt><dd><p>increaseCounterForLanguage(bucketedCounterMap, candidateLanguage)</p>
<dl>
<dt>val candidateLanguageFilteringThreshold =</dt><dd><p>filteringThresholdPerLanguageSeq(indexOfCandidateLanguage)</p>
</dd>
<dt>bucketingModelScoreMap.get(targetNsfwTextDetectionModel) match {</dt><dd><dl>
<dt>case Some(scoreOptFut) =&gt;</dt><dd><dl>
<dt>scoreOptFut.map {</dt><dd><dl>
<dt>case Some(score) =&gt;</dt><dd><dl class="simple">
<dt>val candidateShouldBeFiltered =</dt><dd><p>score &gt; candidateLanguageFilteringThreshold</p>
</dd>
<dt>if (candidateShouldBeFiltered) {</dt><dd><p>increaseCounterForLanguage(filteredCounterMap, candidateLanguage)</p>
</dd>
</dl>
<p>}
candidateShouldBeFiltered</p>
</dd>
</dl>
<p>case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>wrongDetectionModelCounter.incr()
Future.False</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>increaseCounterForLanguage(lowScoreCounterMap, candidateLanguage)
Future.False</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}
candidateShouldBeFilteredFut.map(result =&gt; !result)</p>
</dd>
</dl>
<p>} else Future.True</p>
</dd>
</dl>
<p>} else Future.True</p>
</dd>
</dl>
<p>}
.withStats(stats.scope(s”predicate_$name”))
.withName(name)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>def authorProfileBasedPredicate(
)(</p>
<blockquote>
<div><p>implicit stats: StatsReceiver</p>
</div></blockquote>
<dl>
<dt>): NamedPredicate[PushCandidate with TweetCandidate] = {</dt><dd><p>val name = “author_profile”
val statsScope = stats.scope(name)
val filterByNsfwToken = statsScope.counter(“filter_by_nsfw_token”)
val filterByAccountAge = statsScope.counter(“filter_by_account_age”)</p>
<dl>
<dt>Predicate</dt><dd><dl>
<dt>.fromAsync { candidate: PushCandidate with TweetCandidate =&gt;</dt><dd><p>val target = candidate.target
candidate match {</p>
<blockquote>
<div><dl>
<dt>case cand: PushCandidate with TweetAuthorDetails =&gt;</dt><dd><dl>
<dt>cand.tweetAuthor.map {</dt><dd><dl>
<dt>case Some(author) =&gt;</dt><dd><p>val nsfwTokens = target.params(PushFeatureSwitchParams.NsfwTokensParam)
val accountAgeInHours =</p>
<blockquote>
<div><p>(Time.now - Time.fromMilliseconds(author.createdAtMsec)).inHours</p>
</div></blockquote>
<p>val isNsfwAccount = CandidateHydrationUtil.isNsfwAccount(author, nsfwTokens)
val isVerified = author.safety.map(_.verified).getOrElse(false)</p>
<dl>
<dt>if (CandidateUtil.shouldApplyHealthQualityFilters(candidate) &amp;&amp; !isVerified) {</dt><dd><dl class="simple">
<dt>val enableNsfwTokenCheck =</dt><dd><p>target.params(PushFeatureSwitchParams.EnableNsfwTokenBasedFiltering)</p>
</dd>
<dt>val minimumAllowedAge =</dt><dd><p>target.params(PushFeatureSwitchParams.MinimumAllowedAuthorAccountAgeInHours)</p>
</dd>
<dt>cand.cachePredicateInfo(</dt><dd><p>name + “_nsfwToken”,
if (isNsfwAccount) 1.0 else 0.0,
0.0,
enableNsfwTokenCheck &amp;&amp; isNsfwAccount)</p>
</dd>
<dt>cand.cachePredicateInfo(</dt><dd><p>name + “_authorAge”,
accountAgeInHours,
minimumAllowedAge,
accountAgeInHours &lt; minimumAllowedAge)</p>
</dd>
<dt>if (enableNsfwTokenCheck &amp;&amp; isNsfwAccount) {</dt><dd><p>filterByNsfwToken.incr()
false</p>
</dd>
<dt>} else if (accountAgeInHours &lt; minimumAllowedAge) {</dt><dd><p>filterByAccountAge.incr()
false</p>
</dd>
</dl>
<p>} else true</p>
</dd>
</dl>
<p>} else true</p>
</dd>
</dl>
<p>case _ =&gt; true</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>case _ =&gt; Future.value(true)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
.withStats(stats.scope(s”predicate_$name”))
.withName(name)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def authorSensitiveMediaPredicate(</dt><dd><p>producerMediaRepresentationStore: ReadableStore[Long, UserMediaRepresentation]</p>
</dd>
<dt>)(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate with TweetAuthor] = {</dt><dd><p>val name = “author_sensitive_media_mrtwistly”
val statsScope = stats.scope(name)
val enableQueryNum = statsScope.counter(“enable_query”)
val nonEmptyMediaRepresentationNum = statsScope.counter(“non_empty_media_representation”)
val filteredOON = statsScope.counter(“filtered_oon”)</p>
<dl>
<dt>Predicate</dt><dd><dl>
<dt>.fromAsync { candidate: PushCandidate with TweetAuthor =&gt;</dt><dd><p>val target = candidate.target
val useAggressiveThresholds = CandidateUtil.useAggressiveHealthThresholds(candidate)</p>
<dl>
<dt>if (CandidateUtil.shouldApplyHealthQualityFilters(candidate) &amp;&amp;</dt><dd><p>RecTypes.isOutOfNetworkTweetRecType(candidate.commonRecType) &amp;&amp;
target.params(PushFeatureSwitchParams.EnableQueryAuthorMediaRepresentationStore)) {
enableQueryNum.incr()</p>
<dl>
<dt>candidate.authorId match {</dt><dd><dl>
<dt>case Some(authorId) =&gt;</dt><dd><dl>
<dt>producerMediaRepresentationStore.get(authorId).map {</dt><dd><dl>
<dt>case Some(mediaRepresentation) =&gt;</dt><dd><p>nonEmptyMediaRepresentationNum.incr()
val sumScore: Double = mediaRepresentation.mediaRepresentation.values.sum
val nudityScore: Double = mediaRepresentation.mediaRepresentation</p>
<blockquote>
<div><p>.getOrElse(MediaAnnotationsUtil.nudityCategoryId, 0.0)</p>
</div></blockquote>
<p>val nudityRate = if (sumScore &gt; 0) nudityScore / sumScore else 0.0</p>
<dl class="simple">
<dt>candidate</dt><dd><p>.cacheExternalScore(“AuthorNudityScore”, Future.value(Some(nudityScore)))</p>
</dd>
</dl>
<p>candidate.cacheExternalScore(“AuthorNudityRate”, Future.value(Some(nudityRate)))</p>
<dl class="simple">
<dt>val threshold = if (useAggressiveThresholds) {</dt><dd><dl class="simple">
<dt>target.params(</dt><dd><p>PushFeatureSwitchParams.AuthorSensitiveMediaFilteringThresholdForMrTwistly)</p>
</dd>
</dl>
</dd>
<dt>} else {</dt><dd><p>target.params(PushFeatureSwitchParams.AuthorSensitiveMediaFilteringThreshold)</p>
</dd>
</dl>
<p>}
candidate.cachePredicateInfo(</p>
<blockquote>
<div><p>name,
nudityRate,
threshold,
nudityRate &gt; threshold,
Some(Map[String, Double](“sumScore” -&gt; sumScore, “nudityScore” -&gt; nudityScore)))</p>
</div></blockquote>
<dl class="simple">
<dt>if (nudityRate &gt; threshold) {</dt><dd><p>filteredOON.incr()
false</p>
</dd>
</dl>
<p>} else true</p>
</dd>
</dl>
<p>case _ =&gt; true</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>case _ =&gt; Future.True</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>Future.True</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.withStats(stats.scope(s”predicate_$name”))
.withName(name)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>def sensitiveMediaCategoryPredicate(
)(</p>
<blockquote>
<div><p>implicit stats: StatsReceiver</p>
</div></blockquote>
<dl>
<dt>): NamedPredicate[PushCandidate with TweetCandidate] = {</dt><dd><p>val name = “sensitive_media_category”
val tweetMediaAnnotationFeature =</p>
<blockquote>
<div><p>“tweet.mediaunderstanding.tweet_annotations.sensitive_category_probabilities”</p>
</div></blockquote>
<p>val scopedStatsReceiver = stats.scope(name)
val allCandidatesCounter = scopedStatsReceiver.counter(“all_candidates”)
val nonZeroNudityCandidatesCounter = scopedStatsReceiver.counter(“non_zero_nudity_candidates”)
val nudityScoreStats = scopedStatsReceiver.stat(“nudity_scores”)</p>
<dl>
<dt>Predicate</dt><dd><dl>
<dt>.fromAsync { candidate: PushCandidate =&gt;</dt><dd><p>allCandidatesCounter.incr()
val target = candidate.target
val nudityScore = candidate.sparseContinuousFeatures</p>
<blockquote>
<div><dl class="simple">
<dt>.getOrElse(tweetMediaAnnotationFeature, Map.empty[String, Double]).getOrElse(</dt><dd><p>MediaAnnotationsUtil.nudityCategoryId,
0.0)</p>
</dd>
</dl>
</div></blockquote>
<p>if (nudityScore &gt; 0) nonZeroNudityCandidatesCounter.incr()
nudityScoreStats.add(nudityScore.toFloat)
val threshold =</p>
<blockquote>
<div><p>target.params(PushFeatureSwitchParams.TweetMediaSensitiveCategoryThresholdParam)</p>
</div></blockquote>
<p>candidate.cachePredicateInfo(name, nudityScore, threshold, nudityScore &gt; threshold)
if (CandidateUtil.shouldApplyHealthQualityFilters(candidate) &amp;&amp; nudityScore &gt; threshold) {</p>
<blockquote>
<div><p>Future.False</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>Future.True</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.withStats(stats.scope(s”predicate_$name”))
.withName(name)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>def profanityPredicate(
)(</p>
<blockquote>
<div><p>implicit stats: StatsReceiver</p>
</div></blockquote>
<dl>
<dt>): NamedPredicate[PushCandidate with TweetCandidate] = {</dt><dd><p>val name = “profanity_filter”
val scopedStatsReceiver = stats.scope(name)
val allCandidatesCounter = scopedStatsReceiver.counter(“all_candidates”)</p>
<dl>
<dt>Predicate</dt><dd><dl>
<dt>.fromAsync { candidate: PushCandidate =&gt;</dt><dd><p>allCandidatesCounter.incr()
val target = candidate.target</p>
<dl class="simple">
<dt>lazy val enableFilter =</dt><dd><p>target.params(PushFeatureSwitchParams.EnableProfanityFilterParam)</p>
</dd>
<dt>val tweetSemanticCoreIds = candidate.sparseBinaryFeatures</dt><dd><p>.getOrElse(PushConstants.TweetSemanticCoreIdFeature, Set.empty[String])</p>
</dd>
<dt>if (CandidateUtil.shouldApplyHealthQualityFilters(candidate) &amp;&amp;</dt><dd><p>tweetSemanticCoreIds.contains(PushConstants.ProfanityFilter_Id) &amp;&amp; enableFilter) {
Future.False</p>
</dd>
<dt>} else {</dt><dd><p>Future.True</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.withStats(stats.scope(s”predicate_$name”))
.withName(name)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>def agathaAbusiveTweetAuthorPredicateMrTwistly(
)(</p>
<blockquote>
<div><p>implicit stats: StatsReceiver</p>
</div></blockquote>
<dl>
<dt>): NamedPredicate[PushCandidate with OutOfNetworkTweetCandidate] = {</dt><dd><p>val name = “agatha_abusive_tweet_author_mr_twistly”
val scopedStatsReceiver = stats.scope(name)
val allCandidatesCounter = scopedStatsReceiver.counter(“all_candidates”)
val isMrBackfillCRCandidateCounter = scopedStatsReceiver.counter(“isMrBackfillCR_candidates”)
Predicate</p>
<blockquote>
<div><dl>
<dt>.fromAsync { cand: PushCandidate with OutOfNetworkTweetCandidate =&gt;</dt><dd><p>allCandidatesCounter.incr()
val target = cand.target
val tweetSemanticCoreIds = cand.sparseBinaryFeatures</p>
<blockquote>
<div><p>.getOrElse(PushConstants.TweetSemanticCoreIdFeature, Set.empty[String])</p>
</div></blockquote>
<dl class="simple">
<dt>val hasAbuseStrikeTop2Percent =</dt><dd><p>tweetSemanticCoreIds.contains(PushConstants.AbuseStrike_Top2Percent_Id)</p>
</dd>
<dt>val hasAbuseStrikeTop1Percent =</dt><dd><p>tweetSemanticCoreIds.contains(PushConstants.AbuseStrike_Top1Percent_Id)</p>
</dd>
<dt>val hasAbuseStrikeTop05Percent =</dt><dd><p>tweetSemanticCoreIds.contains(PushConstants.AbuseStrike_Top05Percent_Id)</p>
</dd>
<dt>if (hasAbuseStrikeTop2Percent) {</dt><dd><p>scopedStatsReceiver.counter(“abuse_strike_top_2_percent_candidates”).incr()</p>
</dd>
</dl>
<p>}
if (hasAbuseStrikeTop1Percent) {</p>
<blockquote>
<div><p>scopedStatsReceiver.counter(“abuse_strike_top_1_percent_candidates”).incr()</p>
</div></blockquote>
<p>}
if (hasAbuseStrikeTop05Percent) {</p>
<blockquote>
<div><p>scopedStatsReceiver.counter(“abuse_strike_top_05_percent_candidates”).incr()</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>if (CandidateUtil.shouldApplyHealthQualityFilters(cand) &amp;&amp; cand.isMrBackfillCR.getOrElse(</dt><dd><blockquote>
<div><p>false)) {</p>
</div></blockquote>
<p>isMrBackfillCRCandidateCounter.incr()
if (hasAbuseStrikeTop2Percent) {</p>
<blockquote>
<div><dl>
<dt>if (target.params(</dt><dd><blockquote>
<div><p>PushFeatureSwitchParams.EnableAbuseStrikeTop2PercentFilterSimCluster) &amp;&amp; hasAbuseStrikeTop2Percent ||</p>
</div></blockquote>
<dl class="simple">
<dt>target.params(</dt><dd><p>PushFeatureSwitchParams.EnableAbuseStrikeTop1PercentFilterSimCluster) &amp;&amp; hasAbuseStrikeTop1Percent ||</p>
</dd>
<dt>target.params(</dt><dd><p>PushFeatureSwitchParams.EnableAbuseStrikeTop05PercentFilterSimCluster) &amp;&amp; hasAbuseStrikeTop05Percent) {</p>
</dd>
</dl>
<p>Future.False</p>
</dd>
<dt>} else {</dt><dd><p>Future.True</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>Future.True</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>} else Future.True</p>
</dd>
</dl>
<p>}
.withStats(stats.scope(s”predicate_$name”))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def userHealthSignalsPredicate(</dt><dd><p>userHealthSignalStore: ReadableStore[Long, UserHealthSignalResponse]</p>
</dd>
<dt>)(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[PushCandidate with TweetDetails] = {</dt><dd><p>val name = “agatha_user_health_model_score”
val scopedStatsReceiver = stats.scope(name)
val allCandidatesCounter = scopedStatsReceiver.counter(“all_candidates”)
val bucketedUserCandidatesCounter =</p>
<blockquote>
<div><p>scopedStatsReceiver.counter(“bucketed_user_candidates”)</p>
</div></blockquote>
<p>val filteredOON = scopedStatsReceiver.counter(“filtered_oon”)</p>
<dl>
<dt>Predicate</dt><dd><dl>
<dt>.fromAsync { candidate: PushCandidate with TweetDetails =&gt;</dt><dd><p>allCandidatesCounter.incr()
val target = candidate.target
val useAggressiveThresholds = CandidateUtil.useAggressiveHealthThresholds(candidate)</p>
<dl>
<dt>if (CandidateUtil.shouldApplyHealthQualityFilters(candidate) &amp;&amp; target.params(</dt><dd><blockquote>
<div><p>PushFeatureSwitchParams.EnableAgathaUserHealthModelPredicate)) {</p>
</div></blockquote>
<dl>
<dt>val healthSignalsResponseFutOpt: Future[Option[UserHealthSignalResponse]] =</dt><dd><dl class="simple">
<dt>candidate.authorId match {</dt><dd><p>case Some(authorId) =&gt; userHealthSignalStore.get(authorId)
case _ =&gt; Future.None</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>healthSignalsResponseFutOpt.map {</dt><dd><dl>
<dt>case Some(response) =&gt;</dt><dd><dl>
<dt>val agathaRecentAbuseStrikeScore: Double = userHealthSignalValueToDouble(</dt><dd><dl class="simple">
<dt>response.signalValues</dt><dd><p>.getOrElse(AgathaRecentAbuseStrikeDouble, SignalValue.DoubleValue(0.0)))</p>
</dd>
</dl>
</dd>
<dt>val agathaCalibratedNSFWScore: Double = userHealthSignalValueToDouble(</dt><dd><dl class="simple">
<dt>response.signalValues</dt><dd><p>.getOrElse(AgathaCalibratedNsfwDouble, SignalValue.DoubleValue(0.0)))</p>
</dd>
</dl>
</dd>
<dt>val agathaTextNSFWScore: Double = userHealthSignalValueToDouble(response.signalValues</dt><dd><p>.getOrElse(NsfwTextUserScoreDouble, SignalValue.DoubleValue(0.0)))</p>
</dd>
<dt>candidate</dt><dd><dl class="simple">
<dt>.cacheExternalScore(</dt><dd><p>“agathaRecentAbuseStrikeScore”,
Future.value(Some(agathaRecentAbuseStrikeScore)))</p>
</dd>
</dl>
</dd>
<dt>candidate</dt><dd><dl class="simple">
<dt>.cacheExternalScore(</dt><dd><p>“agathaCalibratedNSFWScore”,
Future.value(Some(agathaCalibratedNSFWScore)))</p>
</dd>
</dl>
</dd>
<dt>candidate</dt><dd><p>.cacheExternalScore(“agathaTextNSFWScore”, Future.value(Some(agathaTextNSFWScore)))</p>
</dd>
<dt>val NSFWShouldBucket = agathaCalibratedNSFWScore &gt; target.params(</dt><dd><p>PushFeatureSwitchParams.AgathaCalibratedNSFWBucketThreshold)</p>
</dd>
<dt>val textNSFWShouldBucket = agathaTextNSFWScore &gt; target.params(</dt><dd><p>PushFeatureSwitchParams.AgathaTextNSFWBucketThreshold)</p>
</dd>
<dt>if (NSFWShouldBucket || textNSFWShouldBucket) {</dt><dd><p>bucketedUserCandidatesCounter.incr()
if (NSFWShouldBucket) {</p>
<blockquote>
<div><p>scopedStatsReceiver.counter(“calibrated_nsfw_bucketed_user_candidates”).incr()</p>
</div></blockquote>
<p>}
if (textNSFWShouldBucket) {</p>
<blockquote>
<div><p>scopedStatsReceiver.counter(“text_nsfw_bucketed_user_candidates”).incr()</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>val (thresholdAgathaNsfw, thresholdTextNsfw) = if (useAggressiveThresholds) {</dt><dd><dl class="simple">
<dt>(</dt><dd><dl class="simple">
<dt>target.params(</dt><dd><p>PushFeatureSwitchParams.AgathaCalibratedNSFWThresholdForMrTwistly),</p>
</dd>
<dt>target</dt><dd><p>.params(PushFeatureSwitchParams.AgathaTextNSFWThresholdForMrTwistly))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>(</dt><dd><p>target.params(PushFeatureSwitchParams.AgathaCalibratedNSFWThreshold),
target.params(PushFeatureSwitchParams.AgathaTextNSFWThreshold))</p>
</dd>
</dl>
</dd>
</dl>
<p>}
candidate.cachePredicateInfo(</p>
<blockquote>
<div><p>name + “_agathaNsfw”,
agathaCalibratedNSFWScore,
thresholdAgathaNsfw,
agathaCalibratedNSFWScore &gt; thresholdAgathaNsfw)</p>
</div></blockquote>
<dl class="simple">
<dt>candidate.cachePredicateInfo(</dt><dd><p>name + “_authorTextNsfw”,
agathaTextNSFWScore,
thresholdTextNsfw,
agathaTextNSFWScore &gt; thresholdTextNsfw)</p>
</dd>
<dt>if ((agathaCalibratedNSFWScore &gt; thresholdAgathaNsfw) ||</dt><dd><p>(agathaTextNSFWScore &gt; thresholdTextNsfw)) {
filteredOON.incr()
false</p>
</dd>
</dl>
<p>} else true</p>
</dd>
<dt>} else {</dt><dd><p>true</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>case _ =&gt; true</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>Future.True</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.withStats(stats.scope(s”predicate_$name”))
.withName(name)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def userHealthSignalValueToDouble(signalValue: SignalValue): Double = {</dt><dd><dl class="simple">
<dt>signalValue match {</dt><dd><p>case SignalValue.DoubleValue(value) =&gt; value
case _ =&gt; throw new Exception(f”Could not convert signal value to double”)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/pushservice/src/main/scala/com/twitter/frigate/pushservice/predicate/HealthPredicates.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>