<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.frigate.pushservice.predicate</p>
<p>import com.twitter.conversions.DurationOps._
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.frigate.common.base.TargetUser
import com.twitter.frigate.common.candidate.FrigateHistory
import com.twitter.frigate.common.candidate.HTLVisitHistory
import com.twitter.frigate.common.candidate.TargetABDecider
import com.twitter.frigate.common.candidate.UserDetails
import com.twitter.frigate.common.predicate.TargetUserPredicates
import com.twitter.frigate.common.predicate.{FatiguePredicate =&gt; CommonFatiguePredicate}
import com.twitter.frigate.common.store.deviceinfo.MobileClientType
import com.twitter.frigate.pushservice.model.PushTypes.Target
import com.twitter.frigate.pushservice.params.PushFeatureSwitchParams
import com.twitter.frigate.pushservice.target.TargetScoringDetails
import com.twitter.frigate.pushservice.util.PushCapUtil
import com.twitter.frigate.thriftscala.NotificationDisplayLocation
import com.twitter.frigate.thriftscala.{CommonRecommendationType =&gt; CRT}
import com.twitter.hermit.predicate.NamedPredicate
import com.twitter.hermit.predicate.Predicate
import com.twitter.timelines.configapi.FSBoundedParam
import com.twitter.timelines.configapi.Param
import com.twitter.util.Duration
import com.twitter.util.Future</p>
<p>object TargetPredicates {</p>
<blockquote>
<div><dl>
<dt>def paramPredicate[T &lt;: Target](</dt><dd><p>param: Param[Boolean]</p>
</dd>
<dt>)(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[T] = {</dt><dd><p>val name = param.getClass.getSimpleName.stripSuffix(“$”)
Predicate</p>
<blockquote>
<div><p>.from { target: T =&gt; target.params(param) }
.withStats(statsReceiver.scope(s”param_${name}_controlled_predicate”))
.withName(s”param_${name}_controlled_predicate”)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Use the predicate except fn is true., Same as the candidate version but for Target</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>def exceptedPredicate[T &lt;: TargetUser](</dt><dd><p>name: String,
fn: T =&gt; Future[Boolean],
predicate: Predicate[T]</p>
</dd>
<dt>)(</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[T] = {</dt><dd><dl class="simple">
<dt>Predicate</dt><dd><p>.fromAsync { e: T =&gt; fn(e) }
.or(predicate)
.withStats(statsReceiver.scope(name))
.withName(name)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Refresh For push handler target user predicate to fatigue on visiting Home timeline</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>def targetHTLVisitPredicate[</dt><dd><p>T &lt;: TargetUser with UserDetails with TargetABDecider with HTLVisitHistory</p>
</dd>
</dl>
<p>](
)(</p>
<blockquote>
<div><p>implicit statsReceiver: StatsReceiver</p>
</div></blockquote>
<dl>
<dt>): NamedPredicate[T] = {</dt><dd><p>val name = “target_htl_visit_predicate”
Predicate</p>
<blockquote>
<div><dl>
<dt>.fromAsync { target: T =&gt;</dt><dd><p>val hoursToFatigue = target.params(PushFeatureSwitchParams.HTLVisitFatigueTime)
TargetUserPredicates</p>
<blockquote>
<div><p>.homeTimelineFatigue(hoursToFatigue.hours)
.apply(Seq(target))
.map(_.head)</p>
</div></blockquote>
</dd>
</dl>
<p>}
.withStats(statsReceiver.scope(name))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def targetPushBitEnabledPredicate[T &lt;: Target](</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[T] = {</dt><dd><p>val name = “push_bit_enabled”
val scopedStats = statsReceiver.scope(s”targetpredicate_$name”)</p>
<dl>
<dt>Predicate</dt><dd><dl>
<dt>.fromAsync { target: T =&gt;</dt><dd><dl>
<dt>target.deviceInfo</dt><dd><dl>
<dt>.map { info =&gt;</dt><dd><dl class="simple">
<dt>info.exists { deviceInfo =&gt;</dt><dd><p>deviceInfo.isRecommendationsEligible ||
deviceInfo.isNewsEligible ||
deviceInfo.isTopicsEligible ||
deviceInfo.isSpacesEligible</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}.withStats(scopedStats)
.withName(name)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>def targetFatiguePredicate[T &lt;: Target](
)(</p>
<blockquote>
<div><p>implicit statsReceiver: StatsReceiver</p>
</div></blockquote>
<dl>
<dt>): NamedPredicate[T] = {</dt><dd><p>val name = “target_fatigue_predicate”
val predicateStatScope = statsReceiver.scope(name)
Predicate</p>
<blockquote>
<div><dl>
<dt>.fromAsync { target: T =&gt;</dt><dd><dl>
<dt>PushCapUtil</dt><dd><p>.getPushCapFatigue(target, predicateStatScope)
.flatMap { pushCapInfo =&gt;</p>
<blockquote>
<div><dl>
<dt>CommonFatiguePredicate</dt><dd><dl class="simple">
<dt>.magicRecsPushTargetFatiguePredicate(</dt><dd><p>interval = pushCapInfo.fatigueInterval,
maxInInterval = pushCapInfo.pushcap</p>
</dd>
</dl>
<p>)
.apply(Seq(target))
.map(_.headOption.getOrElse(false))</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.withStats(predicateStatScope)
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def teamExceptedPredicate[T &lt;: TargetUser](</dt><dd><p>predicate: NamedPredicate[T]</p>
</dd>
<dt>)(</dt><dd><p>implicit stats: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[T] = {</dt><dd><dl class="simple">
<dt>Predicate</dt><dd><p>.fromAsync { t: T =&gt; t.isTeamMember }
.or(predicate)
.withStats(stats.scope(predicate.name))
.withName(predicate.name)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def targetValidMobileSDKPredicate[T &lt;: Target](</dt><dd><p>implicit statsReceiver: StatsReceiver</p>
</dd>
<dt>): NamedPredicate[T] = {</dt><dd><p>val name = “valid_mobile_sdk”
val scopedStats = statsReceiver.scope(s”targetpredicate_$name”)</p>
<dl>
<dt>Predicate</dt><dd><dl class="simple">
<dt>.fromAsync { target: T =&gt;</dt><dd><dl class="simple">
<dt>TargetUserPredicates.validMobileSDKPredicate</dt><dd><p>.apply(Seq(target)).map(_.headOption.getOrElse(false))</p>
</dd>
</dl>
</dd>
</dl>
<p>}.withStats(scopedStats)
.withName(name)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>def magicRecsMinDurationSinceSent[T &lt;: Target](
)(</p>
<blockquote>
<div><p>implicit statsReceiver: StatsReceiver</p>
</div></blockquote>
<dl>
<dt>): NamedPredicate[T] = {</dt><dd><p>val name = “target_min_duration_since_push”
Predicate</p>
<blockquote>
<div><dl>
<dt>.fromAsync { target: T =&gt;</dt><dd><dl class="simple">
<dt>PushCapUtil.getMinDurationSincePush(target, statsReceiver).flatMap { minDurationSincePush =&gt;</dt><dd><dl class="simple">
<dt>CommonFatiguePredicate</dt><dd><p>.magicRecsMinDurationSincePush(interval = minDurationSincePush)
.apply(Seq(target)).map(_.head)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.withStats(statsReceiver.scope(name))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def optoutProbPredicate[</dt><dd><p>T &lt;: TargetUser with TargetABDecider with TargetScoringDetails with FrigateHistory</p>
</dd>
</dl>
<p>](
)(</p>
<blockquote>
<div><p>implicit statsReceiver: StatsReceiver</p>
</div></blockquote>
<dl>
<dt>): NamedPredicate[T] = {</dt><dd><p>val name = “target_has_high_optout_probability”
Predicate</p>
<blockquote>
<div><dl>
<dt>.fromAsync { target: T =&gt;</dt><dd><p>val isNewUser = target.is30DayNewUserFromSnowflakeIdTime
if (isNewUser) {</p>
<blockquote>
<div><p>statsReceiver.scope(name).counter(“all_new_users”).incr()</p>
</div></blockquote>
<p>}
target.bucketOptoutProbability</p>
<blockquote>
<div><dl>
<dt>.flatMap {</dt><dd><dl>
<dt>case Some(optoutProb) =&gt;</dt><dd><dl>
<dt>if (optoutProb &gt;= target.params(PushFeatureSwitchParams.BucketOptoutThresholdParam)) {</dt><dd><dl>
<dt>CommonFatiguePredicate</dt><dd><dl class="simple">
<dt>.magicRecsPushTargetFatiguePredicate(</dt><dd><p>interval = 24.hours,
maxInInterval = target.params(PushFeatureSwitchParams.OptoutExptPushCapParam)</p>
</dd>
</dl>
<p>)
.apply(Seq(target))
.map { values =&gt;</p>
<blockquote>
<div><p>val isValid = values.headOption.getOrElse(false)
if (!isValid &amp;&amp; isNewUser) {</p>
<blockquote>
<div><p>statsReceiver.scope(name).counter(“filtered_new_users”).incr()</p>
</div></blockquote>
<p>}
isValid</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>} else Future.True</p>
</dd>
</dl>
<p>case _ =&gt; Future.True</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>}
.withStats(statsReceiver.scope(name))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Predicate used to specify CRT fatigue given interval and max number of candidates within interval.</p></li>
<li><p>&#64;param crt                   The specific CRT that this predicate is being applied to</p></li>
<li><p>&#64;param intervalParam         The fatigue interval</p></li>
<li><p>&#64;param maxInIntervalParam    The max number of the given CRT’s candidates that are acceptable</p></li>
<li><p>in the interval</p></li>
<li><p>&#64;param stats                 StatsReceiver</p></li>
<li><p>&#64;return                      Target Predicate</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>def pushRecTypeFatiguePredicate(</dt><dd><p>crt: CRT,
intervalParam: Param[Duration],
maxInIntervalParam: FSBoundedParam[Int],
stats: StatsReceiver</p>
</dd>
<dt>): Predicate[Target] =</dt><dd><dl>
<dt>Predicate.fromAsync { target: Target =&gt;</dt><dd><p>val interval = target.params(intervalParam)
val maxIninterval = target.params(maxInIntervalParam)
CommonFatiguePredicate</p>
<blockquote>
<div><dl class="simple">
<dt>.recTypeTargetFatiguePredicate(</dt><dd><p>interval = interval,
maxInInterval = maxIninterval,
recommendationType = crt,
notificationDisplayLocation = NotificationDisplayLocation.PushToMobileDevice,
minInterval = 30.minutes</p>
</dd>
</dl>
<p>)(stats.scope(s”${crt}_push_candidate_fatigue”)).apply(Seq(target)).map(_.head)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>def inlineActionFatiguePredicate(
)(</p>
<blockquote>
<div><p>implicit statsReceiver: StatsReceiver</p>
</div></blockquote>
<dl>
<dt>): NamedPredicate[Target] = {</dt><dd><p>val name = “inline_action_fatigue”
val predicateRequests = statsReceiver.scope(name).counter(“requests”)
val targetIsInExpt = statsReceiver.scope(name).counter(“target_in_expt”)
val predicateEnabled = statsReceiver.scope(name).counter(“enabled”)
val predicateDisabled = statsReceiver.scope(name).counter(“disabled”)
val inlineFatigueDisabled = statsReceiver.scope(name).counter(“inline_fatigue_disabled”)</p>
<dl>
<dt>Predicate</dt><dd><dl>
<dt>.fromAsync { target: Target =&gt;</dt><dd><p>predicateRequests.incr()
if (target.params(PushFeatureSwitchParams.TargetInInlineActionAppVisitFatigue)) {</p>
<blockquote>
<div><p>targetIsInExpt.incr()
target.inlineActionHistory.map { inlineHistory =&gt;</p>
<blockquote>
<div><dl>
<dt>if (inlineHistory.nonEmpty &amp;&amp; target.params(</dt><dd><blockquote>
<div><p>PushFeatureSwitchParams.EnableInlineActionAppVisitFatigue)) {</p>
</div></blockquote>
<p>predicateEnabled.incr()
val inlineFatigue = target.params(PushFeatureSwitchParams.InlineActionAppVisitFatigue)
val lookbackInMs = inlineFatigue.ago.inMilliseconds
val filteredHistory = inlineHistory.filter {</p>
<blockquote>
<div><p>case (time, _) =&gt; time &gt; lookbackInMs</p>
</div></blockquote>
<p>}
filteredHistory.isEmpty</p>
</dd>
<dt>} else {</dt><dd><p>inlineFatigueDisabled.incr()
true</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>predicateDisabled.incr()
Future.True</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.withStats(statsReceiver.scope(name))
.withName(name)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>def webNotifsHoldback[T &lt;: TargetUser with UserDetails with TargetABDecider](
)(</p>
<blockquote>
<div><p>implicit stats: StatsReceiver</p>
</div></blockquote>
<dl>
<dt>): NamedPredicate[T] = {</dt><dd><p>val name = “mr_web_notifs_holdback”
Predicate</p>
<blockquote>
<div><dl>
<dt>.fromAsync { targetUserContext: T =&gt;</dt><dd><dl>
<dt>targetUserContext.deviceInfo.map { deviceInfoOpt =&gt;</dt><dd><dl>
<dt>val isPrimaryWeb = deviceInfoOpt.exists {</dt><dd><dl class="simple">
<dt>_.guessedPrimaryClient.exists { clientType =&gt;</dt><dd><p>clientType == MobileClientType.Web</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
!(isPrimaryWeb &amp;&amp; targetUserContext.params(PushFeatureSwitchParams.MRWebHoldbackParam))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.withStats(stats.scope(s”predicate_$name”))
.withName(name)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/pushservice/src/main/scala/com/twitter/frigate/pushservice/predicate/TargetPredicates.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>