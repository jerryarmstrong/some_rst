<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.frigate.pushservice.refresh_handler</p>
<p>import com.twitter.finagle.stats.Counter
import com.twitter.finagle.stats.Stat
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.frigate.common.base.Stats.track
import com.twitter.frigate.common.base.Stats.trackSeq
import com.twitter.frigate.common.base._
import com.twitter.frigate.common.logger.MRLogger
import com.twitter.frigate.pushservice.model.PushTypes.PushCandidate
import com.twitter.frigate.pushservice.model.PushTypes.RawCandidate
import com.twitter.frigate.pushservice.model.PushTypes.Target
import com.twitter.frigate.pushservice.adaptor._
import com.twitter.frigate.pushservice.params.PushFeatureSwitchParams
import com.twitter.frigate.pushservice.rank.RFPHLightRanker
import com.twitter.frigate.pushservice.rank.RFPHRanker
import com.twitter.frigate.pushservice.scriber.MrRequestScribeHandler
import com.twitter.frigate.pushservice.take.candidate_validator.RFPHCandidateValidator
import com.twitter.frigate.pushservice.target.PushTargetUserBuilder
import com.twitter.frigate.pushservice.target.RFPHTargetPredicates
import com.twitter.frigate.pushservice.util.RFPHTakeStepUtil
import com.twitter.frigate.pushservice.util.AdhocStatsUtil
import com.twitter.frigate.pushservice.thriftscala.PushContext
import com.twitter.frigate.pushservice.thriftscala.RefreshRequest
import com.twitter.frigate.pushservice.thriftscala.RefreshResponse
import com.twitter.frigate.thriftscala.CommonRecommendationType
import com.twitter.hermit.predicate.Predicate
import com.twitter.timelines.configapi.FeatureValue
import com.twitter.util._</p>
<p>case class ResultWithDebugInfo(result: Result, predicateResults: Seq[PredicateWithResult])</p>
<dl>
<dt>class RefreshForPushHandler(</dt><dd><p>val pushTargetUserBuilder: PushTargetUserBuilder,
val candSourceGenerator: PushCandidateSourceGenerator,
rfphRanker: RFPHRanker,
candidateHydrator: PushCandidateHydrator,
candidateValidator: RFPHCandidateValidator,
rfphTakeStepUtil: RFPHTakeStepUtil,
rfphRestrictStep: RFPHRestrictStep,
val rfphNotifier: RefreshForPushNotifier,
rfphStatsRecorder: RFPHStatsRecorder,
mrRequestScriberNode: String,
rfphFeatureHydrator: RFPHFeatureHydrator,
rfphPrerankFilter: RFPHPrerankFilter,
rfphLightRanker: RFPHLightRanker</p>
</dd>
<dt>)(</dt><dd><dl class="simple">
<dt>globalStats: StatsReceiver)</dt><dd><p>extends FetchRankFlowWithHydratedCandidates[Target, RawCandidate, PushCandidate] {</p>
</dd>
</dl>
<p>val log = MRLogger(“RefreshForPushHandler”)</p>
<dl class="simple">
<dt>implicit val statsReceiver: StatsReceiver =</dt><dd><p>globalStats.scope(“RefreshForPushHandler”)</p>
</dd>
<dt>private val maxCandidatesToBatchInTakeStat: Stat =</dt><dd><p>statsReceiver.stat(“max_cands_to_batch_in_take”)</p>
</dd>
</dl>
<p>private val rfphRequestCounter = statsReceiver.counter(“requests”)</p>
<p>private val buildTargetStats = statsReceiver.scope(“build_target”)
private val processStats = statsReceiver.scope(“process”)
private val notifyStats = statsReceiver.scope(“notify”)</p>
<p>private val lightRankingStats: StatsReceiver = statsReceiver.scope(“light_ranking”)
private val reRankingStats: StatsReceiver = statsReceiver.scope(“rerank”)
private val featureHydrationLatency: StatsReceiver =</p>
<blockquote>
<div><p>statsReceiver.scope(“featureHydrationLatency”)</p>
</div></blockquote>
<p>private val candidateHydrationStats: StatsReceiver = statsReceiver.scope(“candidate_hydration”)</p>
<dl class="simple">
<dt>lazy val candSourceEligibleCounter: Counter =</dt><dd><p>candidateStats.counter(“cand_source_eligible”)</p>
</dd>
<dt>lazy val candSourceNotEligibleCounter: Counter =</dt><dd><p>candidateStats.counter(“cand_source_not_eligible”)</p>
</dd>
</dl>
<p>//pre-ranking stats
val allCandidatesFilteredPreRank = filterStats.counter(“all_candidates_filtered”)</p>
<p>// total invalid candidates
val totalStats: StatsReceiver = statsReceiver.scope(“total”)
val totalInvalidCandidatesStat: Stat = totalStats.stat(“candidates_invalid”)</p>
<p>val mrRequestScribeBuiltStats: Counter = statsReceiver.counter(“mr_request_scribe_built”)</p>
<p>val mrRequestCandidateScribeStats = statsReceiver.scope(“mr_request_scribe_candidates”)
val mrRequestTargetScribeStats = statsReceiver.scope(“mr_request_scribe_target”)</p>
<dl class="simple">
<dt>val mrRequestScribeHandler =</dt><dd><p>new MrRequestScribeHandler(mrRequestScriberNode, statsReceiver.scope(“mr_request_scribe”))</p>
</dd>
</dl>
<p>val adhocStatsUtil = new AdhocStatsUtil(statsReceiver.scope(“adhoc_stats”))</p>
<dl class="simple">
<dt>private def numRecsPerTypeStat(crt: CommonRecommendationType) =</dt><dd><p>fetchStats.scope(crt.toString).stat(“dist”)</p>
</dd>
</dl>
<p>// static list of target predicates
private val targetPredicates = RFPHTargetPredicates(targetStats.scope(“predicates”))</p>
<dl class="simple">
<dt>def buildTarget(</dt><dd><p>userId: Long,
inputPushContext: Option[PushContext],
forcedFeatureValues: Option[Map[String, FeatureValue]] = None</p>
</dd>
<dt>): Future[Target] =</dt><dd><p>pushTargetUserBuilder.buildTarget(userId, inputPushContext, forcedFeatureValues)</p>
</dd>
</dl>
<p>override def targetPredicates(target: Target): List[Predicate[Target]] = targetPredicates</p>
<dl>
<dt>override def isTargetValid(target: Target): Future[Result] = {</dt><dd><dl>
<dt>val resultFut = if (target.skipFilters) {</dt><dd><p>Future.value(trackTargetPredStats(None))</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>predicateSeq(target).track(Seq(target)).map { resultArr =&gt;</dt><dd><p>trackTargetPredStats(resultArr(0))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
track(targetStats)(resultFut)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def candidateSources(</dt><dd><p>target: Target</p>
</dd>
<dt>): Future[Seq[CandidateSource[Target, RawCandidate]]] = {</dt><dd><dl>
<dt>Future</dt><dd><dl>
<dt>.collect(candSourceGenerator.sources.map { cs =&gt;</dt><dd><dl>
<dt>cs.isCandidateSourceAvailable(target).map { isEligible =&gt;</dt><dd><dl class="simple">
<dt>if (isEligible) {</dt><dd><p>candSourceEligibleCounter.incr()
Some(cs)</p>
</dd>
<dt>} else {</dt><dd><p>candSourceNotEligibleCounter.incr()
None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}).map(_.flatten)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def updateCandidateCounter(</dt><dd><p>candidateResults: Seq[CandidateResult[PushCandidate, Result]]</p>
</dd>
<dt>): Unit = {</dt><dd><dl>
<dt>candidateResults.foreach {</dt><dd><dl class="simple">
<dt>case candidateResult if candidateResult.result == OK =&gt;</dt><dd><p>okCandidateCounter.incr()</p>
</dd>
<dt>case candidateResult if candidateResult.result.isInstanceOf[Invalid] =&gt;</dt><dd><p>invalidCandidateCounter.incr()</p>
</dd>
</dl>
<p>case _ =&gt;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override def hydrateCandidates(</dt><dd><p>candidates: Seq[CandidateDetails[RawCandidate]]</p>
</dd>
</dl>
<p>): Future[Seq[CandidateDetails[PushCandidate]]] = candidateHydrator(candidates)</p>
<dl class="simple">
<dt>override def filter(</dt><dd><p>target: Target,
hydratedCandidates: Seq[CandidateDetails[PushCandidate]]</p>
</dd>
<dt>): Future[</dt><dd><p>(Seq[CandidateDetails[PushCandidate]], Seq[CandidateResult[PushCandidate, Result]])</p>
</dd>
</dl>
<p>] = rfphPrerankFilter.filter(target, hydratedCandidates)</p>
<dl class="simple">
<dt>def lightRankAndTake(</dt><dd><p>target: Target,
candidates: Seq[CandidateDetails[PushCandidate]]</p>
</dd>
<dt>): Future[Seq[CandidateDetails[PushCandidate]]] = {</dt><dd><p>rfphLightRanker.rank(target, candidates)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def rank(</dt><dd><p>target: Target,
candidatesDetails: Seq[CandidateDetails[PushCandidate]]</p>
</dd>
<dt>): Future[Seq[CandidateDetails[PushCandidate]]] = {</dt><dd><dl class="simple">
<dt>val featureHydratedCandidatesFut = trackSeq(featureHydrationLatency)(</dt><dd><dl class="simple">
<dt>rfphFeatureHydrator</dt><dd><p>.candidateFeatureHydration(candidatesDetails, target.mrRequestContextForFeatureStore)</p>
</dd>
</dl>
</dd>
</dl>
<p>)
featureHydratedCandidatesFut.flatMap { featureHydratedCandidates =&gt;</p>
<blockquote>
<div><p>rfphStatsRecorder.rankDistributionStats(featureHydratedCandidates, numRecsPerTypeStat)
rfphRanker.initialRank(target, candidatesDetails)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def reRank(</dt><dd><p>target: Target,
rankedCandidates: Seq[CandidateDetails[PushCandidate]]</p>
</dd>
<dt>): Future[Seq[CandidateDetails[PushCandidate]]] = {</dt><dd><p>rfphRanker.reRank(target, rankedCandidates)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def validCandidates(</dt><dd><p>target: Target,
candidates: Seq[PushCandidate]</p>
</dd>
<dt>): Future[Seq[Result]] = {</dt><dd><dl class="simple">
<dt>Future.collect(candidates.map { candidate =&gt;</dt><dd><p>rfphTakeStepUtil.isCandidateValid(candidate, candidateValidator).map(res =&gt; res.result)</p>
</dd>
</dl>
<p>})</p>
</dd>
</dl>
<p>}</p>
<p>override def desiredCandidateCount(target: Target): Int = target.desiredCandidateCount</p>
<dl class="simple">
<dt>override def batchForCandidatesCheck(target: Target): Int = {</dt><dd><p>val fsParam = PushFeatureSwitchParams.NumberOfMaxCandidatesToBatchInRFPHTakeStep
val maxToBatch = target.params(fsParam)
maxCandidatesToBatchInTakeStat.add(maxToBatch)
maxToBatch</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def process(</dt><dd><p>target: Target,
externalCandidates: Seq[RawCandidate] = Nil</p>
</dd>
<dt>): Future[Response[PushCandidate, Result]] = {</dt><dd><dl>
<dt>isTargetValid(target).flatMap {</dt><dd><dl>
<dt>case OK =&gt;</dt><dd><dl>
<dt>for {</dt><dd><p>candidatesFromSources &lt;- trackSeq(fetchStats)(fetchCandidates(target))
externalCandidateDetails = externalCandidates.map(</p>
<blockquote>
<div><p>CandidateDetails(_, “refresh_for_push_handler_external_candidate”))</p>
</div></blockquote>
<p>allCandidates = candidatesFromSources ++ externalCandidateDetails
hydratedCandidatesWithCopy &lt;-</p>
<blockquote>
<div><p>trackSeq(candidateHydrationStats)(hydrateCandidates(allCandidates))</p>
</div></blockquote>
<p>_ = adhocStatsUtil.getCandidateSourceStats(hydratedCandidatesWithCopy)
(candidates, preRankingFilteredCandidates) &lt;-</p>
<blockquote>
<div><p>track(filterStats)(filter(target, hydratedCandidatesWithCopy))</p>
</div></blockquote>
<p>_ = adhocStatsUtil.getPreRankingFilterStats(preRankingFilteredCandidates)
lightRankerFilteredCandidates &lt;-</p>
<blockquote>
<div><p>trackSeq(lightRankingStats)(lightRankAndTake(target, candidates))</p>
</div></blockquote>
<p>_ = adhocStatsUtil.getLightRankingStats(lightRankerFilteredCandidates)
rankedCandidates &lt;- trackSeq(rankingStats)(rank(target, lightRankerFilteredCandidates))
_ = adhocStatsUtil.getRankingStats(rankedCandidates)
rerankedCandidates &lt;- trackSeq(reRankingStats)(reRank(target, rankedCandidates))
_ = adhocStatsUtil.getReRankingStats(rerankedCandidates)
(restrictedCandidates, restrictFilteredCandidates) =</p>
<blockquote>
<div><p>rfphRestrictStep.restrict(target, rerankedCandidates)</p>
</div></blockquote>
<dl class="simple">
<dt>allTakeCandidateResults &lt;- track(takeStats)(</dt><dd><p>take(target, restrictedCandidates, desiredCandidateCount(target))</p>
</dd>
</dl>
<p>)
_ = adhocStatsUtil.getTakeCandidateResultStats(allTakeCandidateResults)
_ &lt;- track(mrRequestCandidateScribeStats)(</p>
<blockquote>
<div><dl class="simple">
<dt>mrRequestScribeHandler.scribeForCandidateFiltering(</dt><dd><p>target,
hydratedCandidatesWithCopy,
preRankingFilteredCandidates,
rankedCandidates,
rerankedCandidates,
restrictFilteredCandidates,
allTakeCandidateResults</p>
</dd>
</dl>
<p>))</p>
</div></blockquote>
</dd>
</dl>
<p>} yield {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Take processes post restrict step candidates and returns both:</p></li>
<li><ol class="arabic simple">
<li><p>valid + invalid candidates</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>Candidates that are not processed (more than desired) + restricted candidates</p></li>
</ol>
</li>
<li><p>We need #2 only for importance sampling</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>val takeCandidateResults =</dt><dd><dl class="simple">
<dt>allTakeCandidateResults.filterNot { candResult =&gt;</dt><dd><p>candResult.result == MoreThanDesiredCandidates</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>val totalInvalidCandidates = {</dt><dd><dl class="simple">
<dt>preRankingFilteredCandidates.size + //pre-ranking filtered candidates</dt><dd><p>(rerankedCandidates.length - restrictedCandidates.length) + //candidates reject in restrict step
takeCandidateResults.count(_.result != OK) //candidates reject in take step</p>
</dd>
</dl>
</dd>
</dl>
<p>}
takeInvalidCandidateDist.add(</p>
<blockquote>
<div><dl class="simple">
<dt>takeCandidateResults</dt><dd><p>.count(_.result != OK)</p>
</dd>
</dl>
</div></blockquote>
<p>) // take step invalid candidates
totalInvalidCandidatesStat.add(totalInvalidCandidates)
val allCandidateResults = takeCandidateResults ++ preRankingFilteredCandidates
Response(OK, allCandidateResults)</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>case result: Result =&gt;</dt><dd><dl>
<dt>for (_ &lt;- track(mrRequestTargetScribeStats)(</dt><dd><blockquote>
<div><p>mrRequestScribeHandler.scribeForTargetFiltering(target, result))) yield {</p>
</div></blockquote>
<p>mrRequestScribeBuiltStats.incr()
Response(result, Nil)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def refreshAndSend(request: RefreshRequest): Future[RefreshResponse] = {</dt><dd><p>rfphRequestCounter.incr()
for {</p>
<blockquote>
<div><dl class="simple">
<dt>target &lt;- track(buildTargetStats)(</dt><dd><dl class="simple">
<dt>pushTargetUserBuilder</dt><dd><p>.buildTarget(request.userId, request.context))</p>
</dd>
</dl>
</dd>
</dl>
<p>response &lt;- track(processStats)(process(target, externalCandidates = Seq.empty))
refreshResponse &lt;- track(notifyStats)(rfphNotifier.checkResponseAndNotify(response, target))</p>
</div></blockquote>
<dl class="simple">
<dt>} yield {</dt><dd><p>refreshResponse</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/pushservice/src/main/scala/com/twitter/frigate/pushservice/refresh_handler/RefreshForPushHandler.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>