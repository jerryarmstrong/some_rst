<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../" id="documentation_options" src="../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.ann.hnsw;</p>
<p>import java.io.IOException;
import java.nio.ByteBuffer;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Random;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.atomic.AtomicReference;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReadWriteLock;
import java.util.concurrent.locks.ReentrantLock;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.function.Function;</p>
<p>import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;</p>
<p>import org.apache.thrift.TException;</p>
<p>import com.twitter.ann.common.IndexOutputFile;
import com.twitter.ann.common.thriftjava.HnswInternalIndexMetadata;
import com.twitter.bijection.Injection;
import com.twitter.logging.Logger;
import com.twitter.mediaservices.commons.codec.ArrayByteBufferCodec;
import com.twitter.search.common.file.AbstractFile;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Typed multithreaded HNSW implementation supporting creation/querying of approximate nearest neighbour</p></li>
<li><p>Paper: <a class="reference external" href="https://arxiv.org/pdf/1603.09320.pdf">https://arxiv.org/pdf/1603.09320.pdf</a></p></li>
<li><p>Multithreading impl based on NMSLIB version : <a class="reference external" href="https://github.com/nmslib/hnsw/blob/master/hnswlib/hnswalg.h">https://github.com/nmslib/hnsw/blob/master/hnswlib/hnswalg.h</a></p></li>
<li></li>
<li><p>&#64;param &lt;T&gt; The type of items inserted / searched in the HNSW index.</p></li>
<li><p>&#64;param &lt;Q&gt; The type of KNN query.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public class HnswIndex&lt;T, Q&gt; {</dt><dd><p>private static final Logger LOG = Logger.get(HnswIndex.class);
private static final String METADATA_FILE_NAME = “hnsw_internal_metadata”;
private static final String GRAPH_FILE_NAME = “hnsw_internal_graph”;
private static final int MAP_SIZE_FACTOR = 5;</p>
<p>private final DistanceFunction&lt;T, T&gt; distFnIndex;
private final DistanceFunction&lt;Q, T&gt; distFnQuery;
private final int efConstruction;
private final int maxM;
private final int maxM0;
private final double levelMultiplier;
private final AtomicReference&lt;HnswMeta&lt;T&gt;&gt; graphMeta = new AtomicReference&lt;&gt;();
private final Map&lt;HnswNode&lt;T&gt;, ImmutableList&lt;T&gt;&gt; graph;
// To take lock on vertex level
private final ConcurrentHashMap&lt;T, ReadWriteLock&gt; locks;
// To take lock on whole graph only if vertex addition is on layer above the current maxLevel
private final ReentrantLock globalLock;
private final Function&lt;T, ReadWriteLock&gt; lockProvider;</p>
<p>private final RandomProvider randomProvider;</p>
<p>// Probability of reevaluating connections of an element in the neighborhood during an update
// Can be used as a knob to adjust update_speed/search_speed tradeoff.
private final float updateNeighborProbability;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Creates instance of hnsw index.</p></li>
<li></li>
<li><p>&#64;param distFnIndex      Any distance metric/non metric that specifies similarity between two items for indexing.</p></li>
<li><p>&#64;param distFnQuery      Any distance metric/non metric that specifies similarity between item for which nearest neighbours queried for and already indexed item.</p></li>
<li><p>&#64;param efConstruction   Provide speed vs index quality tradeoff, higher the value better the quality and higher the time to create index.</p></li>
<li><p>Valid range of efConstruction can be anywhere between 1 and tens of thousand. Typically, it should be set so that a search of M</p></li>
<li><p>neighbors with ef=efConstruction should end in recall&gt;0.95.</p></li>
<li><p>&#64;param maxM             Maximum connections per layer except 0th level.</p></li>
<li><p>Optimal values between 5-48.</p></li>
<li><p>Smaller M generally produces better result for lower recalls and/ or lower dimensional data,</p></li>
<li><p>while bigger M is better for high recall and/ or high dimensional, data on the expense of more memory/disk usage</p></li>
<li><p>&#64;param expectedElements Approximate number of elements to be indexed</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>protected HnswIndex(</dt><dd><p>DistanceFunction&lt;T, T&gt; distFnIndex,
DistanceFunction&lt;Q, T&gt; distFnQuery,
int efConstruction,
int maxM,
int expectedElements,
RandomProvider randomProvider</p>
</dd>
<dt>) {</dt><dd><dl class="simple">
<dt>this(distFnIndex,</dt><dd><p>distFnQuery,
efConstruction,
maxM,
expectedElements,
new HnswMeta&lt;&gt;(-1, Optional.empty()),
new ConcurrentHashMap&lt;&gt;(MAP_SIZE_FACTOR * expectedElements),
randomProvider</p>
</dd>
</dl>
<p>);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private HnswIndex(</dt><dd><p>DistanceFunction&lt;T, T&gt; distFnIndex,
DistanceFunction&lt;Q, T&gt; distFnQuery,
int efConstruction,
int maxM,
int expectedElements,
HnswMeta&lt;T&gt; graphMeta,
Map&lt;HnswNode&lt;T&gt;, ImmutableList&lt;T&gt;&gt; graph,
RandomProvider randomProvider</p>
</dd>
<dt>) {</dt><dd><p>this.distFnIndex = distFnIndex;
this.distFnQuery = distFnQuery;
this.efConstruction = efConstruction;
this.maxM = maxM;
this.maxM0 = 2 * maxM;
this.levelMultiplier = 1.0 / Math.log(1.0 * maxM);
this.graphMeta.set(graphMeta);
this.graph = graph;
this.locks = new ConcurrentHashMap&lt;&gt;(MAP_SIZE_FACTOR * expectedElements);
this.globalLock = new ReentrantLock();
this.lockProvider = key -&gt; new ReentrantReadWriteLock();
this.randomProvider = randomProvider;
this.updateNeighborProbability = 1.0f;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>wireConnectionForAllLayers finds connections for a new element and creates bi-direction links.</p></li>
<li><p>The method assumes using a reentrant lock to link list reads.</p></li>
<li></li>
<li><p>&#64;param entryPoint the global entry point</p></li>
<li><p>&#64;param item       the item for which the connections are found</p></li>
<li><p>&#64;param itemLevel  the level of the added item (maximum layer in which we wire the connections)</p></li>
<li><p>&#64;param maxLayer   the level of the entry point</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>private void wireConnectionForAllLayers(final T entryPoint, final T item, final int itemLevel,</dt><dd><blockquote>
<div><p>final int maxLayer, final boolean isUpdate) {</p>
</div></blockquote>
<p>T curObj = entryPoint;
if (itemLevel &lt; maxLayer) {</p>
<blockquote>
<div><p>curObj = bestEntryPointUntilLayer(curObj, item, maxLayer, itemLevel, distFnIndex);</p>
</div></blockquote>
<p>}
for (int level = Math.min(itemLevel, maxLayer); level &gt;= 0; level–) {</p>
<blockquote>
<div><dl class="simple">
<dt>final DistancedItemQueue&lt;T, T&gt; candidates =</dt><dd><p>searchLayerForCandidates(item, curObj, efConstruction, level, distFnIndex, isUpdate);</p>
</dd>
</dl>
<p>curObj = mutuallyConnectNewElement(item, candidates, level, isUpdate);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Insert the item into HNSW index.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>public void insert(final T item) throws IllegalDuplicateInsertException {</dt><dd><p>final Lock itemLock = locks.computeIfAbsent(item, lockProvider).writeLock();
itemLock.lock();
try {</p>
<blockquote>
<div><p>final HnswMeta&lt;T&gt; metadata = graphMeta.get();
// If the graph already have the item, should not re-insert it again
// Need to check entry point in case we reinsert first item where is are no graph
// but only a entry point
if (graph.containsKey(HnswNode.from(0, item))</p>
<blockquote>
<div><blockquote>
<div><p>|| (metadata.getEntryPoint().isPresent()
&amp;&amp; Objects.equals(metadata.getEntryPoint().get(), item))) {</p>
</div></blockquote>
<dl class="simple">
<dt>throw new IllegalDuplicateInsertException(</dt><dd><p>“Duplicate insertion is not supported: “ + item);</p>
</dd>
</dl>
</div></blockquote>
<p>}
final int curLevel = getRandomLevel();
Optional&lt;T&gt; entryPoint = metadata.getEntryPoint();
// The global lock prevents two threads from making changes to the entry point. This lock
// should get taken very infrequently. Something like log-base-levelMultiplier(num items)
// For a full explanation of locking see this document: <a class="reference external" href="http://go/hnsw-locking">http://go/hnsw-locking</a>
int maxLevelCopy = metadata.getMaxLevel();
if (curLevel &gt; maxLevelCopy) {</p>
<blockquote>
<div><p>globalLock.lock();
// Re initialize the entryPoint and maxLevel in case these are changed by any other thread
// No need to check the condition again since,
// it is already checked at the end before updating entry point struct
// No need to unlock for optimization and keeping as is if condition fails since threads
// will not be entering this section a lot.
final HnswMeta&lt;T&gt; temp = graphMeta.get();
entryPoint = temp.getEntryPoint();
maxLevelCopy = temp.getMaxLevel();</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if (entryPoint.isPresent()) {</dt><dd><p>wireConnectionForAllLayers(entryPoint.get(), item, curLevel, maxLevelCopy, false);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>if (curLevel &gt; maxLevelCopy) {</dt><dd><dl class="simple">
<dt>Preconditions.checkState(globalLock.isHeldByCurrentThread(),</dt><dd><p>“Global lock not held before updating entry point”);</p>
</dd>
</dl>
<p>graphMeta.set(new HnswMeta&lt;&gt;(curLevel, Optional.of(item)));</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>} finally {</dt><dd><dl class="simple">
<dt>if (globalLock.isHeldByCurrentThread()) {</dt><dd><p>globalLock.unlock();</p>
</dd>
</dl>
<p>}
itemLock.unlock();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>set connections of an element with synchronization</p></li>
<li><p>The only other place that should have the lock for writing is during</p></li>
<li><p>the element insertion</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>private void setConnectionList(final T item, int layer, List&lt;T&gt; connections) {</dt><dd><p>final Lock candidateLock = locks.computeIfAbsent(item, lockProvider).writeLock();
candidateLock.lock();
try {</p>
<blockquote>
<div><dl class="simple">
<dt>graph.put(</dt><dd><p>HnswNode.from(layer, item),
ImmutableList.copyOf(connections)</p>
</dd>
</dl>
<p>);</p>
</div></blockquote>
<dl class="simple">
<dt>} finally {</dt><dd><p>candidateLock.unlock();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Reinsert the item into HNSW index.</p></li>
<li><p>This method updates the links of an element assuming</p></li>
<li><p>the element’s distance function is changed externally (e.g. by updating the features)</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>public void reInsert(final T item) {</dt><dd><p>final HnswMeta&lt;T&gt; metadata = graphMeta.get();</p>
<p>Optional&lt;T&gt; entryPoint = metadata.getEntryPoint();</p>
<dl class="simple">
<dt>Preconditions.checkState(entryPoint.isPresent(),</dt><dd><p>“Update cannot be performed if entry point is not present”);</p>
</dd>
</dl>
<p>// This is a check for the single element case
if (entryPoint.get().equals(item) &amp;&amp; graph.isEmpty()) {</p>
<blockquote>
<div><p>return;</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>Preconditions.checkState(graph.containsKey(HnswNode.from(0, item)),</dt><dd><p>“Graph does not contain the item to be updated at level 0”);</p>
</dd>
</dl>
<p>int curLevel = 0;</p>
<p>int maxLevelCopy = metadata.getMaxLevel();</p>
<dl>
<dt>for (int layer = maxLevelCopy; layer &gt;= 0; layer–) {</dt><dd><dl class="simple">
<dt>if (graph.containsKey(HnswNode.from(layer, item))) {</dt><dd><p>curLevel = layer;
break;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// Updating the links of the elements from the 1-hop radius of the updated element</p>
<p>for (int layer = 0; layer &lt;= curLevel; layer++) {</p>
<blockquote>
<div><p>// Filling the element sets for candidates and updated elements
final HashSet&lt;T&gt; setCand = new HashSet&lt;T&gt;();
final HashSet&lt;T&gt; setNeigh = new HashSet&lt;T&gt;();
final List&lt;T&gt; listOneHop = getConnectionListForRead(item, layer);</p>
<dl class="simple">
<dt>if (listOneHop.isEmpty()) {</dt><dd><p>LOG.debug(“No links for the updated element. Empty dataset?”);
continue;</p>
</dd>
</dl>
<p>}</p>
<p>setCand.add(item);</p>
<dl>
<dt>for (T elOneHop<span class="classifier">listOneHop) {</span></dt><dd><p>setCand.add(elOneHop);
if (randomProvider.get().nextFloat() &gt; updateNeighborProbability) {</p>
<blockquote>
<div><p>continue;</p>
</div></blockquote>
<p>}
setNeigh.add(elOneHop);
final List&lt;T&gt; listTwoHop = getConnectionListForRead(elOneHop, layer);</p>
<dl class="simple">
<dt>if (listTwoHop.isEmpty()) {</dt><dd><p>LOG.debug(“No links for the updated element. Empty dataset?”);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>for (T oneHopEl<span class="classifier">listTwoHop) {</span></dt><dd><p>setCand.add(oneHopEl);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
// No need to update the item itself, so remove it
setNeigh.remove(item);</p>
<p>// Updating the link lists of elements from setNeigh:
for (T neigh : setNeigh) {</p>
<blockquote>
<div><p>final HashSet&lt;T&gt; setCopy = new HashSet&lt;T&gt;(setCand);
setCopy.remove(neigh);
int keepElementsNum = Math.min(efConstruction, setCopy.size());
final DistancedItemQueue&lt;T, T&gt; candidates = new DistancedItemQueue&lt;&gt;(</p>
<blockquote>
<div><p>neigh,
ImmutableList.of(),
false,
distFnIndex</p>
</div></blockquote>
<p>);
for (T cand : setCopy) {</p>
<blockquote>
<div><p>final float distance = distFnIndex.distance(neigh, cand);
if (candidates.size() &lt; keepElementsNum) {</p>
<blockquote>
<div><p>candidates.enqueue(cand, distance);</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><dl class="simple">
<dt>if (distance &lt; candidates.peek().getDistance()) {</dt><dd><p>candidates.dequeue();
candidates.enqueue(cand, distance);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
final ImmutableList&lt;T&gt; neighbours = selectNearestNeighboursByHeuristic(</p>
<blockquote>
<div><p>candidates,
layer == 0 ? maxM0 : maxM</p>
</div></blockquote>
<p>);</p>
<p>final List&lt;T&gt; temp = getConnectionListForRead(neigh, layer);
if (temp.isEmpty()) {</p>
<blockquote>
<div><p>LOG.debug(“existing linkslist is empty. Corrupt index”);</p>
</div></blockquote>
<p>}
if (neighbours.isEmpty()) {</p>
<blockquote>
<div><p>LOG.debug(“predicted linkslist is empty. Corrupt index”);</p>
</div></blockquote>
<p>}
setConnectionList(neigh, layer, neighbours);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
wireConnectionForAllLayers(metadata.getEntryPoint().get(), item, curLevel, maxLevelCopy, true);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>This method can be used to get the graph statistics, specifically</p></li>
<li><p>it prints the histogram of inbound connections for each element.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>private String getStats() {</dt><dd><p>int histogramMaxBins = 50;
int[] histogram = new int[histogramMaxBins];
HashMap&lt;T, Integer&gt; mmap = new HashMap&lt;T, Integer&gt;();
for (HnswNode&lt;T&gt; key : graph.keySet()) {</p>
<blockquote>
<div><dl>
<dt>if (key.level == 0) {</dt><dd><p>List&lt;T&gt; linkList = getConnectionListForRead(key.item, key.level);
for (T node : linkList) {</p>
<blockquote>
<div><p>int a = mmap.computeIfAbsent(node, k -&gt; 0);
mmap.put(node, a + 1);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>for (T key<span class="classifier">mmap.keySet()) {</span></dt><dd><p>int ind = mmap.get(key) &lt; histogramMaxBins - 1 ? mmap.get(key) : histogramMaxBins - 1;
histogram[ind]++;</p>
</dd>
</dl>
<p>}
int minNonZeroIndex;
for (minNonZeroIndex = histogramMaxBins - 1; minNonZeroIndex &gt;= 0; minNonZeroIndex–) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (histogram[minNonZeroIndex] &gt; 0) {</dt><dd><p>break;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>String output = “”;
for (int i = 0; i &lt;= minNonZeroIndex; i++) {</p>
<blockquote>
<div><p>output += “” + i + “t” + histogram[i] / (0.01f * mmap.keySet().size()) + “n”;</p>
</div></blockquote>
<p>}</p>
<p>return output;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private int getRandomLevel() {</dt><dd><p>return (int) (-Math.log(randomProvider.get().nextDouble()) * levelMultiplier);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Note that to avoid deadlocks it is important that this method is called after all the searches</p></li>
<li><p>of the graph have completed. If you take a lock on any items discovered in the graph after</p></li>
<li><p>this, you may get stuck waiting on a thread that is waiting for item to be fully inserted.</p></li>
<li><p>&lt;p&gt;</p></li>
<li><p>Note: when using concurrent writers we can miss connections that we would otherwise get.</p></li>
<li><p>This will reduce the recall.</p></li>
<li><p>&lt;p&gt;</p></li>
<li><p>For a full explanation of locking see this document: <a class="reference external" href="http://go/hnsw-locking">http://go/hnsw-locking</a></p></li>
<li><p>The method returns the closest nearest neighbor (can be used as an enter point)</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>private T mutuallyConnectNewElement(</dt><dd><p>final T item,
final DistancedItemQueue&lt;T, T&gt; candidates, // Max queue
final int level,
final boolean isUpdate</p>
</dd>
</dl>
<p>) {</p>
<blockquote>
<div><p>// Using maxM here. Its implementation is ambiguous in HNSW paper,
// so using the way it is getting used in Hnsw lib.
final ImmutableList&lt;T&gt; neighbours = selectNearestNeighboursByHeuristic(candidates, maxM);
setConnectionList(item, level, neighbours);
final int M = level == 0 ? maxM0 : maxM;
for (T nn : neighbours) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (nn.equals(item)) {</dt><dd><p>continue;</p>
</dd>
</dl>
<p>}
final Lock curLock = locks.computeIfAbsent(nn, lockProvider).writeLock();
curLock.lock();
try {</p>
<blockquote>
<div><p>final HnswNode&lt;T&gt; key = HnswNode.from(level, nn);
final ImmutableList&lt;T&gt; connections = graph.getOrDefault(key, ImmutableList.of());
final boolean isItemAlreadyPresent =</p>
<blockquote>
<div><p>isUpdate &amp;&amp; connections.indexOf(item) != -1 ? true : false;</p>
</div></blockquote>
<p>// If <cite>item</cite> is already present in the neighboring connections,
// then no need to modify any connections or run the search heuristics.
if (isItemAlreadyPresent) {</p>
<blockquote>
<div><p>continue;</p>
</div></blockquote>
<p>}</p>
<p>final ImmutableList&lt;T&gt; updatedConnections;
if (connections.size() &lt; M) {</p>
<blockquote>
<div><p>final List&lt;T&gt; temp = new ArrayList&lt;&gt;(connections);
temp.add(item);
updatedConnections = ImmutableList.copyOf(temp.iterator());</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>// Max Queue
final DistancedItemQueue&lt;T, T&gt; queue = new DistancedItemQueue&lt;&gt;(</p>
<blockquote>
<div><p>nn,
connections,
false,
distFnIndex</p>
</div></blockquote>
<p>);
queue.enqueue(item);
updatedConnections = selectNearestNeighboursByHeuristic(queue, M);</p>
</dd>
</dl>
<p>}
if (updatedConnections.isEmpty()) {</p>
<blockquote>
<div><p>LOG.debug(“Internal error: predicted linkslist is empty”);</p>
</div></blockquote>
<p>}</p>
<p>graph.put(key, updatedConnections);</p>
</div></blockquote>
<dl class="simple">
<dt>} finally {</dt><dd><p>curLock.unlock();</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return neighbours.get(0);</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/*</dt><dd><ul class="simple">
<li><p>bestEntryPointUntilLayer starts the graph search for item from the entry point</p></li>
<li><p>until the searches reaches the selectedLayer layer.</p></li>
<li><p>&#64;return a point from selectedLayer layer, was the closest on the (selectedLayer+1) layer</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>private &lt;K&gt; T bestEntryPointUntilLayer(</dt><dd><p>final T entryPoint,
final K item,
int maxLayer,
int selectedLayer,
DistanceFunction&lt;K, T&gt; distFn</p>
</dd>
<dt>) {</dt><dd><p>T curObj = entryPoint;
if (selectedLayer &lt; maxLayer) {</p>
<blockquote>
<div><p>float curDist = distFn.distance(item, curObj);
for (int level = maxLayer; level &gt; selectedLayer; level–) {</p>
<blockquote>
<div><p>boolean changed = true;
while (changed) {</p>
<blockquote>
<div><p>changed = false;
final List&lt;T&gt; list = getConnectionListForRead(curObj, level);
for (T nn : list) {</p>
<blockquote>
<div><p>final float tempDist = distFn.distance(item, nn);
if (tempDist &lt; curDist) {</p>
<blockquote>
<div><p>curDist = tempDist;
curObj = nn;
changed = true;</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>return curObj;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;VisibleForTesting
protected ImmutableList&lt;T&gt; selectNearestNeighboursByHeuristic(</p>
<blockquote>
<div><p>final DistancedItemQueue&lt;T, T&gt; candidates, // Max queue
final int maxConnections</p>
</div></blockquote>
<dl>
<dt>) {</dt><dd><dl class="simple">
<dt>Preconditions.checkState(!candidates.isMinQueue(),</dt><dd><p>“candidates in selectNearestNeighboursByHeuristic should be a max queue”);</p>
</dd>
</dl>
<p>final T baseElement = candidates.getOrigin();
if (candidates.size() &lt;= maxConnections) {</p>
<blockquote>
<div><p>List&lt;T&gt; list = candidates.toListWithItem();
list.remove(baseElement);
return ImmutableList.copyOf(list);</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>final List&lt;T&gt; resSet = new ArrayList&lt;&gt;(maxConnections);
// Min queue for closest elements first
final DistancedItemQueue&lt;T, T&gt; minQueue = candidates.reverse();
while (minQueue.nonEmpty()) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (resSet.size() &gt;= maxConnections) {</dt><dd><p>break;</p>
</dd>
</dl>
<p>}
final DistancedItem&lt;T&gt; candidate = minQueue.dequeue();</p>
<p>// We do not want to creates loops:
// While heuristic is used only for creating the links
if (candidate.getItem().equals(baseElement)) {</p>
<blockquote>
<div><p>continue;</p>
</div></blockquote>
<p>}</p>
<p>boolean toInclude = true;
for (T e : resSet) {</p>
<blockquote>
<div><p>// Do not include candidate if the distance from candidate to any of existing item in
// resSet is closer to the distance from the candidate to the item. By doing this, the
// connection of graph will be more diverse, and in case of highly clustered data set,
// connections will be made between clusters instead of all being in the same cluster.
final float dist = distFnIndex.distance(e, candidate.getItem());
if (dist &lt; candidate.getDistance()) {</p>
<blockquote>
<div><p>toInclude = false;
break;</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if (toInclude) {</dt><dd><p>resSet.add(candidate.getItem());</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return ImmutableList.copyOf(resSet);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Search the index for the neighbours.</p></li>
<li></li>
<li><p>&#64;param query           Query</p></li>
<li><p>&#64;param numOfNeighbours Number of neighbours to search for.</p></li>
<li><p>&#64;param ef              This param controls the accuracy of the search.</p></li>
<li><p>Bigger the ef better the accuracy on the expense of latency.</p></li>
<li><p>Keep it atleast number of neighbours to find.</p></li>
<li><p>&#64;return Neighbours</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>public List&lt;DistancedItem&lt;T&gt;&gt; searchKnn(final Q query, final int numOfNeighbours, final int ef) {</dt><dd><p>final HnswMeta&lt;T&gt; metadata = graphMeta.get();
if (metadata.getEntryPoint().isPresent()) {</p>
<blockquote>
<div><dl class="simple">
<dt>T entryPoint = bestEntryPointUntilLayer(metadata.getEntryPoint().get(),</dt><dd><p>query, metadata.getMaxLevel(), 0, distFnQuery);</p>
</dd>
</dl>
<p>// Get the actual neighbours from 0th layer
final List&lt;DistancedItem&lt;T&gt;&gt; neighbours =</p>
<blockquote>
<div><dl class="simple">
<dt>searchLayerForCandidates(query, entryPoint, Math.max(ef, numOfNeighbours),</dt><dd><p>0, distFnQuery, false).dequeueAll();</p>
</dd>
</dl>
</div></blockquote>
<p>Collections.reverse(neighbours);
return neighbours.size() &gt; numOfNeighbours</p>
<blockquote>
<div><p>? neighbours.subList(0, numOfNeighbours) : neighbours;</p>
</div></blockquote>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>return Collections.emptyList();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// This method is currently not used
// It is needed for debugging purposes only
private void checkIntegrity(String message) {</p>
<blockquote>
<div><p>final HnswMeta&lt;T&gt; metadata = graphMeta.get();
for (HnswNode&lt;T&gt; node : graph.keySet()) {</p>
<blockquote>
<div><p>List&lt;T&gt; linkList = graph.get(node);</p>
<dl>
<dt>for (T el<span class="classifier">linkList) {</span></dt><dd><dl class="simple">
<dt>if (el.equals(node.item)) {</dt><dd><p>LOG.debug(message);
throw new RuntimeException(“integrity check failed”);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private &lt;K&gt; DistancedItemQueue&lt;K, T&gt; searchLayerForCandidates(</dt><dd><p>final K item,
final T entryPoint,
final int ef,
final int level,
final DistanceFunction&lt;K, T&gt; distFn,
boolean isUpdate</p>
</dd>
<dt>) {</dt><dd><p>// Min queue
final DistancedItemQueue&lt;K, T&gt; cQueue = new DistancedItemQueue&lt;&gt;(</p>
<blockquote>
<div><p>item,
Collections.singletonList(entryPoint),
true,
distFn</p>
</div></blockquote>
<p>);
// Max Queue
final DistancedItemQueue&lt;K, T&gt; wQueue = cQueue.reverse();
final Set&lt;T&gt; visited = new HashSet&lt;&gt;();
float lowerBoundDistance = wQueue.peek().getDistance();
visited.add(entryPoint);</p>
<dl>
<dt>while (cQueue.nonEmpty()) {</dt><dd><p>final DistancedItem&lt;T&gt; candidate = cQueue.peek();
if (candidate.getDistance() &gt; lowerBoundDistance) {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}</p>
<p>cQueue.dequeue();
final List&lt;T&gt; list = getConnectionListForRead(candidate.getItem(), level);
for (T nn : list) {</p>
<blockquote>
<div><dl>
<dt>if (!visited.contains(nn)) {</dt><dd><p>visited.add(nn);
final float distance = distFn.distance(item, nn);
if (wQueue.size() &lt; ef || distance &lt; wQueue.peek().getDistance()) {</p>
<blockquote>
<div><p>cQueue.enqueue(nn, distance);</p>
<dl class="simple">
<dt>if (isUpdate &amp;&amp; item.equals(nn)) {</dt><dd><p>continue;</p>
</dd>
</dl>
<p>}</p>
<p>wQueue.enqueue(nn, distance);
if (wQueue.size() &gt; ef) {</p>
<blockquote>
<div><p>wQueue.dequeue();</p>
</div></blockquote>
<p>}</p>
<p>lowerBoundDistance = wQueue.peek().getDistance();</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>return wQueue;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Serialize hnsw index</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
<dt>public void toDirectory(IndexOutputFile indexOutputFile, Injection&lt;T, byte[]&gt; injection)</dt><dd><p>throws IOException, TException {</p>
</dd>
<dt>final int totalGraphEntries = HnswIndexIOUtil.saveHnswGraphEntries(</dt><dd><p>graph,
indexOutputFile.createFile(GRAPH_FILE_NAME).getOutputStream(),
injection);</p>
</dd>
<dt>HnswIndexIOUtil.saveMetadata(</dt><dd><p>graphMeta.get(),
efConstruction,
maxM,
totalGraphEntries,
injection,
indexOutputFile.createFile(METADATA_FILE_NAME).getOutputStream());</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Load hnsw index</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>public static &lt;T, Q&gt; HnswIndex&lt;T, Q&gt; loadHnswIndex(</dt><dd><blockquote>
<div><p>DistanceFunction&lt;T, T&gt; distFnIndex,
DistanceFunction&lt;Q, T&gt; distFnQuery,
AbstractFile directory,
Injection&lt;T, byte[]&gt; injection,
RandomProvider randomProvider) throws IOException, TException {</p>
</div></blockquote>
<p>final AbstractFile graphFile = directory.getChild(GRAPH_FILE_NAME);
final AbstractFile metadataFile = directory.getChild(METADATA_FILE_NAME);
final HnswInternalIndexMetadata metadata = HnswIndexIOUtil.loadMetadata(metadataFile);
final Map&lt;HnswNode&lt;T&gt;, ImmutableList&lt;T&gt;&gt; graph =</p>
<blockquote>
<div><p>HnswIndexIOUtil.loadHnswGraph(graphFile, injection, metadata.numElements);</p>
</div></blockquote>
<p>final ByteBuffer entryPointBB = metadata.entryPoint;
final HnswMeta&lt;T&gt; graphMeta = new HnswMeta&lt;&gt;(</p>
<blockquote>
<div><p>metadata.maxLevel,
entryPointBB == null ? Optional.empty()</p>
<blockquote>
<div><p>: Optional.of(injection.invert(ArrayByteBufferCodec.decode(entryPointBB)).get())</p>
</div></blockquote>
</div></blockquote>
<p>);
return new HnswIndex&lt;&gt;(</p>
<blockquote>
<div><p>distFnIndex,
distFnQuery,
metadata.efConstruction,
metadata.maxM,
metadata.numElements,
graphMeta,
graph,
randomProvider</p>
</div></blockquote>
<p>);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private List&lt;T&gt; getConnectionListForRead(T node, int level) {</dt><dd><p>final Lock curLock = locks.computeIfAbsent(node, lockProvider).readLock();
curLock.lock();
final List&lt;T&gt; list;
try {</p>
<blockquote>
<div><dl class="simple">
<dt>list = graph</dt><dd><p>.getOrDefault(HnswNode.from(level, node), ImmutableList.of());</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>} finally {</dt><dd><p>curLock.unlock();</p>
</dd>
</dl>
<p>}</p>
<p>return list;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;VisibleForTesting
AtomicReference&lt;HnswMeta&lt;T&gt;&gt; getGraphMeta() {</p>
<blockquote>
<div><p>return graphMeta;</p>
</div></blockquote>
<p>}</p>
<p>&#64;VisibleForTesting
Map&lt;T, ReadWriteLock&gt; getLocks() {</p>
<blockquote>
<div><p>return locks;</p>
</div></blockquote>
<p>}</p>
<p>&#64;VisibleForTesting
Map&lt;HnswNode&lt;T&gt;, ImmutableList&lt;T&gt;&gt; getGraph() {</p>
<blockquote>
<div><p>return graph;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>public interface RandomProvider {</dt><dd><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>RandomProvider interface made public for scala 2.12 compat</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
</dl>
<p>Random get();</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../_sources/ann/src/main/java/com/twitter/ann/hnsw/HnswIndex.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>