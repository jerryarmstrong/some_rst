<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.cr_mixer.util</p>
<p>import com.twitter.cr_mixer.model.Candidate
import com.twitter.cr_mixer.model.CandidateGenerationInfo
import com.twitter.cr_mixer.model.RankedCandidate
import com.twitter.cr_mixer.model.SourceInfo
import com.twitter.cr_mixer.thriftscala.SimilarityEngineType
import com.twitter.simclusters_v2.common.TweetId
import scala.collection.mutable
import scala.collection.mutable.ArrayBuffer</p>
<p>object InterleaveUtil {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Interleaves candidates by iteratively taking one candidate from the 1st Seq and adding it to the result.</p></li>
<li><p>Once we take a candidate from a Seq, we move this Seq to the end of the queue to process,</p></li>
<li><p>and remove the candidate from that Seq.</p></li>
<li></li>
<li><p>We keep a mutable.Set[TweetId] buffer to ensure there are no duplicates.</p></li>
<li></li>
<li><p>&#64;param candidates candidates assumed to be sorted by eventTime (latest event comes first)</p></li>
<li><p>&#64;return interleaved candidates</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>def interleave[CandidateType &lt;: Candidate](</dt><dd><p>candidates: Seq[Seq[CandidateType]]</p>
</dd>
</dl>
<p>): Seq[CandidateType] = {</p>
<blockquote>
<div><p>// copy candidates into a mutable map so this method is thread-safe
val candidatesPerSequence = candidates.map { tweetCandidates =&gt;</p>
<blockquote>
<div><p>mutable.Queue() ++= tweetCandidates</p>
</div></blockquote>
<p>}</p>
<p>val seen = mutable.Set[TweetId]()</p>
<p>val candidateSeqQueue = mutable.Queue() ++= candidatesPerSequence</p>
<p>val result = ArrayBuffer[CandidateType]()</p>
<dl>
<dt>while (candidateSeqQueue.nonEmpty) {</dt><dd><p>val candidatesQueue = candidateSeqQueue.head</p>
<dl>
<dt>if (candidatesQueue.nonEmpty) {</dt><dd><p>val candidate = candidatesQueue.dequeue()
val candidateTweetId = candidate.tweetId
val seenCandidate = seen.contains(candidateTweetId)
if (!seenCandidate) {</p>
<blockquote>
<div><p>result += candidate
seen.add(candidate.tweetId)
candidateSeqQueue.enqueue(</p>
<blockquote>
<div><p>candidateSeqQueue.dequeue()</p>
</div></blockquote>
<p>) // move this Seq to end</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>candidateSeqQueue.dequeue() //finished processing this Seq</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
//convert result to immutable seq
result.toList</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Interleaves candidates by iteratively</p></li>
<li><ol class="arabic simple">
<li><p>Checking weight to see if enough accumulation has occurred to sample from</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>If yes, taking one candidate from the the Seq and adding it to the result.</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="3">
<li><p>Move this Seq to the end of the queue to process (and remove the candidate from that Seq if</p></li>
</ol>
</li>
<li><p>we sampled it from step 2).</p></li>
<li></li>
<li><p>We keep count of the iterations to prevent infinite loops.</p></li>
<li><p>We keep a mutable.Set[TweetId] buffer to ensure there are no duplicates.</p></li>
<li></li>
<li><p>&#64;param candidatesAndWeight candidates assumed to be sorted by eventTime (latest event comes first),</p></li>
<li><p>along with sampling weights to help prioritize important groups.</p></li>
<li><p>&#64;param maxWeightAdjustments Maximum number of iterations to account for weighting before</p></li>
<li><p>defaulting to uniform interleaving.</p></li>
<li><p>&#64;return interleaved candidates</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>def weightedInterleave[CandidateType &lt;: Candidate](</dt><dd><p>candidatesAndWeight: Seq[(Seq[CandidateType], Double)],
maxWeightAdjustments: Int = 0</p>
</dd>
</dl>
<p>): Seq[CandidateType] = {</p>
<blockquote>
<div><p>// Set to avoid numerical issues around 1.0
val min_weight = 1 - 1e-30</p>
<p>// copy candidates into a mutable map so this method is thread-safe
// adds a counter to use towards sampling
val candidatesAndWeightsPerSequence: Seq[</p>
<blockquote>
<div><p>(mutable.Queue[CandidateType], InterleaveWeights)</p>
</div></blockquote>
<dl>
<dt>] =</dt><dd><dl class="simple">
<dt>candidatesAndWeight.map { candidatesAndWeight =&gt;</dt><dd><p>(mutable.Queue() ++= candidatesAndWeight._1, InterleaveWeights(candidatesAndWeight._2, 0.0))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>val seen: mutable.Set[TweetId] = mutable.Set[TweetId]()</p>
<dl class="simple">
<dt>val candidateSeqQueue: mutable.Queue[(mutable.Queue[CandidateType], InterleaveWeights)] =</dt><dd><p>mutable.Queue() ++= candidatesAndWeightsPerSequence</p>
</dd>
</dl>
<p>val result: ArrayBuffer[CandidateType] = ArrayBuffer[CandidateType]()
var number_iterations: Int = 0</p>
<dl>
<dt>while (candidateSeqQueue.nonEmpty) {</dt><dd><p>val (candidatesQueue, currentWeights) = candidateSeqQueue.head
if (candidatesQueue.nonEmpty) {</p>
<blockquote>
<div><p>// Confirm weighting scheme
currentWeights.summed_weight += currentWeights.weight
number_iterations += 1
if (currentWeights.summed_weight &gt;= min_weight || number_iterations &gt;= maxWeightAdjustments) {</p>
<blockquote>
<div><p>// If we sample, then adjust the counter
currentWeights.summed_weight -= 1.0
val candidate = candidatesQueue.dequeue()
val candidateTweetId = candidate.tweetId
val seenCandidate = seen.contains(candidateTweetId)
if (!seenCandidate) {</p>
<blockquote>
<div><p>result += candidate
seen.add(candidate.tweetId)
candidateSeqQueue.enqueue(candidateSeqQueue.dequeue()) // move this Seq to end</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>candidateSeqQueue.enqueue(candidateSeqQueue.dequeue()) // move this Seq to end</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>candidateSeqQueue.dequeue() //finished processing this Seq</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
//convert result to immutable seq
result.toList</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>def buildCandidatesKeyByCGInfo(</dt><dd><p>candidates: Seq[RankedCandidate],</p>
</dd>
<dt>): Seq[Seq[RankedCandidate]] = {</dt><dd><p>// To accommodate the re-grouping in InterleaveRanker
// In InterleaveBlender, we have already abandoned the grouping keys, and use Seq[Seq[]] to do interleave
// Since that we build the candidateSeq with groupingKey, we can guarantee there is no empty candidateSeq
val candidateSeqKeyByCG =</p>
<blockquote>
<div><p>candidates.groupBy(candidate =&gt; GroupingKey.toGroupingKey(candidate.reasonChosen))</p>
</div></blockquote>
<dl class="simple">
<dt>candidateSeqKeyByCG.map {</dt><dd><dl class="simple">
<dt>case (groupingKey, candidateSeq) =&gt;</dt><dd><p>candidateSeq.sortBy(-_.predictionScore)</p>
</dd>
</dl>
</dd>
</dl>
<p>}.toSeq</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>case class GroupingKey(</dt><dd><p>sourceInfoOpt: Option[SourceInfo],
similarityEngineType: SimilarityEngineType,
modelId: Option[String]) {}</p>
</dd>
<dt>object GroupingKey {</dt><dd><dl>
<dt>def toGroupingKey(candidateGenerationInfo: CandidateGenerationInfo): GroupingKey = {</dt><dd><dl class="simple">
<dt>GroupingKey(</dt><dd><p>candidateGenerationInfo.sourceInfoOpt,
candidateGenerationInfo.similarityEngineInfo.similarityEngineType,
candidateGenerationInfo.similarityEngineInfo.modelId</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>case class InterleaveWeights(weight: Double, var summed_weight: Double)</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/cr-mixer/server/src/main/scala/com/twitter/cr_mixer/util/InterleaveUtil.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>