<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.cr_mixer.logging</p>
<p>import com.google.common.base.CaseFormat
import com.twitter.abdecider.ScribingABDeciderUtil
import com.twitter.scribelib.marshallers.ClientDataProvider
import com.twitter.scribelib.marshallers.ScribeSerialization
import com.twitter.timelines.clientevent.MinimalClientDataProvider
import com.twitter.cr_mixer.model.BlendedCandidate
import com.twitter.cr_mixer.model.CrCandidateGeneratorQuery
import com.twitter.cr_mixer.model.InitialCandidate
import com.twitter.cr_mixer.model.RankedCandidate
import com.twitter.cr_mixer.logging.ScribeLoggerUtils._
import com.twitter.cr_mixer.model.GraphSourceInfo
import com.twitter.cr_mixer.param.decider.CrMixerDecider
import com.twitter.cr_mixer.param.decider.DeciderConstants
import com.twitter.cr_mixer.scribe.ScribeCategories
import com.twitter.cr_mixer.thriftscala.CrMixerTweetRequest
import com.twitter.cr_mixer.thriftscala.CrMixerTweetResponse
import com.twitter.cr_mixer.thriftscala.FetchCandidatesResult
import com.twitter.cr_mixer.thriftscala.FetchSignalSourcesResult
import com.twitter.cr_mixer.thriftscala.GetTweetsRecommendationsScribe
import com.twitter.cr_mixer.thriftscala.InterleaveResult
import com.twitter.cr_mixer.thriftscala.PerformanceMetrics
import com.twitter.cr_mixer.thriftscala.PreRankFilterResult
import com.twitter.cr_mixer.thriftscala.Product
import com.twitter.cr_mixer.thriftscala.RankResult
import com.twitter.cr_mixer.thriftscala.Result
import com.twitter.cr_mixer.thriftscala.SourceSignal
import com.twitter.cr_mixer.thriftscala.TopLevelApiResult
import com.twitter.cr_mixer.thriftscala.TweetCandidateWithMetadata
import com.twitter.cr_mixer.thriftscala.VITTweetCandidateScribe
import com.twitter.cr_mixer.thriftscala.VITTweetCandidatesScribe
import com.twitter.cr_mixer.model.ModuleNames
import com.twitter.cr_mixer.model.SourceInfo
import com.twitter.cr_mixer.util.CandidateGenerationKeyUtil
import com.twitter.cr_mixer.util.MetricTagUtil
import com.twitter.decider.SimpleRecipient
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.finagle.tracing.Trace
import com.twitter.finatra.kafka.producers.KafkaProducerBase
import com.twitter.logging.Logger
import com.twitter.simclusters_v2.common.UserId
import com.twitter.simclusters_v2.thriftscala.InternalId
import com.twitter.util.Future
import com.twitter.util.Stopwatch
import com.twitter.util.Time</p>
<p>import javax.inject.Inject
import javax.inject.Named
import javax.inject.Singleton
import scala.util.Random</p>
<p>&#64;Singleton
case class CrMixerScribeLogger &#64;Inject() (</p>
<blockquote>
<div><p>decider: CrMixerDecider,
statsReceiver: StatsReceiver,
&#64;Named(ModuleNames.TweetRecsLogger) tweetRecsScribeLogger: Logger,
&#64;Named(ModuleNames.BlueVerifiedTweetRecsLogger) blueVerifiedTweetRecsScribeLogger: Logger,
&#64;Named(ModuleNames.TopLevelApiDdgMetricsLogger) ddgMetricsLogger: Logger,
kafkaProducer: KafkaProducerBase[String, GetTweetsRecommendationsScribe]) {</p>
<p>import CrMixerScribeLogger._</p>
<p>private val scopedStats = statsReceiver.scope(“CrMixerScribeLogger”)
private val topLevelApiStats = scopedStats.scope(“TopLevelApi”)
private val upperFunnelsStats = scopedStats.scope(“UpperFunnels”)
private val kafkaMessagesStats = scopedStats.scope(“KafkaMessages”)
private val topLevelApiDdgMetricsStats = scopedStats.scope(“TopLevelApiDdgMetrics”)
private val blueVerifiedTweetCandidatesStats = scopedStats.scope(“BlueVerifiedTweetCandidates”)</p>
<p>private val serialization = new ScribeSerialization {}</p>
<dl>
<dt>def scribeSignalSources(</dt><dd><p>query: CrCandidateGeneratorQuery,
getResultFn: =&gt; Future[(Set[SourceInfo], Map[String, Option[GraphSourceInfo]])]</p>
</dd>
<dt>): Future[(Set[SourceInfo], Map[String, Option[GraphSourceInfo]])] = {</dt><dd><dl class="simple">
<dt>scribeResultsAndPerformanceMetrics(</dt><dd><p>ScribeMetadata.from(query),
getResultFn,
convertToResultFn = convertFetchSignalSourcesResult</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def scribeInitialCandidates(</dt><dd><p>query: CrCandidateGeneratorQuery,
getResultFn: =&gt; Future[Seq[Seq[InitialCandidate]]]</p>
</dd>
<dt>): Future[Seq[Seq[InitialCandidate]]] = {</dt><dd><dl class="simple">
<dt>scribeResultsAndPerformanceMetrics(</dt><dd><p>ScribeMetadata.from(query),
getResultFn,
convertToResultFn = convertFetchCandidatesResult</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def scribePreRankFilterCandidates(</dt><dd><p>query: CrCandidateGeneratorQuery,
getResultFn: =&gt; Future[Seq[Seq[InitialCandidate]]]</p>
</dd>
<dt>): Future[Seq[Seq[InitialCandidate]]] = {</dt><dd><dl class="simple">
<dt>scribeResultsAndPerformanceMetrics(</dt><dd><p>ScribeMetadata.from(query),
getResultFn,
convertToResultFn = convertPreRankFilterResult</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def scribeInterleaveCandidates(</dt><dd><p>query: CrCandidateGeneratorQuery,
getResultFn: =&gt; Future[Seq[BlendedCandidate]]</p>
</dd>
<dt>): Future[Seq[BlendedCandidate]] = {</dt><dd><dl class="simple">
<dt>scribeResultsAndPerformanceMetrics(</dt><dd><p>ScribeMetadata.from(query),
getResultFn,
convertToResultFn = convertInterleaveResult,
enableKafkaScribe = true</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def scribeRankedCandidates(</dt><dd><p>query: CrCandidateGeneratorQuery,
getResultFn: =&gt; Future[Seq[RankedCandidate]]</p>
</dd>
<dt>): Future[Seq[RankedCandidate]] = {</dt><dd><dl class="simple">
<dt>scribeResultsAndPerformanceMetrics(</dt><dd><p>ScribeMetadata.from(query),
getResultFn,
convertToResultFn = convertRankResult</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Scribe Top Level API Request / Response and performance metrics</p></li>
<li><p>for the getTweetRecommendations() endpoint.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>def scribeGetTweetRecommendations(</dt><dd><p>request: CrMixerTweetRequest,
startTime: Long,
scribeMetadata: ScribeMetadata,
getResultFn: =&gt; Future[CrMixerTweetResponse]</p>
</dd>
<dt>): Future[CrMixerTweetResponse] = {</dt><dd><p>val timer = Stopwatch.start()
getResultFn.onSuccess { response =&gt;</p>
<blockquote>
<div><p>val latencyMs = timer().inMilliseconds
val result = convertTopLevelAPIResult(request, response, startTime)
val traceId = Trace.id.traceId.toLong
val scribeMsg = buildScribeMessage(result, scribeMetadata, latencyMs, traceId)</p>
<p>// We use upperFunnelPerStepScribeRate to cover TopLevelApi scribe logs
if (decider.isAvailableForId(</p>
<blockquote>
<div><blockquote>
<div><p>scribeMetadata.userId,
DeciderConstants.upperFunnelPerStepScribeRate)) {</p>
</div></blockquote>
<p>topLevelApiStats.counter(scribeMetadata.product.originalName).incr()
scribeResult(scribeMsg)</p>
</div></blockquote>
<p>}
if (decider.isAvailableForId(</p>
<blockquote>
<div><blockquote>
<div><p>scribeMetadata.userId,
DeciderConstants.topLevelApiDdgMetricsScribeRate)) {</p>
</div></blockquote>
<p>topLevelApiDdgMetricsStats.counter(scribeMetadata.product.originalName).incr()
val topLevelDdgMetricsMetadata = TopLevelDdgMetricsMetadata.from(request)
publishTopLevelDdgMetrics(</p>
<blockquote>
<div><p>logger = ddgMetricsLogger,
topLevelDdgMetricsMetadata = topLevelDdgMetricsMetadata,
latencyMs = latencyMs,
candidateSize = response.tweets.length)</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Scribe all of the Blue Verified tweets that are candidates from cr-mixer</p></li>
<li><p>from the getTweetRecommendations() endpoint for stats tracking/debugging purposes.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>def scribeGetTweetRecommendationsForBlueVerified(</dt><dd><p>scribeMetadata: ScribeMetadata,
getResultFn: =&gt; Future[Seq[RankedCandidate]]</p>
</dd>
<dt>): Future[Seq[RankedCandidate]] = {</dt><dd><dl>
<dt>getResultFn.onSuccess { rankedCandidates =&gt;</dt><dd><dl>
<dt>if (decider.isAvailable(DeciderConstants.enableScribeForBlueVerifiedTweetCandidates)) {</dt><dd><p>blueVerifiedTweetCandidatesStats.counter(“process_request”).incr()</p>
<dl class="simple">
<dt>val blueVerifiedTweetCandidates = rankedCandidates.filter { tweet =&gt;</dt><dd><p>tweet.tweetInfo.hasBlueVerifiedAnnotation.contains(true)</p>
</dd>
</dl>
<p>}</p>
<p>val impressedBuckets = getImpressedBuckets(blueVerifiedTweetCandidatesStats).getOrElse(Nil)</p>
<dl>
<dt>val blueVerifiedCandidateScribes = blueVerifiedTweetCandidates.map { candidate =&gt;</dt><dd><dl class="simple">
<dt>blueVerifiedTweetCandidatesStats</dt><dd><dl class="simple">
<dt>.scope(scribeMetadata.product.name).counter(</dt><dd><p>candidate.tweetInfo.authorId.toString).incr()</p>
</dd>
</dl>
</dd>
<dt>VITTweetCandidateScribe(</dt><dd><p>tweetId = candidate.tweetId,
authorId = candidate.tweetInfo.authorId,
score = candidate.predictionScore,
metricTags = MetricTagUtil.buildMetricTags(candidate)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val blueVerifiedScribe =</dt><dd><dl class="simple">
<dt>VITTweetCandidatesScribe(</dt><dd><p>uuid = scribeMetadata.requestUUID,
userId = scribeMetadata.userId,
candidates = blueVerifiedCandidateScribes,
product = scribeMetadata.product,
impressedBuckets = impressedBuckets</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>publish(</dt><dd><p>logger = blueVerifiedTweetRecsScribeLogger,
codec = VITTweetCandidatesScribe,
message = blueVerifiedScribe)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Scribe Per-step intermediate results and performance metrics</p></li>
<li><p>for each step: fetch signals, fetch candidates, filters, ranker, etc</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>private[logging] def scribeResultsAndPerformanceMetrics[T](</dt><dd><p>scribeMetadata: ScribeMetadata,
getResultFn: =&gt; Future[T],
convertToResultFn: (T, UserId) =&gt; Result,
enableKafkaScribe: Boolean = false</p>
</dd>
<dt>): Future[T] = {</dt><dd><p>val timer = Stopwatch.start()
getResultFn.onSuccess { input =&gt;</p>
<blockquote>
<div><p>val latencyMs = timer().inMilliseconds
val result = convertToResultFn(input, scribeMetadata.userId)
val traceId = Trace.id.traceId.toLong
val scribeMsg = buildScribeMessage(result, scribeMetadata, latencyMs, traceId)</p>
<dl>
<dt>if (decider.isAvailableForId(</dt><dd><blockquote>
<div><p>scribeMetadata.userId,
DeciderConstants.upperFunnelPerStepScribeRate)) {</p>
</div></blockquote>
<p>upperFunnelsStats.counter(scribeMetadata.product.originalName).incr()
scribeResult(scribeMsg)</p>
</dd>
</dl>
<p>}</p>
<p>// forks the scribe as a Kafka message for async feature hydration
if (enableKafkaScribe &amp;&amp; shouldScribeKafkaMessage(</p>
<blockquote>
<div><blockquote>
<div><p>scribeMetadata.userId,
scribeMetadata.product)) {</p>
</div></blockquote>
<p>kafkaMessagesStats.counter(scribeMetadata.product.originalName).incr()</p>
<p>val batchedKafkaMessages = downsampleKafkaMessage(scribeMsg)
batchedKafkaMessages.foreach { kafkaMessage =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>kafkaProducer.send(</dt><dd><p>topic = ScribeCategories.TweetsRecs.scribeCategory,
key = traceId.toString,
value = kafkaMessage,
timestamp = Time.now.inMilliseconds</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def convertTopLevelAPIResult(</dt><dd><p>request: CrMixerTweetRequest,
response: CrMixerTweetResponse,
startTime: Long</p>
</dd>
<dt>): Result = {</dt><dd><dl>
<dt>Result.TopLevelApiResult(</dt><dd><dl class="simple">
<dt>TopLevelApiResult(</dt><dd><p>timestamp = startTime,
request = request,
response = response</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def convertFetchSignalSourcesResult(</dt><dd><p>sourceInfoSetTuple: (Set[SourceInfo], Map[String, Option[GraphSourceInfo]]),
requestUserId: UserId</p>
</dd>
<dt>): Result = {</dt><dd><dl class="simple">
<dt>val sourceSignals = sourceInfoSetTuple._1.map { sourceInfo =&gt;</dt><dd><p>SourceSignal(id = Some(sourceInfo.internalId))</p>
</dd>
</dl>
<p>}
// For source graphs, we pass in requestUserId as a placeholder
val sourceGraphs = sourceInfoSetTuple._2.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (_, _) =&gt;</dt><dd><p>SourceSignal(id = Some(InternalId.UserId(requestUserId)))</p>
</dd>
</dl>
</div></blockquote>
<p>}
Result.FetchSignalSourcesResult(</p>
<blockquote>
<div><dl class="simple">
<dt>FetchSignalSourcesResult(</dt><dd><p>signals = Some(sourceSignals ++ sourceGraphs)</p>
</dd>
</dl>
<p>))</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def convertFetchCandidatesResult(</dt><dd><p>candidatesSeq: Seq[Seq[InitialCandidate]],
requestUserId: UserId</p>
</dd>
<dt>): Result = {</dt><dd><dl>
<dt>val tweetCandidatesWithMetadata = candidatesSeq.flatMap { candidates =&gt;</dt><dd><dl>
<dt>candidates.map { candidate =&gt;</dt><dd><dl>
<dt>TweetCandidateWithMetadata(</dt><dd><p>tweetId = candidate.tweetId,
candidateGenerationKey = Some(</p>
<blockquote>
<div><p>CandidateGenerationKeyUtil.toThrift(candidate.candidateGenerationInfo, requestUserId)),</p>
</div></blockquote>
<p>score = Some(candidate.getSimilarityScore),
numCandidateGenerationKeys = None // not populated yet</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
Result.FetchCandidatesResult(FetchCandidatesResult(Some(tweetCandidatesWithMetadata)))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def convertPreRankFilterResult(</dt><dd><p>candidatesSeq: Seq[Seq[InitialCandidate]],
requestUserId: UserId</p>
</dd>
<dt>): Result = {</dt><dd><dl>
<dt>val tweetCandidatesWithMetadata = candidatesSeq.flatMap { candidates =&gt;</dt><dd><dl>
<dt>candidates.map { candidate =&gt;</dt><dd><dl>
<dt>TweetCandidateWithMetadata(</dt><dd><p>tweetId = candidate.tweetId,
candidateGenerationKey = Some(</p>
<blockquote>
<div><p>CandidateGenerationKeyUtil.toThrift(candidate.candidateGenerationInfo, requestUserId)),</p>
</div></blockquote>
<p>score = Some(candidate.getSimilarityScore),
numCandidateGenerationKeys = None // not populated yet</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
Result.PreRankFilterResult(PreRankFilterResult(Some(tweetCandidatesWithMetadata)))</p>
</dd>
</dl>
<p>}</p>
<p>// We take InterleaveResult for Unconstrained dataset ML ranker training
private def convertInterleaveResult(</p>
<blockquote>
<div><p>blendedCandidates: Seq[BlendedCandidate],
requestUserId: UserId</p>
</div></blockquote>
<dl>
<dt>): Result = {</dt><dd><dl>
<dt>val tweetCandidatesWithMetadata = blendedCandidates.map { blendedCandidate =&gt;</dt><dd><dl class="simple">
<dt>val candidateGenerationKey =</dt><dd><p>CandidateGenerationKeyUtil.toThrift(blendedCandidate.reasonChosen, requestUserId)</p>
</dd>
<dt>TweetCandidateWithMetadata(</dt><dd><p>tweetId = blendedCandidate.tweetId,
candidateGenerationKey = Some(candidateGenerationKey),
authorId = Some(blendedCandidate.tweetInfo.authorId), // for ML pipeline training
score = Some(blendedCandidate.getSimilarityScore),
numCandidateGenerationKeys = Some(blendedCandidate.potentialReasons.size)</p>
</dd>
</dl>
<p>) // hydrate fields for light ranking training data</p>
</dd>
</dl>
<p>}
Result.InterleaveResult(InterleaveResult(Some(tweetCandidatesWithMetadata)))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def convertRankResult(</dt><dd><p>rankedCandidates: Seq[RankedCandidate],
requestUserId: UserId</p>
</dd>
<dt>): Result = {</dt><dd><dl>
<dt>val tweetCandidatesWithMetadata = rankedCandidates.map { rankedCandidate =&gt;</dt><dd><dl class="simple">
<dt>val candidateGenerationKey =</dt><dd><p>CandidateGenerationKeyUtil.toThrift(rankedCandidate.reasonChosen, requestUserId)</p>
</dd>
<dt>TweetCandidateWithMetadata(</dt><dd><p>tweetId = rankedCandidate.tweetId,
candidateGenerationKey = Some(candidateGenerationKey),
score = Some(rankedCandidate.getSimilarityScore),
numCandidateGenerationKeys = Some(rankedCandidate.potentialReasons.size)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}
Result.RankResult(RankResult(Some(tweetCandidatesWithMetadata)))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def buildScribeMessage(</dt><dd><p>result: Result,
scribeMetadata: ScribeMetadata,
latencyMs: Long,
traceId: Long</p>
</dd>
<dt>): GetTweetsRecommendationsScribe = {</dt><dd><dl class="simple">
<dt>GetTweetsRecommendationsScribe(</dt><dd><p>uuid = scribeMetadata.requestUUID,
userId = scribeMetadata.userId,
result = result,
traceId = Some(traceId),
performanceMetrics = Some(PerformanceMetrics(Some(latencyMs))),
impressedBuckets = getImpressedBuckets(scopedStats)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private def scribeResult(</dt><dd><p>scribeMsg: GetTweetsRecommendationsScribe</p>
</dd>
<dt>): Unit = {</dt><dd><dl class="simple">
<dt>publish(</dt><dd><p>logger = tweetRecsScribeLogger,
codec = GetTweetsRecommendationsScribe,
message = scribeMsg)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Gate for producing messages to Kafka for async feature hydration</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>private def shouldScribeKafkaMessage(</dt><dd><p>userId: UserId,
product: Product</p>
</dd>
<dt>): Boolean = {</dt><dd><dl class="simple">
<dt>val isEligibleUser = decider.isAvailable(</dt><dd><p>DeciderConstants.kafkaMessageScribeSampleRate,
Some(SimpleRecipient(userId)))</p>
</dd>
</dl>
<p>val isHomeProduct = (product == Product.Home)
isEligibleUser &amp;&amp; isHomeProduct</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Due to size limits of Strato (see SD-19028), each Kafka message must be downsampled</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>private[logging] def downsampleKafkaMessage(</dt><dd><p>scribeMsg: GetTweetsRecommendationsScribe</p>
</dd>
<dt>): Seq[GetTweetsRecommendationsScribe] = {</dt><dd><dl>
<dt>val sampledResultSeq: Seq[Result] = scribeMsg.result match {</dt><dd><dl>
<dt>case Result.InterleaveResult(interleaveResult) =&gt;</dt><dd><dl>
<dt>val sampledTweetsSeq = interleaveResult.tweets</dt><dd><dl class="simple">
<dt>.map { tweets =&gt;</dt><dd><dl class="simple">
<dt>Random</dt><dd><p>.shuffle(tweets).take(KafkaMaxTweetsPerMessage)
.grouped(BatchSize).toSeq</p>
</dd>
</dl>
</dd>
</dl>
<p>}.getOrElse(Seq.empty)</p>
</dd>
<dt>sampledTweetsSeq.map { sampledTweets =&gt;</dt><dd><p>Result.InterleaveResult(InterleaveResult(Some(sampledTweets)))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>// if it’s an unrecognized type, err on the side of sending no candidates
case _ =&gt;</p>
<blockquote>
<div><p>kafkaMessagesStats.counter(“InvalidKafkaMessageResultType”).incr()
Seq(Result.InterleaveResult(InterleaveResult(None)))</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>sampledResultSeq.map { sampledResult =&gt;</dt><dd><dl class="simple">
<dt>GetTweetsRecommendationsScribe(</dt><dd><p>uuid = scribeMsg.uuid,
userId = scribeMsg.userId,
result = sampledResult,
traceId = scribeMsg.traceId,
performanceMetrics = None,
impressedBuckets = None</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Handles client_event serialization to log data into DDG metrics</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>private[logging] def publishTopLevelDdgMetrics(</dt><dd><p>logger: Logger,
topLevelDdgMetricsMetadata: TopLevelDdgMetricsMetadata,
candidateSize: Long,
latencyMs: Long,</p>
</dd>
<dt>): Unit = {</dt><dd><dl class="simple">
<dt>val data = Map[Any, Any](</dt><dd><p>“latency_ms” -&gt; latencyMs,
“event_value” -&gt; candidateSize</p>
</dd>
</dl>
<p>)
val label: (String, String) = (“tweetrec”, “”)
val namespace = getNamespace(topLevelDdgMetricsMetadata, label) + (“action” -&gt; “candidates”)
val message =</p>
<blockquote>
<div><dl class="simple">
<dt>serialization</dt><dd><p>.serializeClientEvent(namespace, getClientData(topLevelDdgMetricsMetadata), data)</p>
</dd>
</dl>
</div></blockquote>
<p>logger.info(message)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def getClientData(</dt><dd><p>topLevelDdgMetricsMetadata: TopLevelDdgMetricsMetadata</p>
</dd>
<dt>): ClientDataProvider =</dt><dd><dl class="simple">
<dt>MinimalClientDataProvider(</dt><dd><p>userId = topLevelDdgMetricsMetadata.userId,
guestId = None,
clientApplicationId = topLevelDdgMetricsMetadata.clientApplicationId,
countryCode = topLevelDdgMetricsMetadata.countryCode</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>private def getNamespace(</dt><dd><p>topLevelDdgMetricsMetadata: TopLevelDdgMetricsMetadata,
label: (String, String)</p>
</dd>
<dt>): Map[String, String] = {</dt><dd><dl>
<dt>val productName =</dt><dd><dl class="simple">
<dt>CaseFormat.UPPER_CAMEL</dt><dd><p>.to(CaseFormat.LOWER_UNDERSCORE, topLevelDdgMetricsMetadata.product.originalName)</p>
</dd>
</dl>
</dd>
<dt>Map(</dt><dd><dl class="simple">
<dt>“client” -&gt; ScribingABDeciderUtil.clientForAppId(</dt><dd><p>topLevelDdgMetricsMetadata.clientApplicationId),</p>
</dd>
</dl>
<p>“page” -&gt; “cr-mixer”,
“section” -&gt; productName,
“component” -&gt; label._1,
“element” -&gt; label._2</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>object CrMixerScribeLogger {</dt><dd><p>val KafkaMaxTweetsPerMessage: Int = 200
val BatchSize: Int = 20</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/cr-mixer/server/src/main/scala/com/twitter/cr_mixer/logging/CrMixerScribeLogger.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>