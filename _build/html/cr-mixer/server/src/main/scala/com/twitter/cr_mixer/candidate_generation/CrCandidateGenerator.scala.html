<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.cr_mixer.candidate_generation</p>
<p>import com.twitter.cr_mixer.blender.SwitchBlender
import com.twitter.cr_mixer.config.TimeoutConfig
import com.twitter.cr_mixer.filter.PostRankFilterRunner
import com.twitter.cr_mixer.filter.PreRankFilterRunner
import com.twitter.cr_mixer.logging.CrMixerScribeLogger
import com.twitter.cr_mixer.model.BlendedCandidate
import com.twitter.cr_mixer.model.CrCandidateGeneratorQuery
import com.twitter.cr_mixer.model.GraphSourceInfo
import com.twitter.cr_mixer.model.InitialCandidate
import com.twitter.cr_mixer.model.RankedCandidate
import com.twitter.cr_mixer.model.SourceInfo
import com.twitter.cr_mixer.param.RankerParams
import com.twitter.cr_mixer.param.RecentNegativeSignalParams
import com.twitter.cr_mixer.ranker.SwitchRanker
import com.twitter.cr_mixer.source_signal.SourceInfoRouter
import com.twitter.cr_mixer.source_signal.UssStore.EnabledNegativeSourceTypes
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.frigate.common.util.StatsUtil
import com.twitter.simclusters_v2.thriftscala.InternalId
import com.twitter.util.Future
import com.twitter.util.JavaTimer
import com.twitter.util.Timer</p>
<p>import javax.inject.Inject
import javax.inject.Singleton</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>For now it performs the main steps as follows:</p></li>
<li><ol class="arabic simple">
<li><p>Source signal (via USS, FRS) fetch</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>Candidate generation</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="3">
<li><p>Filtering</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="4">
<li><p>Interleave blender</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="5">
<li><p>Ranker</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="6">
<li><p>Post-ranker filter</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="7">
<li><p>Truncation</p></li>
</ol>
</li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
</dl>
<p>&#64;Singleton
class CrCandidateGenerator &#64;Inject() (</p>
<blockquote>
<div><p>sourceInfoRouter: SourceInfoRouter,
candidateSourceRouter: CandidateSourcesRouter,
switchBlender: SwitchBlender,
preRankFilterRunner: PreRankFilterRunner,
postRankFilterRunner: PostRankFilterRunner,
switchRanker: SwitchRanker,
crMixerScribeLogger: CrMixerScribeLogger,
timeoutConfig: TimeoutConfig,
globalStats: StatsReceiver) {
private val timer: Timer = new JavaTimer(true)</p>
<p>private val stats: StatsReceiver = globalStats.scope(this.getClass.getCanonicalName)</p>
<p>private val fetchSourcesStats = stats.scope(“fetchSources”)
private val fetchPositiveSourcesStats = stats.scope(“fetchPositiveSources”)
private val fetchNegativeSourcesStats = stats.scope(“fetchNegativeSources”)
private val fetchCandidatesStats = stats.scope(“fetchCandidates”)
private val fetchCandidatesAfterFilterStats = stats.scope(“fetchCandidatesAfterFilter”)
private val preRankFilterStats = stats.scope(“preRankFilter”)
private val interleaveStats = stats.scope(“interleave”)
private val rankStats = stats.scope(“rank”)
private val postRankFilterStats = stats.scope(“postRankFilter”)
private val blueVerifiedTweetStats = stats.scope(“blueVerifiedTweetStats”)
private val blueVerifiedTweetStatsPerSimilarityEngine =</p>
<blockquote>
<div><p>stats.scope(“blueVerifiedTweetStatsPerSimilarityEngine”)</p>
</div></blockquote>
<dl>
<dt>def get(query: CrCandidateGeneratorQuery): Future[Seq[RankedCandidate]] = {</dt><dd><p>val allStats = stats.scope(“all”)
val perProductStats = stats.scope(“perProduct”, query.product.toString)
val perProductBlueVerifiedStats =</p>
<blockquote>
<div><p>blueVerifiedTweetStats.scope(“perProduct”, query.product.toString)</p>
</div></blockquote>
<dl>
<dt>StatsUtil.trackItemsStats(allStats) {</dt><dd><dl>
<dt>trackResultStats(perProductStats) {</dt><dd><dl>
<dt>StatsUtil.trackItemsStats(perProductStats) {</dt><dd><dl>
<dt>val result = for {</dt><dd><dl class="simple">
<dt>(sourceSignals, sourceGraphsMap) &lt;- StatsUtil.trackBlockStats(fetchSourcesStats) {</dt><dd><p>fetchSources(query)</p>
</dd>
</dl>
<p>}
initialCandidates &lt;- StatsUtil.trackBlockStats(fetchCandidatesAfterFilterStats) {</p>
<blockquote>
<div><p>// find the positive and negative signals
val (positiveSignals, negativeSignals) = sourceSignals.partition { signal =&gt;</p>
<blockquote>
<div><p>!EnabledNegativeSourceTypes.contains(signal.sourceType)</p>
</div></blockquote>
<p>}
fetchPositiveSourcesStats.stat(“size”).add(positiveSignals.size)
fetchNegativeSourcesStats.stat(“size”).add(negativeSignals.size)</p>
<p>// find the positive signals to keep, removing block and muted users
val filteredSourceInfo =</p>
<blockquote>
<div><dl>
<dt>if (negativeSignals.nonEmpty &amp;&amp; query.params(</dt><dd><blockquote>
<div><p>RecentNegativeSignalParams.EnableSourceParam)) {</p>
</div></blockquote>
<p>filterSourceInfo(positiveSignals, negativeSignals)</p>
</dd>
<dt>} else {</dt><dd><p>positiveSignals</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>// fetch candidates from the positive signals
StatsUtil.trackBlockStats(fetchCandidatesStats) {</p>
<blockquote>
<div><p>fetchCandidates(query, filteredSourceInfo, sourceGraphsMap)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
filteredCandidates &lt;- StatsUtil.trackBlockStats(preRankFilterStats) {</p>
<blockquote>
<div><p>preRankFilter(query, initialCandidates)</p>
</div></blockquote>
<p>}
interleavedCandidates &lt;- StatsUtil.trackItemsStats(interleaveStats) {</p>
<blockquote>
<div><p>interleave(query, filteredCandidates)</p>
</div></blockquote>
<p>}
rankedCandidates &lt;- StatsUtil.trackItemsStats(rankStats) {</p>
<blockquote>
<div><dl class="simple">
<dt>val candidatesToRank =</dt><dd><p>interleavedCandidates.take(query.params(RankerParams.MaxCandidatesToRank))</p>
</dd>
</dl>
<p>rank(query, candidatesToRank)</p>
</div></blockquote>
<p>}
postRankFilterCandidates &lt;- StatsUtil.trackItemsStats(postRankFilterStats) {</p>
<blockquote>
<div><p>postRankFilter(query, rankedCandidates)</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>} yield {</dt><dd><dl class="simple">
<dt>trackTopKStats(</dt><dd><p>800,
postRankFilterCandidates,
isQueryK = false,
perProductBlueVerifiedStats)</p>
</dd>
<dt>trackTopKStats(</dt><dd><p>400,
postRankFilterCandidates,
isQueryK = false,
perProductBlueVerifiedStats)</p>
</dd>
<dt>trackTopKStats(</dt><dd><p>query.maxNumResults,
postRankFilterCandidates,
isQueryK = true,
perProductBlueVerifiedStats)</p>
</dd>
<dt>val (blueVerifiedTweets, remainingTweets) =</dt><dd><dl class="simple">
<dt>postRankFilterCandidates.partition(</dt><dd><p>_.tweetInfo.hasBlueVerifiedAnnotation.contains(true))</p>
</dd>
</dl>
</dd>
</dl>
<p>val topKBlueVerified = blueVerifiedTweets.take(query.maxNumResults)
val topKRemaining = remainingTweets.take(query.maxNumResults - topKBlueVerified.size)</p>
<p>trackBlueVerifiedTweetStats(topKBlueVerified, perProductBlueVerifiedStats)</p>
<dl class="simple">
<dt>if (topKBlueVerified.nonEmpty &amp;&amp; query.params(RankerParams.EnableBlueVerifiedTopK)) {</dt><dd><p>topKBlueVerified ++ topKRemaining</p>
</dd>
<dt>} else {</dt><dd><p>postRankFilterCandidates</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
result.raiseWithin(timeoutConfig.serviceTimeout)(timer)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def fetchSources(</dt><dd><p>query: CrCandidateGeneratorQuery</p>
</dd>
<dt>): Future[(Set[SourceInfo], Map[String, Option[GraphSourceInfo]])] = {</dt><dd><dl>
<dt>crMixerScribeLogger.scribeSignalSources(</dt><dd><p>query,
sourceInfoRouter</p>
<blockquote>
<div><p>.get(query.userId, query.product, query.userState, query.params))</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def filterSourceInfo(</dt><dd><p>positiveSignals: Set[SourceInfo],
negativeSignals: Set[SourceInfo]</p>
</dd>
<dt>): Set[SourceInfo] = {</dt><dd><dl class="simple">
<dt>val filterUsers: Set[Long] = negativeSignals.flatMap {</dt><dd><p>case SourceInfo(_, InternalId.UserId(userId), _) =&gt; Some(userId)
case _ =&gt; None</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>positiveSignals.filter {</dt><dd><p>case SourceInfo(_, InternalId.UserId(userId), _) =&gt; !filterUsers.contains(userId)
case _ =&gt; true</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def fetchCandidates(</dt><dd><p>query: CrCandidateGeneratorQuery,
sourceSignals: Set[SourceInfo],
sourceGraphs: Map[String, Option[GraphSourceInfo]]</p>
</dd>
<dt>): Future[Seq[Seq[InitialCandidate]]] = {</dt><dd><dl>
<dt>val initialCandidates = candidateSourceRouter</dt><dd><dl class="simple">
<dt>.fetchCandidates(</dt><dd><p>query.userId,
sourceSignals,
sourceGraphs,
query.params</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>initialCandidates.map(_.flatten.map { candidate =&gt;</dt><dd><dl class="simple">
<dt>if (candidate.tweetInfo.hasBlueVerifiedAnnotation.contains(true)) {</dt><dd><dl class="simple">
<dt>blueVerifiedTweetStatsPerSimilarityEngine</dt><dd><dl class="simple">
<dt>.scope(query.product.toString).scope(</dt><dd><p>candidate.candidateGenerationInfo.contributingSimilarityEngines.head.similarityEngineType.toString).counter(
candidate.tweetInfo.authorId.toString).incr()</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>})</p>
<dl class="simple">
<dt>crMixerScribeLogger.scribeInitialCandidates(</dt><dd><p>query,
initialCandidates</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def preRankFilter(</dt><dd><p>query: CrCandidateGeneratorQuery,
candidates: Seq[Seq[InitialCandidate]]</p>
</dd>
<dt>): Future[Seq[Seq[InitialCandidate]]] = {</dt><dd><dl>
<dt>crMixerScribeLogger.scribePreRankFilterCandidates(</dt><dd><p>query,
preRankFilterRunner</p>
<blockquote>
<div><p>.runSequentialFilters(query, candidates))</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private def postRankFilter(</dt><dd><p>query: CrCandidateGeneratorQuery,
candidates: Seq[RankedCandidate]</p>
</dd>
<dt>): Future[Seq[RankedCandidate]] = {</dt><dd><p>postRankFilterRunner.run(query, candidates)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def interleave(</dt><dd><p>query: CrCandidateGeneratorQuery,
candidates: Seq[Seq[InitialCandidate]]</p>
</dd>
<dt>): Future[Seq[BlendedCandidate]] = {</dt><dd><dl>
<dt>crMixerScribeLogger.scribeInterleaveCandidates(</dt><dd><p>query,
switchBlender</p>
<blockquote>
<div><p>.blend(query.params, query.userState, candidates))</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def rank(</dt><dd><p>query: CrCandidateGeneratorQuery,
candidates: Seq[BlendedCandidate],</p>
</dd>
<dt>): Future[Seq[RankedCandidate]] = {</dt><dd><dl class="simple">
<dt>crMixerScribeLogger.scribeRankedCandidates(</dt><dd><p>query,
switchRanker.rank(query, candidates)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def trackResultStats(</dt><dd><p>stats: StatsReceiver</p>
</dd>
<dt>)(</dt><dd><p>fn: =&gt; Future[Seq[RankedCandidate]]</p>
</dd>
<dt>): Future[Seq[RankedCandidate]] = {</dt><dd><dl class="simple">
<dt>fn.onSuccess { candidates =&gt;</dt><dd><p>trackReasonChosenSourceTypeStats(candidates, stats)
trackReasonChosenSimilarityEngineStats(candidates, stats)
trackPotentialReasonsSourceTypeStats(candidates, stats)
trackPotentialReasonsSimilarityEngineStats(candidates, stats)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def trackReasonChosenSourceTypeStats(</dt><dd><p>candidates: Seq[RankedCandidate],
stats: StatsReceiver</p>
</dd>
<dt>): Unit = {</dt><dd><dl>
<dt>candidates</dt><dd><p>.groupBy(_.reasonChosen.sourceInfoOpt.map(_.sourceType))
.foreach {</p>
<blockquote>
<div><dl class="simple">
<dt>case (sourceTypeOpt, rankedCands) =&gt;</dt><dd><p>val sourceType = sourceTypeOpt.map(_.toString).getOrElse(“RequesterId”) // default
stats.stat(“reasonChosen”, “sourceType”, sourceType, “size”).add(rankedCands.size)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def trackReasonChosenSimilarityEngineStats(</dt><dd><p>candidates: Seq[RankedCandidate],
stats: StatsReceiver</p>
</dd>
<dt>): Unit = {</dt><dd><dl>
<dt>candidates</dt><dd><p>.groupBy(_.reasonChosen.similarityEngineInfo.similarityEngineType)
.foreach {</p>
<blockquote>
<div><dl class="simple">
<dt>case (seInfoType, rankedCands) =&gt;</dt><dd><dl class="simple">
<dt>stats</dt><dd><dl class="simple">
<dt>.stat(“reasonChosen”, “similarityEngine”, seInfoType.toString, “size”).add(</dt><dd><p>rankedCands.size)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def trackPotentialReasonsSourceTypeStats(</dt><dd><p>candidates: Seq[RankedCandidate],
stats: StatsReceiver</p>
</dd>
<dt>): Unit = {</dt><dd><dl>
<dt>candidates</dt><dd><p>.flatMap(_.potentialReasons.map(_.sourceInfoOpt.map(_.sourceType)))
.groupBy(source =&gt; source)
.foreach {</p>
<blockquote>
<div><dl class="simple">
<dt>case (sourceInfoOpt, seq) =&gt;</dt><dd><p>val sourceType = sourceInfoOpt.map(_.toString).getOrElse(“RequesterId”) // default
stats.stat(“potentialReasons”, “sourceType”, sourceType, “size”).add(seq.size)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def trackPotentialReasonsSimilarityEngineStats(</dt><dd><p>candidates: Seq[RankedCandidate],
stats: StatsReceiver</p>
</dd>
<dt>): Unit = {</dt><dd><dl>
<dt>candidates</dt><dd><p>.flatMap(_.potentialReasons.map(_.similarityEngineInfo.similarityEngineType))
.groupBy(se =&gt; se)
.foreach {</p>
<blockquote>
<div><dl class="simple">
<dt>case (seType, seq) =&gt;</dt><dd><p>stats.stat(“potentialReasons”, “similarityEngine”, seType.toString, “size”).add(seq.size)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def trackBlueVerifiedTweetStats(</dt><dd><p>candidates: Seq[RankedCandidate],
statsReceiver: StatsReceiver</p>
</dd>
<dt>): Unit = {</dt><dd><dl>
<dt>candidates.foreach { candidate =&gt;</dt><dd><dl>
<dt>if (candidate.tweetInfo.hasBlueVerifiedAnnotation.contains(true)) {</dt><dd><p>statsReceiver.counter(candidate.tweetInfo.authorId.toString).incr()
statsReceiver</p>
<blockquote>
<div><p>.scope(candidate.tweetInfo.authorId.toString).counter(candidate.tweetId.toString).incr()</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def trackTopKStats(</dt><dd><p>k: Int,
tweetCandidates: Seq[RankedCandidate],
isQueryK: Boolean,
statsReceiver: StatsReceiver</p>
</dd>
<dt>): Unit = {</dt><dd><p>val (topK, beyondK) = tweetCandidates.splitAt(k)</p>
<dl class="simple">
<dt>val blueVerifiedIds = tweetCandidates.collect {</dt><dd><dl class="simple">
<dt>case candidate if candidate.tweetInfo.hasBlueVerifiedAnnotation.contains(true) =&gt;</dt><dd><p>candidate.tweetInfo.authorId</p>
</dd>
</dl>
</dd>
</dl>
<p>}.toSet</p>
<dl>
<dt>blueVerifiedIds.foreach { blueVerifiedId =&gt;</dt><dd><p>val numTweetsTopK = topK.count(_.tweetInfo.authorId == blueVerifiedId)
val numTweetsBeyondK = beyondK.count(_.tweetInfo.authorId == blueVerifiedId)</p>
<dl>
<dt>if (isQueryK) {</dt><dd><p>statsReceiver.scope(blueVerifiedId.toString).stat(s”topK”).add(numTweetsTopK)
statsReceiver</p>
<blockquote>
<div><p>.scope(blueVerifiedId.toString).stat(s”beyondK”).add(numTweetsBeyondK)</p>
</div></blockquote>
</dd>
<dt>} else {</dt><dd><p>statsReceiver.scope(blueVerifiedId.toString).stat(s”top$k”).add(numTweetsTopK)
statsReceiver</p>
<blockquote>
<div><p>.scope(blueVerifiedId.toString).stat(s”beyond$k”).add(numTweetsBeyondK)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/cr-mixer/server/src/main/scala/com/twitter/cr_mixer/candidate_generation/CrCandidateGenerator.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>