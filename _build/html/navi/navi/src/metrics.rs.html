<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
   
  <link rel="stylesheet" href="../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>use log::error;
use prometheus::{</p>
<blockquote>
<div><p>CounterVec, HistogramOpts, HistogramVec, IntCounter, IntCounterVec, IntGauge, IntGaugeVec,
Opts, Registry,</p>
</div></blockquote>
<p>};
use warp::{Rejection, Reply};
use crate::{NAME, VERSION};</p>
<dl>
<dt>lazy_static! {</dt><dd><p>pub static ref REGISTRY: Registry = Registry::new();
pub static ref NUM_REQUESTS_RECEIVED: IntCounter =</p>
<blockquote>
<div><dl class="simple">
<dt>IntCounter::new(“:navi:num_requests”, “Number of Requests Received”)</dt><dd><p>.expect(“metric can be created”);</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>pub static ref NUM_REQUESTS_FAILED: IntCounter = IntCounter::new(</dt><dd><p>“:navi:num_requests_failed”,
“Number of Request Inference Failed”</p>
</dd>
</dl>
<p>)
.expect(“metric can be created”);
pub static ref NUM_REQUESTS_DROPPED: IntCounter = IntCounter::new(</p>
<blockquote>
<div><p>“:navi:num_requests_dropped”,
“Number of Oneshot Receivers Dropped”</p>
</div></blockquote>
<p>)
.expect(“metric can be created”);
pub static ref NUM_BATCHES_DROPPED: IntCounter = IntCounter::new(</p>
<blockquote>
<div><p>“:navi:num_batches_dropped”,
“Number of Batches Proactively Dropped”</p>
</div></blockquote>
<p>)
.expect(“metric can be created”);
pub static ref NUM_BATCH_PREDICTION: IntCounter =</p>
<blockquote>
<div><dl class="simple">
<dt>IntCounter::new(“:navi:num_batch_prediction”, “Number of batch prediction”)</dt><dd><p>.expect(“metric can be created”);</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>pub static ref BATCH_SIZE: IntGauge =</dt><dd><p>IntGauge::new(“:navi:batch_size”, “Size of current batch”).expect(“metric can be created”);</p>
</dd>
<dt>pub static ref NAVI_VERSION: IntGauge =</dt><dd><dl class="simple">
<dt>IntGauge::new(“:navi:navi_version”, “navi’s current version”)</dt><dd><p>.expect(“metric can be created”);</p>
</dd>
</dl>
</dd>
<dt>pub static ref RESPONSE_TIME_COLLECTOR: HistogramVec = HistogramVec::new(</dt><dd><dl class="simple">
<dt>HistogramOpts::new(“:navi:response_time”, “Response Time in ms”).buckets(Vec::from(&amp;[</dt><dd><p>0.0, 10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0, 80.0, 90.0, 100.0, 110.0, 120.0, 130.0,
140.0, 150.0, 160.0, 170.0, 180.0, 190.0, 200.0, 250.0, 300.0, 500.0, 1000.0</p>
</dd>
</dl>
<dl class="simple">
<dt>]</dt><dd><p>as &amp;’static [f64])),</p>
</dd>
</dl>
<p>&amp;[“model_name”]</p>
</dd>
</dl>
<p>)
.expect(“metric can be created”);
pub static ref NUM_PREDICTIONS: IntCounterVec = IntCounterVec::new(</p>
<blockquote>
<div><dl class="simple">
<dt>Opts::new(</dt><dd><p>“:navi:num_predictions”,
“Number of predictions made by model”</p>
</dd>
</dl>
<p>),
&amp;[“model_name”]</p>
</div></blockquote>
<p>)
.expect(“metric can be created”);
pub static ref PREDICTION_SCORE_SUM: CounterVec = CounterVec::new(</p>
<blockquote>
<div><dl class="simple">
<dt>Opts::new(</dt><dd><p>“:navi:prediction_score_sum”,
“Sum of prediction score made by model”</p>
</dd>
</dl>
<p>),
&amp;[“model_name”]</p>
</div></blockquote>
<p>)
.expect(“metric can be created”);
pub static ref NEW_MODEL_SNAPSHOT: IntCounterVec = IntCounterVec::new(</p>
<blockquote>
<div><dl class="simple">
<dt>Opts::new(</dt><dd><p>“:navi:new_model_snapshot”,
“Load a new version of model snapshot”</p>
</dd>
</dl>
<p>),
&amp;[“model_name”]</p>
</div></blockquote>
<p>)
.expect(“metric can be created”);
pub static ref MODEL_SNAPSHOT_VERSION: IntGaugeVec = IntGaugeVec::new(</p>
<blockquote>
<div><dl class="simple">
<dt>Opts::new(</dt><dd><p>“:navi:model_snapshot_version”,
“Record model snapshot version”</p>
</dd>
</dl>
<p>),
&amp;[“model_name”]</p>
</div></blockquote>
<p>)
.expect(“metric can be created”);
pub static ref NUM_REQUESTS_RECEIVED_BY_MODEL: IntCounterVec = IntCounterVec::new(</p>
<blockquote>
<div><dl class="simple">
<dt>Opts::new(</dt><dd><p>“:navi:num_requests_by_model”,
“Number of Requests Received by model”</p>
</dd>
</dl>
<p>),
&amp;[“model_name”]</p>
</div></blockquote>
<p>)
.expect(“metric can be created”);
pub static ref NUM_REQUESTS_FAILED_BY_MODEL: IntCounterVec = IntCounterVec::new(</p>
<blockquote>
<div><dl class="simple">
<dt>Opts::new(</dt><dd><p>“:navi:num_requests_failed_by_model”,
“Number of Request Inference Failed by model”</p>
</dd>
</dl>
<p>),
&amp;[“model_name”]</p>
</div></blockquote>
<p>)
.expect(“metric can be created”);
pub static ref NUM_REQUESTS_DROPPED_BY_MODEL: IntCounterVec = IntCounterVec::new(</p>
<blockquote>
<div><dl class="simple">
<dt>Opts::new(</dt><dd><p>“:navi:num_requests_dropped_by_model”,
“Number of Oneshot Receivers Dropped by model”</p>
</dd>
</dl>
<p>),
&amp;[“model_name”]</p>
</div></blockquote>
<p>)
.expect(“metric can be created”);
pub static ref NUM_BATCHES_DROPPED_BY_MODEL: IntCounterVec = IntCounterVec::new(</p>
<blockquote>
<div><dl class="simple">
<dt>Opts::new(</dt><dd><p>“:navi:num_batches_dropped_by_model”,
“Number of Batches Proactively Dropped by model”</p>
</dd>
</dl>
<p>),
&amp;[“model_name”]</p>
</div></blockquote>
<p>)
.expect(“metric can be created”);
pub static ref INFERENCE_FAILED_REQUESTS_BY_MODEL: IntCounterVec = IntCounterVec::new(</p>
<blockquote>
<div><dl class="simple">
<dt>Opts::new(</dt><dd><p>“:navi:inference_failed_requests_by_model”,
“Number of failed inference requests by model”</p>
</dd>
</dl>
<p>),
&amp;[“model_name”]</p>
</div></blockquote>
<p>)
.expect(“metric can be created”);
pub static ref NUM_PREDICTION_BY_MODEL: IntCounterVec = IntCounterVec::new(</p>
<blockquote>
<div><dl class="simple">
<dt>Opts::new(</dt><dd><p>“:navi:num_prediction_by_model”,
“Number of prediction by model”</p>
</dd>
</dl>
<p>),
&amp;[“model_name”]</p>
</div></blockquote>
<p>)
.expect(“metric can be created”);
pub static ref NUM_BATCH_PREDICTION_BY_MODEL: IntCounterVec = IntCounterVec::new(</p>
<blockquote>
<div><dl class="simple">
<dt>Opts::new(</dt><dd><p>“:navi:num_batch_prediction_by_model”,
“Number of batch prediction by model”</p>
</dd>
</dl>
<p>),
&amp;[“model_name”]</p>
</div></blockquote>
<p>)
.expect(“metric can be created”);
pub static ref BATCH_SIZE_BY_MODEL: IntGaugeVec = IntGaugeVec::new(</p>
<blockquote>
<div><dl class="simple">
<dt>Opts::new(</dt><dd><p>“:navi:batch_size_by_model”,
“Size of current batch by model”</p>
</dd>
</dl>
<p>),
&amp;[“model_name”]</p>
</div></blockquote>
<p>)
.expect(“metric can be created”);
pub static ref CUSTOMOP_VERSION: IntGauge =</p>
<blockquote>
<div><dl class="simple">
<dt>IntGauge::new(“:navi:customop_version”, “The hashed Custom OP Version”)</dt><dd><p>.expect(“metric can be created”);</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>pub static ref MPSC_CHANNEL_SIZE: IntGauge =</dt><dd><dl class="simple">
<dt>IntGauge::new(“:navi:mpsc_channel_size”, “The mpsc channel’s request size”)</dt><dd><p>.expect(“metric can be created”);</p>
</dd>
</dl>
</dd>
<dt>pub static ref BLOCKING_REQUEST_NUM: IntGauge = IntGauge::new(</dt><dd><p>“:navi:blocking_request_num”,
“The (batch) request waiting or being executed”</p>
</dd>
</dl>
<p>)
.expect(“metric can be created”);
pub static ref MODEL_INFERENCE_TIME_COLLECTOR: HistogramVec = HistogramVec::new(</p>
<blockquote>
<div><dl>
<dt>HistogramOpts::new(“:navi:model_inference_time”, “Model inference time in ms”).buckets(</dt><dd><dl class="simple">
<dt>Vec::from(&amp;[</dt><dd><p>0.0, 5.0, 10.0, 15.0, 20.0, 25.0, 30.0, 35.0, 40.0, 45.0, 50.0, 55.0, 60.0, 65.0,
70.0, 75.0, 80.0, 85.0, 90.0, 100.0, 110.0, 120.0, 130.0, 140.0, 150.0, 160.0,
170.0, 180.0, 190.0, 200.0, 250.0, 300.0, 500.0, 1000.0</p>
</dd>
</dl>
<p>] as &amp;’static [f64])</p>
</dd>
</dl>
<p>),
&amp;[“model_name”]</p>
</div></blockquote>
<p>)
.expect(“metric can be created”);
pub static ref CONVERTER_TIME_COLLECTOR: HistogramVec = HistogramVec::new(</p>
<blockquote>
<div><dl>
<dt>HistogramOpts::new(“:navi:converter_time”, “converter time in microseconds”).buckets(</dt><dd><dl class="simple">
<dt>Vec::from(&amp;[</dt><dd><p>0.0, 500.0, 1000.0, 1500.0, 2000.0, 2500.0, 3000.0, 3500.0, 4000.0, 4500.0, 5000.0,
5500.0, 6000.0, 6500.0, 7000.0, 20000.0</p>
</dd>
</dl>
<p>] as &amp;’static [f64])</p>
</dd>
</dl>
<p>),
&amp;[“model_name”]</p>
</div></blockquote>
<p>)
.expect(“metric can be created”);
pub static ref CERT_EXPIRY_EPOCH: IntGauge =</p>
<blockquote>
<div><dl class="simple">
<dt>IntGauge::new(“:navi:cert_expiry_epoch”, “Timestamp when the current cert expires”)</dt><dd><p>.expect(“metric can be created”);</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>pub fn register_custom_metrics() {</dt><dd><dl class="simple">
<dt>REGISTRY</dt><dd><p>.register(Box::new(NUM_REQUESTS_RECEIVED.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(NUM_REQUESTS_FAILED.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(NUM_REQUESTS_DROPPED.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(RESPONSE_TIME_COLLECTOR.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(NAVI_VERSION.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(BATCH_SIZE.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(NUM_BATCH_PREDICTION.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(NUM_BATCHES_DROPPED.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(NUM_PREDICTIONS.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(PREDICTION_SCORE_SUM.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(NEW_MODEL_SNAPSHOT.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(MODEL_SNAPSHOT_VERSION.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(NUM_REQUESTS_RECEIVED_BY_MODEL.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(NUM_REQUESTS_FAILED_BY_MODEL.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(NUM_REQUESTS_DROPPED_BY_MODEL.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(NUM_BATCHES_DROPPED_BY_MODEL.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(INFERENCE_FAILED_REQUESTS_BY_MODEL.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(NUM_PREDICTION_BY_MODEL.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(NUM_BATCH_PREDICTION_BY_MODEL.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(BATCH_SIZE_BY_MODEL.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(CUSTOMOP_VERSION.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(MPSC_CHANNEL_SIZE.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(BLOCKING_REQUEST_NUM.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(MODEL_INFERENCE_TIME_COLLECTOR.clone()))
.expect(“collector can be registered”);</p>
</dd>
<dt>REGISTRY</dt><dd><p>.register(Box::new(CONVERTER_TIME_COLLECTOR.clone()))
.expect(“collector can be registered”);</p>
</dd>
</dl>
<p>REGISTRY
.register(Box::new(CERT_EXPIRY_EPOCH.clone()))
.expect(“collector can be registered”);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>pub fn register_dynamic_metrics(c: &amp;HistogramVec) {</dt><dd><dl class="simple">
<dt>REGISTRY</dt><dd><p>.register(Box::new(c.clone()))
.expect(“dynamic metric collector cannot be registered”);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>pub async fn metrics_handler() -&gt; Result&lt;impl Reply, Rejection&gt; {</dt><dd><p>use prometheus::Encoder;
let encoder = prometheus::TextEncoder::new();</p>
<p>let mut buffer = Vec::new();
if let Err(e) = encoder.encode(&amp;REGISTRY.gather(), &amp;mut buffer) {</p>
<blockquote>
<div><p>error!(“could not encode custom metrics: {}”, e);</p>
</div></blockquote>
<p>};
let mut res = match String::from_utf8(buffer) {</p>
<blockquote>
<div><p>Ok(v) =&gt; format!(“#{}:{}n{}”, NAME, VERSION, v),
Err(e) =&gt; {</p>
<blockquote>
<div><p>error!(“custom metrics could not be from_utf8’d: {}”, e);
String::default()</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>};</p>
<p>buffer = Vec::new();
if let Err(e) = encoder.encode(&amp;prometheus::gather(), &amp;mut buffer) {</p>
<blockquote>
<div><p>error!(“could not encode prometheus metrics: {}”, e);</p>
</div></blockquote>
<p>};
let res_custom = match String::from_utf8(buffer) {</p>
<blockquote>
<div><p>Ok(v) =&gt; v,
Err(e) =&gt; {</p>
<blockquote>
<div><p>error!(“prometheus metrics could not be from_utf8’d: {}”, e);
String::default()</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>};</p>
<p>res.push_str(&amp;res_custom);
Ok(res)</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../_sources/navi/navi/src/metrics.rs.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>