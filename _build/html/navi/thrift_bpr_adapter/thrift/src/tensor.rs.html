<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>// Autogenerated by Thrift Compiler (0.17.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING</p>
<p>#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_skip)]</p>
<p>use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;</p>
<p>use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;</p>
<p>#[derive(Copy, Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DataType(pub i32);</p>
<dl>
<dt>impl DataType {</dt><dd><p>pub const FLOAT: DataType = DataType(0);
pub const DOUBLE: DataType = DataType(1);
pub const INT32: DataType = DataType(2);
pub const INT64: DataType = DataType(3);
pub const UINT8: DataType = DataType(4);
pub const STRING: DataType = DataType(5);
pub const BYTE: DataType = DataType(6);
pub const BOOL: DataType = DataType(7);
pub const RESERVED_1: DataType = DataType(8);
pub const RESERVED_2: DataType = DataType(9);
pub const RESERVED_3: DataType = DataType(10);
pub const ENUM_VALUES: &amp;’static [Self] = &amp;[</p>
<blockquote>
<div><p>Self::FLOAT,
Self::DOUBLE,
Self::INT32,
Self::INT64,
Self::UINT8,
Self::STRING,
Self::BYTE,
Self::BOOL,
Self::RESERVED_1,
Self::RESERVED_2,
Self::RESERVED_3,</p>
</div></blockquote>
<p>];</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for DataType {</dt><dd><p>#[allow(clippy::trivially_copy_pass_by_ref)]
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>o_prot.write_i32(self.0)</p>
</div></blockquote>
<p>}
fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;DataType&gt; {</p>
<blockquote>
<div><p>let enum_value = i_prot.read_i32()?;
Ok(DataType::from(enum_value))</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl From&lt;i32&gt; for DataType {</dt><dd><dl>
<dt>fn from(i: i32) -&gt; Self {</dt><dd><dl class="simple">
<dt>match i {</dt><dd><p>0 =&gt; DataType::FLOAT,
1 =&gt; DataType::DOUBLE,
2 =&gt; DataType::INT32,
3 =&gt; DataType::INT64,
4 =&gt; DataType::UINT8,
5 =&gt; DataType::STRING,
6 =&gt; DataType::BYTE,
7 =&gt; DataType::BOOL,
8 =&gt; DataType::RESERVED_1,
9 =&gt; DataType::RESERVED_2,
10 =&gt; DataType::RESERVED_3,
_ =&gt; DataType(i)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl From&lt;&amp;i32&gt; for DataType {</dt><dd><dl class="simple">
<dt>fn from(i: &amp;i32) -&gt; Self {</dt><dd><p>DataType::from(<a href="#id1"><span class="problematic" id="id2">*</span></a>i)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl From&lt;DataType&gt; for i32 {</dt><dd><dl class="simple">
<dt>fn from(e: DataType) -&gt; i32 {</dt><dd><p>e.0</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl From&lt;&amp;DataType&gt; for i32 {</dt><dd><dl class="simple">
<dt>fn from(e: &amp;DataType) -&gt; i32 {</dt><dd><p>e.0</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// StringTensor
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct StringTensor {</p>
<blockquote>
<div><p>pub strings: Vec&lt;String&gt;,
pub shape: Option&lt;Vec&lt;i64&gt;&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl StringTensor {</dt><dd><dl>
<dt>pub fn new&lt;F2&gt;(strings: Vec&lt;String&gt;, shape: F2) -&gt; StringTensor where F2: Into&lt;Option&lt;Vec&lt;i64&gt;&gt;&gt; {</dt><dd><dl class="simple">
<dt>StringTensor {</dt><dd><p>strings,
shape: shape.into(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for StringTensor {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;StringTensor&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;Vec&lt;String&gt;&gt; = None;
let mut f_2: Option&lt;Vec&lt;i64&gt;&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl>
<dt>1 =&gt; {</dt><dd><p>let list_ident = i_prot.read_list_begin()?;
let mut val: Vec&lt;String&gt; = Vec::with_capacity(list_ident.size as usize);
for _ in 0..list_ident.size {</p>
<blockquote>
<div><p>let list_elem_0 = i_prot.read_string()?;
val.push(list_elem_0);</p>
</div></blockquote>
<p>}
i_prot.read_list_end()?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
2 =&gt; {</p>
<blockquote>
<div><p>let list_ident = i_prot.read_list_begin()?;
let mut val: Vec&lt;i64&gt; = Vec::with_capacity(list_ident.size as usize);
for _ in 0..list_ident.size {</p>
<blockquote>
<div><p>let list_elem_1 = i_prot.read_i64()?;
val.push(list_elem_1);</p>
</div></blockquote>
<p>}
i_prot.read_list_end()?;
f_2 = Some(val);</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
verify_required_field_exists(“StringTensor.strings”, &amp;f_1)?;
let ret = StringTensor {</p>
<blockquote>
<div><p>strings: f_1.expect(“auto-generated code should have checked for presence of required fields”),
shape: f_2,</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“StringTensor”);
o_prot.write_struct_begin(&amp;struct_ident)?;
o_prot.write_field_begin(&amp;TFieldIdentifier::new(“strings”, TType::List, 1))?;
o_prot.write_list_begin(&amp;TListIdentifier::new(TType::String, self.strings.len() as i32))?;
for e in &amp;self.strings {</p>
<blockquote>
<div><p>o_prot.write_string(e)?;</p>
</div></blockquote>
<p>}
o_prot.write_list_end()?;
o_prot.write_field_end()?;
if let Some(ref fld_var) = self.shape {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“shape”, TType::List, 2))?;
o_prot.write_list_begin(&amp;TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
for e in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id3"><span class="problematic" id="id4">*</span></a>e)?;</p>
</div></blockquote>
<p>}
o_prot.write_list_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// Int32Tensor
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Int32Tensor {</p>
<blockquote>
<div><p>pub ints: Vec&lt;i32&gt;,
pub shape: Option&lt;Vec&lt;i64&gt;&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl Int32Tensor {</dt><dd><dl>
<dt>pub fn new&lt;F2&gt;(ints: Vec&lt;i32&gt;, shape: F2) -&gt; Int32Tensor where F2: Into&lt;Option&lt;Vec&lt;i64&gt;&gt;&gt; {</dt><dd><dl class="simple">
<dt>Int32Tensor {</dt><dd><p>ints,
shape: shape.into(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for Int32Tensor {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;Int32Tensor&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;Vec&lt;i32&gt;&gt; = None;
let mut f_2: Option&lt;Vec&lt;i64&gt;&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl>
<dt>1 =&gt; {</dt><dd><p>let list_ident = i_prot.read_list_begin()?;
let mut val: Vec&lt;i32&gt; = Vec::with_capacity(list_ident.size as usize);
for _ in 0..list_ident.size {</p>
<blockquote>
<div><p>let list_elem_2 = i_prot.read_i32()?;
val.push(list_elem_2);</p>
</div></blockquote>
<p>}
i_prot.read_list_end()?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
2 =&gt; {</p>
<blockquote>
<div><p>let list_ident = i_prot.read_list_begin()?;
let mut val: Vec&lt;i64&gt; = Vec::with_capacity(list_ident.size as usize);
for _ in 0..list_ident.size {</p>
<blockquote>
<div><p>let list_elem_3 = i_prot.read_i64()?;
val.push(list_elem_3);</p>
</div></blockquote>
<p>}
i_prot.read_list_end()?;
f_2 = Some(val);</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
verify_required_field_exists(“Int32Tensor.ints”, &amp;f_1)?;
let ret = Int32Tensor {</p>
<blockquote>
<div><p>ints: f_1.expect(“auto-generated code should have checked for presence of required fields”),
shape: f_2,</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“Int32Tensor”);
o_prot.write_struct_begin(&amp;struct_ident)?;
o_prot.write_field_begin(&amp;TFieldIdentifier::new(“ints”, TType::List, 1))?;
o_prot.write_list_begin(&amp;TListIdentifier::new(TType::I32, self.ints.len() as i32))?;
for e in &amp;self.ints {</p>
<blockquote>
<div><p>o_prot.write_i32(<a href="#id5"><span class="problematic" id="id6">*</span></a>e)?;</p>
</div></blockquote>
<p>}
o_prot.write_list_end()?;
o_prot.write_field_end()?;
if let Some(ref fld_var) = self.shape {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“shape”, TType::List, 2))?;
o_prot.write_list_begin(&amp;TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
for e in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id7"><span class="problematic" id="id8">*</span></a>e)?;</p>
</div></blockquote>
<p>}
o_prot.write_list_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// Int64Tensor
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct Int64Tensor {</p>
<blockquote>
<div><p>pub longs: Vec&lt;i64&gt;,
pub shape: Option&lt;Vec&lt;i64&gt;&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl Int64Tensor {</dt><dd><dl>
<dt>pub fn new&lt;F2&gt;(longs: Vec&lt;i64&gt;, shape: F2) -&gt; Int64Tensor where F2: Into&lt;Option&lt;Vec&lt;i64&gt;&gt;&gt; {</dt><dd><dl class="simple">
<dt>Int64Tensor {</dt><dd><p>longs,
shape: shape.into(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for Int64Tensor {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;Int64Tensor&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;Vec&lt;i64&gt;&gt; = None;
let mut f_2: Option&lt;Vec&lt;i64&gt;&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl>
<dt>1 =&gt; {</dt><dd><p>let list_ident = i_prot.read_list_begin()?;
let mut val: Vec&lt;i64&gt; = Vec::with_capacity(list_ident.size as usize);
for _ in 0..list_ident.size {</p>
<blockquote>
<div><p>let list_elem_4 = i_prot.read_i64()?;
val.push(list_elem_4);</p>
</div></blockquote>
<p>}
i_prot.read_list_end()?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
2 =&gt; {</p>
<blockquote>
<div><p>let list_ident = i_prot.read_list_begin()?;
let mut val: Vec&lt;i64&gt; = Vec::with_capacity(list_ident.size as usize);
for _ in 0..list_ident.size {</p>
<blockquote>
<div><p>let list_elem_5 = i_prot.read_i64()?;
val.push(list_elem_5);</p>
</div></blockquote>
<p>}
i_prot.read_list_end()?;
f_2 = Some(val);</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
verify_required_field_exists(“Int64Tensor.longs”, &amp;f_1)?;
let ret = Int64Tensor {</p>
<blockquote>
<div><p>longs: f_1.expect(“auto-generated code should have checked for presence of required fields”),
shape: f_2,</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“Int64Tensor”);
o_prot.write_struct_begin(&amp;struct_ident)?;
o_prot.write_field_begin(&amp;TFieldIdentifier::new(“longs”, TType::List, 1))?;
o_prot.write_list_begin(&amp;TListIdentifier::new(TType::I64, self.longs.len() as i32))?;
for e in &amp;self.longs {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id9"><span class="problematic" id="id10">*</span></a>e)?;</p>
</div></blockquote>
<p>}
o_prot.write_list_end()?;
o_prot.write_field_end()?;
if let Some(ref fld_var) = self.shape {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“shape”, TType::List, 2))?;
o_prot.write_list_begin(&amp;TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
for e in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id11"><span class="problematic" id="id12">*</span></a>e)?;</p>
</div></blockquote>
<p>}
o_prot.write_list_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// FloatTensor
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct FloatTensor {</p>
<blockquote>
<div><p>pub floats: Vec&lt;OrderedFloat&lt;f64&gt;&gt;,
pub shape: Option&lt;Vec&lt;i64&gt;&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl FloatTensor {</dt><dd><dl>
<dt>pub fn new&lt;F2&gt;(floats: Vec&lt;OrderedFloat&lt;f64&gt;&gt;, shape: F2) -&gt; FloatTensor where F2: Into&lt;Option&lt;Vec&lt;i64&gt;&gt;&gt; {</dt><dd><dl class="simple">
<dt>FloatTensor {</dt><dd><p>floats,
shape: shape.into(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for FloatTensor {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;FloatTensor&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;Vec&lt;OrderedFloat&lt;f64&gt;&gt;&gt; = None;
let mut f_2: Option&lt;Vec&lt;i64&gt;&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl>
<dt>1 =&gt; {</dt><dd><p>let list_ident = i_prot.read_list_begin()?;
let mut val: Vec&lt;OrderedFloat&lt;f64&gt;&gt; = Vec::with_capacity(list_ident.size as usize);
for _ in 0..list_ident.size {</p>
<blockquote>
<div><p>let list_elem_6 = OrderedFloat::from(i_prot.read_double()?);
val.push(list_elem_6);</p>
</div></blockquote>
<p>}
i_prot.read_list_end()?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
2 =&gt; {</p>
<blockquote>
<div><p>let list_ident = i_prot.read_list_begin()?;
let mut val: Vec&lt;i64&gt; = Vec::with_capacity(list_ident.size as usize);
for _ in 0..list_ident.size {</p>
<blockquote>
<div><p>let list_elem_7 = i_prot.read_i64()?;
val.push(list_elem_7);</p>
</div></blockquote>
<p>}
i_prot.read_list_end()?;
f_2 = Some(val);</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
verify_required_field_exists(“FloatTensor.floats”, &amp;f_1)?;
let ret = FloatTensor {</p>
<blockquote>
<div><p>floats: f_1.expect(“auto-generated code should have checked for presence of required fields”),
shape: f_2,</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“FloatTensor”);
o_prot.write_struct_begin(&amp;struct_ident)?;
o_prot.write_field_begin(&amp;TFieldIdentifier::new(“floats”, TType::List, 1))?;
o_prot.write_list_begin(&amp;TListIdentifier::new(TType::Double, self.floats.len() as i32))?;
for e in &amp;self.floats {</p>
<blockquote>
<div><p>o_prot.write_double((<a href="#id13"><span class="problematic" id="id14">*</span></a>e).into())?;</p>
</div></blockquote>
<p>}
o_prot.write_list_end()?;
o_prot.write_field_end()?;
if let Some(ref fld_var) = self.shape {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“shape”, TType::List, 2))?;
o_prot.write_list_begin(&amp;TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
for e in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id15"><span class="problematic" id="id16">*</span></a>e)?;</p>
</div></blockquote>
<p>}
o_prot.write_list_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// DoubleTensor
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DoubleTensor {</p>
<blockquote>
<div><p>pub doubles: Vec&lt;OrderedFloat&lt;f64&gt;&gt;,
pub shape: Option&lt;Vec&lt;i64&gt;&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl DoubleTensor {</dt><dd><dl>
<dt>pub fn new&lt;F2&gt;(doubles: Vec&lt;OrderedFloat&lt;f64&gt;&gt;, shape: F2) -&gt; DoubleTensor where F2: Into&lt;Option&lt;Vec&lt;i64&gt;&gt;&gt; {</dt><dd><dl class="simple">
<dt>DoubleTensor {</dt><dd><p>doubles,
shape: shape.into(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for DoubleTensor {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;DoubleTensor&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;Vec&lt;OrderedFloat&lt;f64&gt;&gt;&gt; = None;
let mut f_2: Option&lt;Vec&lt;i64&gt;&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl>
<dt>1 =&gt; {</dt><dd><p>let list_ident = i_prot.read_list_begin()?;
let mut val: Vec&lt;OrderedFloat&lt;f64&gt;&gt; = Vec::with_capacity(list_ident.size as usize);
for _ in 0..list_ident.size {</p>
<blockquote>
<div><p>let list_elem_8 = OrderedFloat::from(i_prot.read_double()?);
val.push(list_elem_8);</p>
</div></blockquote>
<p>}
i_prot.read_list_end()?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
2 =&gt; {</p>
<blockquote>
<div><p>let list_ident = i_prot.read_list_begin()?;
let mut val: Vec&lt;i64&gt; = Vec::with_capacity(list_ident.size as usize);
for _ in 0..list_ident.size {</p>
<blockquote>
<div><p>let list_elem_9 = i_prot.read_i64()?;
val.push(list_elem_9);</p>
</div></blockquote>
<p>}
i_prot.read_list_end()?;
f_2 = Some(val);</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
verify_required_field_exists(“DoubleTensor.doubles”, &amp;f_1)?;
let ret = DoubleTensor {</p>
<blockquote>
<div><p>doubles: f_1.expect(“auto-generated code should have checked for presence of required fields”),
shape: f_2,</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“DoubleTensor”);
o_prot.write_struct_begin(&amp;struct_ident)?;
o_prot.write_field_begin(&amp;TFieldIdentifier::new(“doubles”, TType::List, 1))?;
o_prot.write_list_begin(&amp;TListIdentifier::new(TType::Double, self.doubles.len() as i32))?;
for e in &amp;self.doubles {</p>
<blockquote>
<div><p>o_prot.write_double((<a href="#id17"><span class="problematic" id="id18">*</span></a>e).into())?;</p>
</div></blockquote>
<p>}
o_prot.write_list_end()?;
o_prot.write_field_end()?;
if let Some(ref fld_var) = self.shape {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“shape”, TType::List, 2))?;
o_prot.write_list_begin(&amp;TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
for e in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id19"><span class="problematic" id="id20">*</span></a>e)?;</p>
</div></blockquote>
<p>}
o_prot.write_list_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// BoolTensor
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BoolTensor {</p>
<blockquote>
<div><p>pub booleans: Vec&lt;bool&gt;,
pub shape: Option&lt;Vec&lt;i64&gt;&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl BoolTensor {</dt><dd><dl>
<dt>pub fn new&lt;F2&gt;(booleans: Vec&lt;bool&gt;, shape: F2) -&gt; BoolTensor where F2: Into&lt;Option&lt;Vec&lt;i64&gt;&gt;&gt; {</dt><dd><dl class="simple">
<dt>BoolTensor {</dt><dd><p>booleans,
shape: shape.into(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for BoolTensor {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;BoolTensor&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;Vec&lt;bool&gt;&gt; = None;
let mut f_2: Option&lt;Vec&lt;i64&gt;&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl>
<dt>1 =&gt; {</dt><dd><p>let list_ident = i_prot.read_list_begin()?;
let mut val: Vec&lt;bool&gt; = Vec::with_capacity(list_ident.size as usize);
for _ in 0..list_ident.size {</p>
<blockquote>
<div><p>let list_elem_10 = i_prot.read_bool()?;
val.push(list_elem_10);</p>
</div></blockquote>
<p>}
i_prot.read_list_end()?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
2 =&gt; {</p>
<blockquote>
<div><p>let list_ident = i_prot.read_list_begin()?;
let mut val: Vec&lt;i64&gt; = Vec::with_capacity(list_ident.size as usize);
for _ in 0..list_ident.size {</p>
<blockquote>
<div><p>let list_elem_11 = i_prot.read_i64()?;
val.push(list_elem_11);</p>
</div></blockquote>
<p>}
i_prot.read_list_end()?;
f_2 = Some(val);</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
verify_required_field_exists(“BoolTensor.booleans”, &amp;f_1)?;
let ret = BoolTensor {</p>
<blockquote>
<div><p>booleans: f_1.expect(“auto-generated code should have checked for presence of required fields”),
shape: f_2,</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“BoolTensor”);
o_prot.write_struct_begin(&amp;struct_ident)?;
o_prot.write_field_begin(&amp;TFieldIdentifier::new(“booleans”, TType::List, 1))?;
o_prot.write_list_begin(&amp;TListIdentifier::new(TType::Bool, self.booleans.len() as i32))?;
for e in &amp;self.booleans {</p>
<blockquote>
<div><p>o_prot.write_bool(<a href="#id21"><span class="problematic" id="id22">*</span></a>e)?;</p>
</div></blockquote>
<p>}
o_prot.write_list_end()?;
o_prot.write_field_end()?;
if let Some(ref fld_var) = self.shape {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“shape”, TType::List, 2))?;
o_prot.write_list_begin(&amp;TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
for e in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id23"><span class="problematic" id="id24">*</span></a>e)?;</p>
</div></blockquote>
<p>}
o_prot.write_list_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// RawTypedTensor
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct RawTypedTensor {</p>
<blockquote>
<div><p>pub data_type: DataType,
pub content: Vec&lt;u8&gt;,
pub shape: Option&lt;Vec&lt;i64&gt;&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl RawTypedTensor {</dt><dd><dl>
<dt>pub fn new&lt;F3&gt;(data_type: DataType, content: Vec&lt;u8&gt;, shape: F3) -&gt; RawTypedTensor where F3: Into&lt;Option&lt;Vec&lt;i64&gt;&gt;&gt; {</dt><dd><dl class="simple">
<dt>RawTypedTensor {</dt><dd><p>data_type,
content,
shape: shape.into(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for RawTypedTensor {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;RawTypedTensor&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;DataType&gt; = None;
let mut f_2: Option&lt;Vec&lt;u8&gt;&gt; = None;
let mut f_3: Option&lt;Vec&lt;i64&gt;&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl class="simple">
<dt>1 =&gt; {</dt><dd><p>let val = DataType::read_from_in_protocol(i_prot)?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
2 =&gt; {</p>
<blockquote>
<div><p>let val = i_prot.read_bytes()?;
f_2 = Some(val);</p>
</div></blockquote>
<p>},
3 =&gt; {</p>
<blockquote>
<div><p>let list_ident = i_prot.read_list_begin()?;
let mut val: Vec&lt;i64&gt; = Vec::with_capacity(list_ident.size as usize);
for _ in 0..list_ident.size {</p>
<blockquote>
<div><p>let list_elem_12 = i_prot.read_i64()?;
val.push(list_elem_12);</p>
</div></blockquote>
<p>}
i_prot.read_list_end()?;
f_3 = Some(val);</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
verify_required_field_exists(“RawTypedTensor.data_type”, &amp;f_1)?;
verify_required_field_exists(“RawTypedTensor.content”, &amp;f_2)?;
let ret = RawTypedTensor {</p>
<blockquote>
<div><p>data_type: f_1.expect(“auto-generated code should have checked for presence of required fields”),
content: f_2.expect(“auto-generated code should have checked for presence of required fields”),
shape: f_3,</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“RawTypedTensor”);
o_prot.write_struct_begin(&amp;struct_ident)?;
o_prot.write_field_begin(&amp;TFieldIdentifier::new(“dataType”, TType::I32, 1))?;
self.data_type.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?;
o_prot.write_field_begin(&amp;TFieldIdentifier::new(“content”, TType::String, 2))?;
o_prot.write_bytes(&amp;self.content)?;
o_prot.write_field_end()?;
if let Some(ref fld_var) = self.shape {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“shape”, TType::List, 3))?;
o_prot.write_list_begin(&amp;TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
for e in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id25"><span class="problematic" id="id26">*</span></a>e)?;</p>
</div></blockquote>
<p>}
o_prot.write_list_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// BinaryTensor
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BinaryTensor {</p>
<blockquote>
<div><p>pub binaries: Vec&lt;Vec&lt;u8&gt;&gt;,
pub shape: Option&lt;Vec&lt;i64&gt;&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl BinaryTensor {</dt><dd><dl>
<dt>pub fn new&lt;F2&gt;(binaries: Vec&lt;Vec&lt;u8&gt;&gt;, shape: F2) -&gt; BinaryTensor where F2: Into&lt;Option&lt;Vec&lt;i64&gt;&gt;&gt; {</dt><dd><dl class="simple">
<dt>BinaryTensor {</dt><dd><p>binaries,
shape: shape.into(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for BinaryTensor {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;BinaryTensor&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;Vec&lt;Vec&lt;u8&gt;&gt;&gt; = None;
let mut f_2: Option&lt;Vec&lt;i64&gt;&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl>
<dt>1 =&gt; {</dt><dd><p>let list_ident = i_prot.read_list_begin()?;
let mut val: Vec&lt;Vec&lt;u8&gt;&gt; = Vec::with_capacity(list_ident.size as usize);
for _ in 0..list_ident.size {</p>
<blockquote>
<div><p>let list_elem_13 = i_prot.read_bytes()?;
val.push(list_elem_13);</p>
</div></blockquote>
<p>}
i_prot.read_list_end()?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
2 =&gt; {</p>
<blockquote>
<div><p>let list_ident = i_prot.read_list_begin()?;
let mut val: Vec&lt;i64&gt; = Vec::with_capacity(list_ident.size as usize);
for _ in 0..list_ident.size {</p>
<blockquote>
<div><p>let list_elem_14 = i_prot.read_i64()?;
val.push(list_elem_14);</p>
</div></blockquote>
<p>}
i_prot.read_list_end()?;
f_2 = Some(val);</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
verify_required_field_exists(“BinaryTensor.binaries”, &amp;f_1)?;
let ret = BinaryTensor {</p>
<blockquote>
<div><p>binaries: f_1.expect(“auto-generated code should have checked for presence of required fields”),
shape: f_2,</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“BinaryTensor”);
o_prot.write_struct_begin(&amp;struct_ident)?;
o_prot.write_field_begin(&amp;TFieldIdentifier::new(“binaries”, TType::List, 1))?;
o_prot.write_list_begin(&amp;TListIdentifier::new(TType::String, self.binaries.len() as i32))?;
for e in &amp;self.binaries {</p>
<blockquote>
<div><p>o_prot.write_bytes(e)?;</p>
</div></blockquote>
<p>}
o_prot.write_list_end()?;
o_prot.write_field_end()?;
if let Some(ref fld_var) = self.shape {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“shape”, TType::List, 2))?;
o_prot.write_list_begin(&amp;TListIdentifier::new(TType::I64, fld_var.len() as i32))?;
for e in fld_var {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id27"><span class="problematic" id="id28">*</span></a>e)?;</p>
</div></blockquote>
<p>}
o_prot.write_list_end()?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// GeneralTensor
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum GeneralTensor {</p>
<blockquote>
<div><p>RawTypedTensor(RawTypedTensor),
StringTensor(StringTensor),
Int32Tensor(Int32Tensor),
Int64Tensor(Int64Tensor),
FloatTensor(FloatTensor),
DoubleTensor(DoubleTensor),
BoolTensor(BoolTensor),
BinaryTensor(BinaryTensor),</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl TSerializable for GeneralTensor {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;GeneralTensor&gt; {</dt><dd><p>let mut ret: Option&lt;GeneralTensor&gt; = None;
let mut received_field_count = 0;
i_prot.read_struct_begin()?;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl>
<dt>1 =&gt; {</dt><dd><p>let val = RawTypedTensor::read_from_in_protocol(i_prot)?;
if ret.is_none() {</p>
<blockquote>
<div><p>ret = Some(GeneralTensor::RawTypedTensor(val));</p>
</div></blockquote>
<p>}
received_field_count += 1;</p>
</dd>
</dl>
<p>},
2 =&gt; {</p>
<blockquote>
<div><p>let val = StringTensor::read_from_in_protocol(i_prot)?;
if ret.is_none() {</p>
<blockquote>
<div><p>ret = Some(GeneralTensor::StringTensor(val));</p>
</div></blockquote>
<p>}
received_field_count += 1;</p>
</div></blockquote>
<p>},
3 =&gt; {</p>
<blockquote>
<div><p>let val = Int32Tensor::read_from_in_protocol(i_prot)?;
if ret.is_none() {</p>
<blockquote>
<div><p>ret = Some(GeneralTensor::Int32Tensor(val));</p>
</div></blockquote>
<p>}
received_field_count += 1;</p>
</div></blockquote>
<p>},
4 =&gt; {</p>
<blockquote>
<div><p>let val = Int64Tensor::read_from_in_protocol(i_prot)?;
if ret.is_none() {</p>
<blockquote>
<div><p>ret = Some(GeneralTensor::Int64Tensor(val));</p>
</div></blockquote>
<p>}
received_field_count += 1;</p>
</div></blockquote>
<p>},
5 =&gt; {</p>
<blockquote>
<div><p>let val = FloatTensor::read_from_in_protocol(i_prot)?;
if ret.is_none() {</p>
<blockquote>
<div><p>ret = Some(GeneralTensor::FloatTensor(val));</p>
</div></blockquote>
<p>}
received_field_count += 1;</p>
</div></blockquote>
<p>},
6 =&gt; {</p>
<blockquote>
<div><p>let val = DoubleTensor::read_from_in_protocol(i_prot)?;
if ret.is_none() {</p>
<blockquote>
<div><p>ret = Some(GeneralTensor::DoubleTensor(val));</p>
</div></blockquote>
<p>}
received_field_count += 1;</p>
</div></blockquote>
<p>},
7 =&gt; {</p>
<blockquote>
<div><p>let val = BoolTensor::read_from_in_protocol(i_prot)?;
if ret.is_none() {</p>
<blockquote>
<div><p>ret = Some(GeneralTensor::BoolTensor(val));</p>
</div></blockquote>
<p>}
received_field_count += 1;</p>
</div></blockquote>
<p>},
8 =&gt; {</p>
<blockquote>
<div><p>let val = BinaryTensor::read_from_in_protocol(i_prot)?;
if ret.is_none() {</p>
<blockquote>
<div><p>ret = Some(GeneralTensor::BinaryTensor(val));</p>
</div></blockquote>
<p>}
received_field_count += 1;</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;
received_field_count += 1;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
if received_field_count == 0 {</p>
<blockquote>
<div><dl>
<dt>Err(</dt><dd><dl>
<dt>thrift::Error::Protocol(</dt><dd><dl class="simple">
<dt>ProtocolError::new(</dt><dd><p>ProtocolErrorKind::InvalidData,
“received empty union from remote GeneralTensor”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>} else if received_field_count &gt; 1 {</dt><dd><dl>
<dt>Err(</dt><dd><dl>
<dt>thrift::Error::Protocol(</dt><dd><dl class="simple">
<dt>ProtocolError::new(</dt><dd><p>ProtocolErrorKind::InvalidData,
“received multiple fields for union from remote GeneralTensor”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>} else {</dt><dd><p>Ok(ret.expect(“return value should have been constructed”))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“GeneralTensor”);
o_prot.write_struct_begin(&amp;struct_ident)?;
match <a href="#id29"><span class="problematic" id="id30">*</span></a>self {</p>
<blockquote>
<div><dl class="simple">
<dt>GeneralTensor::RawTypedTensor(ref f) =&gt; {</dt><dd><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“rawTypedTensor”, TType::Struct, 1))?;
f.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?;</p>
</dd>
</dl>
<p>},
GeneralTensor::StringTensor(ref f) =&gt; {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“stringTensor”, TType::Struct, 2))?;
f.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?;</p>
</div></blockquote>
<p>},
GeneralTensor::Int32Tensor(ref f) =&gt; {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“int32Tensor”, TType::Struct, 3))?;
f.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?;</p>
</div></blockquote>
<p>},
GeneralTensor::Int64Tensor(ref f) =&gt; {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“int64Tensor”, TType::Struct, 4))?;
f.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?;</p>
</div></blockquote>
<p>},
GeneralTensor::FloatTensor(ref f) =&gt; {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“floatTensor”, TType::Struct, 5))?;
f.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?;</p>
</div></blockquote>
<p>},
GeneralTensor::DoubleTensor(ref f) =&gt; {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“doubleTensor”, TType::Struct, 6))?;
f.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?;</p>
</div></blockquote>
<p>},
GeneralTensor::BoolTensor(ref f) =&gt; {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“boolTensor”, TType::Struct, 7))?;
f.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?;</p>
</div></blockquote>
<p>},
GeneralTensor::BinaryTensor(ref f) =&gt; {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“binaryTensor”, TType::Struct, 8))?;
f.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// COOSparseTensor
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct COOSparseTensor {</p>
<blockquote>
<div><p>pub dense_shape: Vec&lt;i64&gt;,
pub indices: Int64Tensor,
pub values: GeneralTensor,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl COOSparseTensor {</dt><dd><dl>
<dt>pub fn new(dense_shape: Vec&lt;i64&gt;, indices: Int64Tensor, values: GeneralTensor) -&gt; COOSparseTensor {</dt><dd><dl class="simple">
<dt>COOSparseTensor {</dt><dd><p>dense_shape,
indices,
values,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for COOSparseTensor {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;COOSparseTensor&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;Vec&lt;i64&gt;&gt; = None;
let mut f_2: Option&lt;Int64Tensor&gt; = None;
let mut f_3: Option&lt;GeneralTensor&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl>
<dt>1 =&gt; {</dt><dd><p>let list_ident = i_prot.read_list_begin()?;
let mut val: Vec&lt;i64&gt; = Vec::with_capacity(list_ident.size as usize);
for _ in 0..list_ident.size {</p>
<blockquote>
<div><p>let list_elem_15 = i_prot.read_i64()?;
val.push(list_elem_15);</p>
</div></blockquote>
<p>}
i_prot.read_list_end()?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
2 =&gt; {</p>
<blockquote>
<div><p>let val = Int64Tensor::read_from_in_protocol(i_prot)?;
f_2 = Some(val);</p>
</div></blockquote>
<p>},
3 =&gt; {</p>
<blockquote>
<div><p>let val = GeneralTensor::read_from_in_protocol(i_prot)?;
f_3 = Some(val);</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
verify_required_field_exists(“COOSparseTensor.dense_shape”, &amp;f_1)?;
verify_required_field_exists(“COOSparseTensor.indices”, &amp;f_2)?;
verify_required_field_exists(“COOSparseTensor.values”, &amp;f_3)?;
let ret = COOSparseTensor {</p>
<blockquote>
<div><p>dense_shape: f_1.expect(“auto-generated code should have checked for presence of required fields”),
indices: f_2.expect(“auto-generated code should have checked for presence of required fields”),
values: f_3.expect(“auto-generated code should have checked for presence of required fields”),</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“COOSparseTensor”);
o_prot.write_struct_begin(&amp;struct_ident)?;
o_prot.write_field_begin(&amp;TFieldIdentifier::new(“denseShape”, TType::List, 1))?;
o_prot.write_list_begin(&amp;TListIdentifier::new(TType::I64, self.dense_shape.len() as i32))?;
for e in &amp;self.dense_shape {</p>
<blockquote>
<div><p>o_prot.write_i64(<a href="#id31"><span class="problematic" id="id32">*</span></a>e)?;</p>
</div></blockquote>
<p>}
o_prot.write_list_end()?;
o_prot.write_field_end()?;
o_prot.write_field_begin(&amp;TFieldIdentifier::new(“indices”, TType::Struct, 2))?;
self.indices.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?;
o_prot.write_field_begin(&amp;TFieldIdentifier::new(“values”, TType::Struct, 3))?;
self.values.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?;
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// SparseTensor
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub enum SparseTensor {</p>
<blockquote>
<div><p>CooSparseTensor(COOSparseTensor),</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl TSerializable for SparseTensor {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;SparseTensor&gt; {</dt><dd><p>let mut ret: Option&lt;SparseTensor&gt; = None;
let mut received_field_count = 0;
i_prot.read_struct_begin()?;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl>
<dt>1 =&gt; {</dt><dd><p>let val = COOSparseTensor::read_from_in_protocol(i_prot)?;
if ret.is_none() {</p>
<blockquote>
<div><p>ret = Some(SparseTensor::CooSparseTensor(val));</p>
</div></blockquote>
<p>}
received_field_count += 1;</p>
</dd>
</dl>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;
received_field_count += 1;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
if received_field_count == 0 {</p>
<blockquote>
<div><dl>
<dt>Err(</dt><dd><dl>
<dt>thrift::Error::Protocol(</dt><dd><dl class="simple">
<dt>ProtocolError::new(</dt><dd><p>ProtocolErrorKind::InvalidData,
“received empty union from remote SparseTensor”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>} else if received_field_count &gt; 1 {</dt><dd><dl>
<dt>Err(</dt><dd><dl>
<dt>thrift::Error::Protocol(</dt><dd><dl class="simple">
<dt>ProtocolError::new(</dt><dd><p>ProtocolErrorKind::InvalidData,
“received multiple fields for union from remote SparseTensor”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>} else {</dt><dd><p>Ok(ret.expect(“return value should have been constructed”))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“SparseTensor”);
o_prot.write_struct_begin(&amp;struct_ident)?;
match <a href="#id33"><span class="problematic" id="id34">*</span></a>self {</p>
<blockquote>
<div><dl class="simple">
<dt>SparseTensor::CooSparseTensor(ref f) =&gt; {</dt><dd><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“cooSparseTensor”, TType::Struct, 1))?;
f.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?;</p>
</dd>
</dl>
<p>},</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../_sources/navi/thrift_bpr_adapter/thrift/src/tensor.rs.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>