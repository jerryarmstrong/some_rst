<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>// Autogenerated by Thrift Compiler (0.17.0)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING</p>
<p>#![allow(unused_imports)]
#![allow(unused_extern_crates)]
#![allow(clippy::too_many_arguments, clippy::type_complexity, clippy::vec_box)]
#![cfg_attr(rustfmt, rustfmt_skip)]</p>
<p>use std::cell::RefCell;
use std::collections::{BTreeMap, BTreeSet};
use std::convert::{From, TryFrom};
use std::default::Default;
use std::error::Error;
use std::fmt;
use std::fmt::{Display, Formatter};
use std::rc::Rc;</p>
<p>use thrift::OrderedFloat;
use thrift::{ApplicationError, ApplicationErrorKind, ProtocolError, ProtocolErrorKind, TThriftClient};
use thrift::protocol::{TFieldIdentifier, TListIdentifier, TMapIdentifier, TMessageIdentifier, TMessageType, TInputProtocol, TOutputProtocol, TSerializable, TSetIdentifier, TStructIdentifier, TType};
use thrift::protocol::field_id;
use thrift::protocol::verify_expected_message_type;
use thrift::protocol::verify_expected_sequence_number;
use thrift::protocol::verify_expected_service_call;
use thrift::protocol::verify_required_field_exists;
use thrift::server::TProcessor;</p>
<p>use crate::data;</p>
<p>//
// PredictionServiceException
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PredictionServiceException {</p>
<blockquote>
<div><p>pub description: Option&lt;String&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl PredictionServiceException {</dt><dd><dl>
<dt>pub fn new&lt;F1&gt;(description: F1) -&gt; PredictionServiceException where F1: Into&lt;Option&lt;String&gt;&gt; {</dt><dd><dl class="simple">
<dt>PredictionServiceException {</dt><dd><p>description: description.into(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for PredictionServiceException {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;PredictionServiceException&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;String&gt; = Some(“”.to_owned());
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl class="simple">
<dt>1 =&gt; {</dt><dd><p>let val = i_prot.read_string()?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
let ret = PredictionServiceException {</p>
<blockquote>
<div><p>description: f_1,</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“PredictionServiceException”);
o_prot.write_struct_begin(&amp;struct_ident)?;
if let Some(ref fld_var) = self.description {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“description”, TType::String, 1))?;
o_prot.write_string(fld_var)?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl Default for PredictionServiceException {</dt><dd><dl>
<dt>fn default() -&gt; Self {</dt><dd><dl class="simple">
<dt>PredictionServiceException{</dt><dd><p>description: Some(“”.to_owned()),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>impl Error for PredictionServiceException {}</p>
<dl>
<dt>impl From&lt;PredictionServiceException&gt; for thrift::Error {</dt><dd><dl class="simple">
<dt>fn from(e: PredictionServiceException) -&gt; Self {</dt><dd><p>thrift::Error::User(Box::new(e))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl Display for PredictionServiceException {</dt><dd><dl class="simple">
<dt>fn fmt(&amp;self, f: &amp;mut Formatter) -&gt; fmt::Result {</dt><dd><p>write!(f, “remote service threw PredictionServiceException”)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// PredictionRequest
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PredictionRequest {</p>
<blockquote>
<div><p>pub features: <a class="reference external" href="data::DataRecord">data::DataRecord</a>,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl PredictionRequest {</dt><dd><dl>
<dt>pub fn new(features: <a class="reference external" href="data::DataRecord">data::DataRecord</a>) -&gt; PredictionRequest {</dt><dd><dl class="simple">
<dt>PredictionRequest {</dt><dd><p>features,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for PredictionRequest {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;PredictionRequest&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl class="simple">
<dt>1 =&gt; {</dt><dd><p>let val = <a class="reference external" href="data::DataRecord::read_from_in_protocol(i_prot">data::DataRecord::read_from_in_protocol(i_prot</a>)?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
verify_required_field_exists(“PredictionRequest.features”, &amp;f_1)?;
let ret = PredictionRequest {</p>
<blockquote>
<div><p>features: f_1.expect(“auto-generated code should have checked for presence of required fields”),</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“PredictionRequest”);
o_prot.write_struct_begin(&amp;struct_ident)?;
o_prot.write_field_begin(&amp;TFieldIdentifier::new(“features”, TType::Struct, 1))?;
self.features.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?;
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// PredictionResponse
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PredictionResponse {</p>
<blockquote>
<div><p>pub prediction: <a class="reference external" href="data::DataRecord">data::DataRecord</a>,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl PredictionResponse {</dt><dd><dl>
<dt>pub fn new(prediction: <a class="reference external" href="data::DataRecord">data::DataRecord</a>) -&gt; PredictionResponse {</dt><dd><dl class="simple">
<dt>PredictionResponse {</dt><dd><p>prediction,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for PredictionResponse {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;PredictionResponse&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl class="simple">
<dt>1 =&gt; {</dt><dd><p>let val = <a class="reference external" href="data::DataRecord::read_from_in_protocol(i_prot">data::DataRecord::read_from_in_protocol(i_prot</a>)?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
verify_required_field_exists(“PredictionResponse.prediction”, &amp;f_1)?;
let ret = PredictionResponse {</p>
<blockquote>
<div><p>prediction: f_1.expect(“auto-generated code should have checked for presence of required fields”),</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“PredictionResponse”);
o_prot.write_struct_begin(&amp;struct_ident)?;
o_prot.write_field_begin(&amp;TFieldIdentifier::new(“prediction”, TType::Struct, 1))?;
self.prediction.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?;
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// BatchPredictionRequest
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BatchPredictionRequest {</p>
<blockquote>
<div><p>pub individual_features_list: Vec&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt;,
pub common_features: Option&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl BatchPredictionRequest {</dt><dd><dl>
<dt>pub fn new&lt;F2&gt;(individual_features_list: Vec&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt;, common_features: F2) -&gt; BatchPredictionRequest where F2: Into&lt;Option&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt;&gt; {</dt><dd><dl class="simple">
<dt>BatchPredictionRequest {</dt><dd><p>individual_features_list,
common_features: common_features.into(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for BatchPredictionRequest {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;BatchPredictionRequest&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;Vec&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt;&gt; = None;
let mut f_2: Option&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl>
<dt>1 =&gt; {</dt><dd><p>let list_ident = i_prot.read_list_begin()?;
let mut val: Vec&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt; = Vec::with_capacity(list_ident.size as usize);
for _ in 0..list_ident.size {</p>
<blockquote>
<div><p>let list_elem_0 = <a class="reference external" href="data::DataRecord::read_from_in_protocol(i_prot">data::DataRecord::read_from_in_protocol(i_prot</a>)?;
val.push(list_elem_0);</p>
</div></blockquote>
<p>}
i_prot.read_list_end()?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
2 =&gt; {</p>
<blockquote>
<div><p>let val = <a class="reference external" href="data::DataRecord::read_from_in_protocol(i_prot">data::DataRecord::read_from_in_protocol(i_prot</a>)?;
f_2 = Some(val);</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
verify_required_field_exists(“BatchPredictionRequest.individual_features_list”, &amp;f_1)?;
let ret = BatchPredictionRequest {</p>
<blockquote>
<div><p>individual_features_list: f_1.expect(“auto-generated code should have checked for presence of required fields”),
common_features: f_2,</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“BatchPredictionRequest”);
o_prot.write_struct_begin(&amp;struct_ident)?;
o_prot.write_field_begin(&amp;TFieldIdentifier::new(“individualFeaturesList”, TType::List, 1))?;
o_prot.write_list_begin(&amp;TListIdentifier::new(TType::Struct, self.individual_features_list.len() as i32))?;
for e in &amp;self.individual_features_list {</p>
<blockquote>
<div><p>e.write_to_out_protocol(o_prot)?;</p>
</div></blockquote>
<p>}
o_prot.write_list_end()?;
o_prot.write_field_end()?;
if let Some(ref fld_var) = self.common_features {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“commonFeatures”, TType::Struct, 2))?;
fld_var.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// BatchPredictionResponse
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct BatchPredictionResponse {</p>
<blockquote>
<div><p>pub predictions: Vec&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl BatchPredictionResponse {</dt><dd><dl>
<dt>pub fn new(predictions: Vec&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt;) -&gt; BatchPredictionResponse {</dt><dd><dl class="simple">
<dt>BatchPredictionResponse {</dt><dd><p>predictions,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for BatchPredictionResponse {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;BatchPredictionResponse&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;Vec&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt;&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl>
<dt>1 =&gt; {</dt><dd><p>let list_ident = i_prot.read_list_begin()?;
let mut val: Vec&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt; = Vec::with_capacity(list_ident.size as usize);
for _ in 0..list_ident.size {</p>
<blockquote>
<div><p>let list_elem_1 = <a class="reference external" href="data::DataRecord::read_from_in_protocol(i_prot">data::DataRecord::read_from_in_protocol(i_prot</a>)?;
val.push(list_elem_1);</p>
</div></blockquote>
<p>}
i_prot.read_list_end()?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
verify_required_field_exists(“BatchPredictionResponse.predictions”, &amp;f_1)?;
let ret = BatchPredictionResponse {</p>
<blockquote>
<div><p>predictions: f_1.expect(“auto-generated code should have checked for presence of required fields”),</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“BatchPredictionResponse”);
o_prot.write_struct_begin(&amp;struct_ident)?;
o_prot.write_field_begin(&amp;TFieldIdentifier::new(“predictions”, TType::List, 1))?;
o_prot.write_list_begin(&amp;TListIdentifier::new(TType::Struct, self.predictions.len() as i32))?;
for e in &amp;self.predictions {</p>
<blockquote>
<div><p>e.write_to_out_protocol(o_prot)?;</p>
</div></blockquote>
<p>}
o_prot.write_list_end()?;
o_prot.write_field_end()?;
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// DataRecordPair
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct DataRecordPair {</p>
<blockquote>
<div><p>pub first: Option&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt;,
pub second: Option&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl DataRecordPair {</dt><dd><dl>
<dt>pub fn new&lt;F1, F2&gt;(first: F1, second: F2) -&gt; DataRecordPair where F1: Into&lt;Option&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt;&gt;, F2: Into&lt;Option&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt;&gt; {</dt><dd><dl class="simple">
<dt>DataRecordPair {</dt><dd><p>first: first.into(),
second: second.into(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for DataRecordPair {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;DataRecordPair&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt; = None;
let mut f_2: Option&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl class="simple">
<dt>1 =&gt; {</dt><dd><p>let val = <a class="reference external" href="data::DataRecord::read_from_in_protocol(i_prot">data::DataRecord::read_from_in_protocol(i_prot</a>)?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
2 =&gt; {</p>
<blockquote>
<div><p>let val = <a class="reference external" href="data::DataRecord::read_from_in_protocol(i_prot">data::DataRecord::read_from_in_protocol(i_prot</a>)?;
f_2 = Some(val);</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
let ret = DataRecordPair {</p>
<blockquote>
<div><p>first: f_1,
second: f_2,</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“DataRecordPair”);
o_prot.write_struct_begin(&amp;struct_ident)?;
if let Some(ref fld_var) = self.first {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“first”, TType::Struct, 1))?;
fld_var.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.second {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“second”, TType::Struct, 2))?;
fld_var.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl Default for DataRecordPair {</dt><dd><dl>
<dt>fn default() -&gt; Self {</dt><dd><dl class="simple">
<dt>DataRecordPair{</dt><dd><p>first: None,
second: None,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// PredictionTrainingExample
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct PredictionTrainingExample {</p>
<blockquote>
<div><p>pub features: Option&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt;,
pub features_for_pairwise_learning: Option&lt;DataRecordPair&gt;,
pub compact_features: Option&lt;<a class="reference external" href="data::CompactDataRecord">data::CompactDataRecord</a>&gt;,
pub compressed_data_record: Option&lt;Vec&lt;u8&gt;&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl PredictionTrainingExample {</dt><dd><dl>
<dt>pub fn new&lt;F1, F2, F3, F4&gt;(features: F1, features_for_pairwise_learning: F2, compact_features: F3, compressed_data_record: F4) -&gt; PredictionTrainingExample where F1: Into&lt;Option&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt;&gt;, F2: Into&lt;Option&lt;DataRecordPair&gt;&gt;, F3: Into&lt;Option&lt;<a class="reference external" href="data::CompactDataRecord">data::CompactDataRecord</a>&gt;&gt;, F4: Into&lt;Option&lt;Vec&lt;u8&gt;&gt;&gt; {</dt><dd><dl class="simple">
<dt>PredictionTrainingExample {</dt><dd><p>features: features.into(),
features_for_pairwise_learning: features_for_pairwise_learning.into(),
compact_features: compact_features.into(),
compressed_data_record: compressed_data_record.into(),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl TSerializable for PredictionTrainingExample {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;PredictionTrainingExample&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;<a class="reference external" href="data::DataRecord">data::DataRecord</a>&gt; = None;
let mut f_2: Option&lt;DataRecordPair&gt; = None;
let mut f_3: Option&lt;<a class="reference external" href="data::CompactDataRecord">data::CompactDataRecord</a>&gt; = None;
let mut f_4: Option&lt;Vec&lt;u8&gt;&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl class="simple">
<dt>1 =&gt; {</dt><dd><p>let val = <a class="reference external" href="data::DataRecord::read_from_in_protocol(i_prot">data::DataRecord::read_from_in_protocol(i_prot</a>)?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
2 =&gt; {</p>
<blockquote>
<div><p>let val = DataRecordPair::read_from_in_protocol(i_prot)?;
f_2 = Some(val);</p>
</div></blockquote>
<p>},
3 =&gt; {</p>
<blockquote>
<div><p>let val = <a class="reference external" href="data::CompactDataRecord::read_from_in_protocol(i_prot">data::CompactDataRecord::read_from_in_protocol(i_prot</a>)?;
f_3 = Some(val);</p>
</div></blockquote>
<p>},
4 =&gt; {</p>
<blockquote>
<div><p>let val = i_prot.read_bytes()?;
f_4 = Some(val);</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
let ret = PredictionTrainingExample {</p>
<blockquote>
<div><p>features: f_1,
features_for_pairwise_learning: f_2,
compact_features: f_3,
compressed_data_record: f_4,</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“PredictionTrainingExample”);
o_prot.write_struct_begin(&amp;struct_ident)?;
if let Some(ref fld_var) = self.features {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“features”, TType::Struct, 1))?;
fld_var.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.features_for_pairwise_learning {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“featuresForPairwiseLearning”, TType::Struct, 2))?;
fld_var.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.compact_features {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“compactFeatures”, TType::Struct, 3))?;
fld_var.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.compressed_data_record {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“compressedDataRecord”, TType::String, 4))?;
o_prot.write_bytes(fld_var)?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl Default for PredictionTrainingExample {</dt><dd><dl>
<dt>fn default() -&gt; Self {</dt><dd><dl class="simple">
<dt>PredictionTrainingExample{</dt><dd><p>features: None,
features_for_pairwise_learning: None,
compact_features: None,
compressed_data_record: Some(Vec::new()),</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// PredictionService service client
//</p>
<dl class="simple">
<dt>pub trait TPredictionServiceSyncClient {</dt><dd><p>fn get_prediction(&amp;mut self, request: PredictionRequest) -&gt; thrift::Result&lt;PredictionResponse&gt;;
fn get_batch_prediction(&amp;mut self, batch_request: BatchPredictionRequest) -&gt; thrift::Result&lt;BatchPredictionResponse&gt;;</p>
</dd>
</dl>
<p>}</p>
<p>pub trait TPredictionServiceSyncClientMarker {}</p>
<dl class="simple">
<dt>pub struct PredictionServiceSyncClient&lt;IP, OP&gt; where IP: TInputProtocol, OP: TOutputProtocol {</dt><dd><p>_i_prot: IP,
_o_prot: OP,
_sequence_number: i32,</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl &lt;IP, OP&gt; PredictionServiceSyncClient&lt;IP, OP&gt; where IP: TInputProtocol, OP: TOutputProtocol {</dt><dd><dl class="simple">
<dt>pub fn new(input_protocol: IP, output_protocol: OP) -&gt; PredictionServiceSyncClient&lt;IP, OP&gt; {</dt><dd><p>PredictionServiceSyncClient { _i_prot: input_protocol, _o_prot: output_protocol, _sequence_number: 0 }</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>impl &lt;IP, OP&gt; TThriftClient for PredictionServiceSyncClient&lt;IP, OP&gt; where IP: TInputProtocol, OP: TOutputProtocol {</dt><dd><p>fn i_prot_mut(&amp;mut self) -&gt; &amp;mut dyn TInputProtocol { &amp;mut self._i_prot }
fn o_prot_mut(&amp;mut self) -&gt; &amp;mut dyn TOutputProtocol { &amp;mut self._o_prot }
fn sequence_number(&amp;self) -&gt; i32 { self._sequence_number }
fn increment_sequence_number(&amp;mut self) -&gt; i32 { self._sequence_number += 1; self._sequence_number }</p>
</dd>
</dl>
<p>}</p>
<p>impl &lt;IP, OP&gt; TPredictionServiceSyncClientMarker for PredictionServiceSyncClient&lt;IP, OP&gt; where IP: TInputProtocol, OP: TOutputProtocol {}</p>
<dl>
<dt>impl &lt;C: TThriftClient + TPredictionServiceSyncClientMarker&gt; TPredictionServiceSyncClient for C {</dt><dd><dl>
<dt>fn get_prediction(&amp;mut self, request: PredictionRequest) -&gt; thrift::Result&lt;PredictionResponse&gt; {</dt><dd><dl>
<dt>(</dt><dd><dl class="simple">
<dt>{</dt><dd><p>self.increment_sequence_number();
let message_ident = TMessageIdentifier::new(“getPrediction”, TMessageType::Call, self.sequence_number());
let call_args = PredictionServiceGetPredictionArgs { request };
self.o_prot_mut().write_message_begin(&amp;message_ident)?;
call_args.write_to_out_protocol(self.o_prot_mut())?;
self.o_prot_mut().write_message_end()?;
self.o_prot_mut().flush()</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>)?;
{</p>
<blockquote>
<div><p>let message_ident = self.i_prot_mut().read_message_begin()?;
verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
verify_expected_service_call(“getPrediction”, &amp;message_ident.name)?;
if message_ident.message_type == TMessageType::Exception {</p>
<blockquote>
<div><p>let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
self.i_prot_mut().read_message_end()?;
return Err(thrift::Error::Application(remote_error))</p>
</div></blockquote>
<p>}
verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
let result = PredictionServiceGetPredictionResult::read_from_in_protocol(self.i_prot_mut())?;
self.i_prot_mut().read_message_end()?;
result.ok_or()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
fn get_batch_prediction(&amp;mut self, batch_request: BatchPredictionRequest) -&gt; thrift::Result&lt;BatchPredictionResponse&gt; {</p>
<blockquote>
<div><dl>
<dt>(</dt><dd><dl class="simple">
<dt>{</dt><dd><p>self.increment_sequence_number();
let message_ident = TMessageIdentifier::new(“getBatchPrediction”, TMessageType::Call, self.sequence_number());
let call_args = PredictionServiceGetBatchPredictionArgs { batch_request };
self.o_prot_mut().write_message_begin(&amp;message_ident)?;
call_args.write_to_out_protocol(self.o_prot_mut())?;
self.o_prot_mut().write_message_end()?;
self.o_prot_mut().flush()</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>)?;
{</p>
<blockquote>
<div><p>let message_ident = self.i_prot_mut().read_message_begin()?;
verify_expected_sequence_number(self.sequence_number(), message_ident.sequence_number)?;
verify_expected_service_call(“getBatchPrediction”, &amp;message_ident.name)?;
if message_ident.message_type == TMessageType::Exception {</p>
<blockquote>
<div><p>let remote_error = thrift::Error::read_application_error_from_in_protocol(self.i_prot_mut())?;
self.i_prot_mut().read_message_end()?;
return Err(thrift::Error::Application(remote_error))</p>
</div></blockquote>
<p>}
verify_expected_message_type(TMessageType::Reply, message_ident.message_type)?;
let result = PredictionServiceGetBatchPredictionResult::read_from_in_protocol(self.i_prot_mut())?;
self.i_prot_mut().read_message_end()?;
result.ok_or()</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// PredictionService service processor
//</p>
<dl class="simple">
<dt>pub trait PredictionServiceSyncHandler {</dt><dd><p>fn handle_get_prediction(&amp;self, request: PredictionRequest) -&gt; thrift::Result&lt;PredictionResponse&gt;;
fn handle_get_batch_prediction(&amp;self, batch_request: BatchPredictionRequest) -&gt; thrift::Result&lt;BatchPredictionResponse&gt;;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>pub struct PredictionServiceSyncProcessor&lt;H: PredictionServiceSyncHandler&gt; {</dt><dd><p>handler: H,</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl &lt;H: PredictionServiceSyncHandler&gt; PredictionServiceSyncProcessor&lt;H&gt; {</dt><dd><dl>
<dt>pub fn new(handler: H) -&gt; PredictionServiceSyncProcessor&lt;H&gt; {</dt><dd><dl class="simple">
<dt>PredictionServiceSyncProcessor {</dt><dd><p>handler,</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
fn process_get_prediction(&amp;self, incoming_sequence_number: i32, i_prot: &amp;mut dyn TInputProtocol, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>TPredictionServiceProcessFunctions::process_get_prediction(&amp;self.handler, incoming_sequence_number, i_prot, o_prot)</p>
</div></blockquote>
<p>}
fn process_get_batch_prediction(&amp;self, incoming_sequence_number: i32, i_prot: &amp;mut dyn TInputProtocol, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>TPredictionServiceProcessFunctions::process_get_batch_prediction(&amp;self.handler, incoming_sequence_number, i_prot, o_prot)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>pub struct TPredictionServiceProcessFunctions;</p>
<dl>
<dt>impl TPredictionServiceProcessFunctions {</dt><dd><dl>
<dt>pub fn process_get_prediction&lt;H: PredictionServiceSyncHandler&gt;(handler: &amp;H, incoming_sequence_number: i32, i_prot: &amp;mut dyn TInputProtocol, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</dt><dd><p>let args = PredictionServiceGetPredictionArgs::read_from_in_protocol(i_prot)?;
match handler.handle_get_prediction(args.request) {</p>
<blockquote>
<div><dl class="simple">
<dt>Ok(handler_return) =&gt; {</dt><dd><p>let message_ident = TMessageIdentifier::new(“getPrediction”, TMessageType::Reply, incoming_sequence_number);
o_prot.write_message_begin(&amp;message_ident)?;
let ret = PredictionServiceGetPredictionResult { result_value: Some(handler_return), prediction_service_exception: None };
ret.write_to_out_protocol(o_prot)?;
o_prot.write_message_end()?;
o_prot.flush()</p>
</dd>
</dl>
<p>},
Err(e) =&gt; {</p>
<blockquote>
<div><dl>
<dt>match e {</dt><dd><dl>
<dt>thrift::Error::User(usr_err) =&gt; {</dt><dd><dl>
<dt>if usr_err.downcast_ref::&lt;PredictionServiceException&gt;().is_some() {</dt><dd><p>let err = usr_err.downcast::&lt;PredictionServiceException&gt;().expect(“downcast already checked”);
let ret_err = PredictionServiceGetPredictionResult{ result_value: None, prediction_service_exception: Some(<a href="#id1"><span class="problematic" id="id2">*</span></a>err) };
let message_ident = TMessageIdentifier::new(“getPrediction”, TMessageType::Reply, incoming_sequence_number);
o_prot.write_message_begin(&amp;message_ident)?;
ret_err.write_to_out_protocol(o_prot)?;
o_prot.write_message_end()?;
o_prot.flush()</p>
</dd>
<dt>} else {</dt><dd><dl>
<dt>let ret_err = {</dt><dd><dl class="simple">
<dt>ApplicationError::new(</dt><dd><p>ApplicationErrorKind::Unknown,
usr_err.to_string()</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>};
let message_ident = TMessageIdentifier::new(“getPrediction”, TMessageType::Exception, incoming_sequence_number);
o_prot.write_message_begin(&amp;message_ident)?;
thrift::Error::write_application_error_to_out_protocol(&amp;ret_err, o_prot)?;
o_prot.write_message_end()?;
o_prot.flush()</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>},
thrift::Error::Application(app_err) =&gt; {</p>
<blockquote>
<div><p>let message_ident = TMessageIdentifier::new(“getPrediction”, TMessageType::Exception, incoming_sequence_number);
o_prot.write_message_begin(&amp;message_ident)?;
thrift::Error::write_application_error_to_out_protocol(&amp;app_err, o_prot)?;
o_prot.write_message_end()?;
o_prot.flush()</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><dl>
<dt>let ret_err = {</dt><dd><dl class="simple">
<dt>ApplicationError::new(</dt><dd><p>ApplicationErrorKind::Unknown,
e.to_string()</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>};
let message_ident = TMessageIdentifier::new(“getPrediction”, TMessageType::Exception, incoming_sequence_number);
o_prot.write_message_begin(&amp;message_ident)?;
thrift::Error::write_application_error_to_out_protocol(&amp;ret_err, o_prot)?;
o_prot.write_message_end()?;
o_prot.flush()</p>
</div></blockquote>
<p>},</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
pub fn process_get_batch_prediction&lt;H: PredictionServiceSyncHandler&gt;(handler: &amp;H, incoming_sequence_number: i32, i_prot: &amp;mut dyn TInputProtocol, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let args = PredictionServiceGetBatchPredictionArgs::read_from_in_protocol(i_prot)?;
match handler.handle_get_batch_prediction(args.batch_request) {</p>
<blockquote>
<div><dl class="simple">
<dt>Ok(handler_return) =&gt; {</dt><dd><p>let message_ident = TMessageIdentifier::new(“getBatchPrediction”, TMessageType::Reply, incoming_sequence_number);
o_prot.write_message_begin(&amp;message_ident)?;
let ret = PredictionServiceGetBatchPredictionResult { result_value: Some(handler_return), prediction_service_exception: None };
ret.write_to_out_protocol(o_prot)?;
o_prot.write_message_end()?;
o_prot.flush()</p>
</dd>
</dl>
<p>},
Err(e) =&gt; {</p>
<blockquote>
<div><dl>
<dt>match e {</dt><dd><dl>
<dt>thrift::Error::User(usr_err) =&gt; {</dt><dd><dl>
<dt>if usr_err.downcast_ref::&lt;PredictionServiceException&gt;().is_some() {</dt><dd><p>let err = usr_err.downcast::&lt;PredictionServiceException&gt;().expect(“downcast already checked”);
let ret_err = PredictionServiceGetBatchPredictionResult{ result_value: None, prediction_service_exception: Some(<a href="#id3"><span class="problematic" id="id4">*</span></a>err) };
let message_ident = TMessageIdentifier::new(“getBatchPrediction”, TMessageType::Reply, incoming_sequence_number);
o_prot.write_message_begin(&amp;message_ident)?;
ret_err.write_to_out_protocol(o_prot)?;
o_prot.write_message_end()?;
o_prot.flush()</p>
</dd>
<dt>} else {</dt><dd><dl>
<dt>let ret_err = {</dt><dd><dl class="simple">
<dt>ApplicationError::new(</dt><dd><p>ApplicationErrorKind::Unknown,
usr_err.to_string()</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>};
let message_ident = TMessageIdentifier::new(“getBatchPrediction”, TMessageType::Exception, incoming_sequence_number);
o_prot.write_message_begin(&amp;message_ident)?;
thrift::Error::write_application_error_to_out_protocol(&amp;ret_err, o_prot)?;
o_prot.write_message_end()?;
o_prot.flush()</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>},
thrift::Error::Application(app_err) =&gt; {</p>
<blockquote>
<div><p>let message_ident = TMessageIdentifier::new(“getBatchPrediction”, TMessageType::Exception, incoming_sequence_number);
o_prot.write_message_begin(&amp;message_ident)?;
thrift::Error::write_application_error_to_out_protocol(&amp;app_err, o_prot)?;
o_prot.write_message_end()?;
o_prot.flush()</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><dl>
<dt>let ret_err = {</dt><dd><dl class="simple">
<dt>ApplicationError::new(</dt><dd><p>ApplicationErrorKind::Unknown,
e.to_string()</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>};
let message_ident = TMessageIdentifier::new(“getBatchPrediction”, TMessageType::Exception, incoming_sequence_number);
o_prot.write_message_begin(&amp;message_ident)?;
thrift::Error::write_application_error_to_out_protocol(&amp;ret_err, o_prot)?;
o_prot.write_message_end()?;
o_prot.flush()</p>
</div></blockquote>
<p>},</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>impl &lt;H: PredictionServiceSyncHandler&gt; TProcessor for PredictionServiceSyncProcessor&lt;H&gt; {</dt><dd><dl>
<dt>fn process(&amp;self, i_prot: &amp;mut dyn TInputProtocol, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</dt><dd><p>let message_ident = i_prot.read_message_begin()?;
let res = match &amp;*message_ident.name {</p>
<blockquote>
<div><dl class="simple">
<dt>“getPrediction” =&gt; {</dt><dd><p>self.process_get_prediction(message_ident.sequence_number, i_prot, o_prot)</p>
</dd>
</dl>
<p>},
“getBatchPrediction” =&gt; {</p>
<blockquote>
<div><p>self.process_get_batch_prediction(message_ident.sequence_number, i_prot, o_prot)</p>
</div></blockquote>
<p>},
method =&gt; {</p>
<blockquote>
<div><dl>
<dt>Err(</dt><dd><dl>
<dt>thrift::Error::Application(</dt><dd><dl class="simple">
<dt>ApplicationError::new(</dt><dd><p>ApplicationErrorKind::UnknownMethod,
format!(“unknown method {}”, method)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
thrift::server::handle_process_result(&amp;message_ident, res, o_prot)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// PredictionServiceGetPredictionArgs
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct PredictionServiceGetPredictionArgs {</p>
<blockquote>
<div><p>request: PredictionRequest,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl PredictionServiceGetPredictionArgs {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;PredictionServiceGetPredictionArgs&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;PredictionRequest&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl class="simple">
<dt>1 =&gt; {</dt><dd><p>let val = PredictionRequest::read_from_in_protocol(i_prot)?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
verify_required_field_exists(“PredictionServiceGetPredictionArgs.request”, &amp;f_1)?;
let ret = PredictionServiceGetPredictionArgs {</p>
<blockquote>
<div><p>request: f_1.expect(“auto-generated code should have checked for presence of required fields”),</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“getPrediction_args”);
o_prot.write_struct_begin(&amp;struct_ident)?;
o_prot.write_field_begin(&amp;TFieldIdentifier::new(“request”, TType::Struct, 1))?;
self.request.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?;
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// PredictionServiceGetPredictionResult
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct PredictionServiceGetPredictionResult {</p>
<blockquote>
<div><p>result_value: Option&lt;PredictionResponse&gt;,
prediction_service_exception: Option&lt;PredictionServiceException&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl PredictionServiceGetPredictionResult {</dt><dd><dl>
<dt>fn ok_or(self) -&gt; thrift::Result&lt;PredictionResponse&gt; {</dt><dd><dl>
<dt>if self.prediction_service_exception.is_some() {</dt><dd><p>Err(thrift::Error::User(Box::new(self.prediction_service_exception.unwrap())))</p>
</dd>
<dt>} else if self.result_value.is_some() {</dt><dd><p>Ok(self.result_value.unwrap())</p>
</dd>
<dt>} else {</dt><dd><dl>
<dt>Err(</dt><dd><dl>
<dt>thrift::Error::Application(</dt><dd><dl class="simple">
<dt>ApplicationError::new(</dt><dd><p>ApplicationErrorKind::MissingResult,
“no result received for PredictionServiceGetPrediction”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;PredictionServiceGetPredictionResult&gt; {</p>
<blockquote>
<div><p>i_prot.read_struct_begin()?;
let mut f_0: Option&lt;PredictionResponse&gt; = None;
let mut f_1: Option&lt;PredictionServiceException&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl class="simple">
<dt>0 =&gt; {</dt><dd><p>let val = PredictionResponse::read_from_in_protocol(i_prot)?;
f_0 = Some(val);</p>
</dd>
</dl>
<p>},
1 =&gt; {</p>
<blockquote>
<div><p>let val = PredictionServiceException::read_from_in_protocol(i_prot)?;
f_1 = Some(val);</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
let ret = PredictionServiceGetPredictionResult {</p>
<blockquote>
<div><p>result_value: f_0,
prediction_service_exception: f_1,</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</div></blockquote>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“PredictionServiceGetPredictionResult”);
o_prot.write_struct_begin(&amp;struct_ident)?;
if let Some(ref fld_var) = self.result_value {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“result_value”, TType::Struct, 0))?;
fld_var.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.prediction_service_exception {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“predictionServiceException”, TType::Struct, 1))?;
fld_var.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// PredictionServiceGetBatchPredictionArgs
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct PredictionServiceGetBatchPredictionArgs {</p>
<blockquote>
<div><p>batch_request: BatchPredictionRequest,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl PredictionServiceGetBatchPredictionArgs {</dt><dd><dl>
<dt>fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;PredictionServiceGetBatchPredictionArgs&gt; {</dt><dd><p>i_prot.read_struct_begin()?;
let mut f_1: Option&lt;BatchPredictionRequest&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl class="simple">
<dt>1 =&gt; {</dt><dd><p>let val = BatchPredictionRequest::read_from_in_protocol(i_prot)?;
f_1 = Some(val);</p>
</dd>
</dl>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
verify_required_field_exists(“PredictionServiceGetBatchPredictionArgs.batch_request”, &amp;f_1)?;
let ret = PredictionServiceGetBatchPredictionArgs {</p>
<blockquote>
<div><p>batch_request: f_1.expect(“auto-generated code should have checked for presence of required fields”),</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</dd>
</dl>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“getBatchPrediction_args”);
o_prot.write_struct_begin(&amp;struct_ident)?;
o_prot.write_field_begin(&amp;TFieldIdentifier::new(“batchRequest”, TType::Struct, 1))?;
self.batch_request.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?;
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>//
// PredictionServiceGetBatchPredictionResult
//</p>
<p>#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd)]
struct PredictionServiceGetBatchPredictionResult {</p>
<blockquote>
<div><p>result_value: Option&lt;BatchPredictionResponse&gt;,
prediction_service_exception: Option&lt;PredictionServiceException&gt;,</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>impl PredictionServiceGetBatchPredictionResult {</dt><dd><dl>
<dt>fn ok_or(self) -&gt; thrift::Result&lt;BatchPredictionResponse&gt; {</dt><dd><dl>
<dt>if self.prediction_service_exception.is_some() {</dt><dd><p>Err(thrift::Error::User(Box::new(self.prediction_service_exception.unwrap())))</p>
</dd>
<dt>} else if self.result_value.is_some() {</dt><dd><p>Ok(self.result_value.unwrap())</p>
</dd>
<dt>} else {</dt><dd><dl>
<dt>Err(</dt><dd><dl>
<dt>thrift::Error::Application(</dt><dd><dl class="simple">
<dt>ApplicationError::new(</dt><dd><p>ApplicationErrorKind::MissingResult,
“no result received for PredictionServiceGetBatchPrediction”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
fn read_from_in_protocol(i_prot: &amp;mut dyn TInputProtocol) -&gt; thrift::Result&lt;PredictionServiceGetBatchPredictionResult&gt; {</p>
<blockquote>
<div><p>i_prot.read_struct_begin()?;
let mut f_0: Option&lt;BatchPredictionResponse&gt; = None;
let mut f_1: Option&lt;PredictionServiceException&gt; = None;
loop {</p>
<blockquote>
<div><p>let field_ident = i_prot.read_field_begin()?;
if field_ident.field_type == TType::Stop {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}
let field_id = field_id(&amp;field_ident)?;
match field_id {</p>
<blockquote>
<div><dl class="simple">
<dt>0 =&gt; {</dt><dd><p>let val = BatchPredictionResponse::read_from_in_protocol(i_prot)?;
f_0 = Some(val);</p>
</dd>
</dl>
<p>},
1 =&gt; {</p>
<blockquote>
<div><p>let val = PredictionServiceException::read_from_in_protocol(i_prot)?;
f_1 = Some(val);</p>
</div></blockquote>
<p>},
_ =&gt; {</p>
<blockquote>
<div><p>i_prot.skip(field_ident.field_type)?;</p>
</div></blockquote>
<p>},</p>
</div></blockquote>
<p>};
i_prot.read_field_end()?;</p>
</div></blockquote>
<p>}
i_prot.read_struct_end()?;
let ret = PredictionServiceGetBatchPredictionResult {</p>
<blockquote>
<div><p>result_value: f_0,
prediction_service_exception: f_1,</p>
</div></blockquote>
<p>};
Ok(ret)</p>
</div></blockquote>
<p>}
fn write_to_out_protocol(&amp;self, o_prot: &amp;mut dyn TOutputProtocol) -&gt; thrift::Result&lt;()&gt; {</p>
<blockquote>
<div><p>let struct_ident = TStructIdentifier::new(“PredictionServiceGetBatchPredictionResult”);
o_prot.write_struct_begin(&amp;struct_ident)?;
if let Some(ref fld_var) = self.result_value {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“result_value”, TType::Struct, 0))?;
fld_var.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
if let Some(ref fld_var) = self.prediction_service_exception {</p>
<blockquote>
<div><p>o_prot.write_field_begin(&amp;TFieldIdentifier::new(“predictionServiceException”, TType::Struct, 1))?;
fld_var.write_to_out_protocol(o_prot)?;
o_prot.write_field_end()?</p>
</div></blockquote>
<p>}
o_prot.write_field_stop()?;
o_prot.write_struct_end()</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../_sources/navi/thrift_bpr_adapter/thrift/src/prediction_service.rs.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>