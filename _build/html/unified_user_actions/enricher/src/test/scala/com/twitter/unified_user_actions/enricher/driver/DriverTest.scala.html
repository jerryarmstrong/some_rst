<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../../" id="documentation_options" src="../../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.unified_user_actions.enricher.driver</p>
<p>import com.twitter.inject.Test
import com.twitter.unified_user_actions.enricher.EnricherFixture
import com.twitter.unified_user_actions.enricher.hydrator.Hydrator
import com.twitter.unified_user_actions.enricher.internal.thriftscala.EnrichmentEnvelop
import com.twitter.unified_user_actions.enricher.internal.thriftscala.EnrichmentIdType
import com.twitter.unified_user_actions.enricher.internal.thriftscala.EnrichmentInstruction
import com.twitter.unified_user_actions.enricher.internal.thriftscala.EnrichmentKey
import com.twitter.unified_user_actions.enricher.internal.thriftscala.EnrichmentPlan
import com.twitter.unified_user_actions.enricher.internal.thriftscala.EnrichmentStage
import com.twitter.unified_user_actions.enricher.internal.thriftscala.EnrichmentStageStatus
import com.twitter.unified_user_actions.enricher.internal.thriftscala.EnrichmentStageType
import com.twitter.unified_user_actions.enricher.partitioner.Partitioner
import com.twitter.util.Await
import com.twitter.util.Future
import org.scalatest.BeforeAndAfter
import org.scalatest.matchers.should.Matchers
import scala.collection.mutable</p>
<dl>
<dt>class DriverTest extends Test with Matchers with BeforeAndAfter {</dt><dd><dl class="simple">
<dt>object ExecutionContext {</dt><dd><p>var executionCount = 0</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>before {</dt><dd><p>ExecutionContext.executionCount = 0</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>trait Fixtures extends EnricherFixture {</dt><dd><p>val repartitionTweet = mkStage()
val repartitionNotiTweet =</p>
<blockquote>
<div><p>mkStage(instructions = Seq(EnrichmentInstruction.NotificationTweetEnrichment))</p>
</div></blockquote>
<p>val hydrateTweet = mkStage(stageType = EnrichmentStageType.Hydration)
val hydrateTweetMultiInstructions = mkStage(</p>
<blockquote>
<div><p>stageType = EnrichmentStageType.Hydration,
instructions = Seq(</p>
<blockquote>
<div><p>EnrichmentInstruction.NotificationTweetEnrichment,
EnrichmentInstruction.TweetEnrichment,
EnrichmentInstruction.NotificationTweetEnrichment,
EnrichmentInstruction.TweetEnrichment</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>)
val hydrateNotiTweet = mkStage(</p>
<blockquote>
<div><p>stageType = EnrichmentStageType.Hydration,
instructions = Seq(EnrichmentInstruction.NotificationTweetEnrichment))</p>
</div></blockquote>
<p>val key1 = EnrichmentKey(EnrichmentIdType.TweetId, 123L)
val tweet1 = mkUUATweetEvent(981L)
val hydrator = new MockHydrator
val partitioner = new MockPartitioner
val outputTopic = “output”
val partitionTopic = “partition”</p>
<dl class="simple">
<dt>def complete(</dt><dd><p>enrichmentStage: EnrichmentStage,
outputTopic: Option[String] = None</p>
</dd>
<dt>): EnrichmentStage = {</dt><dd><p>enrichmentStage.copy(status = EnrichmentStageStatus.Completion, outputTopic = outputTopic)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def mkPlan(enrichmentStages: EnrichmentStage*): EnrichmentPlan = {</dt><dd><p>EnrichmentPlan(enrichmentStages)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def mkStage(</dt><dd><p>status: EnrichmentStageStatus = EnrichmentStageStatus.Initialized,
stageType: EnrichmentStageType = EnrichmentStageType.Repartition,
instructions: Seq[EnrichmentInstruction] = Seq(EnrichmentInstruction.TweetEnrichment)</p>
</dd>
<dt>): EnrichmentStage = {</dt><dd><p>EnrichmentStage(status, stageType, instructions)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>trait ExecutionCount {</dt><dd><dl class="simple">
<dt>val callMap: mutable.Map[Int, (EnrichmentInstruction, EnrichmentEnvelop)] =</dt><dd><p>mutable.Map[Int, (EnrichmentInstruction, EnrichmentEnvelop)]()</p>
</dd>
<dt>def recordExecution(instruction: EnrichmentInstruction, envelop: EnrichmentEnvelop): Unit = {</dt><dd><p>ExecutionContext.executionCount = ExecutionContext.executionCount + 1
callMap.put(ExecutionContext.executionCount, (instruction, envelop))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>class MockHydrator extends Hydrator with ExecutionCount {</dt><dd><dl class="simple">
<dt>def hydrate(</dt><dd><p>instruction: EnrichmentInstruction,
key: Option[EnrichmentKey],
envelop: EnrichmentEnvelop</p>
</dd>
<dt>): Future[EnrichmentEnvelop] = {</dt><dd><p>recordExecution(instruction, envelop)
Future(envelop.copy(envelopId = ExecutionContext.executionCount))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>class MockPartitioner extends Partitioner with ExecutionCount {</dt><dd><dl class="simple">
<dt>def repartition(</dt><dd><p>instruction: EnrichmentInstruction,
envelop: EnrichmentEnvelop</p>
</dd>
<dt>): Option[EnrichmentKey] = {</dt><dd><p>recordExecution(instruction, envelop)
Some(EnrichmentKey(EnrichmentIdType.TweetId, ExecutionContext.executionCount))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>test(“single partitioning plan works”) {</dt><dd><dl>
<dt>new Fixtures {</dt><dd><p>val driver = new EnrichmentDriver(Some(outputTopic), partitionTopic, hydrator, partitioner)
// given a simple plan that only repartition the input and nothing else
val plan = mkPlan(repartitionTweet)</p>
<dl>
<dt>(1L to 10).foreach(id =&gt; {</dt><dd><p>val envelop = EnrichmentEnvelop(id, tweet1, plan)</p>
<p>// when
val actual = Await.result(driver.execute(Some(key1), Future(envelop)))</p>
<p>val expectedKey = Some(key1.copy(id = id))
val expectedValue =</p>
<blockquote>
<div><p>envelop.copy(plan = mkPlan(complete(repartitionTweet, Some(partitionTopic))))</p>
</div></blockquote>
<p>// then the result should have a new partitioned key, with the envelop unchanged except the plan is complete
// however, the output topic is the partitionTopic (since this is only a partitioning stage)
assert((expectedKey, expectedValue) == actual)</p>
</dd>
</dl>
<p>})</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>test(“multi-stage partitioning plan works”) {</dt><dd><dl>
<dt>new Fixtures {</dt><dd><p>val driver = new EnrichmentDriver(Some(outputTopic), partitionTopic, hydrator, partitioner)
// given a plan that chain multiple repartition stages together
val plan = mkPlan(repartitionTweet, repartitionNotiTweet)
val envelop1 = EnrichmentEnvelop(1L, tweet1, plan)</p>
<p>// when 1st partitioning trip
val actual1 = Await.result(driver.execute(Some(key1), Future(envelop1)))</p>
<p>// then the result should have a new partitioned key, with the envelop unchanged except the
// 1st stage of the plan is complete
val expectedKey1 = key1.copy(id = 1L)
val expectedValue1 =</p>
<blockquote>
<div><dl class="simple">
<dt>envelop1.copy(plan =</dt><dd><p>mkPlan(complete(repartitionTweet, Some(partitionTopic)), repartitionNotiTweet))</p>
</dd>
</dl>
</div></blockquote>
<p>assert((Some(expectedKey1), expectedValue1) == actual1)</p>
<p>// then, we reuse the last result to exercise the logics on the driver again for the 2st trip
val actual2 = Await.result(driver.execute(Some(expectedKey1), Future(expectedValue1)))
val expectedKey2 = key1.copy(id = 2L)
val expectedValue2 =</p>
<blockquote>
<div><dl class="simple">
<dt>envelop1.copy(plan = mkPlan(</dt><dd><p>complete(repartitionTweet, Some(partitionTopic)),
complete(repartitionNotiTweet, Some(partitionTopic))))</p>
</dd>
</dl>
</div></blockquote>
<p>assert((Some(expectedKey2), expectedValue2) == actual2)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>test(“single hydration plan works”) {</dt><dd><dl>
<dt>new Fixtures {</dt><dd><p>val driver = new EnrichmentDriver(Some(outputTopic), partitionTopic, hydrator, partitioner)
// given a simple plan that only hydrate the input and nothing else
val plan = mkPlan(hydrateTweet)</p>
<dl>
<dt>(1L to 10).foreach(id =&gt; {</dt><dd><p>val envelop = EnrichmentEnvelop(id, tweet1, plan)</p>
<p>// when
val actual = Await.result(driver.execute(Some(key1), Future(envelop)))</p>
<dl class="simple">
<dt>val expectedValue =</dt><dd><p>envelop.copy(envelopId = id, plan = mkPlan(complete(hydrateTweet, Some(outputTopic))))</p>
</dd>
</dl>
<p>// then the result should have the same key, with the envelop hydrated &amp; the plan is complete
// the output topic should be the final topic since this is a hydration stage and the plan is complete
assert((Some(key1), expectedValue) == actual)</p>
</dd>
</dl>
<p>})</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>test(“single hydration with multiple instructions plan works”) {</dt><dd><dl>
<dt>new Fixtures {</dt><dd><p>val driver = new EnrichmentDriver(Some(outputTopic), partitionTopic, hydrator, partitioner)
// given a simple plan that only hydrate the input and nothing else
val plan = mkPlan(hydrateTweetMultiInstructions)
val envelop = EnrichmentEnvelop(0L, tweet1, plan)</p>
<p>// when
val actual = Await.result(driver.execute(Some(key1), Future(envelop)))
val expectedValue = envelop.copy(</p>
<blockquote>
<div><p>envelopId = 4L, // hydrate is called 4 times for 4 instructions in 1 stage
plan = mkPlan(complete(hydrateTweetMultiInstructions, Some(outputTopic))))</p>
</div></blockquote>
<p>// then the result should have the same key, with the envelop hydrated &amp; the plan is complete
// the output topic should be the final topic since this is a hydration stage and the plan is complete
assert((Some(key1), expectedValue) == actual)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>test(“multi-stage hydration plan works”) {</dt><dd><dl>
<dt>new Fixtures {</dt><dd><p>val driver = new EnrichmentDriver(Some(outputTopic), partitionTopic, hydrator, partitioner)
// given a plan that only hydrate twice
val plan = mkPlan(hydrateTweet, hydrateNotiTweet)
val envelop = EnrichmentEnvelop(1L, tweet1, plan)</p>
<p>// when
val actual = Await.result(driver.execute(Some(key1), Future(envelop)))</p>
<p>// then the result should have the same key, with the envelop hydrated. since there’s no
// partitioning stages, the driver will just recurse until all the hydration is done,
// then output to the final topic
val expectedValue =</p>
<blockquote>
<div><dl>
<dt>envelop.copy(</dt><dd><p>envelopId = 2L,
plan = mkPlan(</p>
<blockquote>
<div><p>complete(hydrateTweet),
complete(</p>
<blockquote>
<div><p>hydrateNotiTweet,
Some(outputTopic)</p>
</div></blockquote>
<p>) // only the last stage has the output topic</p>
</div></blockquote>
<p>))</p>
</dd>
</dl>
</div></blockquote>
<p>assert((Some(key1), expectedValue) == actual)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>test(“multi-stage partition+hydration plan works”) {</dt><dd><dl>
<dt>new Fixtures {</dt><dd><p>val driver = new EnrichmentDriver(Some(outputTopic), partitionTopic, hydrator, partitioner)</p>
<p>// given a plan that repartition then hydrate twice
val plan = mkPlan(repartitionTweet, hydrateTweet, repartitionNotiTweet, hydrateNotiTweet)
var curEnvelop = EnrichmentEnvelop(1L, tweet1, plan)
var curKey = key1</p>
<p>// stage 1, partitioning on tweet should be correct
var actual = Await.result(driver.execute(Some(curKey), Future(curEnvelop)))
var expectedKey = curKey.copy(id = 1L)
var expectedValue = curEnvelop.copy(</p>
<blockquote>
<div><dl class="simple">
<dt>plan = mkPlan(</dt><dd><p>complete(repartitionTweet, Some(partitionTopic)),
hydrateTweet,
repartitionNotiTweet,
hydrateNotiTweet))</p>
</dd>
</dl>
</div></blockquote>
<p>assert((Some(expectedKey), expectedValue) == actual)
curEnvelop = actual._2
curKey = actual._1.get</p>
<p>// stage 2-3, hydrating on tweet should be correct
// and since the next stage after hydration is a repartition, it will does so correctly
actual = Await.result(driver.execute(Some(curKey), Future(curEnvelop)))
expectedKey = curKey.copy(id = 3) // repartition is done in stage 3
expectedValue = curEnvelop.copy(</p>
<blockquote>
<div><p>envelopId = 2L, // hydration is done in stage 2
plan = mkPlan(</p>
<blockquote>
<div><p>complete(repartitionTweet, Some(partitionTopic)),
complete(hydrateTweet),
complete(repartitionNotiTweet, Some(partitionTopic)),
hydrateNotiTweet)</p>
</div></blockquote>
</div></blockquote>
<p>)</p>
<p>assert((Some(expectedKey), expectedValue) == actual)
curEnvelop = actual._2
curKey = actual._1.get</p>
<p>// then finally, stage 4 would output to the final topic
actual = Await.result(driver.execute(Some(curKey), Future(curEnvelop)))
expectedKey = curKey // nothing’s changed in the key
expectedValue = curEnvelop.copy(</p>
<blockquote>
<div><p>envelopId = 4L,
plan = mkPlan(</p>
<blockquote>
<div><p>complete(repartitionTweet, Some(partitionTopic)),
complete(hydrateTweet),
complete(repartitionNotiTweet, Some(partitionTopic)),
complete(hydrateNotiTweet, Some(outputTopic))</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>)</p>
<p>assert((Some(expectedKey), expectedValue) == actual)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../../_sources/unified_user_actions/enricher/src/test/scala/com/twitter/unified_user_actions/enricher/driver/DriverTest.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>