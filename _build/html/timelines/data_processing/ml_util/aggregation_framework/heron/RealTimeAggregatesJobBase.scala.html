<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../" id="documentation_options" src="../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.timelines.data_processing.ml_util.aggregation_framework.heron</p>
<p>import com.twitter.algebird.Monoid
import com.twitter.bijection.Injection
import com.twitter.bijection.thrift.CompactThriftCodec
import com.twitter.conversions.DurationOps._
import com.twitter.finagle.mtls.authentication.EmptyServiceIdentifier
import com.twitter.finagle.mtls.authentication.ServiceIdentifier
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.heron.util.CommonMetric
import com.twitter.ml.api.DataRecord
import com.twitter.scalding.Args
import com.twitter.storehaus.algebra.MergeableStore
import com.twitter.storehaus.algebra.StoreAlgebra._
import com.twitter.storehaus_internal.memcache.Memcache
import com.twitter.storehaus_internal.store.CombinedStore
import com.twitter.storehaus_internal.store.ReplicatingWritableStore
import com.twitter.summingbird.batch.BatchID
import com.twitter.summingbird.batch.Batcher
import com.twitter.summingbird.online.MergeableStoreFactory
import com.twitter.summingbird.online.option._
import com.twitter.summingbird.option.CacheSize
import com.twitter.summingbird.option.JobId
import com.twitter.summingbird.storm.option.FlatMapStormMetrics
import com.twitter.summingbird.storm.option.SummerStormMetrics
import com.twitter.summingbird.storm.Storm
import com.twitter.summingbird.storm.StormMetric
import com.twitter.summingbird.Options
import com.twitter.summingbird._
import com.twitter.summingbird_internal.runner.common.CapTicket
import com.twitter.summingbird_internal.runner.common.JobName
import com.twitter.summingbird_internal.runner.common.TeamEmail
import com.twitter.summingbird_internal.runner.common.TeamName
import com.twitter.summingbird_internal.runner.storm.ProductionStormConfig
import com.twitter.timelines.data_processing.ml_util.aggregation_framework._
import com.twitter.timelines.data_processing.ml_util.aggregation_framework.job.AggregatesV2Job
import com.twitter.timelines.data_processing.ml_util.aggregation_framework.job.AggregatesV2Job
import com.twitter.timelines.data_processing.ml_util.aggregation_framework.job.DataRecordFeatureCounter
import org.apache.heron.api.{Config =&gt; HeronConfig}
import org.apache.heron.common.basics.ByteAmount
import org.apache.storm.Config
import scala.collection.JavaConverters._</p>
<dl>
<dt>object RealTimeAggregatesJobBase {</dt><dd><dl class="simple">
<dt>lazy val commonMetric: StormMetric[CommonMetric] =</dt><dd><p>StormMetric(new CommonMetric(), CommonMetric.NAME, CommonMetric.POLL_INTERVAL)</p>
</dd>
</dl>
<p>lazy val flatMapMetrics: FlatMapStormMetrics = FlatMapStormMetrics(Iterable(commonMetric))
lazy val summerMetrics: SummerStormMetrics = SummerStormMetrics(Iterable(commonMetric))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>trait RealTimeAggregatesJobBase extends Serializable {</dt><dd><p>import RealTimeAggregatesJobBase._
import com.twitter.summingbird_internal.bijection.BatchPairImplicits._</p>
<p>def statsReceiver: StatsReceiver</p>
<p>def aggregatesToCompute: Set[TypedAggregateGroup[_]]</p>
<p>def jobConfigs: RealTimeAggregatesJobConfigs</p>
<dl class="simple">
<dt>implicit lazy val dataRecordCodec: Injection[DataRecord, Array[Byte]] =</dt><dd><p>CompactThriftCodec[DataRecord]</p>
</dd>
</dl>
<p>implicit lazy val monoid: Monoid[DataRecord] = DataRecordAggregationMonoid(aggregatesToCompute)
implicit lazy val aggregationKeyInjection: Injection[AggregationKey, Array[Byte]] =</p>
<blockquote>
<div><p>AggregationKeyInjection</p>
</div></blockquote>
<p>val clusters: Set[String] = Set(“atla”, “pdxa”)</p>
<dl>
<dt>def buildAggregateStoreToStorm(</dt><dd><p>isProd: Boolean,
serviceIdentifier: ServiceIdentifier,
jobConfig: RealTimeAggregatesJobConfig</p>
</dd>
<dt>): (AggregateStore =&gt; Option[Storm#Store[AggregationKey, DataRecord]]) = {</dt><dd><dl>
<dt>(store: AggregateStore) =&gt;</dt><dd><dl>
<dt>store match {</dt><dd><dl>
<dt>case rtaStore: RealTimeAggregateStore if rtaStore.isProd == isProd =&gt; {</dt><dd><dl>
<dt>lazy val primaryStore: MergeableStore[(AggregationKey, BatchID), DataRecord] =</dt><dd><dl class="simple">
<dt>Memcache.getMemcacheStore[(AggregationKey, BatchID), DataRecord](</dt><dd><p>rtaStore.online(serviceIdentifier))</p>
</dd>
</dl>
</dd>
<dt>lazy val mergeableStore: MergeableStore[(AggregationKey, BatchID), DataRecord] =</dt><dd><dl>
<dt>if (jobConfig.enableUserReindexingNighthawkBtreeStore</dt><dd><p>|| jobConfig.enableUserReindexingNighthawkHashStore) {
val reindexingNighthawkBtreeWritableDataRecordStoreList =</p>
<blockquote>
<div><dl>
<dt>if (jobConfig.enableUserReindexingNighthawkBtreeStore) {</dt><dd><dl>
<dt>lazy val cacheClientNighthawkConfig =</dt><dd><p>jobConfig.userReindexingNighthawkBtreeStoreConfig.online(serviceIdentifier)</p>
</dd>
<dt>List(</dt><dd><dl class="simple">
<dt>UserReindexingNighthawkWritableDataRecordStore.getBtreeStore(</dt><dd><p>nighthawkCacheConfig = cacheClientNighthawkConfig,
// Choose a reasonably large target size as this will be equivalent to the number of unique (user, timestamp)
// keys that are returned on read on the pKey, and we may have duplicate authors and associated records.
targetSize = 512,
statsReceiver = statsReceiver,
// Assuming trims are relatively expensive, choose a trimRate that’s not as aggressive. In this case we trim on
// 10% of all writes.
trimRate = 0.1</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
</dl>
<p>} else { Nil }</p>
</div></blockquote>
<dl>
<dt>val reindexingNighthawkHashWritableDataRecordStoreList =</dt><dd><dl>
<dt>if (jobConfig.enableUserReindexingNighthawkHashStore) {</dt><dd><dl>
<dt>lazy val cacheClientNighthawkConfig =</dt><dd><p>jobConfig.userReindexingNighthawkHashStoreConfig.online(serviceIdentifier)</p>
</dd>
<dt>List(</dt><dd><dl class="simple">
<dt>UserReindexingNighthawkWritableDataRecordStore.getHashStore(</dt><dd><p>nighthawkCacheConfig = cacheClientNighthawkConfig,
// Choose a reasonably large target size as this will be equivalent to the number of unique (user, timestamp)
// keys that are returned on read on the pKey, and we may have duplicate authors and associated records.
targetSize = 512,
statsReceiver = statsReceiver,
// Assuming trims are relatively expensive, choose a trimRate that’s not as aggressive. In this case we trim on
// 10% of all writes.
trimRate = 0.1</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
</dl>
<p>} else { Nil }</p>
</dd>
<dt>lazy val replicatingWritableStore = new ReplicatingWritableStore(</dt><dd><dl class="simple">
<dt>stores = List(primaryStore) ++ reindexingNighthawkBtreeWritableDataRecordStoreList</dt><dd><p>++ reindexingNighthawkHashWritableDataRecordStoreList</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>lazy val combinedStoreWithReindexing = new CombinedStore(</dt><dd><p>read = primaryStore,
write = replicatingWritableStore</p>
</dd>
</dl>
<p>)</p>
<p>combinedStoreWithReindexing.toMergeable</p>
</dd>
<dt>} else {</dt><dd><p>primaryStore</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>lazy val storeFactory: MergeableStoreFactory[(AggregationKey, BatchID), DataRecord] =</dt><dd><p>Storm.store(mergeableStore)(Batcher.unit)</p>
</dd>
</dl>
<p>Some(storeFactory)</p>
</dd>
</dl>
<p>}
case _ =&gt; None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def buildDataRecordSourceToStorm(</dt><dd><p>jobConfig: RealTimeAggregatesJobConfig</p>
</dd>
<dt>): (AggregateSource =&gt; Option[Producer[Storm, DataRecord]]) = { (source: AggregateSource) =&gt;</dt><dd><dl>
<dt>{</dt><dd><dl>
<dt>source match {</dt><dd><dl class="simple">
<dt>case stormAggregateSource: StormAggregateSource =&gt;</dt><dd><p>Some(stormAggregateSource.build(statsReceiver, jobConfig))</p>
</dd>
</dl>
<p>case _ =&gt; None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def apply(args: Args): ProductionStormConfig = {</dt><dd><p>lazy val isProd = args.boolean(“production”)
lazy val cluster = args.getOrElse(“cluster”, “”)
lazy val isDebug = args.boolean(“debug”)
lazy val role = args.getOrElse(“role”, “”)
lazy val service =</p>
<blockquote>
<div><dl class="simple">
<dt>args.getOrElse(</dt><dd><p>“service_name”,
“”</p>
</dd>
</dl>
<p>) // don’t use the argument service, which is a reserved heron argument</p>
</div></blockquote>
<p>lazy val environment = if (isProd) “prod” else “devel”
lazy val s2sEnabled = args.boolean(“s2s”)
lazy val keyedByUserEnabled = args.boolean(“keyed_by_user”)
lazy val keyedByAuthorEnabled = args.boolean(“keyed_by_author”)</p>
<p>require(clusters.contains(cluster))
if (s2sEnabled) {</p>
<blockquote>
<div><p>require(role.length() &gt; 0)
require(service.length() &gt; 0)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>lazy val serviceIdentifier = if (s2sEnabled) {</dt><dd><dl class="simple">
<dt>ServiceIdentifier(</dt><dd><p>role = role,
service = service,
environment = environment,
zone = cluster</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>} else EmptyServiceIdentifier</p>
<dl>
<dt>lazy val jobConfig = {</dt><dd><p>val jobConfig = if (isProd) jobConfigs.Prod else jobConfigs.Devel
jobConfig.copy(</p>
<blockquote>
<div><p>serviceIdentifier = serviceIdentifier,
keyedByUserEnabled = keyedByUserEnabled,
keyedByAuthorEnabled = keyedByAuthorEnabled)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<p>lazy val dataRecordSourceToStorm = buildDataRecordSourceToStorm(jobConfig)
lazy val aggregateStoreToStorm =</p>
<blockquote>
<div><p>buildAggregateStoreToStorm(isProd, serviceIdentifier, jobConfig)</p>
</div></blockquote>
<p>lazy val JaasConfigFlag = “-Djava.security.auth.login.config=resources/jaas.conf”
lazy val JaasDebugFlag = “-Dsun.security.krb5.debug=true”
lazy val JaasConfigString =</p>
<blockquote>
<div><p>if (isDebug) { “%s %s”.format(JaasConfigFlag, JaasDebugFlag) }
else JaasConfigFlag</p>
</div></blockquote>
<dl>
<dt>new ProductionStormConfig {</dt><dd><p>implicit val jobId: JobId = JobId(jobConfig.name)
override val jobName = JobName(jobConfig.name)
override val teamName = TeamName(jobConfig.teamName)
override val teamEmail = TeamEmail(jobConfig.teamEmail)
override val capTicket = CapTicket(“n/a”)</p>
<dl>
<dt>val configureHeronJvmSettings = {</dt><dd><p>val heronJvmOptions = new java.util.HashMap[String, AnyRef]()
jobConfig.componentToRamGigaBytesMap.foreach {</p>
<blockquote>
<div><dl class="simple">
<dt>case (component, gigabytes) =&gt;</dt><dd><dl class="simple">
<dt>HeronConfig.setComponentRam(</dt><dd><p>heronJvmOptions,
component,
ByteAmount.fromGigabytes(gigabytes))</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>HeronConfig.setContainerRamRequested(</dt><dd><p>heronJvmOptions,
ByteAmount.fromGigabytes(jobConfig.containerRamGigaBytes)</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>jobConfig.componentsToKerberize.foreach { component =&gt;</dt><dd><dl class="simple">
<dt>HeronConfig.setComponentJvmOptions(</dt><dd><p>heronJvmOptions,
component,
JaasConfigString</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>jobConfig.componentToMetaSpaceSizeMap.foreach {</dt><dd><dl>
<dt>case (component, metaspaceSize) =&gt;</dt><dd><dl class="simple">
<dt>HeronConfig.setComponentJvmOptions(</dt><dd><p>heronJvmOptions,
component,
metaspaceSize</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>heronJvmOptions.asScala.toMap ++ AggregatesV2Job</dt><dd><dl class="simple">
<dt>.aggregateNames(aggregatesToCompute).map {</dt><dd><p>case (prefix, aggNames) =&gt; (s”extras.aggregateNames.${prefix}”, aggNames)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def transformConfig(m: Map[String, AnyRef]): Map[String, AnyRef] = {</dt><dd><dl>
<dt>super.transformConfig(m) ++ List(</dt><dd><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Disable acking by setting acker executors to 0. Tuples that come off the</p></li>
<li><p>spout will be immediately acked which effectively disables retries on tuple</p></li>
<li><p>failures. This should help topology throughput/availability by relaxing consistency.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
</dl>
<p>Config.TOPOLOGY_ACKER_EXECUTORS -&gt; int2Integer(0),
Config.TOPOLOGY_WORKERS -&gt; int2Integer(jobConfig.topologyWorkers),
HeronConfig.TOPOLOGY_CONTAINER_CPU_REQUESTED -&gt; int2Integer(8),
HeronConfig.TOPOLOGY_DROPTUPLES_UPON_BACKPRESSURE -&gt; java.lang.Boolean.valueOf(true),
HeronConfig.TOPOLOGY_WORKER_CHILDOPTS -&gt; List(</p>
<blockquote>
<div><p>JaasConfigString,
s”-Dcom.twitter.eventbus.client.zoneName=${cluster}”,
“-Dcom.twitter.eventbus.client.EnableKafkaSaslTls=true”</p>
</div></blockquote>
<p>).mkString(” “),
“storm.job.uniqueId” -&gt; jobId.get</p>
</dd>
</dl>
<p>) ++ configureHeronJvmSettings</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override lazy val getNamedOptions: Map[String, Options] = jobConfig.topologyNamedOptions ++</dt><dd><dl>
<dt>Map(</dt><dd><dl>
<dt>“DEFAULT” -&gt; Options()</dt><dd><p>.set(flatMapMetrics)
.set(summerMetrics)
.set(MaxWaitingFutures(1000))
.set(FlushFrequency(30.seconds))
.set(UseAsyncCache(true))
.set(AsyncPoolSize(4))
.set(SourceParallelism(jobConfig.sourceCount))
.set(SummerBatchMultiplier(1000)),</p>
</dd>
<dt>“FLATMAP” -&gt; Options()</dt><dd><p>.set(FlatMapParallelism(jobConfig.flatMapCount))
.set(CacheSize(0)),</p>
</dd>
<dt>“SUMMER” -&gt; Options()</dt><dd><p>.set(SummerParallelism(jobConfig.summerCount))
/**</p>
<blockquote>
<div><ul class="simple">
<li><p>Sets number of tuples a Summer awaits before aggregation. Set higher</p></li>
<li><p>if you need to lower qps to memcache at the expense of introducing</p></li>
<li><p>some (stable) latency.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</div></blockquote>
<p>.set(CacheSize(jobConfig.cacheSize))</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val featureCounters: Seq[DataRecordFeatureCounter] =</dt><dd><p>Seq(DataRecordFeatureCounter.any(Counter(Group(“feature_counter”), Name(“num_records”))))</p>
</dd>
<dt>override def graph: TailProducer[Storm, Any] = AggregatesV2Job.generateJobGraph[Storm](</dt><dd><p>aggregateSet = aggregatesToCompute,
aggregateSourceToSummingbird = dataRecordSourceToStorm,
aggregateStoreToSummingbird = aggregateStoreToStorm,
featureCounters = featureCounters</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../_sources/timelines/data_processing/ml_util/aggregation_framework/heron/RealTimeAggregatesJobBase.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>