<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../" id="documentation_options" src="../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.earlybird_root.mergers;</p>
<p>import java.util.Collections;
import java.util.List;
import javax.annotation.Nullable;</p>
<p>import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.cache.CacheBuilder;
import com.google.common.cache.CacheLoader;
import com.google.common.cache.LoadingCache;
import com.google.common.collect.Lists;</p>
<p>import org.slf4j.Logger;
import org.slf4j.LoggerFactory;</p>
<p>import com.twitter.common.collections.Pair;
import com.twitter.common.quantity.Amount;
import com.twitter.common.quantity.Time;
import com.twitter.common.util.Clock;
import com.twitter.search.common.futures.Futures;
import com.twitter.search.common.metrics.SearchCounter;
import com.twitter.search.common.partitioning.snowflakeparser.SnowflakeIdParser;
import com.twitter.search.common.query.thriftjava.EarlyTerminationInfo;
import com.twitter.search.common.relevance.utils.ResultComparators;
import com.twitter.search.common.search.EarlyTerminationState;
import com.twitter.search.common.util.FinagleUtil;
import com.twitter.search.common.util.earlybird.EarlybirdResponseMergeUtil;
import com.twitter.search.common.util.earlybird.EarlybirdResponseUtil;
import com.twitter.search.earlybird.thrift.EarlybirdRequest;
import com.twitter.search.earlybird.thrift.EarlybirdResponse;
import com.twitter.search.earlybird.thrift.EarlybirdResponseCode;
import com.twitter.search.earlybird.thrift.ThriftSearchQuery;
import com.twitter.search.earlybird.thrift.ThriftSearchRankingMode;
import com.twitter.search.earlybird.thrift.ThriftSearchResult;
import com.twitter.search.earlybird.thrift.ThriftSearchResults;
import com.twitter.search.earlybird.thrift.ThriftTweetSource;
import com.twitter.search.earlybird_root.common.EarlybirdFeatureSchemaMerger;
import com.twitter.search.earlybird_root.common.EarlybirdRequestContext;
import com.twitter.search.earlybird_root.common.EarlybirdServiceResponse;
import com.twitter.util.Function;
import com.twitter.util.Function0;
import com.twitter.util.Future;</p>
<p>/** Utility functions for merging recency and relevance results. <a href="#id1"><span class="problematic" id="id2">*</span></a>/
public class SuperRootResponseMerger {</p>
<blockquote>
<div><p>private static final Logger LOG = LoggerFactory.getLogger(SuperRootResponseMerger.class);
private static final String ALL_STATS_PREFIX = “<a href="#id41"><span class="problematic" id="id42">superroot_response_merger_</span></a>”;</p>
<dl class="simple">
<dt>private static final SearchCounter FULL_ARCHIVE_MIN_ID_GREATER_THAN_REALTIME_MIN_ID =</dt><dd><p>SearchCounter.export(“full_archive_min_id_greater_than_realtime_min_id”);</p>
</dd>
</dl>
<p>private static final String ERROR_FORMAT = “%s%s_errors_from_cluster_%s_%s”;</p>
<p>private final ThriftSearchRankingMode rankingMode;
private final EarlybirdFeatureSchemaMerger featureSchemaMerger;
private final String featureStatPrefix;
private final Clock clock;
private final String rankingModeStatPrefix;</p>
<p>private final SearchCounter mergedResponseSearchResultsNotSet;
private final SearchCounter invalidMinStatusId;
private final SearchCounter invalidMaxStatusId;
private final SearchCounter noMinIds;
private final SearchCounter noMaxIds;
private final SearchCounter mergedResponses;
private final SearchCounter mergedResponsesWithExactDups;
private final LoadingCache&lt;Pair&lt;ThriftTweetSource, ThriftTweetSource&gt;, SearchCounter&gt; dupsStats;</p>
<dl>
<dt>private static final EarlybirdResponse EMPTY_RESPONSE =</dt><dd><dl class="simple">
<dt>new EarlybirdResponse(EarlybirdResponseCode.SUCCESS, 0)</dt><dd><dl class="simple">
<dt>.setSearchResults(new ThriftSearchResults()</dt><dd><p>.setResults(Lists.&lt;ThriftSearchResult&gt;newArrayList()));</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Creates a new SuperRootResponseMerger instance.</p></li>
<li><p>&#64;param rankingMode The ranking mode to use when merging results.</p></li>
<li><p>&#64;param featureSchemaMerger The merger that can merge feature schema from different tiers.</p></li>
<li><p>&#64;param clock The clock that will be used to merge results.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>public SuperRootResponseMerger(ThriftSearchRankingMode rankingMode,</dt><dd><blockquote>
<div><p>EarlybirdFeatureSchemaMerger featureSchemaMerger,
Clock clock) {</p>
</div></blockquote>
<p>this.rankingModeStatPrefix = rankingMode.name().toLowerCase();</p>
<p>this.rankingMode = rankingMode;
this.featureSchemaMerger = featureSchemaMerger;
this.clock = clock;
this.featureStatPrefix = “<a href="#id43"><span class="problematic" id="id44">superroot_</span></a>” + rankingMode.name().toLowerCase();</p>
<dl class="simple">
<dt>mergedResponseSearchResultsNotSet = SearchCounter.export(</dt><dd><p>ALL_STATS_PREFIX + rankingModeStatPrefix + “_merged_response_search_results_not_set”);</p>
</dd>
<dt>invalidMinStatusId =</dt><dd><p>SearchCounter.export(ALL_STATS_PREFIX + rankingModeStatPrefix + “_invalid_min_status_id”);</p>
</dd>
<dt>invalidMaxStatusId =</dt><dd><p>SearchCounter.export(ALL_STATS_PREFIX + rankingModeStatPrefix + “_invalid_max_status_id”);</p>
</dd>
</dl>
<p>noMinIds = SearchCounter.export(ALL_STATS_PREFIX + rankingModeStatPrefix + “_no_min_ids”);
noMaxIds = SearchCounter.export(ALL_STATS_PREFIX + rankingModeStatPrefix + “_no_max_ids”);
mergedResponses = SearchCounter.export(ALL_STATS_PREFIX + rankingModeStatPrefix</p>
<blockquote>
<div><ul class="simple">
<li><p>“_merged_responses”);</p></li>
</ul>
</div></blockquote>
<dl>
<dt>mergedResponsesWithExactDups =</dt><dd><dl class="simple">
<dt>SearchCounter.export(ALL_STATS_PREFIX + rankingModeStatPrefix</dt><dd><ul class="simple">
<li><p>“_merged_responses_with_exact_dups”);</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>dupsStats = CacheBuilder.newBuilder()</dt><dd><dl>
<dt>.build(new CacheLoader&lt;Pair&lt;ThriftTweetSource, ThriftTweetSource&gt;, SearchCounter&gt;() {</dt><dd><blockquote>
<div><p>&#64;Override
public SearchCounter load(Pair&lt;ThriftTweetSource, ThriftTweetSource&gt; key) {</p>
<blockquote>
<div><dl class="simple">
<dt>return SearchCounter.export(</dt><dd><p>ALL_STATS_PREFIX + rankingModeStatPrefix + “_merged_responses_with_exact_dups_”
+ key.getFirst().name() + “_” + key.getSecond().name());</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>});</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void incrErrorCount(String cluster, &#64;Nullable EarlybirdResponse response) {</dt><dd><p>String cause;
if (response != null) {</p>
<blockquote>
<div><p>cause = response.getResponseCode().name().toLowerCase();</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>cause = “null_response”;</p>
</dd>
</dl>
<p>}
String statName = String.format(</p>
<blockquote>
<div><p>ERROR_FORMAT, ALL_STATS_PREFIX, rankingModeStatPrefix, cluster, cause</p>
</div></blockquote>
<p>);</p>
<p>SearchCounter.export(statName).increment();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Merges the given response futures.</p></li>
<li></li>
<li><p>&#64;param earlybirdRequestContext The earlybird request.</p></li>
<li><p>&#64;param realtimeResponseFuture The response from the realtime cluster.</p></li>
<li><p>&#64;param protectedResponseFuture The response from the protected cluster.</p></li>
<li><p>&#64;param fullArchiveResponseFuture The response from the full archive cluster.</p></li>
<li><p>&#64;return A future with the merged results.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>public Future&lt;EarlybirdResponse&gt; mergeResponseFutures(</dt><dd><blockquote>
<div><p>final EarlybirdRequestContext earlybirdRequestContext,
final Future&lt;EarlybirdServiceResponse&gt; realtimeResponseFuture,
final Future&lt;EarlybirdServiceResponse&gt; protectedResponseFuture,
final Future&lt;EarlybirdServiceResponse&gt; fullArchiveResponseFuture) {</p>
</div></blockquote>
<dl>
<dt>Future&lt;EarlybirdResponse&gt; mergedResponseFuture = Futures.map(</dt><dd><p>realtimeResponseFuture, protectedResponseFuture, fullArchiveResponseFuture,
new Function0&lt;EarlybirdResponse&gt;() {</p>
<blockquote>
<div><p>&#64;Override
public EarlybirdResponse apply() {</p>
<blockquote>
<div><p>// If the realtime response is not valid, return an error response.
// Also, the realtime service should always be called.
EarlybirdServiceResponse realtimeResponse = Futures.get(realtimeResponseFuture);</p>
<dl>
<dt>if (realtimeResponse.getServiceState().serviceWasRequested()</dt><dd><blockquote>
<div><dl class="simple">
<dt>&amp;&amp; (!realtimeResponse.getServiceState().serviceWasCalled()</dt><dd><dl class="simple">
<dt>|| !EarlybirdResponseMergeUtil.isValidResponse(</dt><dd><p>realtimeResponse.getResponse()))) {</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>incrErrorCount(“realtime”, realtimeResponse.getResponse());
return EarlybirdResponseMergeUtil.transformInvalidResponse(</p>
<blockquote>
<div><p>realtimeResponse.getResponse(), “realtime”);</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<p>// If we have a protected response and it’s not valid, return an error response.
EarlybirdServiceResponse protectedResponse = Futures.get(protectedResponseFuture);
if (protectedResponse.getServiceState().serviceWasCalled()) {</p>
<blockquote>
<div><dl>
<dt>if (!EarlybirdResponseMergeUtil.isValidResponse(protectedResponse.getResponse())) {</dt><dd><p>incrErrorCount(“protected”, protectedResponse.getResponse());</p>
<dl class="simple">
<dt>return EarlybirdResponseMergeUtil.transformInvalidResponse(</dt><dd><p>protectedResponse.getResponse(), “protected”);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// If we have a full archive response, check if it’s valid.
EarlybirdServiceResponse fullArchiveResponse = Futures.get(fullArchiveResponseFuture);
boolean archiveHasError =</p>
<blockquote>
<div><p>fullArchiveResponse.getServiceState().serviceWasCalled()
&amp;&amp; !EarlybirdResponseMergeUtil.isValidResponse(fullArchiveResponse.getResponse());</p>
</div></blockquote>
<p>// Merge the responses.
EarlybirdResponse mergedResponse = mergeResponses(</p>
<blockquote>
<div><p>earlybirdRequestContext,
realtimeResponse.getResponse(),
protectedResponse.getResponse(),
fullArchiveResponse.getResponse());</p>
</div></blockquote>
<p>// If the realtime clusters didn’t return any results, and the full archive cluster
// returned an error response, return an error merged response.
if (archiveHasError &amp;&amp; !EarlybirdResponseUtil.hasResults(mergedResponse)) {</p>
<blockquote>
<div><p>incrErrorCount(“full_archive”, fullArchiveResponse.getResponse());</p>
<dl class="simple">
<dt>return EarlybirdResponseMergeUtil.failedEarlybirdResponse(</dt><dd><p>fullArchiveResponse.getResponse().getResponseCode(),
“realtime clusters had no results and archive cluster response had error”);</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>// Corner case: the realtime response could have exactly numRequested results, and could
// be exhausted (not early-terminated). In this case, the request should not have been
// sent to the full archive cluster.
//   - If the full archive cluster is not available, or was not requested, then we don’t
//     need to change anything.
//   - If the full archive cluster is available and was requested (but wasn’t hit
//     because we found enough results in the realtime cluster), then we should set the
//     early-termination flag on the merged response, to indicate that we potentially
//     have more results for this query in our index.
if ((fullArchiveResponse.getServiceState()</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>== EarlybirdServiceResponse.ServiceState.SERVICE_NOT_CALLED)</p>
</div></blockquote>
<p>&amp;&amp; !EarlybirdResponseUtil.isEarlyTerminated(realtimeResponse.getResponse())) {</p>
</div></blockquote>
<p>EarlyTerminationInfo earlyTerminationInfo = new EarlyTerminationInfo(true);
earlyTerminationInfo.setEarlyTerminationReason(</p>
<blockquote>
<div><p>EarlyTerminationState.TERMINATED_NUM_RESULTS_EXCEEDED.getTerminationReason());</p>
</div></blockquote>
<p>mergedResponse.setEarlyTerminationInfo(earlyTerminationInfo);</p>
</div></blockquote>
<p>}</p>
<p>// If we’ve exhausted all clusters, set the minSearchedStatusID to 0.
if (!EarlybirdResponseUtil.isEarlyTerminated(mergedResponse)) {</p>
<blockquote>
<div><p>mergedResponse.getSearchResults().setMinSearchedStatusID(0);</p>
</div></blockquote>
<p>}</p>
<p>return mergedResponse;</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>});</p>
</dd>
</dl>
<p>// Handle all merging exceptions.
return handleResponseException(mergedResponseFuture,</p>
<blockquote>
<div><p>“Exception thrown while merging responses.”);</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Merge the results in the given responses.</p></li>
<li></li>
<li><p>&#64;param earlybirdRequestContext The earlybird request context.</p></li>
<li><p>&#64;param realtimeResponse The response from the realtime cluster.</p></li>
<li><p>&#64;param protectedResponse The response from the protected cluster.</p></li>
<li><p>&#64;param fullArchiveResponse The response from the full archive cluster.</p></li>
<li><p>&#64;return The merged response.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>private EarlybirdResponse mergeResponses(</dt><dd><blockquote>
<div><p>EarlybirdRequestContext earlybirdRequestContext,
&#64;Nullable EarlybirdResponse realtimeResponse,
&#64;Nullable EarlybirdResponse protectedResponse,
&#64;Nullable EarlybirdResponse fullArchiveResponse) {</p>
</div></blockquote>
<p>EarlybirdRequest request = earlybirdRequestContext.getRequest();
ThriftSearchQuery searchQuery = request.getSearchQuery();
int numResultsRequested;</p>
<dl class="simple">
<dt>if (request.isSetNumResultsToReturnAtRoot()) {</dt><dd><p>numResultsRequested = request.getNumResultsToReturnAtRoot();</p>
</dd>
<dt>} else {</dt><dd><p>numResultsRequested = searchQuery.getNumResults();</p>
</dd>
</dl>
<p>}</p>
<p>Preconditions.checkState(numResultsRequested &gt; 0);</p>
<p>EarlybirdResponse mergedResponse = EMPTY_RESPONSE.deepCopy();
if ((realtimeResponse != null)</p>
<blockquote>
<div><blockquote>
<div><p>&amp;&amp; (realtimeResponse.getResponseCode() != EarlybirdResponseCode.TIER_SKIPPED)) {</p>
</div></blockquote>
<p>mergedResponse = realtimeResponse.deepCopy();</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>if (!mergedResponse.isSetSearchResults()) {</dt><dd><p>mergedResponseSearchResultsNotSet.increment();
mergedResponse.setSearchResults(</p>
<blockquote>
<div><p>new ThriftSearchResults(Lists.&lt;ThriftSearchResult&gt;newArrayList()));</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<p>// If either the realtime or the full archive response is early-terminated, we want the merged
// response to be early-terminated too. The early-termination flag from the realtime response
// carries over to the merged response, because mergedResponse is just a deep copy of the
// realtime response. So we only need to check the early-termination flag of the full archive
// response.
if ((fullArchiveResponse != null)</p>
<blockquote>
<div><blockquote>
<div><p>&amp;&amp; EarlybirdResponseUtil.isEarlyTerminated(fullArchiveResponse)) {</p>
</div></blockquote>
<p>mergedResponse.setEarlyTerminationInfo(fullArchiveResponse.getEarlyTerminationInfo());</p>
</div></blockquote>
<p>}</p>
<p>// If realtime has empty results and protected has some results then we copy the early
// termination information if that is present
if (protectedResponse != null</p>
<blockquote>
<div><blockquote>
<div><p>&amp;&amp; mergedResponse.getSearchResults().getResults().isEmpty()
&amp;&amp; !protectedResponse.getSearchResults().getResults().isEmpty()
&amp;&amp; EarlybirdResponseUtil.isEarlyTerminated(protectedResponse)) {</p>
</div></blockquote>
<p>mergedResponse.setEarlyTerminationInfo(protectedResponse.getEarlyTerminationInfo());</p>
</div></blockquote>
<p>}</p>
<p>// Merge the results.
List&lt;ThriftSearchResult&gt; mergedResults = mergeResults(</p>
<blockquote>
<div><p>numResultsRequested, realtimeResponse, protectedResponse, fullArchiveResponse);</p>
</div></blockquote>
<p>// Trim the merged results if necessary.
boolean resultsTrimmed = false;
if (mergedResults.size() &gt; numResultsRequested</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>&amp;&amp; !(searchQuery.isSetRelevanceOptions()</dt><dd><p>&amp;&amp; searchQuery.getRelevanceOptions().isReturnAllResults())) {</p>
</dd>
</dl>
</div></blockquote>
<p>// If we have more results than requested, trim the result list and re-adjust
// minSearchedStatusID.
mergedResults = mergedResults.subList(0, numResultsRequested);</p>
<p>// Mark early termination in merged response
if (!EarlybirdResponseUtil.isEarlyTerminated(mergedResponse)) {</p>
<blockquote>
<div><p>EarlyTerminationInfo earlyTerminationInfo = new EarlyTerminationInfo(true);
earlyTerminationInfo.setEarlyTerminationReason(</p>
<blockquote>
<div><p>EarlyTerminationState.TERMINATED_NUM_RESULTS_EXCEEDED.getTerminationReason());</p>
</div></blockquote>
<p>mergedResponse.setEarlyTerminationInfo(earlyTerminationInfo);</p>
</div></blockquote>
<p>}</p>
<p>resultsTrimmed = true;</p>
</div></blockquote>
<p>}</p>
<p>mergedResponse.getSearchResults().setResults(mergedResults);
featureSchemaMerger.mergeFeatureSchemaAcrossClusters(</p>
<blockquote>
<div><p>earlybirdRequestContext,
mergedResponse,
featureStatPrefix,
realtimeResponse,
protectedResponse,
fullArchiveResponse);</p>
</div></blockquote>
<p>// Set the minSearchedStatusID and maxSearchedStatusID fields on the merged response.
setMinSearchedStatusId(mergedResponse, realtimeResponse, protectedResponse, fullArchiveResponse,</p>
<blockquote>
<div><p>resultsTrimmed);</p>
</div></blockquote>
<dl class="simple">
<dt>setMaxSearchedStatusId(mergedResponse, realtimeResponse, protectedResponse,</dt><dd><p>fullArchiveResponse);</p>
</dd>
<dt>int numRealtimeSearchedSegments =</dt><dd><dl class="simple">
<dt>(realtimeResponse != null &amp;&amp; realtimeResponse.isSetNumSearchedSegments())</dt><dd><p>? realtimeResponse.getNumSearchedSegments()
: 0;</p>
</dd>
</dl>
</dd>
<dt>int numProtectedSearchedSegments =</dt><dd><dl class="simple">
<dt>(protectedResponse != null &amp;&amp; protectedResponse.isSetNumSearchedSegments())</dt><dd><p>? protectedResponse.getNumSearchedSegments()
: 0;</p>
</dd>
</dl>
</dd>
<dt>int numArchiveSearchedSegments =</dt><dd><dl class="simple">
<dt>(fullArchiveResponse != null &amp;&amp; fullArchiveResponse.isSetNumSearchedSegments())</dt><dd><p>? fullArchiveResponse.getNumSearchedSegments()
: 0;</p>
</dd>
</dl>
</dd>
<dt>mergedResponse.setNumSearchedSegments(</dt><dd><p>numRealtimeSearchedSegments + numProtectedSearchedSegments + numArchiveSearchedSegments);</p>
</dd>
<dt>if (earlybirdRequestContext.getRequest().getDebugMode() &gt; 0) {</dt><dd><dl class="simple">
<dt>mergedResponse.setDebugString(</dt><dd><p>mergeClusterDebugStrings(realtimeResponse, protectedResponse, fullArchiveResponse));</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>return mergedResponse;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Merges the given responses.</p></li>
<li></li>
<li><p>&#64;param numResults the number of results requested</p></li>
<li><p>&#64;param realtimeResponse the response from the realtime response</p></li>
<li><p>&#64;param protectedResponse the response from the protected response</p></li>
<li><p>&#64;param fullArchiveResponse the response from the full archive response</p></li>
<li><p>&#64;return the list of merged results</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>private List&lt;ThriftSearchResult&gt; mergeResults(int numResults,</dt><dd><blockquote>
<div><p>&#64;Nullable EarlybirdResponse realtimeResponse,
&#64;Nullable EarlybirdResponse protectedResponse,
&#64;Nullable EarlybirdResponse fullArchiveResponse) {</p>
</div></blockquote>
<p>mergedResponses.increment();
// We first merge the results from the two realtime clusters, Realtime cluster and
// Realtime Protected Tweets cluster
List&lt;ThriftSearchResult&gt; mergedResults = mergePublicAndProtectedRealtimeResults(</p>
<blockquote>
<div><p>numResults,
realtimeResponse,
protectedResponse,
fullArchiveResponse,
clock);</p>
</div></blockquote>
<dl class="simple">
<dt>EarlybirdResponseMergeUtil.addResultsToList(mergedResults, fullArchiveResponse,</dt><dd><p>ThriftTweetSource.FULL_ARCHIVE_CLUSTER);</p>
</dd>
<dt>List&lt;ThriftSearchResult&gt; distinctMergedResults =</dt><dd><p>EarlybirdResponseMergeUtil.distinctByStatusId(mergedResults, dupsStats);</p>
</dd>
<dt>if (mergedResults != distinctMergedResults) {</dt><dd><p>mergedResponsesWithExactDups.increment();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>if (rankingMode == ThriftSearchRankingMode.RELEVANCE</dt><dd><blockquote>
<div><p>|| rankingMode == ThriftSearchRankingMode.TOPTWEETS) {</p>
</div></blockquote>
<p>distinctMergedResults.sort(ResultComparators.SCORE_COMPARATOR);</p>
</dd>
<dt>} else {</dt><dd><p>distinctMergedResults.sort(ResultComparators.ID_COMPARATOR);</p>
</dd>
</dl>
<p>}</p>
<p>return distinctMergedResults;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul>
<li><p>Method for merging tweets from protected and realtime clusters</p></li>
<li><ul class="simple">
<li><p>realtime, guaranteed newer than any archive tweets</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p>protected, also realtime, but with a potentially larger window (optional)</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p>archive, public, guaranteed older than any public realtime tweets (optional, used for</p></li>
</ul>
</li>
<li><p>id limits, <em>not added to results</em>)</p></li>
<li><p>It adds the ThriftSearchResults from protected tweets to the realtimeResponse</p></li>
<li></li>
<li><p>Algorithm diagram: (with newer tweets at the top)</p></li>
<li><p>————————————  &lt;— protected maxSearchedStatusID</p></li>
<li><p><a href="#id33"><span class="problematic" id="id34">|C:Newest protected realtime tweets|</span></a></p></li>
<li><div class="line-block">
<div class="line">(does not exist if realtime      |</div>
</div>
</li>
<li><div class="line-block">
<div class="line">maxID &gt;= protected maxID)        |</div>
</div>
</li>
<li></li>
<li><div class="line-block">
<div class="line">————————     |  &lt;— 60 seconds ago</div>
</div>
</li>
<li><p><a href="#id11"><span class="problematic" id="id12">|</span></a>D:Newer protected realtime tweets |</p></li>
<li><div class="line-block">
<div class="line">(does not exist if realtime      |</div>
</div>
</li>
<li><div class="line-block">
<div class="line">maxID &gt;= 60 seconds ago)         |</div>
</div>
</li>
<li><p>———-    |     ————————     |  &lt;— public realtime maxSearchedStatusID</p></li>
<li><p><a href="#id35"><span class="problematic" id="id36">|A:Public|</span></a>    <a href="#id13"><span class="problematic" id="id14">|</span></a>E:Automatically valid protected   |</p></li>
<li><p><a href="#id37"><span class="problematic" id="id38">|realtime|</span></a>    <a href="#id15"><span class="problematic" id="id16">|</span></a>realtime tweets                   |</p></li>
<li><p>———-    |     ————————     |  &lt;— public realtime minSearchedStatusID</p></li>
<li><div class="line-block">
<div class="line"><a href="#id17"><span class="problematic" id="id18">|</span></a></div>
</div>
</li>
<li><p>———-    |  E if archive is present         |  &lt;— public archive maxSearchedStatusID</p></li>
<li><p>———-    |  E if archive is present         |  &lt;— public archive maxSearchedStatusID</p></li>
<li><p><a href="#id39"><span class="problematic" id="id40">|B:Public|</span></a>    |  F is archive is not present     |</p></li>
<li><p><a href="#id19"><span class="problematic" id="id20">|</span></a>archive |    |                                  |</p></li>
<li><p>———-    |     ————————     |  &lt;— public archive minSearchedStatusID</p></li>
<li><p><a href="#id21"><span class="problematic" id="id22">|</span></a>F:Older protected realtime tweets |</p></li>
<li><div class="line-block">
<div class="line">(does not exist if protected     |</div>
</div>
</li>
<li><div class="line-block">
<div class="line">minID &gt;= public minID)           |</div>
</div>
</li>
<li><p>————————————  &lt;— protected minSearchedStatusID</p></li>
<li><p>Step 1: Select tweets from groups A, and E. If this is enough, return them</p></li>
<li><p>Step 2: Select tweets from groups A, E, and F. If this is enough, return them</p></li>
<li><p>Step 3: Select tweets from groups A, D, E, and F and return them</p></li>
<li></li>
<li><p>There are two primary tradeoffs, both of which favor public tweets:</p></li>
<li><ol class="arabic simple">
<li><p>Benefit: While public indexing latency is &lt; 60s, auto-updating never misses public tweets</p></li>
</ol>
</li>
<li><p>Cost:    Absence of public tweets may delay protected tweets from being searchable for 60s</p></li>
<li><ol class="arabic simple" start="2">
<li><p>Benefit: No failure or delay from the protected cluster will affect realtime results</p></li>
</ol>
</li>
<li><p>Cost:    If the protected cluster indexes more slowly, auto-update may miss its tweets</p></li>
<li></li>
<li><p>&#64;param fullArchiveTweets - used solely for generating anchor points, not merged in.</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
</dl>
<p>&#64;VisibleForTesting
static List&lt;ThriftSearchResult&gt; mergePublicAndProtectedRealtimeResults(</p>
<blockquote>
<div><blockquote>
<div><p>int numRequested,
EarlybirdResponse realtimeTweets,
EarlybirdResponse realtimeProtectedTweets,
&#64;Nullable EarlybirdResponse fullArchiveTweets,
Clock clock) {</p>
</div></blockquote>
<p>// See which results will actually be used
boolean isRealtimeUsable = EarlybirdResponseUtil.hasResults(realtimeTweets);
boolean isArchiveUsable = EarlybirdResponseUtil.hasResults(fullArchiveTweets);
boolean isProtectedUsable = EarlybirdResponseUtil.hasResults(realtimeProtectedTweets);</p>
<p>long minId = Long.MIN_VALUE;
long maxId = Long.MAX_VALUE;
if (isRealtimeUsable) {</p>
<blockquote>
<div><p>// Determine the actual upper/lower bounds on the tweet id
if (realtimeTweets.getSearchResults().isSetMinSearchedStatusID()) {</p>
<blockquote>
<div><p>minId = realtimeTweets.getSearchResults().getMinSearchedStatusID();</p>
</div></blockquote>
<p>}
if (realtimeTweets.getSearchResults().isSetMaxSearchedStatusID()) {</p>
<blockquote>
<div><p>maxId = realtimeTweets.getSearchResults().getMaxSearchedStatusID();</p>
</div></blockquote>
<p>}</p>
<p>int justRight = realtimeTweets.getSearchResults().getResultsSize();
if (isArchiveUsable) {</p>
<blockquote>
<div><p>justRight += fullArchiveTweets.getSearchResults().getResultsSize();
if (fullArchiveTweets.getSearchResults().isSetMinSearchedStatusID()) {</p>
<blockquote>
<div><p>long fullArchiveMinId = fullArchiveTweets.getSearchResults().getMinSearchedStatusID();
if (fullArchiveMinId &lt;= minId) {</p>
<blockquote>
<div><p>minId = fullArchiveMinId;</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>FULL_ARCHIVE_MIN_ID_GREATER_THAN_REALTIME_MIN_ID.increment();</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
if (isProtectedUsable) {</p>
<blockquote>
<div><dl>
<dt>for (ThriftSearchResult result<span class="classifier">realtimeProtectedTweets.getSearchResults().getResults()) {</span></dt><dd><dl class="simple">
<dt>if (result.getId() &gt;= minId &amp;&amp; result.getId() &lt;= maxId) {</dt><dd><p>justRight++;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if (justRight &lt; numRequested) {</p>
<blockquote>
<div><p>// Since this is only used as an upper bound, old (pre-2010) ids are still handled correctly
maxId = Math.max(</p>
<blockquote>
<div><p>maxId,
SnowflakeIdParser.generateValidStatusId(</p>
<blockquote>
<div><p>clock.nowMillis() - Amount.of(60, Time.SECONDS).as(Time.MILLISECONDS), 0));</p>
</div></blockquote>
</div></blockquote>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>List&lt;ThriftSearchResult&gt; mergedSearchResults = Lists.newArrayListWithCapacity(numRequested * 2);</p>
<p>// Add valid tweets in order of priority: protected, then realtime
// Only add results that are within range (that check only matters for protected)
if (isProtectedUsable) {</p>
<blockquote>
<div><dl>
<dt>EarlybirdResponseMergeUtil.markWithTweetSource(</dt><dd><p>realtimeProtectedTweets.getSearchResults().getResults(),
ThriftTweetSource.REALTIME_PROTECTED_CLUSTER);</p>
</dd>
<dt>for (ThriftSearchResult result<span class="classifier">realtimeProtectedTweets.getSearchResults().getResults()) {</span></dt><dd><dl class="simple">
<dt>if (result.getId() &lt;= maxId &amp;&amp; result.getId() &gt;= minId) {</dt><dd><p>mergedSearchResults.add(result);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if (isRealtimeUsable) {</dt><dd><dl class="simple">
<dt>EarlybirdResponseMergeUtil.addResultsToList(</dt><dd><p>mergedSearchResults, realtimeTweets, ThriftTweetSource.REALTIME_CLUSTER);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>// Set the minSearchedStatusID and maxSearchedStatusID on the protected response to the
// minId and maxId that were used to trim the protected results.
// This is needed in order to correctly set these IDs on the merged response.
ThriftSearchResults protectedResults =</p>
<blockquote>
<div><p>EarlybirdResponseUtil.getResults(realtimeProtectedTweets);</p>
</div></blockquote>
<dl>
<dt>if ((protectedResults != null)</dt><dd><blockquote>
<div><p>&amp;&amp; protectedResults.isSetMinSearchedStatusID()
&amp;&amp; (protectedResults.getMinSearchedStatusID() &lt; minId)) {</p>
</div></blockquote>
<p>protectedResults.setMinSearchedStatusID(minId);</p>
</dd>
</dl>
<p>}
if ((protectedResults != null)</p>
<blockquote>
<div><blockquote>
<div><p>&amp;&amp; protectedResults.isSetMaxSearchedStatusID()
&amp;&amp; (protectedResults.getMaxSearchedStatusID() &gt; maxId)) {</p>
</div></blockquote>
<p>realtimeProtectedTweets.getSearchResults().setMaxSearchedStatusID(maxId);</p>
</div></blockquote>
<p>}</p>
<p>return mergedSearchResults;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Merges the debug strings of the given cluster responses.</p></li>
<li></li>
<li><p>&#64;param realtimeResponse The response from the realtime cluster.</p></li>
<li><p>&#64;param protectedResponse The response from the protected cluster.</p></li>
<li><p>&#64;param fullArchiveResponse The response from the full archive cluster.</p></li>
<li><p>&#64;return The merged debug string.</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
<dt>public static String mergeClusterDebugStrings(&#64;Nullable EarlybirdResponse realtimeResponse,</dt><dd><blockquote>
<div><p>&#64;Nullable EarlybirdResponse protectedResponse,
&#64;Nullable EarlybirdResponse fullArchiveResponse) {</p>
</div></blockquote>
<p>StringBuilder sb = new StringBuilder();
if ((realtimeResponse != null) &amp;&amp; realtimeResponse.isSetDebugString()) {</p>
<blockquote>
<div><p>sb.append(“Realtime response: “).append(realtimeResponse.getDebugString());</p>
</div></blockquote>
<p>}
if ((protectedResponse != null) &amp;&amp; protectedResponse.isSetDebugString()) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (sb.length() &gt; 0) {</dt><dd><p>sb.append(”n”);</p>
</dd>
</dl>
<p>}
sb.append(“Protected response: “).append(protectedResponse.getDebugString());</p>
</div></blockquote>
<p>}
if ((fullArchiveResponse != null) &amp;&amp; fullArchiveResponse.isSetDebugString()) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (sb.length() &gt; 0) {</dt><dd><p>sb.append(”n”);</p>
</dd>
</dl>
<p>}
sb.append(“Full archive response: “).append(fullArchiveResponse.getDebugString());</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if (sb.length() == 0) {</dt><dd><p>return null;</p>
</dd>
</dl>
<p>}
return sb.toString();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Sets the minSearchedStatusID field on the merged response.</p></li>
<li></li>
<li><p>&#64;param mergedResponse The merged response.</p></li>
<li><p>&#64;param fullArchiveResponse The full archive response.</p></li>
<li><p>&#64;param resultsTrimmed Whether the merged response results were trimmed.</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
<dt>private void setMinSearchedStatusId(EarlybirdResponse mergedResponse,</dt><dd><blockquote>
<div><p>EarlybirdResponse realtimeResponse,
EarlybirdResponse protectedResponse,
EarlybirdResponse fullArchiveResponse,
boolean resultsTrimmed) {</p>
</div></blockquote>
<p>Preconditions.checkNotNull(mergedResponse.getSearchResults());
if (resultsTrimmed) {</p>
<blockquote>
<div><p>// We got more results that we asked for and we trimmed them.
// Set minSearchedStatusID to the ID of the oldest result.
ThriftSearchResults searchResults = mergedResponse.getSearchResults();
if (searchResults.getResultsSize() &gt; 0) {</p>
<blockquote>
<div><p>List&lt;ThriftSearchResult&gt; results = searchResults.getResults();
long lastResultId = results.get(results.size() - 1).getId();
searchResults.setMinSearchedStatusID(lastResultId);</p>
</div></blockquote>
<p>}
return;</p>
</div></blockquote>
<p>}</p>
<p>// We did not get more results that we asked for. Get the min of the minSearchedStatusIDs of
// the merged responses.
List&lt;Long&gt; minIDs = Lists.newArrayList();
if (fullArchiveResponse != null</p>
<blockquote>
<div><blockquote>
<div><p>&amp;&amp; fullArchiveResponse.isSetSearchResults()
&amp;&amp; fullArchiveResponse.getSearchResults().isSetMinSearchedStatusID()) {</p>
</div></blockquote>
<p>minIDs.add(fullArchiveResponse.getSearchResults().getMinSearchedStatusID());
if (mergedResponse.getSearchResults().isSetMinSearchedStatusID()</p>
<blockquote>
<div><blockquote>
<div><p>&amp;&amp; mergedResponse.getSearchResults().getMinSearchedStatusID()
&lt; fullArchiveResponse.getSearchResults().getMinSearchedStatusID()) {</p>
</div></blockquote>
<p>invalidMinStatusId.increment();</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>if (protectedResponse != null</dt><dd><blockquote>
<div><p>&amp;&amp; !EarlybirdResponseUtil.hasResults(realtimeResponse)
&amp;&amp; EarlybirdResponseUtil.hasResults(protectedResponse)
&amp;&amp; protectedResponse.getSearchResults().isSetMinSearchedStatusID()) {</p>
</div></blockquote>
<p>minIDs.add(protectedResponse.getSearchResults().getMinSearchedStatusID());</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (mergedResponse.getSearchResults().isSetMinSearchedStatusID()) {</dt><dd><p>minIDs.add(mergedResponse.getSearchResults().getMinSearchedStatusID());</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (!minIDs.isEmpty()) {</dt><dd><p>mergedResponse.getSearchResults().setMinSearchedStatusID(Collections.min(minIDs));</p>
</dd>
<dt>} else {</dt><dd><p>noMinIds.increment();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Sets the maxSearchedStatusID field on the merged response.</p></li>
<li></li>
<li><p>&#64;param mergedResponse The merged response.</p></li>
<li><p>&#64;param fullArchiveResponse The full archive response.</p></li>
</ul>
<p><a href="#id29"><span class="problematic" id="id30">*</span></a>/</p>
</dd>
<dt>private void setMaxSearchedStatusId(EarlybirdResponse mergedResponse,</dt><dd><blockquote>
<div><p>EarlybirdResponse realtimeResponse,
EarlybirdResponse protectedResponse,
EarlybirdResponse fullArchiveResponse) {</p>
</div></blockquote>
<p>Preconditions.checkNotNull(mergedResponse.getSearchResults());
List&lt;Long&gt; maxIDs = Lists.newArrayList();
if (fullArchiveResponse != null</p>
<blockquote>
<div><blockquote>
<div><p>&amp;&amp; fullArchiveResponse.isSetSearchResults()
&amp;&amp; fullArchiveResponse.getSearchResults().isSetMaxSearchedStatusID()) {</p>
</div></blockquote>
<p>maxIDs.add(fullArchiveResponse.getSearchResults().getMaxSearchedStatusID());
if (mergedResponse.getSearchResults().isSetMaxSearchedStatusID()</p>
<blockquote>
<div><blockquote>
<div><p>&amp;&amp; fullArchiveResponse.getSearchResults().getMaxSearchedStatusID()
&gt; mergedResponse.getSearchResults().getMaxSearchedStatusID()) {</p>
</div></blockquote>
<p>invalidMaxStatusId.increment();</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>if (protectedResponse != null</dt><dd><blockquote>
<div><p>&amp;&amp; !EarlybirdResponseUtil.hasResults(realtimeResponse)
&amp;&amp; EarlybirdResponseUtil.hasResults(protectedResponse)
&amp;&amp; protectedResponse.getSearchResults().isSetMaxSearchedStatusID()) {</p>
</div></blockquote>
<p>maxIDs.add(protectedResponse.getSearchResults().getMaxSearchedStatusID());</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (mergedResponse.getSearchResults().isSetMaxSearchedStatusID()) {</dt><dd><p>maxIDs.add(mergedResponse.getSearchResults().getMaxSearchedStatusID());</p>
</dd>
</dl>
<p>}</p>
<p>ThriftSearchResults searchResults = mergedResponse.getSearchResults();
if (searchResults.getResultsSize() &gt; 0) {</p>
<blockquote>
<div><p>List&lt;ThriftSearchResult&gt; results = searchResults.getResults();
maxIDs.add(results.get(0).getId());</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if (!maxIDs.isEmpty()) {</dt><dd><p>mergedResponse.getSearchResults().setMaxSearchedStatusID(Collections.max(maxIDs));</p>
</dd>
<dt>} else {</dt><dd><p>noMaxIds.increment();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Handles exceptions thrown while merging responses. Timeout exceptions are converted to</p></li>
<li><p>SERVER_TIMEOUT_ERROR responses. All other exceptions are converted to PERSISTENT_ERROR</p></li>
<li><p>responses.</p></li>
</ul>
<p><a href="#id31"><span class="problematic" id="id32">*</span></a>/</p>
</dd>
<dt>private Future&lt;EarlybirdResponse&gt; handleResponseException(</dt><dd><blockquote>
<div><p>Future&lt;EarlybirdResponse&gt; responseFuture, final String debugMsg) {</p>
</div></blockquote>
<dl>
<dt>return responseFuture.handle(</dt><dd><dl>
<dt>new Function&lt;Throwable, EarlybirdResponse&gt;() {</dt><dd><p>&#64;Override
public EarlybirdResponse apply(Throwable t) {</p>
<blockquote>
<div><p>EarlybirdResponseCode responseCode = EarlybirdResponseCode.PERSISTENT_ERROR;
if (FinagleUtil.isTimeoutException(t)) {</p>
<blockquote>
<div><p>responseCode = EarlybirdResponseCode.SERVER_TIMEOUT_ERROR;</p>
</div></blockquote>
<p>}
EarlybirdResponse response = new EarlybirdResponse(responseCode, 0);
response.setDebugString(debugMsg + “n” + t);
return response;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>});</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../_sources/src/java/com/twitter/search/earlybird_root/mergers/SuperRootResponseMerger.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>