<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../" id="documentation_options" src="../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.earlybird_root.mergers;</p>
<p>import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;</p>
<p>import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableMap;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;</p>
<p>import org.slf4j.Logger;
import org.slf4j.LoggerFactory;</p>
<p>import com.twitter.search.common.metrics.SearchCounter;
import com.twitter.search.common.metrics.SearchTimerStats;
import com.twitter.search.common.partitioning.snowflakeparser.SnowflakeIdParser;
import com.twitter.search.common.query.thriftjava.EarlyTerminationInfo;
import com.twitter.search.common.relevance.utils.ResultComparators;
import com.twitter.search.earlybird.thrift.EarlybirdResponse;
import com.twitter.search.earlybird.thrift.ThriftSearchResult;
import com.twitter.search.earlybird.thrift.ThriftSearchResults;
import com.twitter.search.earlybird_root.collectors.RecencyMergeCollector;
import com.twitter.search.earlybird_root.common.EarlybirdFeatureSchemaMerger;
import com.twitter.search.earlybird_root.common.EarlybirdRequestContext;
import com.twitter.util.Future;</p>
<dl>
<dt>import static com.twitter.search.earlybird_root.mergers.RecencyResponseMerger</dt><dd><p>.EarlyTerminationTrimmingStats.Type.ALREADY_EARLY_TERMINATED;</p>
</dd>
<dt>import static com.twitter.search.earlybird_root.mergers.RecencyResponseMerger</dt><dd><p>.EarlyTerminationTrimmingStats.Type.FILTERED;</p>
</dd>
<dt>import static com.twitter.search.earlybird_root.mergers.RecencyResponseMerger</dt><dd><p>.EarlyTerminationTrimmingStats.Type.FILTERED_AND_TRUNCATED;</p>
</dd>
<dt>import static com.twitter.search.earlybird_root.mergers.RecencyResponseMerger</dt><dd><p>.EarlyTerminationTrimmingStats.Type.NOT_EARLY_TERMINATED;</p>
</dd>
<dt>import static com.twitter.search.earlybird_root.mergers.RecencyResponseMerger</dt><dd><p>.EarlyTerminationTrimmingStats.Type.TERMINATED_GOT_EXACT_NUM_RESULTS;</p>
</dd>
<dt>import static com.twitter.search.earlybird_root.mergers.RecencyResponseMerger</dt><dd><p>.EarlyTerminationTrimmingStats.Type.TRUNCATED;</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Merger class to merge recency search EarlybirdResponse objects.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public class RecencyResponseMerger extends EarlybirdResponseMerger {</dt><dd><p>private static final Logger LOG = LoggerFactory.getLogger(RecencyResponseMerger.class);</p>
<dl class="simple">
<dt>private static final SearchTimerStats RECENCY_TIMER =</dt><dd><p>SearchTimerStats.export(“merge_recency”, TimeUnit.NANOSECONDS, false, true);</p>
</dd>
</dl>
<p>&#64;VisibleForTesting
static final String TERMINATED_COLLECTED_ENOUGH_RESULTS =</p>
<blockquote>
<div><p>“terminated_collected_enough_results”;</p>
</div></blockquote>
<p>// Allowed replication lag relative to all replicas.  Replication lag exceeding
// this amount may result in some tweets from the replica not returned in search.
private static final long ALLOWED_REPLICATION_LAG_MS = 10000;</p>
<p>private static final double SUCCESSFUL_RESPONSE_THRESHOLD = 0.9;</p>
<p>&#64;VisibleForTesting
static final SearchCounter RECENCY_ZERO_RESULT_COUNT_AFTER_FILTERING_MAX_MIN_IDS =</p>
<blockquote>
<div><p>SearchCounter.export(“merger_recency_zero_result_count_after_filtering_max_min_ids”);</p>
</div></blockquote>
<p>&#64;VisibleForTesting
static final SearchCounter RECENCY_TRIMMED_TOO_MANY_RESULTS_COUNT =</p>
<blockquote>
<div><p>SearchCounter.export(“merger_recency_trimmed_too_many_results_count”);</p>
</div></blockquote>
<dl>
<dt>private static final SearchCounter RECENCY_TIER_MERGE_EARLY_TERMINATED_WITH_NOT_ENOUGH_RESULTS =</dt><dd><p>SearchCounter.export(“merger_recency_tier_merge_early_terminated_with_not_enough_results”);</p>
</dd>
<dt>private static final SearchCounter RECENCY_CLEARED_EARLY_TERMINATION_COUNT =</dt><dd><p>SearchCounter.export(“merger_recency_cleared_early_termination_count”);</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Results were truncated because merged results exceeded the requested numResults.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
</dl>
<p>&#64;VisibleForTesting
static final String MERGING_EARLY_TERMINATION_REASON_TRUNCATED =</p>
<blockquote>
<div><p>“root_merging_truncated_results”;</p>
</div></blockquote>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Results that were were filtered smaller than merged minSearchedStatusId were filtered out.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
</dl>
<p>&#64;VisibleForTesting
static final String MERGING_EARLY_TERMINATION_REASON_FILTERED =</p>
<blockquote>
<div><p>“root_merging_filtered_results”;</p>
</div></blockquote>
<p>&#64;VisibleForTesting
static final EarlyTerminationTrimmingStats PARTITION_MERGING_EARLY_TERMINATION_TRIMMING_STATS =</p>
<blockquote>
<div><p>new EarlyTerminationTrimmingStats(“recency_partition_merging”);</p>
</div></blockquote>
<p>&#64;VisibleForTesting
static final EarlyTerminationTrimmingStats TIER_MERGING_EARLY_TERMINATION_TRIMMING_STATS =</p>
<blockquote>
<div><p>new EarlyTerminationTrimmingStats(“recency_tier_merging”);</p>
</div></blockquote>
<p>&#64;VisibleForTesting
static class EarlyTerminationTrimmingStats {</p>
<blockquote>
<div><dl>
<dt>enum Type {</dt><dd><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>The whole result was not terminated at all.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
</dl>
<p>NOT_EARLY_TERMINATED,
/**</p>
<blockquote>
<div><ul class="simple">
<li><p>Was terminated before we did any trimming.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</div></blockquote>
<p>ALREADY_EARLY_TERMINATED,
/**</p>
<blockquote>
<div><ul class="simple">
<li><p>Was not terminated when merged, but results were filtered due to min/max ranges.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</div></blockquote>
<p>FILTERED,
/**</p>
<blockquote>
<div><ul class="simple">
<li><p>Was not terminated when merged, but results were truncated.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</div></blockquote>
<p>TRUNCATED,
/**</p>
<blockquote>
<div><ul class="simple">
<li><p>Was not terminated when merged, but results were filtered due to min/max ranges and</p></li>
<li><p>truncated.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</div></blockquote>
<p>FILTERED_AND_TRUNCATED,
/**</p>
<blockquote>
<div><ul class="simple">
<li><p>When the search asks for X result, and we get exactly X results back, without trimming</p></li>
<li><p>or truncating on the tail side (min_id side), we still mark the search as early terminated.</p></li>
<li><p>This is because later tiers possibly has more results.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</div></blockquote>
<p>TERMINATED_GOT_EXACT_NUM_RESULTS,</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A counter tracking merged responses for each <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> EarlyTerminationTrimmingStats.Type}</p></li>
<li><p>define above.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
</dl>
<p>private final ImmutableMap&lt;Type, SearchCounter&gt; searchCounterMap;</p>
<dl>
<dt>EarlyTerminationTrimmingStats(String prefix) {</dt><dd><p>Map&lt;Type, SearchCounter&gt; tempMap = Maps.newEnumMap(Type.class);</p>
<dl class="simple">
<dt>tempMap.put(NOT_EARLY_TERMINATED,</dt><dd><p>SearchCounter.export(prefix + “_not_early_terminated_after_merging”));</p>
</dd>
<dt>tempMap.put(ALREADY_EARLY_TERMINATED,</dt><dd><p>SearchCounter.export(prefix + “_early_terminated_before_merge_trimming”));</p>
</dd>
<dt>tempMap.put(TRUNCATED,</dt><dd><p>SearchCounter.export(prefix + “_early_terminated_after_merging_truncated”));</p>
</dd>
<dt>tempMap.put(FILTERED,</dt><dd><p>SearchCounter.export(prefix + “_early_terminated_after_merging_filtered”));</p>
</dd>
<dt>tempMap.put(FILTERED_AND_TRUNCATED,</dt><dd><p>SearchCounter.export(prefix + “_early_terminated_after_merging_filtered_and_truncated”));</p>
</dd>
<dt>tempMap.put(TERMINATED_GOT_EXACT_NUM_RESULTS,</dt><dd><p>SearchCounter.export(prefix + “_early_terminated_after_merging_got_exact_num_results”));</p>
</dd>
</dl>
<p>searchCounterMap = Maps.immutableEnumMap(tempMap);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public SearchCounter getCounterFor(Type type) {</dt><dd><p>return searchCounterMap.get(type);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>private final EarlybirdFeatureSchemaMerger featureSchemaMerger;</p>
<dl>
<dt>public RecencyResponseMerger(EarlybirdRequestContext requestContext,</dt><dd><blockquote>
<div><p>List&lt;Future&lt;EarlybirdResponse&gt;&gt; responses,
ResponseAccumulator mode,
EarlybirdFeatureSchemaMerger featureSchemaMerger) {</p>
</div></blockquote>
<p>super(requestContext, responses, mode);
this.featureSchemaMerger = featureSchemaMerger;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
protected double getDefaultSuccessResponseThreshold() {</p>
<blockquote>
<div><p>return SUCCESSFUL_RESPONSE_THRESHOLD;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
protected SearchTimerStats getMergedResponseTimer() {</p>
<blockquote>
<div><p>return RECENCY_TIMER;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
protected EarlybirdResponse internalMerge(EarlybirdResponse mergedResponse) {</p>
<blockquote>
<div><p>// The merged maxSearchedStatusId and minSearchedStatusId
long maxId = findMaxFullySearchedStatusID();
long minId = findMinFullySearchedStatusID();</p>
<p>RecencyMergeCollector collector = new RecencyMergeCollector(responses.size());
int totalResultSize = addResponsesToCollector(collector);
ThriftSearchResults searchResults = collector.getAllSearchResults();</p>
<p>TrimStats trimStats = trimResults(searchResults, minId, maxId);
setMergedMaxSearchedStatusId(searchResults, maxId);
setMergedMinSearchedStatusId(</p>
<blockquote>
<div><p>searchResults, minId, trimStats.getResultsTruncatedFromTailCount() &gt; 0);</p>
</div></blockquote>
<p>mergedResponse.setSearchResults(searchResults);</p>
<p>// Override some components of the response as appropriate to real-time.
searchResults.setHitCounts(aggregateHitCountMap());
if (accumulatedResponses.isMergingPartitionsWithinATier()</p>
<blockquote>
<div><blockquote>
<div><p>&amp;&amp; clearEarlyTerminationIfReachingTierBottom(mergedResponse)) {</p>
</div></blockquote>
<p>RECENCY_CLEARED_EARLY_TERMINATION_COUNT.increment();</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>setEarlyTerminationForTrimmedResults(mergedResponse, trimStats);</p>
</dd>
</dl>
<p>}</p>
<p>responseMessageBuilder.debugVerbose(“Hits: %s %s”, totalResultSize, trimStats);
responseMessageBuilder.debugVerbose(</p>
<blockquote>
<div><p>“Hash Partitioned Earlybird call completed successfully: %s”, mergedResponse);</p>
</div></blockquote>
<dl class="simple">
<dt>featureSchemaMerger.collectAndSetFeatureSchemaInResponse(</dt><dd><p>searchResults,
requestContext,
“merger_recency_tier”,
accumulatedResponses.getSuccessResponses());</p>
</dd>
</dl>
<p>return mergedResponse;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>When we reached tier bottom, pagination can stop working even though we haven’t got</p></li>
<li><p>all results. e.g.</p></li>
<li><p>Results from partition 1:  [101 91 81], minSearchedStatusId is 81</p></li>
<li><p>Results from Partition 2:  [102 92],  minSearchedStatusId is 92, not early terminated.</p></li>
<li></li>
<li><p>After merge, we get [102, 101, 92], with minResultId == 92. Since results from</p></li>
<li><p>partition 2 is not early terminated, 92 is the tier bottom here. Since results are</p></li>
<li><p>filtered, early termination for merged result is set to true, so blender will call again,</p></li>
<li><p>with maxDocId == 91. This time we get result:</p></li>
<li><p>Results from partition 1: [91 81], minSearchedStatusId is 81</p></li>
<li><p>Results from partition 2: [], minSearchedStatusId is still 92</p></li>
<li><p>After merge we get [] and minSearchedStatusId is still 92. No progress can be made on</p></li>
<li><p>pagination and clients get stuck.</p></li>
<li></li>
<li><p>So in this case, we clear the early termination flag to tell blender there is no more</p></li>
<li><p>result in this tier. Tweets below tier bottom will be missed, but that also happens</p></li>
<li><p>without this step, as the next pagination call will return empty results anyway.</p></li>
<li><p>So even if there is NOT overlap between tiers, this is still better.</p></li>
<li></li>
<li><p>Return true if early termination is cleared due to this, otherwise return false.</p></li>
<li><p>To be safe, we do nothing here to keep existing behavior and only override it in</p></li>
<li><p>StrictRecencyResponseMerger.</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
<dt>protected boolean clearEarlyTerminationIfReachingTierBottom(EarlybirdResponse mergedResponse) {</dt><dd><p>return false;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Determines if the merged response should be early-terminated when it has exactly as many</p></li>
<li><p>trimmed results as requested, as is not early-terminated because of other reasons.</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>protected boolean shouldEarlyTerminateWhenEnoughTrimmedResults() {</dt><dd><p>return true;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>If the end results were trimmed in any way, reflect that in the response as a query that was</p></li>
<li><p>early terminated. A response can be either (1) truncated because we merged more results than</p></li>
<li><p>what was asked for with numResults, or (2) we filtered results that were smaller than the</p></li>
<li><p>merged minSearchedStatusId.</p></li>
<li></li>
<li><p>&#64;param mergedResponse the merged response.</p></li>
<li><p>&#64;param trimStats trim stats for this merge.</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
<dt>private void setEarlyTerminationForTrimmedResults(</dt><dd><blockquote>
<div><p>EarlybirdResponse mergedResponse,
TrimStats trimStats) {</p>
</div></blockquote>
<p>responseMessageBuilder.debugVerbose(“Checking for merge trimming, trimStats %s”, trimStats);</p>
<p>EarlyTerminationTrimmingStats stats = getEarlyTerminationTrimmingStats();</p>
<p>EarlyTerminationInfo earlyTerminationInfo = mergedResponse.getEarlyTerminationInfo();
Preconditions.checkNotNull(earlyTerminationInfo);</p>
<dl>
<dt>if (!earlyTerminationInfo.isEarlyTerminated()) {</dt><dd><dl>
<dt>if (trimStats.getMinIdFilterCount() &gt; 0 || trimStats.getResultsTruncatedFromTailCount() &gt; 0) {</dt><dd><dl class="simple">
<dt>responseMessageBuilder.debugVerbose(“Setting early termination, trimStats: %s, results: %s”,</dt><dd><p>trimStats, mergedResponse);</p>
</dd>
</dl>
<p>earlyTerminationInfo.setEarlyTerminated(true);
addEarlyTerminationReasons(earlyTerminationInfo, trimStats);</p>
<dl>
<dt>if (trimStats.getMinIdFilterCount() &gt; 0</dt><dd><blockquote>
<div><p>&amp;&amp; trimStats.getResultsTruncatedFromTailCount() &gt; 0) {</p>
</div></blockquote>
<p>stats.getCounterFor(FILTERED_AND_TRUNCATED).increment();</p>
</dd>
<dt>} else if (trimStats.getMinIdFilterCount() &gt; 0) {</dt><dd><p>stats.getCounterFor(FILTERED).increment();</p>
</dd>
<dt>} else if (trimStats.getResultsTruncatedFromTailCount() &gt; 0) {</dt><dd><p>stats.getCounterFor(TRUNCATED).increment();</p>
</dd>
<dt>} else {</dt><dd><p>Preconditions.checkState(false, “Invalid TrimStats: %s”, trimStats);</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else if ((computeNumResultsToKeep() == mergedResponse.getSearchResults().getResultsSize())</dt><dd><blockquote>
<div><p>&amp;&amp; shouldEarlyTerminateWhenEnoughTrimmedResults()) {</p>
</div></blockquote>
<p>earlyTerminationInfo.setEarlyTerminated(true);
earlyTerminationInfo.addToMergedEarlyTerminationReasons(</p>
<blockquote>
<div><p>TERMINATED_COLLECTED_ENOUGH_RESULTS);</p>
</div></blockquote>
<p>stats.getCounterFor(TERMINATED_GOT_EXACT_NUM_RESULTS).increment();</p>
</dd>
<dt>} else {</dt><dd><p>stats.getCounterFor(NOT_EARLY_TERMINATED).increment();</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>stats.getCounterFor(ALREADY_EARLY_TERMINATED).increment();
// Even if the results were already marked as early terminated, we can add additional
// reasons for debugging (if the merged results were filtered or truncated).
addEarlyTerminationReasons(earlyTerminationInfo, trimStats);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void addEarlyTerminationReasons(</dt><dd><blockquote>
<div><p>EarlyTerminationInfo earlyTerminationInfo,
TrimStats trimStats) {</p>
</div></blockquote>
<dl class="simple">
<dt>if (trimStats.getMinIdFilterCount() &gt; 0) {</dt><dd><dl class="simple">
<dt>earlyTerminationInfo.addToMergedEarlyTerminationReasons(</dt><dd><p>MERGING_EARLY_TERMINATION_REASON_FILTERED);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (trimStats.getResultsTruncatedFromTailCount() &gt; 0) {</dt><dd><dl class="simple">
<dt>earlyTerminationInfo.addToMergedEarlyTerminationReasons(</dt><dd><p>MERGING_EARLY_TERMINATION_REASON_TRUNCATED);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private EarlyTerminationTrimmingStats getEarlyTerminationTrimmingStats() {</dt><dd><dl class="simple">
<dt>if (accumulatedResponses.isMergingPartitionsWithinATier()) {</dt><dd><p>return getEarlyTerminationTrimmingStatsForPartitions();</p>
</dd>
<dt>} else {</dt><dd><p>return getEarlyTerminationTrimmingStatsForTiers();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>protected EarlyTerminationTrimmingStats getEarlyTerminationTrimmingStatsForPartitions() {</dt><dd><p>return PARTITION_MERGING_EARLY_TERMINATION_TRIMMING_STATS;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>protected EarlyTerminationTrimmingStats getEarlyTerminationTrimmingStatsForTiers() {</dt><dd><p>return TIER_MERGING_EARLY_TERMINATION_TRIMMING_STATS;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>If we get enough results, no need to go on.</p></li>
<li><p>If one of the partitions early terminated, we can’t go on or else there could be a gap.</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
</dl>
<p>&#64;Override
public boolean shouldEarlyTerminateTierMerge(int totalResultsFromSuccessfulShards,</p>
<blockquote>
<div><blockquote>
<div><p>boolean foundEarlyTermination) {</p>
</div></blockquote>
<p>int resultsRequested = computeNumResultsToKeep();</p>
<dl class="simple">
<dt>boolean shouldEarlyTerminate = foundEarlyTermination</dt><dd><p>|| totalResultsFromSuccessfulShards &gt;= resultsRequested;</p>
</dd>
<dt>if (shouldEarlyTerminate &amp;&amp; totalResultsFromSuccessfulShards &lt; resultsRequested) {</dt><dd><p>RECENCY_TIER_MERGE_EARLY_TERMINATED_WITH_NOT_ENOUGH_RESULTS.increment();</p>
</dd>
</dl>
<p>}</p>
<p>return shouldEarlyTerminate;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Find the min status id that has been _completely_ searched across all partitions. The</p></li>
<li><p>largest min status id across all partitions.</p></li>
<li></li>
<li><p>&#64;return the min searched status id found</p></li>
</ul>
<p><a href="#id29"><span class="problematic" id="id30">*</span></a>/</p>
</dd>
<dt>protected long findMinFullySearchedStatusID() {</dt><dd><p>List&lt;Long&gt; minIds = accumulatedResponses.getMinIds();
if (minIds.isEmpty()) {</p>
<blockquote>
<div><p>return Long.MIN_VALUE;</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if (accumulatedResponses.isMergingPartitionsWithinATier()) {</dt><dd><p>// When merging partitions, the min ID should be the largest among the min IDs.
return Collections.max(accumulatedResponses.getMinIds());</p>
</dd>
<dt>} else {</dt><dd><p>// When merging tiers, the min ID should be the smallest among the min IDs.
return Collections.min(accumulatedResponses.getMinIds());</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Find the max status id that has been _completely_ searched across all partitions. The</p></li>
<li><p>smallest max status id across all partitions.</p></li>
<li></li>
<li><p>This is where we reconcile replication lag by selecting the oldest maxid from the</p></li>
<li><p>partitions searched.</p></li>
<li></li>
<li><p>&#64;return the max searched status id found</p></li>
</ul>
<p><a href="#id31"><span class="problematic" id="id32">*</span></a>/
protected long findMaxFullySearchedStatusID() {</p>
<blockquote>
<div><p>List&lt;Long&gt; maxIDs = accumulatedResponses.getMaxIds();
if (maxIDs.isEmpty()) {</p>
<blockquote>
<div><p>return Long.MAX_VALUE;</p>
</div></blockquote>
<p>}
Collections.sort(maxIDs);</p>
<p>final long newest = maxIDs.get(maxIDs.size() - 1);
final long newestTimestamp = SnowflakeIdParser.getTimestampFromTweetId(newest);</p>
<dl>
<dt>for (int i = 0; i &lt; maxIDs.size(); i++) {</dt><dd><p>long oldest = maxIDs.get(i);
long oldestTimestamp = SnowflakeIdParser.getTimestampFromTweetId(oldest);
long deltaMs = newestTimestamp - oldestTimestamp;</p>
<dl class="simple">
<dt>if (i == 0) {</dt><dd><p>LOG.debug(“Max delta is {}”, deltaMs);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>if (deltaMs &lt; ALLOWED_REPLICATION_LAG_MS) {</dt><dd><dl class="simple">
<dt>if (i != 0) {</dt><dd><p>LOG.debug(“{} partition replicas lagging more than {} ms”, i, ALLOWED_REPLICATION_LAG_MS);</p>
</dd>
</dl>
<p>}
return oldest;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// Can’t get here - by this point oldest == newest, and delta is 0.
return newest;</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Trim the ThriftSearchResults if we have enough results, to return the first</p></li>
<li><p>‘computeNumResultsToKeep()’ number of results.</p></li>
<li></li>
<li><p>If we don’t have enough results after trimming, this function will first try to back fill</p></li>
<li><p>older results, then newer results</p></li>
<li></li>
<li><p>&#64;param searchResults ThriftSearchResults that hold the to be trimmed List&lt;ThriftSearchResult&gt;</p></li>
<li><p>&#64;return TrimStats containing statistics about how many results being removed</p></li>
</ul>
<p><a href="#id33"><span class="problematic" id="id34">*</span></a>/</p>
</dd>
<dt>protected TrimStats trimResults(</dt><dd><blockquote>
<div><p>ThriftSearchResults searchResults,
long mergedMin,
long mergedMax) {</p>
</div></blockquote>
<dl class="simple">
<dt>if (!searchResults.isSetResults() || searchResults.getResultsSize() == 0) {</dt><dd><p>// no results, no trimming needed
return TrimStats.EMPTY_STATS;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (requestContext.getRequest().getSearchQuery().isSetSearchStatusIds()) {</dt><dd><p>// Not a normal search, no trimming needed
return TrimStats.EMPTY_STATS;</p>
</dd>
</dl>
<p>}</p>
<p>TrimStats trimStats = new TrimStats();
trimExactDups(searchResults, trimStats);</p>
<p>int numResultsRequested = computeNumResultsToKeep();
if (shouldSkipTrimmingWhenNotEnoughResults(searchResults, numResultsRequested)) {</p>
<blockquote>
<div><p>return trimStats;</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if (accumulatedResponses.isMergingPartitionsWithinATier()) {</dt><dd><dl class="simple">
<dt>trimResultsBasedSearchedRange(</dt><dd><p>searchResults, trimStats, numResultsRequested, mergedMin, mergedMax);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>// Respect “computeNumResultsToKeep()” here, only keep “computeNumResultsToKeep()” results.
truncateResults(searchResults, trimStats);</p>
<p>return trimStats;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>When there’s not enough results, we don’t remove results based on the searched range.</p></li>
<li><p>This has a tradeoff:  with this, we don’t reduce our recall when we already don’t have enough</p></li>
<li><p>results. However, with this, we can lose results while paginating because we return results</p></li>
<li><p>outside of the valid searched range.</p></li>
</ul>
<p><a href="#id35"><span class="problematic" id="id36">*</span></a>/</p>
</dd>
<dt>protected boolean shouldSkipTrimmingWhenNotEnoughResults(</dt><dd><blockquote>
<div><p>ThriftSearchResults searchResults, int numResultsRequested) {</p>
</div></blockquote>
<p>return searchResults.getResultsSize() &lt;= numResultsRequested;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Trim results based on search range. The search range [x, y] is determined by:</p></li>
<li><p>x is the maximun of the minimun search IDs;</p></li>
<li><p>y is the minimun of the maximum search IDs.</p></li>
<li></li>
<li><p>Ids out side of this range are removed.</p></li>
<li><p>If we do not get enough results after the removal, we add IDs back until we get enough results.</p></li>
<li><p>We first add IDs back from the older side back. If there’s still not enough results,</p></li>
<li><p>we start adding IDs from the newer side back.</p></li>
</ul>
<p><a href="#id37"><span class="problematic" id="id38">*</span></a>/</p>
</dd>
<dt>private void trimResultsBasedSearchedRange(ThriftSearchResults searchResults,</dt><dd><blockquote>
<div><p>TrimStats trimStats,
int numResultsRequested,
long mergedMin,
long mergedMax) {</p>
</div></blockquote>
<p>// Save the original results before trimming
List&lt;ThriftSearchResult&gt; originalResults = searchResults.getResults();</p>
<p>filterResultsByMergedMinMaxIds(searchResults, mergedMax, mergedMin, trimStats);</p>
<p>// This does happen. It is hard to say what we should do here so we just return the original
// result here.
if (searchResults.getResultsSize() == 0) {</p>
<blockquote>
<div><p>RECENCY_ZERO_RESULT_COUNT_AFTER_FILTERING_MAX_MIN_IDS.increment();
searchResults.setResults(originalResults);</p>
<p>// Clean up min/mix filtered count, since we’re bringing back whatever we just filtered.
trimStats.clearMaxIdFilterCount();
trimStats.clearMinIdFilterCount();</p>
<dl>
<dt>if (LOG.isDebugEnabled() || responseMessageBuilder.isDebugMode()) {</dt><dd><dl class="simple">
<dt>String errMsg = “No trimming is done as filtered results is empty. “</dt><dd><ul class="simple">
<li><p>“maxId=” + mergedMax + “,minId=” + mergedMin;</p></li>
</ul>
</dd>
</dl>
<p>LOG.debug(errMsg);
responseMessageBuilder.append(errMsg + “n”);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>// oops! we’re trimming too many results. Let’s put some back
if (searchResults.getResultsSize() &lt; numResultsRequested) {</p>
<blockquote>
<div><p>RECENCY_TRIMMED_TOO_MANY_RESULTS_COUNT.increment();</p>
<p>List&lt;ThriftSearchResult&gt; trimmedResults = searchResults.getResults();
long firstTrimmedResultId = trimmedResults.get(0).getId();
long lastTrimmedResultId = trimmedResults.get(trimmedResults.size() - 1).getId();</p>
<p>// First, try to back fill with older results
int i = 0;
for (; i &lt; originalResults.size(); ++i) {</p>
<blockquote>
<div><p>ThriftSearchResult result = originalResults.get(i);
if (result.getId() &lt; lastTrimmedResultId) {</p>
<blockquote>
<div><p>trimmedResults.add(result);
trimStats.decreaseMinIdFilterCount();
if (trimmedResults.size() &gt;= numResultsRequested) {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// still not enough results? back fill with newer results
// find the oldest of the newer results
if (trimmedResults.size() &lt; numResultsRequested) {</p>
<blockquote>
<div><p>// still not enough results? back fill with newer results
// find the oldest of the newer results
for (i = originalResults.size() - 1; i &gt;= 0; –i) {</p>
<blockquote>
<div><p>ThriftSearchResult result = originalResults.get(i);
if (result.getId() &gt; firstTrimmedResultId) {</p>
<blockquote>
<div><p>trimmedResults.add(result);
trimStats.decreaseMaxIdFilterCount();
if (trimmedResults.size() &gt;= numResultsRequested) {</p>
<blockquote>
<div><p>break;</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// newer results were added to the back of the list, re-sort
Collections.sort(trimmedResults, ResultComparators.ID_COMPARATOR);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>protected void setMergedMinSearchedStatusId(</dt><dd><blockquote>
<div><p>ThriftSearchResults searchResults,
long currentMergedMin,
boolean resultsWereTrimmed) {</p>
</div></blockquote>
<dl class="simple">
<dt>if (accumulatedResponses.getMinIds().isEmpty()) {</dt><dd><p>return;</p>
</dd>
</dl>
<p>}</p>
<p>long merged;
if (searchResults == null</p>
<blockquote>
<div><blockquote>
<div><p>|| !searchResults.isSetResults()
|| searchResults.getResultsSize() == 0) {</p>
</div></blockquote>
<p>merged = currentMergedMin;</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>List&lt;ThriftSearchResult&gt; results = searchResults.getResults();
long firstResultId = results.get(0).getId();
long lastResultId = results.get(results.size() - 1).getId();
merged = Math.min(firstResultId, lastResultId);
if (!resultsWereTrimmed) {</p>
<blockquote>
<div><p>// If the results were trimmed, we want to set minSearchedStatusID to the smallest
// tweet ID in the response. Otherwise, we want to take the min between that, and
// the current minSearchedStatusID.
merged = Math.min(merged, currentMergedMin);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>searchResults.setMinSearchedStatusID(merged);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void setMergedMaxSearchedStatusId(</dt><dd><blockquote>
<div><p>ThriftSearchResults searchResults,
long currentMergedMax) {</p>
</div></blockquote>
<dl class="simple">
<dt>if (accumulatedResponses.getMaxIds().isEmpty()) {</dt><dd><p>return;</p>
</dd>
</dl>
<p>}</p>
<p>long merged;
if (searchResults == null</p>
<blockquote>
<div><blockquote>
<div><p>|| !searchResults.isSetResults()
|| searchResults.getResultsSize() == 0) {</p>
</div></blockquote>
<p>merged = currentMergedMax;</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>List&lt;ThriftSearchResult&gt; results = searchResults.getResults();
long firstResultId = results.get(0).getId();
long lastResultId = results.get(results.size() - 1).getId();
long maxResultId = Math.max(firstResultId, lastResultId);
merged = Math.max(maxResultId, currentMergedMax);</p>
</dd>
</dl>
<p>}</p>
<p>searchResults.setMaxSearchedStatusID(merged);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>protected static void filterResultsByMergedMinMaxIds(</dt><dd><blockquote>
<div><p>ThriftSearchResults results, long maxStatusId, long minStatusId, TrimStats trimStats) {</p>
</div></blockquote>
<dl>
<dt>List&lt;ThriftSearchResult&gt; trimedResults =</dt><dd><p>Lists.newArrayListWithCapacity(results.getResultsSize());</p>
</dd>
<dt>for (ThriftSearchResult result<span class="classifier">results.getResults()) {</span></dt><dd><p>long statusId = result.getId();</p>
<dl class="simple">
<dt>if (statusId &gt; maxStatusId) {</dt><dd><p>trimStats.increaseMaxIdFilterCount();</p>
</dd>
<dt>} else if (statusId &lt; minStatusId) {</dt><dd><p>trimStats.increaseMinIdFilterCount();</p>
</dd>
<dt>} else {</dt><dd><p>trimedResults.add(result);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>results.setResults(trimedResults);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../_sources/src/java/com/twitter/search/earlybird_root/mergers/RecencyResponseMerger.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>