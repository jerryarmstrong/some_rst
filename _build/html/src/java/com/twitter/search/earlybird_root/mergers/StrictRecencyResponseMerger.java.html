<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../" id="documentation_options" src="../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.earlybird_root.mergers;</p>
<p>import java.util.Collections;
import java.util.List;
import java.util.concurrent.TimeUnit;</p>
<p>import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;</p>
<p>import com.twitter.search.common.metrics.SearchTimerStats;
import com.twitter.search.common.schema.earlybird.EarlybirdCluster;
import com.twitter.search.earlybird.thrift.EarlybirdResponse;
import com.twitter.search.earlybird.thrift.ThriftSearchResult;
import com.twitter.search.earlybird.thrift.ThriftSearchResults;
import com.twitter.search.earlybird_root.common.EarlybirdFeatureSchemaMerger;
import com.twitter.search.earlybird_root.common.EarlybirdRequestContext;
import com.twitter.util.Future;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A RecencyResponseMerger that prioritizes not losing results during pagination.</p></li>
<li><p>As of now, this merger is used by Gnip to make sure that scrolling returns all results.</p></li>
<li></li>
<li><p>The logic used for merging partitions is a bit tricky, because on one hand, we want to make sure</p></li>
<li><p>that we do miss results on the next pagination request; on the other hand, we want to return as</p></li>
<li><p>many results as we can, and we want to set the minSearchedStatusID of the merged response as low</p></li>
<li><p>as we can, in order to minimize the number of pagination requests.</p></li>
<li></li>
<li><p>The merging logic is:</p></li>
<li></li>
<li><p>Realtime cluster:</p></li>
<li><ol class="arabic simple">
<li><p>merge results from all partitions</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>if at least one partition response is early-terminated, set earlyTerminated = true</p></li>
</ol>
</li>
<li><p>on the merged response</p></li>
<li><ol class="arabic simple" start="3">
<li><p>set trimmingMinId = max(minSearchedStatusIDs of all partition responses)</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="4">
<li><p>trim all results to trimmingMinId</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="5">
<li><p>set minSearchedStatusID on the merged response to trimmingMinId</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="6">
<li><p>if we have more than numRequested results:</p></li>
</ol>
</li>
<li><ul>
<li><p>keep only the newest numRequested results</p></li>
</ul>
</li>
<li><ul>
<li><p>set minSearchedStatusID of the merged response to the lowest tweet ID in the response</p></li>
</ul>
</li>
<li><ol class="arabic simple" start="7">
<li><p>if at least one partition response is not early-terminated, set</p></li>
</ol>
</li>
<li><p>tierBottomId = max(minSearchedStatusIDs of all non-early-terminated responses)</p></li>
<li><p>(otherwise, set tierBottomId to some undefined value: -1, Long.MAX_VALUE, etc.)</p></li>
<li><ol class="arabic simple" start="8">
<li><p>if minSearchedStatusID of the merged response is the same as tierBottomId,</p></li>
</ol>
</li>
<li><p>clear the early-termination flag on the merged response</p></li>
<li></li>
<li><p>The logic in steps 7 and 8 can be a little tricky to understand. They basically say: when we’ve</p></li>
<li><p>exhausted the “least deep” partition in the realtime cluster, it’s time to move to the full</p></li>
<li><p>archive cluster (if we keep going past the “least deep” partition, we might miss results).</p></li>
<li></li>
<li><p>Full archive cluster:</p></li>
<li><ol class="arabic simple">
<li><p>merge results from all partitions</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>if at least one partition response is early-terminated, set earlyTerminated = true</p></li>
</ol>
</li>
<li><p>on the merged response</p></li>
<li><ol class="arabic simple" start="3">
<li><p>set trimmingMinId to:</p></li>
</ol>
</li>
<li><ul>
<li><p>max(minSearchedStatusIDs of early-terminated responses), if at least one partition response</p></li>
</ul>
</li>
<li><p>is early-terminated</p></li>
<li><ul>
<li><p>min(minSearchedStatusIDs of all responses), if all partition responses are not</p></li>
</ul>
</li>
<li><p>early-terminated</p></li>
<li><ol class="arabic simple" start="4">
<li><p>trim all results to trimmingMinId</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="5">
<li><p>set minSearchedStatusID of the merged response to trimmingMinId</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="6">
<li><p>if we have more than numRequested results:</p></li>
</ol>
</li>
<li><ul>
<li><p>keep only the newest numRequested results</p></li>
</ul>
</li>
<li><ul>
<li><p>set minSearchedStatusID of the merged response to the lowest tweet ID in the response</p></li>
</ul>
</li>
<li></li>
<li><p>The logic in step 3 can be a little tricky to understand. On one hand, if we always set</p></li>
<li><p>trimmingMinId to the highest minSearchedStatusID, then some tweets at the very bottom of some</p></li>
<li><p>partitions will never be returned. Consider the case:</p></li>
<li></li>
<li><p>partition 1 has tweets 10, 8, 6</p></li>
<li><p>partition 2 has tweets 9, 7, 5</p></li>
<li></li>
<li><p>In this case, we would always trim all results to minId = 6, and tweet 5 would never be returned.</p></li>
<li></li>
<li><p>On the other hand, if we always set trimmingMinId to the lowest minSearchedStatusID, then we</p></li>
<li><p>might miss tweets from partitions that early-terminated. Consider the case:</p></li>
<li></li>
<li><p>partition 1 has tweets 10, 5, 3, 1 that match our query</p></li>
<li><p>partition 2 has tweets 9, 8, 7, 6, 2 that match our query</p></li>
<li></li>
<li><p>If we ask for 3 results, than partition 1 will return tweets 10, 5, 3, and partition 2 will</p></li>
<li><p>return tweets 9, 8, 7. If we set trimmingMinId = min(minSearchedStatusIDs), then the next</p></li>
<li><p>pagination request will have [max_id = 2], and we will miss tweet 6.</p></li>
<li></li>
<li><p>So the intuition here is that if we have an early-terminated response, we cannot set</p></li>
<li><p>trimmingMinId to something lower than the minSearchedStatusID returned by that partition</p></li>
<li><p>(otherwise we might miss results from that partition). However, if we’ve exhausted all</p></li>
<li><p>partitions, then it’s OK to not trim any result, because tiers do not intersect, so we will not</p></li>
<li><p>miss any result from the next tier once we get there.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public class StrictRecencyResponseMerger extends RecencyResponseMerger {</dt><dd><dl class="simple">
<dt>private static final SearchTimerStats STRICT_RECENCY_TIMER_AVG =</dt><dd><p>SearchTimerStats.export(“merge_recency_strict”, TimeUnit.NANOSECONDS, false, true);</p>
</dd>
</dl>
<p>&#64;VisibleForTesting
static final EarlyTerminationTrimmingStats PARTITION_MERGING_EARLY_TERMINATION_TRIMMING_STATS =</p>
<blockquote>
<div><p>new EarlyTerminationTrimmingStats(“strict_recency_partition_merging”);</p>
</div></blockquote>
<p>&#64;VisibleForTesting
static final EarlyTerminationTrimmingStats TIER_MERGING_EARLY_TERMINATION_TRIMMING_STATS =</p>
<blockquote>
<div><p>new EarlyTerminationTrimmingStats(“strict_recency_tier_merging”);</p>
</div></blockquote>
<p>private final EarlybirdCluster cluster;</p>
<dl>
<dt>public StrictRecencyResponseMerger(EarlybirdRequestContext requestContext,</dt><dd><blockquote>
<div><p>List&lt;Future&lt;EarlybirdResponse&gt;&gt; responses,
ResponseAccumulator mode,
EarlybirdFeatureSchemaMerger featureSchemaMerger,
EarlybirdCluster cluster) {</p>
</div></blockquote>
<p>super(requestContext, responses, mode, featureSchemaMerger);
this.cluster = cluster;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
protected SearchTimerStats getMergedResponseTimer() {</p>
<blockquote>
<div><p>return STRICT_RECENCY_TIMER_AVG;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Unlike <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> com.twitter.search.earlybird_root.mergers.RecencyResponseMerger}, this method</p></li>
<li><p>takes a much simpler approach by just taking the max of the maxSearchedStatusIds.</p></li>
<li></li>
<li><p>Also, when no maxSearchedStatusId is available at all, Long.MIN_VALUE is used instead of</p></li>
<li><p>Long.MAX_VALUE. This ensures that we don’t return any result in these cases.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
</dl>
<p>&#64;Override
protected long findMaxFullySearchedStatusID() {</p>
<blockquote>
<div><dl class="simple">
<dt>return accumulatedResponses.getMaxIds().isEmpty()</dt><dd><p>? Long.MIN_VALUE : Collections.max(accumulatedResponses.getMaxIds());</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>This method is subtly different from the base class version: when no minSearchedStatusId is</p></li>
<li><p>available at all, Long.MAX_VALUE is used instead of Long.MIN_VALUE. This ensures that we</p></li>
<li><p>don’t return any result in these cases.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
</dl>
<p>&#64;Override
protected long findMinFullySearchedStatusID() {</p>
<blockquote>
<div><p>List&lt;Long&gt; minIds = accumulatedResponses.getMinIds();
if (minIds.isEmpty()) {</p>
<blockquote>
<div><p>return Long.MAX_VALUE;</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if (accumulatedResponses.isMergingPartitionsWithinATier()) {</dt><dd><p>return getTrimmingMinId();</p>
</dd>
</dl>
<p>}</p>
<p>// When merging tiers, the min ID should be the smallest among the min IDs.
return Collections.min(minIds);</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
protected TrimStats trimResults(</p>
<blockquote>
<div><blockquote>
<div><p>ThriftSearchResults searchResults, long mergedMin, long mergedMax) {</p>
</div></blockquote>
<dl class="simple">
<dt>if (!searchResults.isSetResults() || searchResults.getResultsSize() == 0) {</dt><dd><p>// no results, no trimming needed
return TrimStats.EMPTY_STATS;</p>
</dd>
</dl>
<p>}</p>
<p>TrimStats trimStats = new TrimStats();
trimExactDups(searchResults, trimStats);
filterResultsByMergedMinMaxIds(searchResults, mergedMax, mergedMin, trimStats);
int numResults = computeNumResultsToKeep();
if (searchResults.getResultsSize() &gt; numResults) {</p>
<blockquote>
<div><p>trimStats.setResultsTruncatedFromTailCount(searchResults.getResultsSize() - numResults);
searchResults.setResults(searchResults.getResults().subList(0, numResults));</p>
</div></blockquote>
<p>}</p>
<p>return trimStats;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>This method is different from the base class version because when minResultId is bigger</p></li>
<li><p>than currentMergedMin, we always take minResultId.</p></li>
<li><p>If we don’t do this, we would lose results.</p></li>
<li></li>
<li><p>Illustration with an example. Assuming we are outside of the lag threshold.</p></li>
<li><p>Num results requested: 3</p></li>
<li><p>Response 1:  min: 100   max: 900   results:  400, 500, 600</p></li>
<li><p>Response 2:  min: 300   max: 700   results:  350, 450, 550</p></li>
<li></li>
<li><p>Merged results: 600, 550, 500</p></li>
<li><p>Merged max: 900</p></li>
<li><p>Merged min: we could take 300 (minId), or take 500 (minResultId).</p></li>
<li></li>
<li><p>If we take minId, and use 300 as the pagination cursor, we’d lose results</p></li>
<li><p>350 and 450 when we paginate. So we have to take minResultId here.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
</dl>
<p>&#64;Override
protected void setMergedMinSearchedStatusId(</p>
<blockquote>
<div><blockquote>
<div><p>ThriftSearchResults searchResults,
long currentMergedMin,
boolean resultsWereTrimmed) {</p>
</div></blockquote>
<dl class="simple">
<dt>if (accumulatedResponses.getMinIds().isEmpty()) {</dt><dd><p>return;</p>
</dd>
</dl>
<p>}</p>
<p>long minId = currentMergedMin;
if (resultsWereTrimmed</p>
<blockquote>
<div><blockquote>
<div><p>&amp;&amp; (searchResults != null)
&amp;&amp; searchResults.isSetResults()
&amp;&amp; (searchResults.getResultsSize() &gt; 0)) {</p>
</div></blockquote>
<p>List&lt;ThriftSearchResult&gt; results = searchResults.getResults();
minId = results.get(results.size() - 1).getId();</p>
</div></blockquote>
<p>}</p>
<p>searchResults.setMinSearchedStatusID(minId);</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
protected boolean clearEarlyTerminationIfReachingTierBottom(EarlybirdResponse mergedResponse) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (EarlybirdCluster.isArchive(cluster)) {</dt><dd><p>// We don’t need to worry about the tier bottom when merging partition responses in the full
// archive cluster: if all partitions were exhausted and we didn’t trim the results, then
// the early-terminated flag on the merged response will be false. If at least one partition
// is early-terminated, or we trimmed some results, then the ealry-terminated flag on the
// merged response will be true, and we should continue getting results from this tier before
// we move to the next one.
return false;</p>
</dd>
</dl>
<p>}</p>
<p>ThriftSearchResults searchResults = mergedResponse.getSearchResults();
if (searchResults.getMinSearchedStatusID() == getTierBottomId()) {</p>
<blockquote>
<div><p>mergedResponse.getEarlyTerminationInfo().setEarlyTerminated(false);
mergedResponse.getEarlyTerminationInfo().unsetMergedEarlyTerminationReasons();
responseMessageBuilder.debugVerbose(</p>
<blockquote>
<div><p>“Set earlytermination to false because minSearchedStatusId is tier bottom”);</p>
</div></blockquote>
<p>return true;</p>
</div></blockquote>
<p>}
return false;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
protected boolean shouldEarlyTerminateWhenEnoughTrimmedResults() {</p>
<blockquote>
<div><p>return false;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
protected final EarlyTerminationTrimmingStats getEarlyTerminationTrimmingStatsForPartitions() {</p>
<blockquote>
<div><p>return PARTITION_MERGING_EARLY_TERMINATION_TRIMMING_STATS;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
protected final EarlyTerminationTrimmingStats getEarlyTerminationTrimmingStatsForTiers() {</p>
<blockquote>
<div><p>return TIER_MERGING_EARLY_TERMINATION_TRIMMING_STATS;</p>
</div></blockquote>
<p>}</p>
<p>/** Determines the bottom of the realtime cluster, based on the partition responses. <a href="#id9"><span class="problematic" id="id10">*</span></a>/
private long getTierBottomId() {</p>
<blockquote>
<div><p>Preconditions.checkState(!EarlybirdCluster.isArchive(cluster));</p>
<p>long tierBottomId = -1;
for (EarlybirdResponse response : accumulatedResponses.getSuccessResponses()) {</p>
<blockquote>
<div><dl>
<dt>if (!isEarlyTerminated(response)</dt><dd><blockquote>
<div><p>&amp;&amp; response.isSetSearchResults()
&amp;&amp; response.getSearchResults().isSetMinSearchedStatusID()
&amp;&amp; (response.getSearchResults().getMinSearchedStatusID() &gt; tierBottomId)) {</p>
</div></blockquote>
<p>tierBottomId = response.getSearchResults().getMinSearchedStatusID();</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>return tierBottomId;</p>
</div></blockquote>
<p>}</p>
<p>/** Determines the minId to which all results should be trimmed. <a href="#id11"><span class="problematic" id="id12">*</span></a>/
private long getTrimmingMinId() {</p>
<blockquote>
<div><p>List&lt;Long&gt; minIds = accumulatedResponses.getMinIds();
Preconditions.checkArgument(!minIds.isEmpty());</p>
<dl class="simple">
<dt>if (!EarlybirdCluster.isArchive(cluster)) {</dt><dd><p>return Collections.max(minIds);</p>
</dd>
</dl>
<p>}</p>
<p>long maxOfEarlyTerminatedMins = -1;
long minOfAllMins = Long.MAX_VALUE;
for (EarlybirdResponse response : accumulatedResponses.getSuccessResponses()) {</p>
<blockquote>
<div><dl>
<dt>if (response.isSetSearchResults()</dt><dd><blockquote>
<div><p>&amp;&amp; response.getSearchResults().isSetMinSearchedStatusID()) {</p>
</div></blockquote>
<p>long minId = response.getSearchResults().getMinSearchedStatusID();
minOfAllMins = Math.min(minOfAllMins, minId);
if (isEarlyTerminated(response)) {</p>
<blockquote>
<div><p>maxOfEarlyTerminatedMins = Math.max(maxOfEarlyTerminatedMins, minId);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if (maxOfEarlyTerminatedMins &gt;= 0) {</p>
<blockquote>
<div><p>return maxOfEarlyTerminatedMins;</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>return minOfAllMins;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>/** Determines if the given earlybird response is early terminated. <a href="#id13"><span class="problematic" id="id14">*</span></a>/
private boolean isEarlyTerminated(EarlybirdResponse response) {</p>
<blockquote>
<div><dl class="simple">
<dt>return response.isSetEarlyTerminationInfo()</dt><dd><p>&amp;&amp; response.getEarlyTerminationInfo().isEarlyTerminated();</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../_sources/src/java/com/twitter/search/earlybird_root/mergers/StrictRecencyResponseMerger.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>