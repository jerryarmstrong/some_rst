<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../" id="documentation_options" src="../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.earlybird_root.mergers;</p>
<p>import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;</p>
<p>import scala.runtime.BoxedUnit;</p>
<p>import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Optional;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;</p>
<p>import org.slf4j.Logger;
import org.slf4j.LoggerFactory;</p>
<p>import com.twitter.search.common.metrics.SearchCounter;
import com.twitter.search.common.metrics.SearchTimerStats;
import com.twitter.search.common.schema.earlybird.EarlybirdCluster;
import com.twitter.search.common.util.FinagleUtil;
import com.twitter.search.common.util.earlybird.EarlybirdResponseMergeUtil;
import com.twitter.search.common.util.earlybird.ResultsUtil;
import com.twitter.search.earlybird.thrift.EarlybirdDebugInfo;
import com.twitter.search.earlybird.thrift.EarlybirdRequest;
import com.twitter.search.earlybird.thrift.EarlybirdResponse;
import com.twitter.search.earlybird.thrift.EarlybirdResponseCode;
import com.twitter.search.earlybird.thrift.ThriftSearchResult;
import com.twitter.search.earlybird.thrift.ThriftSearchResults;
import com.twitter.search.earlybird_root.collectors.MultiwayMergeCollector;
import com.twitter.search.earlybird_root.common.EarlybirdFeatureSchemaMerger;
import com.twitter.search.earlybird_root.common.EarlybirdRequestContext;
import com.twitter.search.earlybird_root.common.EarlybirdRequestType;
import com.twitter.search.earlybird_root.common.EarlybirdRequestUtil;
import com.twitter.util.Function;
import com.twitter.util.Future;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Base EarlybirdResponseMerger containing basic logic to merge EarlybirdResponse objects</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public abstract class EarlybirdResponseMerger implements EarlyTerminateTierMergePredicate {</dt><dd><p>private static final Logger LOG = LoggerFactory.getLogger(EarlybirdResponseMerger.class);
private static final Logger MIN_SEARCHED_STATUS_ID_LOGGER =</p>
<blockquote>
<div><p>LoggerFactory.getLogger(“MinSearchedStatusIdLogger”);</p>
</div></blockquote>
<dl class="simple">
<dt>private static final SearchCounter NO_SEARCH_RESULT_COUNTER =</dt><dd><p>SearchCounter.export(“no_search_result_count”);</p>
</dd>
<dt>private static final SearchCounter NO_RESPONSES_TO_MERGE =</dt><dd><p>SearchCounter.export(“no_responses_to_merge”);</p>
</dd>
<dt>private static final SearchCounter EARLYBIRD_RESPONSE_NO_MORE_RESULTS =</dt><dd><p>SearchCounter.export(“merger_earlybird_response_no_more_results”);</p>
</dd>
<dt>private static final String PARTITION_OR_TIER_COUNTER_NAME_FORMAT =</dt><dd><p>“merger_waited_for_response_from_%s_counter”;</p>
</dd>
<dt>private static final String PARTITION_OR_TIER_ERROR_COUNTER_NAME_FORMAT =</dt><dd><p>“merger_num_error_responses_from_%s”;</p>
</dd>
<dt>private static final String PARTITION_OR_TIER_RESPONSE_CODE_COUNTER_NAME_FORMAT =</dt><dd><p>“merger_earlybird_response_code_from_%s_%s”;</p>
</dd>
</dl>
<p>protected final EarlybirdResponseDebugMessageBuilder responseMessageBuilder;
protected final EarlybirdRequestContext requestContext;
protected final ImmutableList&lt;Future&lt;EarlybirdResponse&gt;&gt; responses;
protected AccumulatedResponses accumulatedResponses;</p>
<p>&#64;VisibleForTesting
static final Map&lt;EarlybirdRequestType, SearchCounter&gt; MERGER_CREATED_STATS =</p>
<blockquote>
<div><p>perRequestTypeCounterImmutableMap(“earlybird_response_merger_%s_created_count”);</p>
</div></blockquote>
<p>&#64;VisibleForTesting
static final Map&lt;EarlybirdRequestType, SearchCounter&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>MIN_SEARCHED_STATUS_ID_LARGER_THAN_REQUEST_MAX_ID = perRequestTypeCounterImmutableMap(</dt><dd><p>“merger_%s_min_searched_status_id_larger_than_request_max_id”);</p>
</dd>
</dl>
</div></blockquote>
<p>&#64;VisibleForTesting
static final Map&lt;EarlybirdRequestType, SearchCounter&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>MIN_SEARCHED_STATUS_ID_LARGER_THAN_REQUEST_UNTIL_TIME = perRequestTypeCounterImmutableMap(</dt><dd><p>“merger_%s_min_searched_status_id_larger_than_request_until_time”);</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>private static Map&lt;EarlybirdRequestType, SearchCounter&gt; perRequestTypeCounterImmutableMap(</dt><dd><blockquote>
<div><p>String statPattern) {</p>
</div></blockquote>
<p>Map&lt;EarlybirdRequestType, SearchCounter&gt; statsMap = Maps.newEnumMap(EarlybirdRequestType.class);
for (EarlybirdRequestType earlybirdRequestType : EarlybirdRequestType.values()) {</p>
<blockquote>
<div><p>String statName = String.format(statPattern, earlybirdRequestType.getNormalizedName());
statsMap.put(earlybirdRequestType, SearchCounter.export(statName));</p>
</div></blockquote>
<p>}</p>
<p>return Maps.immutableEnumMap(statsMap);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public static final com.google.common.base.Function&lt;EarlybirdResponse, Map&lt;Long, Integer&gt;&gt;</dt><dd><dl class="simple">
<dt>HIT_COUNT_GETTER =</dt><dd><dl class="simple">
<dt>response -&gt; response.getSearchResults() == null</dt><dd><p>? null
: response.getSearchResults().getHitCounts();</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>private final ChainMerger chainMerger;</p>
<dl>
<dt>private class ChainMerger {</dt><dd><p>private final EarlybirdRequestContext requestContext;
private final ResponseAccumulator responseAccumulator;
private final List&lt;Future&lt;EarlybirdResponse&gt;&gt; responses;
private final EarlybirdResponseDebugMessageBuilder responseMessageBuilder;
private int currentFutureIndex = -1;</p>
<dl>
<dt>public ChainMerger(EarlybirdRequestContext requestContext,</dt><dd><blockquote>
<div><p>ResponseAccumulator responseAccumulator,
List&lt;Future&lt;EarlybirdResponse&gt;&gt; responses,
EarlybirdResponseDebugMessageBuilder responseMessageBuilder) {</p>
</div></blockquote>
<p>this.requestContext = requestContext;
this.responseAccumulator = responseAccumulator;
this.responses = responses;
this.responseMessageBuilder = responseMessageBuilder;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>public Future&lt;EarlybirdResponse&gt; merge() {</dt><dd><p>// ‘responseFutures’ should always be sorted.
// When returned by EarlybirdScatterGather service, the responses are sorted by partition ID.
// When returned by EarlybirdChainedScatterGatherService,
// responses are sorted descending by tier start date. See:
// com.twitter.search.earlybird_root.EarlybirdChainedScatterGatherService.TIER_COMPARATOR.
//
// When merging responses from partitions, we want to wait for responses from all partitions,
// so the order in which we wait for those results does not matter. When merging responses
// from tiers, we want to wait for the response from the latest. If we don’t need any more
// responses to compute the final response, then we don’t need to wait for the responses from
// other tiers. If we cannot terminate early, then we want to wait for the responses from the
// second tier, and so on.
//
// We do not need to have any explicit synchronization, because:
//   1. The callbacks for future_i are set by the flatMap() callback on future_{i-1} (when
//      recursively calling merge() inside the flatMap()).
//   2. Before setting the callbacks on future_i, future_{i-1}.flatMap() adds the response
//      results to mergeHelper.
//   3. When the callbacks on future_i are set, the memory barrier between
//      thread_running_future_{i-1} and thread_running_future_i is crossed. This guarantees
//      that thread_running_future_i will see the updates to mergeHelper before it sees the
//      callbacks. (Or thread_running_future_{i-1} == thread_running_future_i, in which case
//      synchronization is not an issue, and correctness is guarateed by the order in which
//      things will run.)
//   4. The same reasoning applies to currentFutureIndex.</p>
<p>++currentFutureIndex;
if (currentFutureIndex &gt;= responses.size()) {</p>
<blockquote>
<div><p>return Future.value(getTimedMergedResponse(responseAccumulator.getAccumulatedResults()));</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>final String partitionTierName =</dt><dd><p>responseAccumulator.getNameForLogging(currentFutureIndex, responses.size());</p>
</dd>
<dt>final String nameForEarlybirdResponseCodeStats =</dt><dd><dl class="simple">
<dt>responseAccumulator.getNameForEarlybirdResponseCodeStats(</dt><dd><p>currentFutureIndex, responses.size());</p>
</dd>
</dl>
</dd>
</dl>
<p>// If a tier in the chain throws an exception, convert it to a null response, and let the
// mergeHelper handle it appropriately.
return responses.get(currentFutureIndex)</p>
<blockquote>
<div><dl>
<dt>.handle(Function.func(t -&gt; {</dt><dd><dl>
<dt>if (FinagleUtil.isCancelException(t)) {</dt><dd><dl class="simple">
<dt>return new EarlybirdResponse()</dt><dd><p>.setResponseCode(EarlybirdResponseCode.CLIENT_CANCEL_ERROR);</p>
</dd>
</dl>
</dd>
<dt>} else if (FinagleUtil.isTimeoutException(t)) {</dt><dd><dl class="simple">
<dt>return new EarlybirdResponse()</dt><dd><p>.setResponseCode(EarlybirdResponseCode.SERVER_TIMEOUT_ERROR);</p>
</dd>
</dl>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>SearchCounter.export(</dt><dd><p>String.format(PARTITION_OR_TIER_ERROR_COUNTER_NAME_FORMAT, partitionTierName))
.increment();</p>
</dd>
<dt>if (responseMessageBuilder.isDebugMode()) {</dt><dd><dl class="simple">
<dt>responseMessageBuilder.debugAndLogWarning(</dt><dd><dl class="simple">
<dt>String.format(“[%s] failed, exception [%s]”,</dt><dd><p>partitionTierName, t.toString()));</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}
LOG.warn(“exception response from: “ + partitionTierName, t);
return new EarlybirdResponse()</p>
<blockquote>
<div><p>.setResponseCode(EarlybirdResponseCode.TRANSIENT_ERROR);</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}))
.flatMap(Function.func(response -&gt; {</p>
<blockquote>
<div><p>Preconditions.checkNotNull(response);</p>
<dl>
<dt>SearchCounter.export(</dt><dd><dl class="simple">
<dt>String.format(PARTITION_OR_TIER_RESPONSE_CODE_COUNTER_NAME_FORMAT,</dt><dd><p>nameForEarlybirdResponseCodeStats,
response.getResponseCode().name().toLowerCase()))</p>
</dd>
</dl>
<p>.increment();</p>
</dd>
<dt>if ((response.getResponseCode() != EarlybirdResponseCode.PARTITION_SKIPPED)</dt><dd><blockquote>
<div><p>&amp;&amp; (response.getResponseCode() != EarlybirdResponseCode.TIER_SKIPPED)) {</p>
</div></blockquote>
<dl>
<dt>SearchCounter.export(</dt><dd><blockquote>
<div><p>String.format(PARTITION_OR_TIER_COUNTER_NAME_FORMAT, partitionTierName))</p>
</div></blockquote>
<p>.increment();</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (response.getResponseCode() == EarlybirdResponseCode.CLIENT_CANCEL_ERROR) {</dt><dd><p>// the request has been cancelled, no need to proceed
return Future.value(response);</p>
</dd>
</dl>
<p>}</p>
<p>rewriteResponseCodeIfSearchResultsMissing(requestContext, partitionTierName, response);
responseMessageBuilder.logResponseDebugInfo(</p>
<blockquote>
<div><p>requestContext.getRequest(),
partitionTierName,
response);</p>
</div></blockquote>
<dl class="simple">
<dt>responseAccumulator.addResponse(</dt><dd><p>responseMessageBuilder,
requestContext.getRequest(),
response);</p>
</dd>
<dt>if (responseAccumulator.shouldEarlyTerminateMerge(EarlybirdResponseMerger.this)) {</dt><dd><dl class="simple">
<dt>return Future.value(getTimedMergedResponse(</dt><dd><p>responseAccumulator.getAccumulatedResults()));</p>
</dd>
</dl>
</dd>
</dl>
<p>}
return merge();</p>
</div></blockquote>
<p>}));</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void rewriteResponseCodeIfSearchResultsMissing(</dt><dd><blockquote>
<div><p>EarlybirdRequestContext earlybirdRequestContext,
String partitionTierName,
EarlybirdResponse response) {</p>
</div></blockquote>
<p>// We always require searchResults to be set, even for term stats and facet requests.
// This is because searchResults contains important info such as pagination cursors
// like minSearchStatusId and minSearchedTimeSinceEpoch.
// We expect all successful responses to have searchResults set.
if (response.isSetResponseCode()</p>
<blockquote>
<div><blockquote>
<div><p>&amp;&amp; response.getResponseCode() == EarlybirdResponseCode.SUCCESS
&amp;&amp; response.getSearchResults() == null) {</p>
</div></blockquote>
<p>NO_SEARCH_RESULT_COUNTER.increment();
LOG.warn(“Received Earlybird response with null searchResults from [{}]”</p>
<blockquote>
<div><ul class="simple">
<li><p>“ EarlybirdRequest [{}] EarlybirdResponse [{}] “,</p></li>
</ul>
<p>partitionTierName, earlybirdRequestContext.getRequest(), response);</p>
</div></blockquote>
<p>response.setResponseCode(EarlybirdResponseCode.TRANSIENT_ERROR);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Construct a EarlybirdResponseMerger to merge responses from multiple partitions or tiers</p></li>
<li><p>based on mode.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>EarlybirdResponseMerger(EarlybirdRequestContext requestContext,</dt><dd><blockquote>
<div><p>List&lt;Future&lt;EarlybirdResponse&gt;&gt; responses,
ResponseAccumulator responseAccumulator) {</p>
</div></blockquote>
<p>this.requestContext = requestContext;
this.responses = ImmutableList.copyOf(responses);
this.responseMessageBuilder =</p>
<blockquote>
<div><p>new EarlybirdResponseDebugMessageBuilder(requestContext.getRequest());</p>
</div></blockquote>
<dl class="simple">
<dt>this.chainMerger = new ChainMerger(requestContext, responseAccumulator, responses,</dt><dd><p>responseMessageBuilder);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Get a response merger to merge the given responses.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>public static EarlybirdResponseMerger getResponseMerger(</dt><dd><blockquote>
<div><p>EarlybirdRequestContext requestContext,
List&lt;Future&lt;EarlybirdResponse&gt;&gt; responses,
ResponseAccumulator helper,
EarlybirdCluster cluster,
EarlybirdFeatureSchemaMerger featureSchemaMerger,
int numPartitions) {</p>
</div></blockquote>
<p>EarlybirdRequestType type = requestContext.getEarlybirdRequestType();
MERGER_CREATED_STATS.get(type).increment();
switch (type) {</p>
<blockquote>
<div><dl class="simple">
<dt>case FACETS:</dt><dd><p>return new FacetResponseMerger(requestContext, responses, helper);</p>
</dd>
<dt>case TERM_STATS:</dt><dd><p>return new TermStatisticsResponseMerger(requestContext, responses, helper);</p>
</dd>
<dt>case RECENCY:</dt><dd><p>return new RecencyResponseMerger(requestContext, responses, helper, featureSchemaMerger);</p>
</dd>
<dt>case STRICT_RECENCY:</dt><dd><dl class="simple">
<dt>return new StrictRecencyResponseMerger(</dt><dd><p>requestContext, responses, helper, featureSchemaMerger, cluster);</p>
</dd>
</dl>
</dd>
<dt>case RELEVANCE:</dt><dd><dl class="simple">
<dt>return new RelevanceResponseMerger(</dt><dd><p>requestContext, responses, helper, featureSchemaMerger, numPartitions);</p>
</dd>
</dl>
</dd>
<dt>case TOP_TWEETS:</dt><dd><p>return new TopTweetsResponseMerger(requestContext, responses, helper);</p>
</dd>
<dt>default:</dt><dd><p>throw new RuntimeException(“EarlybirdRequestType “ + type + “is not supported by merge”);</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>This method can perform two types of merges:</p></li>
<li><ol class="arabic simple">
<li><p>merge responses within a tier from different partitions.</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>merge responses from multiple tiers.</p></li>
</ol>
</li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>public final Future&lt;EarlybirdResponse&gt; merge() {</dt><dd><dl>
<dt>return chainMerger.merge()</dt><dd><dl>
<dt>.onSuccess(checkMinSearchedStatusIdFunction(</dt><dd><p>“max_id”,
EarlybirdRequestUtil.getRequestMaxId(requestContext.getParsedQuery()),
MIN_SEARCHED_STATUS_ID_LARGER_THAN_REQUEST_MAX_ID.get(</p>
<blockquote>
<div><p>requestContext.getEarlybirdRequestType())))</p>
</div></blockquote>
</dd>
<dt>.onSuccess(checkMinSearchedStatusIdFunction(</dt><dd><p>“until_time”,
EarlybirdRequestUtil.getRequestMaxIdFromUntilTime(requestContext.getParsedQuery()),
MIN_SEARCHED_STATUS_ID_LARGER_THAN_REQUEST_UNTIL_TIME.get(</p>
<blockquote>
<div><p>requestContext.getEarlybirdRequestType())));</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the function that checks if the minSearchedStatusID on the merged response is higher</p></li>
<li><p>than the max ID in the request.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>private Function&lt;EarlybirdResponse, BoxedUnit&gt; checkMinSearchedStatusIdFunction(</dt><dd><blockquote>
<div><p>final String operator, final Optional&lt;Long&gt; requestMaxId, final SearchCounter stat) {</p>
</div></blockquote>
<dl>
<dt>return Function.cons(mergedResponse -&gt; {</dt><dd><dl>
<dt>if (requestMaxId.isPresent()</dt><dd><blockquote>
<div><p>&amp;&amp; requestMaxId.get() != Long.MAX_VALUE
&amp;&amp; (mergedResponse.getResponseCode() == EarlybirdResponseCode.SUCCESS)
&amp;&amp; mergedResponse.isSetSearchResults()
&amp;&amp; mergedResponse.getSearchResults().isSetMinSearchedStatusID()) {</p>
</div></blockquote>
<p>long minSearchedStatusId = mergedResponse.getSearchResults().getMinSearchedStatusID();
// We sometimes set minSearchedStatusId = max_id + 1 when a request times out even
// before any search happens.
// Check SEARCH-10134 for more details.
if (minSearchedStatusId &gt; requestMaxId.get() + 1) {</p>
<blockquote>
<div><p>stat.increment();
String logMessage = “Response has a minSearchedStatusID ({}) larger than request “</p>
<blockquote>
<div><ul class="simple">
<li><p>operator + “ ({}).”</p></li>
<li><p>“nrequest type: {}”</p></li>
<li><p>“nrequest: {}”</p></li>
<li><p>“nmerged response: {}”</p></li>
<li><p>“nSuccessful accumulated responses:”;</p></li>
</ul>
</div></blockquote>
<p>List&lt;Object&gt; logMessageParams = Lists.newArrayList();
logMessageParams.add(minSearchedStatusId);
logMessageParams.add(requestMaxId.get());
logMessageParams.add(requestContext.getEarlybirdRequestType());
logMessageParams.add(requestContext.getRequest());
logMessageParams.add(mergedResponse);
for (EarlybirdResponse response : accumulatedResponses.getSuccessResponses()) {</p>
<blockquote>
<div><p>logMessage += “naccumulated response: {}”;
logMessageParams.add(response);</p>
</div></blockquote>
<p>}
MIN_SEARCHED_STATUS_ID_LOGGER.warn(logMessage, logMessageParams.toArray());</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>});</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private EarlybirdResponse getTimedMergedResponse(AccumulatedResponses accResponses) {</dt><dd><p>long start = System.nanoTime();
try {</p>
<blockquote>
<div><p>return getMergedResponse(accResponses);</p>
</div></blockquote>
<dl class="simple">
<dt>} finally {</dt><dd><p>long totalTime = System.nanoTime() - start;
getMergedResponseTimer().timerIncrement(totalTime);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private EarlybirdResponse initializeMergedSuccessResponseFromAccumulatedResponses() {</dt><dd><p>EarlybirdResponse mergedResponse = new EarlybirdResponse();</p>
<dl class="simple">
<dt>AccumulatedResponses.PartitionCounts partitionCounts =</dt><dd><p>accumulatedResponses.getPartitionCounts();</p>
</dd>
<dt>mergedResponse.setNumPartitions(partitionCounts.getNumPartitions())</dt><dd><p>.setNumSuccessfulPartitions(partitionCounts.getNumSuccessfulPartitions())
.setPerTierResponse(partitionCounts.getPerTierResponse())
.setNumSearchedSegments(accumulatedResponses.getNumSearchedSegments());</p>
</dd>
</dl>
<p>mergedResponse.setEarlyTerminationInfo(accumulatedResponses.getMergedEarlyTerminationInfo());
mergedResponse.setResponseCode(EarlybirdResponseCode.SUCCESS);</p>
<p>return mergedResponse;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private EarlybirdResponse getMergedResponse(AccumulatedResponses accResponses) {</dt><dd><p>accumulatedResponses = accResponses;
EarlybirdResponse mergedResponse;</p>
<dl>
<dt>if (accumulatedResponses.getSuccessResponses().isEmpty()</dt><dd><blockquote>
<div><p>&amp;&amp; !accumulatedResponses.foundError()) {</p>
</div></blockquote>
<p>// No successful or error responses. This means that all tiers / partitions are intentionally
// skipped. Return a blank successful response.
NO_RESPONSES_TO_MERGE.increment();
mergedResponse = new EarlybirdResponse()</p>
<blockquote>
<div><p>.setResponseCode(EarlybirdResponseCode.SUCCESS)
.setSearchResults(new ThriftSearchResults())
.setDebugString(“No responses to merge, probably because all tiers/partitions “</p>
<blockquote>
<div><ul class="simple">
<li><p>“were skipped.”);</p></li>
</ul>
</div></blockquote>
</div></blockquote>
</dd>
<dt>} else if (accumulatedResponses.isMergingAcrossTiers()) {</dt><dd><p>mergedResponse = getMergedResponseAcrossTiers();</p>
</dd>
<dt>} else {</dt><dd><p>mergedResponse = getMergedResponseAcrossPartitions();</p>
</dd>
</dl>
<p>}</p>
<p>saveMergedDebugString(mergedResponse);
return mergedResponse;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private EarlybirdResponse getMergedResponseAcrossTiers() {</dt><dd><dl class="simple">
<dt>Preconditions.checkState(</dt><dd><dl class="simple">
<dt>!accumulatedResponses.getSuccessResponses().isEmpty()</dt><dd><p>|| accumulatedResponses.foundError());</p>
</dd>
</dl>
</dd>
</dl>
<p>// When merging across tiers, if we have one failed tier, we should fail the whole
// response. Note that due to early termination, if a tier that is old fails
// but the newer tiers return enough results, the failed tier won’t show up
// here in accumulatedResponses – the only tiers that show up here
// will be successful.
if (accumulatedResponses.foundError()) {</p>
<blockquote>
<div><p>// The TierResponseAccumulator early terminates on the first error, so we should
// never get more than one error. This means that the getMergedErrorResponse will
// return an error response with the error code of that one error, and will never
// have to decide which error response to return if the error responses are all
// different.</p>
<p>// Perhaps we should just return accumulatedResponses.getErrorResponses().get(0);
Preconditions.checkState(accumulatedResponses.getErrorResponses().size() == 1);
return accumulatedResponses.getMergedErrorResponse();</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>EarlybirdResponse mergedResponse = initializeMergedSuccessResponseFromAccumulatedResponses();
return internalMerge(mergedResponse);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private EarlybirdResponse getMergedResponseAcrossPartitions() {</dt><dd><dl class="simple">
<dt>Preconditions.checkState(</dt><dd><dl class="simple">
<dt>!accumulatedResponses.getSuccessResponses().isEmpty()</dt><dd><p>|| accumulatedResponses.foundError());</p>
</dd>
</dl>
</dd>
</dl>
<p>EarlybirdResponse mergedResponse;</p>
<p>// Unlike tier merging, one failed response doesn’t mean the merged response should
// fail. If we have successful responses we can check the success ratio and if its
// good we can still return a successful merge.
if (!accumulatedResponses.getSuccessResponses().isEmpty()) {</p>
<blockquote>
<div><p>// We have at least one successful response, but still need to check the success ratio.
// mergedResponse is a SUCCESS response after this call, but we will
// set it to failure below if necessary.
mergedResponse = initializeMergedSuccessResponseFromAccumulatedResponses();</p>
<p>int numSuccessResponses = mergedResponse.getNumSuccessfulPartitions();
int numPartitions = mergedResponse.getNumPartitions();
double successThreshold = getSuccessResponseThreshold();
if (checkSuccessPartitionRatio(numSuccessResponses, numPartitions, successThreshold)) {</p>
<blockquote>
<div><p>// Success! Proceed with merging.
mergedResponse.setResponseCode(EarlybirdResponseCode.SUCCESS);
mergedResponse = internalMerge(mergedResponse);</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><dl class="simple">
<dt>responseMessageBuilder.logBelowSuccessThreshold(</dt><dd><p>requestContext.getRequest().getSearchQuery(), numSuccessResponses, numPartitions,
successThreshold);</p>
</dd>
</dl>
<p>mergedResponse.setResponseCode(EarlybirdResponseCode.TOO_MANY_PARTITIONS_FAILED_ERROR);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>mergedResponse = accumulatedResponses.getMergedErrorResponse();</p>
</dd>
</dl>
<p>}</p>
<p>return mergedResponse;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Derive class should implement the logic to merge the specific type of results (recency,</p></li>
<li><p>relevance, Top Tweets, etc..)</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
</dl>
<p>protected abstract EarlybirdResponse internalMerge(EarlybirdResponse response);</p>
<p>protected abstract SearchTimerStats getMergedResponseTimer();</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Do we have enough results so far that we can early terminate and not continue onto next tier?</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>public boolean shouldEarlyTerminateTierMerge(int totalResultsFromSuccessfulShards,</dt><dd><blockquote>
<div><p>boolean foundEarlyTermination) {</p>
</div></blockquote>
<p>// We are taking the most conservative tier response merging.
// This is the most conservative merge logic — as long as we have some results, we should
// not return anything from the next tier. This may cause not ideal experience where a
// page is not full, but the use can still scroll further.</p>
<p>return foundEarlyTermination || totalResultsFromSuccessfulShards &gt;= 1;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void saveMergedDebugString(EarlybirdResponse mergedResponse) {</dt><dd><dl>
<dt>if (responseMessageBuilder.isDebugMode()) {</dt><dd><p>String message = responseMessageBuilder.debugString();
mergedResponse.setDebugString(message);
if (!accumulatedResponses.getSuccessResponses().isEmpty()</p>
<blockquote>
<div><blockquote>
<div><p>&amp;&amp; accumulatedResponses.getSuccessResponses().get(0).isSetDebugInfo()) {</p>
</div></blockquote>
<dl class="simple">
<dt>EarlybirdDebugInfo debugInfo =</dt><dd><p>accumulatedResponses.getSuccessResponses().get(0).getDebugInfo();</p>
</dd>
</dl>
<p>mergedResponse.setDebugInfo(debugInfo);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private double getSuccessResponseThreshold() {</dt><dd><p>EarlybirdRequest request = requestContext.getRequest();
if (request.isSetSuccessfulResponseThreshold()) {</p>
<blockquote>
<div><p>double successfulResponseThreshold = request.getSuccessfulResponseThreshold();
Preconditions.checkArgument(successfulResponseThreshold &gt; 0,</p>
<blockquote>
<div><p>“Invalid successfulResponseThreshold %s”, successfulResponseThreshold);</p>
</div></blockquote>
<dl class="simple">
<dt>Preconditions.checkArgument(successfulResponseThreshold &lt;= 1.0,</dt><dd><p>“Invalid successfulResponseThreshold %s”, successfulResponseThreshold);</p>
</dd>
</dl>
<p>return successfulResponseThreshold;</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>return getDefaultSuccessResponseThreshold();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>protected abstract double getDefaultSuccessResponseThreshold();</p>
<dl>
<dt>private static boolean checkSuccessPartitionRatio(</dt><dd><blockquote>
<div><p>int numSuccessResponses,
int numPartitions,
double goodResponseThreshold) {</p>
</div></blockquote>
<dl class="simple">
<dt>Preconditions.checkArgument(goodResponseThreshold &gt; 0.0,</dt><dd><p>“Invalid goodResponseThreshold %s”, goodResponseThreshold);</p>
</dd>
</dl>
<p>return numSuccessResponses &gt;= (numPartitions * goodResponseThreshold);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Merge hit counts from all results.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>protected Map&lt;Long, Integer&gt; aggregateHitCountMap() {</dt><dd><dl>
<dt>Map&lt;Long, Integer&gt; hitCounts = ResultsUtil</dt><dd><p>.aggregateCountMap(accumulatedResponses.getSuccessResponses(), HIT_COUNT_GETTER);</p>
</dd>
<dt>if (hitCounts.size() &gt; 0) {</dt><dd><dl>
<dt>if (responseMessageBuilder.isDebugMode()) {</dt><dd><p>responseMessageBuilder.append(“Hit counts:n”);
for (Map.Entry&lt;Long, Integer&gt; entry : hitCounts.entrySet()) {</p>
<blockquote>
<div><dl class="simple">
<dt>responseMessageBuilder.append(String.format(”  %10s seconds: %d hitsn”,</dt><dd><p>entry.getKey() / 1000, entry.getValue()));</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
return hitCounts;</p>
</dd>
</dl>
<p>}
return null;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the number of results to keep as part of merge-collection.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>protected final int computeNumResultsToKeep() {</dt><dd><p>return EarlybirdResponseMergeUtil.computeNumResultsToKeep(requestContext.getRequest());</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Remove exact duplicates (same id) from the result set.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>protected static void trimExactDups(ThriftSearchResults searchResults, TrimStats trimStats) {</dt><dd><p>int numResults = searchResults.getResultsSize();
List&lt;ThriftSearchResult&gt; oldResults = searchResults.getResults();
List&lt;ThriftSearchResult&gt; newResults = Lists.newArrayListWithCapacity(numResults);
HashSet&lt;Long&gt; resultSet = Sets.newHashSetWithExpectedSize(numResults);</p>
<dl>
<dt>for (ThriftSearchResult result<span class="classifier">oldResults) {</span></dt><dd><dl class="simple">
<dt>if (resultSet.contains(result.getId())) {</dt><dd><p>trimStats.increaseRemovedDupsCount();
continue;</p>
</dd>
</dl>
<p>}</p>
<p>newResults.add(result);
resultSet.add(result.getId());</p>
</dd>
</dl>
<p>}</p>
<p>searchResults.setResults(newResults);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>protected final int addResponsesToCollector(MultiwayMergeCollector collector) {</dt><dd><p>int totalResultSize = 0;
for (EarlybirdResponse response : accumulatedResponses.getSuccessResponses()) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (response.isSetSearchResults()) {</dt><dd><p>totalResultSize += response.getSearchResults().getResultsSize();</p>
</dd>
</dl>
<p>}
collector.addResponse(response);</p>
</div></blockquote>
<p>}
return totalResultSize;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Given a sorted searchResults (for recency, sorted by ID; for relevance, sorted by score),</p></li>
<li><p>returns the first ‘computeNumResultsToKeep()’ number of results.</p></li>
<li></li>
<li><p>&#64;param searchResults the searchResults to be truncated.</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
<dt>protected final void truncateResults(ThriftSearchResults searchResults, TrimStats trimStats) {</dt><dd><p>int numResultsRequested = computeNumResultsToKeep();</p>
<dl>
<dt>int to = numResultsRequested == Integer.MAX_VALUE ? searchResults.getResultsSize()</dt><dd><p>: Math.min(numResultsRequested, searchResults.getResultsSize());</p>
</dd>
<dt>if (searchResults.getResultsSize() &gt; to) {</dt><dd><p>trimStats.setResultsTruncatedFromTailCount(searchResults.getResultsSize() - to);</p>
<dl class="simple">
<dt>if (to &gt; 0) {</dt><dd><p>searchResults.setResults(searchResults.getResults().subList(0, to));</p>
</dd>
<dt>} else {</dt><dd><p>// No more results for the next page
EARLYBIRD_RESPONSE_NO_MORE_RESULTS.increment();
searchResults.setResults(Collections.&lt;ThriftSearchResult&gt;emptyList());</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>EarlybirdRequest getEarlybirdRequest() {</dt><dd><p>return requestContext.getRequest();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../_sources/src/java/com/twitter/search/earlybird_root/mergers/EarlybirdResponseMerger.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>