<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../" id="documentation_options" src="../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.ingester.pipeline.twitter;</p>
<p>import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;</p>
<p>import javax.naming.NamingException;</p>
<p>import com.google.common.base.Preconditions;
import com.google.common.collect.Maps;</p>
<p>import org.apache.commons.lang.StringUtils;
import org.apache.commons.pipeline.StageException;
import org.apache.commons.pipeline.stage.InstrumentedBaseStage;</p>
<p>import com.twitter.common.metrics.Metrics;
import com.twitter.common.util.Clock;
import com.twitter.decider.Decider;
import com.twitter.search.common.debug.DebugEventAccumulator;
import com.twitter.search.common.debug.DebugEventUtil;
import com.twitter.search.common.decider.DeciderUtil;
import com.twitter.search.common.metrics.Percentile;
import com.twitter.search.common.metrics.PercentileUtil;
import com.twitter.search.common.metrics.SearchCounter;
import com.twitter.search.common.metrics.SearchCustomGauge;
import com.twitter.search.common.metrics.SearchLongGauge;
import com.twitter.search.common.metrics.SearchRateCounter;
import com.twitter.search.common.metrics.SearchTimerStats;
import com.twitter.search.common.schema.earlybird.EarlybirdCluster;
import com.twitter.search.ingester.pipeline.util.PipelineStageException;
import com.twitter.search.ingester.pipeline.util.PipelineStageRuntimeException;
import com.twitter.search.ingester.pipeline.wire.WireModule;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Common functionality for all stages.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public class TwitterBaseStage&lt;T, R&gt; extends InstrumentedBaseStage {</dt><dd><p>// Currently, all stages run in separate threads, so we could use simple maps here.
// However, it seems safer to use concurrent maps, in case we ever change our stage set up.
// The performance impact should be negligible.
private final ConcurrentMap&lt;Optional&lt;String&gt;, SearchRateCounter&gt; branchEmitObjectsRateCounters =</p>
<blockquote>
<div><p>Maps.newConcurrentMap();</p>
</div></blockquote>
<dl class="simple">
<dt>private final ConcurrentMap&lt;Optional&lt;String&gt;, SearchRateCounter&gt;</dt><dd><p>branchEmitBatchObjectsRateCounters = Maps.newConcurrentMap();</p>
</dd>
</dl>
<p>private String stageNamePrefix = null;</p>
<p>protected WireModule wireModule;
protected Decider decider;
protected Clock clock;
protected EarlybirdCluster earlybirdCluster;</p>
<p>private String fullStageName = null;
private Percentile&lt;Long&gt; processPercentile = null;
private SearchTimerStats processTimerStats = null;
private SearchRateCounter droppedItems = null;
private SearchLongGauge stageExceptions = null;</p>
<p>private SearchRateCounter incomingBatchesRateCounter;
private SearchRateCounter incomingBatchObjectsRateCounter;</p>
<p>private List&lt;String&gt; passThroughToBranches = Collections.emptyList();
private List&lt;String&gt; additionalEmitToBranches = Collections.emptyList();</p>
<p>private boolean passThroughDownstream = false;
private boolean emitDownstream = true;</p>
<p>private String dropItemsDeciderKey;</p>
<p>// From XML config.
public void setPassThroughToBranches(String passThroughToBranchesString) {</p>
<blockquote>
<div><p>// This is a comma-delimited string which is a list of branches to which we just
// pass through the incoming object without any processing/filtering.
this.passThroughToBranches = Arrays.asList(passThroughToBranchesString.split(“,”));</p>
</div></blockquote>
<p>}</p>
<p>// From XML config.
public void setAdditionalEmitToBranches(String emitToBranchesString) {</p>
<blockquote>
<div><p>// This is a comma-delimited string which is a list of branches to which we
// will emit when we call actuallyEmitAndCount(obj).
this.additionalEmitToBranches = Arrays.asList(emitToBranchesString.split(“,”));</p>
</div></blockquote>
<p>}</p>
<p>// From XML config.
public void setPassThroughDownstream(boolean passThroughDownstream) {</p>
<blockquote>
<div><p>// If true, we emit the raw object downstream
this.passThroughDownstream = passThroughDownstream;</p>
</div></blockquote>
<p>}</p>
<p>// From XML config.
public void setEmitDownstream(boolean emitDownstream) {</p>
<blockquote>
<div><p>// If true, we emit the processed object downstream.
this.emitDownstream = emitDownstream;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public final void innerPreprocess() throws StageException {</p>
<blockquote>
<div><dl class="simple">
<dt>try {</dt><dd><p>setupEssentialObjects();
doInnerPreprocess();</p>
</dd>
<dt>} catch (NamingException e) {</dt><dd><p>throw new StageException(this, “Failed to initialize stage.”, e);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/<a href="#id3"><span class="problematic" id="id4">**</span></a><a href="#id5"><span class="problematic" id="id6">*</span></a></dt><dd><ul class="simple">
<li><p>Sets up all necessary objects for this stage of the Pipeline. Previously, this task was done</p></li>
<li><p>by the preprocess() method provided by the ACP library.</p></li>
<li><p>&#64;throws PipelineStageException</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>public void setupStageV2() throws PipelineStageException {</dt><dd><dl class="simple">
<dt>try {</dt><dd><p>setupCommonStats();
innerSetupStats();
setupEssentialObjects();
innerSetup();</p>
</dd>
<dt>} catch (NamingException e) {</dt><dd><p>throw new PipelineStageException(this, “Failed to initialize stage”, e);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>protected void innerSetup() throws PipelineStageException, NamingException { }</p>
<dl>
<dt>/<a href="#id9"><span class="problematic" id="id10">**</span></a><a href="#id11"><span class="problematic" id="id12">*</span></a></dt><dd><ul class="simple">
<li><p>Takes in an argument of type T, processes it and returns an argument of Type R. This is the</p></li>
<li><p>main method of a pipeline stage.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>public R runStageV2(T arg) {</dt><dd><p>long startingTime = startProcessing();
R processed = innerRunStageV2(arg);
endProcessing(startingTime);
return processed;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/<a href="#id15"><span class="problematic" id="id16">**</span></a><a href="#id17"><span class="problematic" id="id18">*</span></a></dt><dd><ul class="simple">
<li><p>Takes in an argument of type T, processes it and pushes the processed element to some place.</p></li>
<li><p>This method does not return anything as any time this method is called on a stage, it means</p></li>
<li><p>there is no stage after this one. An example stage is any KafkaProducerStage.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>public void runFinalStageOfBranchV2(T arg) {</dt><dd><p>long startingTime = startProcessing();
innerRunFinalStageOfBranchV2(arg);
endProcessing(startingTime);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>protected R innerRunStageV2(T arg) {</dt><dd><p>return null;</p>
</dd>
</dl>
<p>}</p>
<p>protected void innerRunFinalStageOfBranchV2(T arg) { }</p>
<dl>
<dt>/<a href="#id21"><span class="problematic" id="id22">**</span></a><a href="#id23"><span class="problematic" id="id24">*</span></a></dt><dd><ul class="simple">
<li><p>called at the end of a pipeline. Cleans up all resources of the stage.</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
</dl>
<p>public void cleanupStageV2() { }</p>
<dl>
<dt>private void setupEssentialObjects() throws NamingException {</dt><dd><p>wireModule = WireModule.getWireModule();
decider = wireModule.getDecider();
clock = wireModule.getClock();
earlybirdCluster = wireModule.getEarlybirdCluster();
dropItemsDeciderKey =</p>
<blockquote>
<div><p>“<a href="#id27"><span class="problematic" id="id28">drop_items_</span></a>” + earlybirdCluster.getNameForStats() + “_” + fullStageName;</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<p>protected void doInnerPreprocess() throws StageException, NamingException { }</p>
<p>&#64;Override
protected void initStats() {</p>
<blockquote>
<div><p>super.initStats();
setupCommonStats();
// Export stage timers
SearchCustomGauge.export(stageNamePrefix + “_queue_size”,</p>
<blockquote>
<div><p>() -&gt; Optional.ofNullable(getQueueSizeAverage()).orElse(0.0));</p>
</div></blockquote>
<dl class="simple">
<dt>SearchCustomGauge.export(stageNamePrefix + “_queue_percentage_full”,</dt><dd><p>() -&gt; Optional.ofNullable(getQueuePercentFull()).orElse(0.0));</p>
</dd>
</dl>
<p>// This only called once on startup
// In some unit tests, getQueueCapacity can return null. Hence this guard is added.
// getQueueCapacity() does not return null here in prod.
SearchLongGauge.export(stageNamePrefix + “_queue_capacity”)</p>
<blockquote>
<div><p>.set(getQueueCapacity() == null ? 0 : getQueueCapacity());</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
<dl>
<dt>private void setupCommonStats() {</dt><dd><p>// If the stage is instantiated only once, the class name is used for stats export
// If the stage is instantiated multiple times, the “stageName” specified in the
// pipeline definition xml file is also included.
if (StringUtils.isBlank(this.getStageName())) {</p>
<blockquote>
<div><p>fullStageName = this.getClass().getSimpleName();</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><dl class="simple">
<dt>fullStageName = String.format(</dt><dd><p>“%s_%s”,
this.getClass().getSimpleName(),
this.getStageName());</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>stageNamePrefix = Metrics.normalizeName(fullStageName).toLowerCase();</p>
<p>droppedItems = SearchRateCounter.export(stageNamePrefix + “_dropped_messages”);
stageExceptions = SearchLongGauge.export(stageNamePrefix + “_stage_exceptions”);</p>
<dl class="simple">
<dt>processTimerStats = SearchTimerStats.export(stageNamePrefix, TimeUnit.NANOSECONDS,</dt><dd><p>true);</p>
</dd>
</dl>
<p>processPercentile = PercentileUtil.createPercentile(stageNamePrefix);</p>
<p>incomingBatchesRateCounter = SearchRateCounter.export(stageNamePrefix + “_incoming_batches”);
incomingBatchObjectsRateCounter =</p>
<blockquote>
<div><p>SearchRateCounter.export(stageNamePrefix + “_incoming_batch_objects”);</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<p>protected void innerSetupStats() {</p>
<p>}</p>
<dl class="simple">
<dt>protected SearchCounter makeStageCounter(String counterName) {</dt><dd><p>return SearchCounter.export(getStageNamePrefix() + “_” + counterName);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private SearchRateCounter getEmitObjectsRateCounterFor(Optional&lt;String&gt; maybeBranch) {</dt><dd><p>return getRateCounterFor(maybeBranch, “emit_objects”, branchEmitObjectsRateCounters);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private SearchRateCounter getEmitBatchObjectsRateCounterFor(Optional&lt;String&gt; maybeBranch) {</dt><dd><p>return getRateCounterFor(maybeBranch, “emit_batch_objects”, branchEmitBatchObjectsRateCounters);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private SearchRateCounter getRateCounterFor(</dt><dd><blockquote>
<div><p>Optional&lt;String&gt; maybeBranch,
String statSuffix,
ConcurrentMap&lt;Optional&lt;String&gt;, SearchRateCounter&gt; rateCountersMap) {</p>
</div></blockquote>
<p>SearchRateCounter rateCounter = rateCountersMap.get(maybeBranch);
if (rateCounter == null) {</p>
<blockquote>
<div><p>String branchSuffix = maybeBranch.map(b -&gt; “_” + b.toLowerCase()).orElse(“”);
rateCounter = SearchRateCounter.export(stageNamePrefix + branchSuffix + “_” + statSuffix);
SearchRateCounter existingRateCounter = rateCountersMap.putIfAbsent(maybeBranch, rateCounter);
if (existingRateCounter != null) {</p>
<blockquote>
<div><dl class="simple">
<dt>Preconditions.checkState(</dt><dd><p>existingRateCounter == rateCounter,
“SearchRateCounter.export() should always return the same stat instance.”);</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
return rateCounter;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getStageNamePrefix() {</dt><dd><p>return stageNamePrefix;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getFullStageName() {</dt><dd><p>return fullStageName;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public void process(Object obj) throws StageException {</p>
<blockquote>
<div><p>long startTime = System.nanoTime();
try {</p>
<blockquote>
<div><p>// this needs to be updated before calling super.process() so that innerProcess can actually
// use the updated incoming rates
updateIncomingBatchStats(obj);
// Track timing events for when tweets enter each stage.
captureStageDebugEvents(obj);</p>
<dl class="simple">
<dt>if (DeciderUtil.isAvailableForRandomRecipient(decider, dropItemsDeciderKey)) {</dt><dd><p>droppedItems.increment();
return;</p>
</dd>
</dl>
<p>}</p>
<p>super.process(obj);</p>
<p>// Now emit the object raw to wherever we need to
emitToPassThroughBranches(obj);</p>
</div></blockquote>
<dl class="simple">
<dt>} finally {</dt><dd><p>long processTime = System.nanoTime() - startTime;
processTimerStats.timerIncrement(processTime);
processPercentile.record(processTime);
stageExceptions.set(stats.getExceptionCount());</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>protected long startProcessing() {</dt><dd><p>long startingTime = System.nanoTime();
checkIfObjectShouldBeEmittedOrThrowRuntimeException();
return startingTime;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>protected void endProcessing(long startingTime) {</dt><dd><p>long processTime = System.nanoTime() - startingTime;
processTimerStats.timerIncrement(processTime);
processPercentile.record(processTime);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void checkIfObjectShouldBeEmittedOrThrowRuntimeException() {</dt><dd><dl>
<dt>if (DeciderUtil.isAvailableForRandomRecipient(decider, dropItemsDeciderKey)) {</dt><dd><p>droppedItems.increment();
throw new PipelineStageRuntimeException(“Object does not have to be processed and passed”</p>
<blockquote>
<div><ul class="simple">
<li><p>“ to the next stage”);</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void emitToPassThroughBranches(Object obj) {</dt><dd><dl class="simple">
<dt>for (String branch<span class="classifier">passThroughToBranches) {</span></dt><dd><p>actuallyEmitAndCount(Optional.of(branch), obj);</p>
</dd>
</dl>
<p>}
if (passThroughDownstream) {</p>
<blockquote>
<div><p>actuallyEmitAndCount(Optional.empty(), obj);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private void updateIncomingBatchStats(Object obj) {</dt><dd><p>incomingBatchesRateCounter.increment();
incomingBatchObjectsRateCounter.increment(getBatchSizeForStats(obj));</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>protected void captureStageDebugEvents(Object obj) {</dt><dd><dl>
<dt>if (obj instanceof DebugEventAccumulator) {</dt><dd><dl class="simple">
<dt>DebugEventUtil.addDebugEvent(</dt><dd><p>(DebugEventAccumulator) obj, getFullStageName(), clock.nowMillis());</p>
</dd>
</dl>
</dd>
<dt>} else if (obj instanceof Collection) {</dt><dd><dl class="simple">
<dt>DebugEventUtil.addDebugEventToCollection(</dt><dd><p>(Collection&lt;?&gt;) obj, getFullStageName(), clock.nowMillis());</p>
</dd>
</dl>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>SearchCounter debugEventsNotSupportedCounter = SearchCounter.export(</dt><dd><p>stageNamePrefix + “_debug_events_not_supported_for_” + obj.getClass());</p>
</dd>
</dl>
<p>debugEventsNotSupportedCounter.increment();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>protected int getBatchSizeForStats(Object obj) {</dt><dd><p>return (obj instanceof Collection) ? ((Collection&lt;?&gt;) obj).size() : 1;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>protected void emitAndCount(Object obj) {</dt><dd><dl class="simple">
<dt>for (String branch<span class="classifier">additionalEmitToBranches) {</span></dt><dd><p>actuallyEmitAndCount(Optional.of(branch), obj);</p>
</dd>
</dl>
<p>}
if (emitDownstream) {</p>
<blockquote>
<div><p>actuallyEmitAndCount(Optional.empty(), obj);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>protected void emitToBranchAndCount(String branch, Object obj) {</dt><dd><p>actuallyEmitAndCount(Optional.of(branch), obj);</p>
</dd>
</dl>
<p>}</p>
<p>// If the branch is none, emit downstream
private void actuallyEmitAndCount(Optional&lt;String&gt; maybeBranch, Object obj) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (maybeBranch.isPresent()) {</dt><dd><p>emit(maybeBranch.get(), obj);</p>
</dd>
<dt>} else {</dt><dd><p>emit(obj);</p>
</dd>
</dl>
<p>}
getEmitObjectsRateCounterFor(maybeBranch).increment();
getEmitBatchObjectsRateCounterFor(maybeBranch).increment(getBatchSizeForStats(obj));</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../_sources/src/java/com/twitter/search/ingester/pipeline/twitter/TwitterBaseStage.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>