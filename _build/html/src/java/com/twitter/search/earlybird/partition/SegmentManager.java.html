<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../" id="documentation_options" src="../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.earlybird.partition;</p>
<p>import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.concurrent.ConcurrentSkipListMap;
import java.util.stream.Collectors;
import javax.annotation.Nullable;</p>
<p>import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.base.Predicate;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;</p>
<p>import org.slf4j.Logger;
import org.slf4j.LoggerFactory;</p>
<p>import com.twitter.common.util.Clock;
import com.twitter.search.common.metrics.SearchCounter;
import com.twitter.search.common.metrics.SearchLongGauge;
import com.twitter.search.common.metrics.SearchStatsReceiver;
import com.twitter.search.common.partitioning.base.Segment;
import com.twitter.search.common.partitioning.base.TimeSlice;
import com.twitter.search.common.partitioning.snowflakeparser.SnowflakeIdParser;
import com.twitter.search.common.schema.base.ImmutableSchemaInterface;
import com.twitter.search.earlybird.EarlybirdIndexConfig;
import com.twitter.search.earlybird.common.CaughtUpMonitor;
import com.twitter.search.earlybird.common.userupdates.UserScrubGeoMap;
import com.twitter.search.earlybird.common.userupdates.UserUpdate;
import com.twitter.search.earlybird.common.userupdates.UserUpdatesChecker;
import com.twitter.search.earlybird.common.userupdates.UserTable;
import com.twitter.search.earlybird.exception.CriticalExceptionHandler;
import com.twitter.search.earlybird.index.EarlybirdSegmentFactory;
import com.twitter.search.earlybird.index.EarlybirdSingleSegmentSearcher;
import com.twitter.search.earlybird.search.EarlybirdLuceneSearcher;
import com.twitter.search.earlybird.search.EarlybirdMultiSegmentSearcher;
import com.twitter.search.earlybird.stats.EarlybirdSearcherStats;
import com.twitter.search.earlybird.thrift.EarlybirdResponseCode;
import com.twitter.tweetypie.thriftjava.UserScrubGeoEvent;</p>
<dl>
<dt>public class SegmentManager {</dt><dd><p>private static final Logger LOG = LoggerFactory.getLogger(SegmentManager.class);
private final Clock clock;
private static final String STATS_PREFIX = “<a href="#id63"><span class="problematic" id="id64">segment_manager_</span></a>”;
private static final SearchLongGauge SEGMENT_COUNT_STATS =</p>
<blockquote>
<div><p>SearchLongGauge.export(STATS_PREFIX + “total_segments”);</p>
</div></blockquote>
<dl>
<dt>private static final SearchCounter OPTIMIZED_SEGMENTS =</dt><dd><p>SearchCounter.export(STATS_PREFIX + “optimized_segments”);</p>
</dd>
<dt>private static final SearchCounter UNOPTIMIZED_SEGMENTS =</dt><dd><p>SearchCounter.export(STATS_PREFIX + “unoptimized_segments”);</p>
</dd>
<dt>public enum Filter {</dt><dd><p>All(info -&gt; true),
Enabled(SegmentInfo::isEnabled),
NeedsIndexing(SegmentInfo::needsIndexing),
Complete(SegmentInfo::isComplete);</p>
<p>private final Predicate&lt;SegmentInfo&gt; predicate;</p>
<dl class="simple">
<dt>Filter(Predicate&lt;SegmentInfo&gt; predicate) {</dt><dd><p>this.predicate = predicate;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private static final Map&lt;String, Filter&gt; NAME_INDEX =</dt><dd><p>Maps.newHashMapWithExpectedSize(Filter.values().length);</p>
</dd>
<dt>static {</dt><dd><dl class="simple">
<dt>for (Filter filter<span class="classifier">Filter.values()) {</span></dt><dd><p>NAME_INDEX.put(filter.name().toLowerCase(), filter);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Parses the filter from the given string, based on the filter name.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public static Filter fromStringIgnoreCase(String str) {</dt><dd><dl class="simple">
<dt>if (str == null) {</dt><dd><p>return null;</p>
</dd>
</dl>
<p>}</p>
<p>return NAME_INDEX.get(str.toLowerCase());</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public enum Order {</dt><dd><p>OLD_TO_NEW,
NEW_TO_OLD,</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A listener that gets notified when the list of segments changes.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>public interface SegmentUpdateListener {</dt><dd><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Called with the new list of segments when it changes.</p></li>
<li></li>
<li><p>&#64;param segments The new list of segments.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
</dl>
<p>void update(Collection&lt;SegmentInfo&gt; segments, String message);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private final List&lt;SegmentUpdateListener&gt; updateListeners =</dt><dd><p>Collections.synchronizedList(Lists.newLinkedList());</p>
</dd>
<dt>private final ConcurrentSkipListMap&lt;Long, ISegmentWriter&gt; segmentWriters =</dt><dd><p>new ConcurrentSkipListMap&lt;&gt;();</p>
</dd>
</dl>
<p>private final Set&lt;Long&gt; badTimesliceIds = new HashSet&lt;&gt;();</p>
<p>private final int maxEnabledSegments;
private final int maxSegmentSize;
private final EarlybirdSegmentFactory earlybirdSegmentFactory;
private final UserTable userTable;
private final UserScrubGeoMap userScrubGeoMap;
private final EarlybirdIndexConfig earlybirdIndexConfig;
private final DynamicPartitionConfig dynamicPartitionConfig;
private final UserUpdatesChecker userUpdatesChecker;
private final SegmentSyncConfig segmentSyncConfig;
private final EarlybirdSearcherStats searcherStats;
private final SearchIndexingMetricSet searchIndexingMetricSet;
private final CriticalExceptionHandler criticalExceptionHandler;
private final CaughtUpMonitor indexCaughtUpMonitor;</p>
<dl>
<dt>public SegmentManager(</dt><dd><blockquote>
<div><p>DynamicPartitionConfig dynamicPartitionConfig,
EarlybirdIndexConfig earlybirdIndexConfig,
SearchIndexingMetricSet searchIndexingMetricSet,
EarlybirdSearcherStats searcherStats,
SearchStatsReceiver earlybirdStatsReceiver,
UserUpdatesChecker userUpdatesChecker,
SegmentSyncConfig segmentSyncConfig,
UserTable userTable,
UserScrubGeoMap userScrubGeoMap,
Clock clock,
int maxSegmentSize,
CriticalExceptionHandler criticalExceptionHandler,
CaughtUpMonitor indexCaughtUpMonitor) {</p>
</div></blockquote>
<p>PartitionConfig curPartitionConfig = dynamicPartitionConfig.getCurrentPartitionConfig();</p>
<p>this.userTable = userTable;
this.userScrubGeoMap = userScrubGeoMap;</p>
<dl class="simple">
<dt>this.earlybirdSegmentFactory = new EarlybirdSegmentFactory(</dt><dd><p>earlybirdIndexConfig,
searchIndexingMetricSet,
searcherStats,
clock);</p>
</dd>
</dl>
<p>this.earlybirdIndexConfig = earlybirdIndexConfig;
this.maxEnabledSegments = curPartitionConfig.getMaxEnabledLocalSegments();
this.dynamicPartitionConfig = dynamicPartitionConfig;
this.userUpdatesChecker = userUpdatesChecker;
this.segmentSyncConfig = segmentSyncConfig;
this.searchIndexingMetricSet = searchIndexingMetricSet;
this.searcherStats = searcherStats;
this.clock = clock;
this.maxSegmentSize = maxSegmentSize;
this.criticalExceptionHandler = criticalExceptionHandler;
this.indexCaughtUpMonitor = indexCaughtUpMonitor;</p>
<dl class="simple">
<dt>earlybirdStatsReceiver.getCustomGauge(“total_loaded_segments”,</dt><dd><p>segmentWriters::size);</p>
</dd>
<dt>earlybirdStatsReceiver.getCustomGauge(“total_indexed_documents”,</dt><dd><p>this::getNumIndexedDocuments);</p>
</dd>
<dt>earlybirdStatsReceiver.getCustomGauge(“total_segment_size_bytes”,</dt><dd><p>this::getTotalSegmentSizeOnDisk);</p>
</dd>
<dt>earlybirdStatsReceiver.getCustomGauge(“earlybird_index_depth_millis”,</dt><dd><p>this::getIndexDepthMillis);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Logs the current state of this segment manager.</p></li>
<li></li>
<li><p>&#64;param label A label that should identify the segment manager.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>public void logState(String label) {</dt><dd><p>StringBuilder sb = new StringBuilder();
sb.append(“State of SegmentManager (” + label + “):n”);
sb.append(“Number of segments: “ + segmentWriters.size());
boolean hasSegments = false;
for (Map.Entry&lt;Long, ISegmentWriter&gt; entry : this.segmentWriters.entrySet()) {</p>
<blockquote>
<div><p>SegmentInfo segmentInfo = entry.getValue().getSegmentInfo();
hasSegments = true;</p>
<dl>
<dt>sb.append(String.format(”nSegment (%s): isClosed: %5s, isComplete: %5s, “</dt><dd><blockquote>
<div><ul class="simple">
<li><p>“isEnabled: %5s, isIndexing: %5s, isOptimized: %5s, wasIndexed: %5s”,</p></li>
</ul>
</div></blockquote>
<p>segmentInfo.getSegmentName(),
segmentInfo.isClosed(),
segmentInfo.isComplete(),
segmentInfo.isEnabled(),
segmentInfo.isIndexing(),
segmentInfo.isOptimized(),
segmentInfo.wasIndexed()</p>
</dd>
</dl>
<p>));</p>
<p>sb.append(String.format(” | Index stats: %s”, segmentInfo.getIndexStats().toString()));</p>
</div></blockquote>
<p>}
if (!hasSegments) {</p>
<blockquote>
<div><p>sb.append(” No segments.”);</p>
</div></blockquote>
<p>}
LOG.info(sb.toString());</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public PartitionConfig getPartitionConfig() {</dt><dd><p>return dynamicPartitionConfig.getCurrentPartitionConfig();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public int getMaxEnabledSegments() {</dt><dd><p>return maxEnabledSegments;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public EarlybirdSegmentFactory getEarlybirdSegmentFactory() {</dt><dd><p>return earlybirdSegmentFactory;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public EarlybirdIndexConfig getEarlybirdIndexConfig() {</dt><dd><p>return earlybirdIndexConfig;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public UserTable getUserTable() {</dt><dd><p>return userTable;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public UserScrubGeoMap getUserScrubGeoMap() {</dt><dd><p>return userScrubGeoMap;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;VisibleForTesting
public void reset() {</p>
<blockquote>
<div><p>segmentWriters.clear();</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the list of all segments that match the given filter, in the given order.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>public Iterable&lt;SegmentInfo&gt; getSegmentInfos(Filter filter, Order order) {</dt><dd><p>Comparator&lt;SegmentInfo&gt; comparator;</p>
<dl class="simple">
<dt>if (order == Order.OLD_TO_NEW) {</dt><dd><p>comparator = Comparator.naturalOrder();</p>
</dd>
<dt>} else {</dt><dd><p>comparator = Comparator.reverseOrder();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>return () -&gt; segmentWriters.values().stream()</dt><dd><p>.map(ISegmentWriter::getSegmentInfo)
.filter(filter.predicate::apply)
.sorted(comparator)
.iterator();</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private void createAndPutSegmentInfo(Segment segment) throws IOException {</dt><dd><p>LOG.info(“Creating new SegmentInfo for segment “ + segment.getSegmentName());
putSegmentInfo(new SegmentInfo(segment, earlybirdSegmentFactory, segmentSyncConfig));</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Updates the list of segments managed by this manager, based on the given list.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>public void updateSegments(List&lt;Segment&gt; segmentsList) throws IOException {</dt><dd><p>// Truncate to the amount of segments we want to keep enabled.
List&lt;Segment&gt; truncatedSegmentList =</p>
<blockquote>
<div><p>SegmentManager.truncateSegmentList(segmentsList, maxEnabledSegments);</p>
</div></blockquote>
<p>final long newestTimeSliceID = getNewestTimeSliceID();
final Set&lt;Long&gt; segmentsToDisable = new HashSet&lt;&gt;(segmentWriters.keySet());</p>
<dl>
<dt>for (Segment segment<span class="classifier">truncatedSegmentList) {</span></dt><dd><p>final long timeSliceID = segment.getTimeSliceID();
segmentsToDisable.remove(timeSliceID);</p>
<p>// On the first loop iteration of the first call to updateSegments(), newestTimeSliceID should
// be set to -1, so the condition should be false. After that, all segments should either be
// newer than the latest process segment, or if we’re replacing an old segment, it should have
// a SegmentInfo instance associated with it.
if (timeSliceID &lt;= newestTimeSliceID) {</p>
<blockquote>
<div><p>ISegmentWriter segmentWriter = segmentWriters.get(timeSliceID);
// Old time slice ID. It should have a SegmentInfo instance associated with it.
if (segmentWriter == null) {</p>
<blockquote>
<div><dl>
<dt>if (!badTimesliceIds.contains(timeSliceID)) {</dt><dd><p>// We’re dealing with a bad timeslice. Log an error, but do it only once per timeslice.
LOG.error(“The SegmentInfo instance associated with an old timeSliceID should never be “</p>
<blockquote>
<div><ul class="simple">
<li><p>“null. TimeSliceID: {}”, timeSliceID);</p></li>
</ul>
</div></blockquote>
<p>badTimesliceIds.add(timeSliceID);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else if (segmentWriter.getSegmentInfo().isClosed()) {</dt><dd><p>// If the SegmentInfo was closed, create a new one.
LOG.info(“SegmentInfo for segment {} is closed.”, segment.getSegmentName());
createAndPutSegmentInfo(segment);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>// New time slice ID: create a SegmentInfo instance for it.
createAndPutSegmentInfo(segment);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// Anything we didn’t see locally can be disabled.
for (Long segmentID : segmentsToDisable) {</p>
<blockquote>
<div><p>disableSegment(segmentID);</p>
</div></blockquote>
<p>}</p>
<p>// Update segment stats and other exported variables.
updateStats();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Re-export stats after a segment has changed, or the set of segments has changed.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>public void updateStats() {</dt><dd><p>// Update the partition count stats.
SEGMENT_COUNT_STATS.set(segmentWriters.size());</p>
<p>OPTIMIZED_SEGMENTS.reset();
UNOPTIMIZED_SEGMENTS.reset();
for (ISegmentWriter writer : segmentWriters.values()) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (writer.getSegmentInfo().isOptimized()) {</dt><dd><p>OPTIMIZED_SEGMENTS.increment();</p>
</dd>
<dt>} else {</dt><dd><p>UNOPTIMIZED_SEGMENTS.increment();</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private long getIndexDepthMillis() {</dt><dd><p>long oldestTimeSliceID = getOldestEnabledTimeSliceID();
if (oldestTimeSliceID == SegmentInfo.INVALID_ID) {</p>
<blockquote>
<div><p>return 0;</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>// Compute timestamp from timesliceId, which is also a snowflake tweetId
long timestamp = SnowflakeIdParser.getTimestampFromTweetId(oldestTimeSliceID);
// Set current index depth in milliseconds
long indexDepthInMillis = System.currentTimeMillis() - timestamp;
// Index depth should never be negative.
if (indexDepthInMillis &lt; 0) {</p>
<blockquote>
<div><p>LOG.warn(“Negative index depth. Large time skew on this Earlybird?”);
return 0;</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>return indexDepthInMillis;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void updateExportedSegmentStats() {</dt><dd><p>int index = 0;
for (SegmentInfo segmentInfo : getSegmentInfos(Filter.Enabled, Order.NEW_TO_OLD)) {</p>
<blockquote>
<div><p>SegmentIndexStatsExporter.export(segmentInfo, index++);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// Marks the SegmentInfo object matching this time slice as disabled.
private void disableSegment(long timeSliceID) {</p>
<blockquote>
<div><p>SegmentInfo info = getSegmentInfo(timeSliceID);
if (info == null) {</p>
<blockquote>
<div><p>LOG.warn(“Tried to disable missing segment “ + timeSliceID);
return;</p>
</div></blockquote>
<p>}
info.setIsEnabled(false);
LOG.info(“Disabled segment “ + info);</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>public long getNewestTimeSliceID() {</dt><dd><p>final Iterator&lt;SegmentInfo&gt; segments = getSegmentInfos(Filter.All, Order.NEW_TO_OLD).iterator();
return segments.hasNext() ? segments.next().getTimeSliceID() : SegmentInfo.INVALID_ID;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the timeslice ID of the oldest enabled segment.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>public long getOldestEnabledTimeSliceID() {</dt><dd><dl class="simple">
<dt>if (segmentWriters.size() == 0) {</dt><dd><p>return SegmentInfo.INVALID_ID;</p>
</dd>
</dl>
<p>}
ISegmentWriter segmentWriter = segmentWriters.firstEntry().getValue();
return segmentWriter.getSegmentInfo().getTimeSliceID();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the SegmentInfo for the given timeSliceID.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>public final SegmentInfo getSegmentInfo(long timeSliceID) {</dt><dd><p>ISegmentWriter segmentWriter = segmentWriters.get(timeSliceID);
return segmentWriter == null ? null : segmentWriter.getSegmentInfo();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the segment info for the segment that should contain the given tweet ID.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>public final SegmentInfo getSegmentInfoFromStatusID(long tweetID) {</dt><dd><dl>
<dt>for (SegmentInfo segmentInfo<span class="classifier">getSegmentInfos(Filter.All, Order.NEW_TO_OLD)) {</span></dt><dd><dl class="simple">
<dt>if (tweetID &gt;= segmentInfo.getTimeSliceID()) {</dt><dd><p>return segmentInfo;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>return null;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Removes the segment associated with the given timeslice ID from the segment manager. This will</p></li>
<li><p>also take care of all required clean up related to the segment being removed, such as closing</p></li>
<li><p>its writer.</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
<dt>public boolean removeSegmentInfo(long timeSliceID) {</dt><dd><dl class="simple">
<dt>if (timeSliceID == getNewestTimeSliceID()) {</dt><dd><p>throw new RuntimeException(“Cannot drop segment of current time-slice “ + timeSliceID);</p>
</dd>
</dl>
<p>}</p>
<p>ISegmentWriter removed = segmentWriters.get(timeSliceID);
if (removed == null) {</p>
<blockquote>
<div><p>return false;</p>
</div></blockquote>
<p>}</p>
<p>LOG.info(“Removing segment {}”, removed.getSegmentInfo());
Preconditions.checkState(!removed.getSegmentInfo().isEnabled());
removed.getSegmentInfo().getIndexSegment().close();
segmentWriters.remove(timeSliceID);</p>
<p>String segmentName = removed.getSegmentInfo().getSegmentName();
updateAllListeners(“Removed segment “ + segmentName);
LOG.info(“Removed segment “ + segmentName);
updateExportedSegmentStats();
updateStats();
return true;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Add the given SegmentWriter into the segmentWriters map.</p></li>
<li><p>If a segment with the same timesliceID already exists in the map, the old one is replaced</p></li>
<li><p>with the new one; this should only happen in the archive.</p></li>
<li></li>
<li><p>The replaced segment is destroyed after a delay to allow in-flight requests to finish.</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>public ISegmentWriter putSegmentInfo(SegmentInfo info) {</dt><dd><p>ISegmentWriter usedSegmentWriter;</p>
<dl class="simple">
<dt>SegmentWriter segmentWriter</dt><dd><p>= new SegmentWriter(info, searchIndexingMetricSet.updateFreshness);</p>
</dd>
<dt>if (!info.isOptimized()) {</dt><dd><dl class="simple">
<dt>LOG.info(“Inserting an optimizing segment writer for segment: {}”,</dt><dd><p>info.getSegmentName());</p>
</dd>
<dt>usedSegmentWriter = new OptimizingSegmentWriter(</dt><dd><p>segmentWriter,
criticalExceptionHandler,
searchIndexingMetricSet,
indexCaughtUpMonitor);</p>
</dd>
</dl>
</dd>
<dt>} else {</dt><dd><p>usedSegmentWriter = segmentWriter;</p>
</dd>
</dl>
<p>}</p>
<p>putSegmentWriter(usedSegmentWriter);
return usedSegmentWriter;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void putSegmentWriter(ISegmentWriter segmentWriter) {</dt><dd><p>SegmentInfo newSegmentInfo = segmentWriter.getSegmentInfo();
SegmentInfo oldSegmentInfo = getSegmentInfo(newSegmentInfo.getTimeSliceID());</p>
<p>// Some sanity checks.
if (oldSegmentInfo != null) {</p>
<blockquote>
<div><p>// This map is thread safe, so this put can be considered atomic.
segmentWriters.put(newSegmentInfo.getTimeSliceID(), segmentWriter);
LOG.info(“Replaced SegmentInfo with a new one in segmentWriters map. “</p>
<blockquote>
<div><ul class="simple">
<li><p>“Old SegmentInfo: {} New SegmentInfo: {}”, oldSegmentInfo, newSegmentInfo);</p></li>
</ul>
</div></blockquote>
<dl class="simple">
<dt>if (!oldSegmentInfo.isClosed()) {</dt><dd><p>oldSegmentInfo.deleteIndexSegmentDirectoryAfterDelay();</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>long newestTimeSliceID = getNewestTimeSliceID();
if (newestTimeSliceID != SegmentInfo.INVALID_ID</p>
<blockquote>
<div><blockquote>
<div><p>&amp;&amp; newestTimeSliceID &gt; newSegmentInfo.getTimeSliceID()) {</p>
</div></blockquote>
<p>LOG.error(“Not adding out-of-order segment “ + newSegmentInfo);
return;</p>
</div></blockquote>
<p>}</p>
<p>segmentWriters.put(newSegmentInfo.getTimeSliceID(), segmentWriter);
LOG.info(“Added segment “ + newSegmentInfo);</p>
</dd>
</dl>
<p>}</p>
<p>updateAllListeners(“Added segment “ + newSegmentInfo.getTimeSliceID());
updateExportedSegmentStats();
updateStats();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private SegmentInfo createSegmentInfo(long timesliceID) throws IOException {</dt><dd><p>PartitionConfig partitionConfig = dynamicPartitionConfig.getCurrentPartitionConfig();</p>
<dl class="simple">
<dt>TimeSlice timeSlice = new TimeSlice(</dt><dd><p>timesliceID,
maxSegmentSize,
partitionConfig.getIndexingHashPartitionID(),
partitionConfig.getNumPartitions());</p>
</dd>
<dt>SegmentInfo segmentInfo =</dt><dd><p>new SegmentInfo(timeSlice.getSegment(), earlybirdSegmentFactory, segmentSyncConfig);</p>
</dd>
</dl>
<p>return segmentInfo;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Create a new optimizing segment writer and add it to the map.</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
<dt>public OptimizingSegmentWriter createAndPutOptimizingSegmentWriter(</dt><dd><blockquote>
<div><p>long timesliceID) throws IOException {</p>
</div></blockquote>
<p>SegmentInfo segmentInfo = createSegmentInfo(timesliceID);</p>
<dl class="simple">
<dt>OptimizingSegmentWriter writer = new OptimizingSegmentWriter(</dt><dd><p>new SegmentWriter(segmentInfo, searchIndexingMetricSet.updateFreshness),
criticalExceptionHandler,
searchIndexingMetricSet,
indexCaughtUpMonitor);</p>
</dd>
</dl>
<p>putSegmentWriter(writer);
return writer;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Create a new segment writer.</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
<dt>public SegmentWriter createSegmentWriter(long timesliceID) throws IOException {</dt><dd><p>SegmentInfo segmentInfo = createSegmentInfo(timesliceID);</p>
<dl class="simple">
<dt>SegmentWriter writer = new SegmentWriter(</dt><dd><p>segmentInfo, searchIndexingMetricSet.updateFreshness);</p>
</dd>
</dl>
<p>return writer;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void updateAllListeners(String message) {</dt><dd><dl>
<dt>List&lt;SegmentInfo&gt; segmentInfos = segmentWriters.values().stream()</dt><dd><p>.map(ISegmentWriter::getSegmentInfo)
.collect(Collectors.toList());</p>
</dd>
<dt>for (SegmentUpdateListener listener<span class="classifier">updateListeners) {</span></dt><dd><dl class="simple">
<dt>try {</dt><dd><p>listener.update(segmentInfos, message);</p>
</dd>
<dt>} catch (Exception e) {</dt><dd><p>LOG.warn(“SegmentManager: Unable to call update() on listener.”, e);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// Returns true if the map contains a SegmentInfo matching the given time slice.
public final boolean hasSegmentInfo(long timeSliceID) {</p>
<blockquote>
<div><p>return segmentWriters.containsKey(timeSliceID);</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>public void addUpdateListener(SegmentUpdateListener listener) {</dt><dd><p>updateListeners.add(listener);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Look up the segment containing the given status id.</p></li>
<li><p>If found, its timeslice id is returned.</p></li>
<li><p>If none found, -1 is returned.</p></li>
</ul>
<p><a href="#id29"><span class="problematic" id="id30">*</span></a>/</p>
</dd>
<dt>public long lookupTimeSliceID(long statusID) throws IOException {</dt><dd><p>SegmentInfo segmentInfo = getSegmentInfoForID(statusID);
if (segmentInfo == null) {</p>
<blockquote>
<div><p>return -1;</p>
</div></blockquote>
<p>}
if (!segmentInfo.getIndexSegment().hasDocument(statusID)) {</p>
<blockquote>
<div><p>return -1;</p>
</div></blockquote>
<p>}</p>
<p>return segmentInfo.getTimeSliceID();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Truncates the given segment list to the specified number of segments, by keeping the newest</p></li>
<li><p>segments.</p></li>
</ul>
<p><a href="#id31"><span class="problematic" id="id32">*</span></a>/</p>
</dd>
</dl>
<p>&#64;VisibleForTesting
public static List&lt;Segment&gt; truncateSegmentList(List&lt;Segment&gt; segmentList, int maxNumSegments) {</p>
<blockquote>
<div><p>// Maybe cut-off the beginning of the sorted list of IDs.
if (maxNumSegments &gt; 0 &amp;&amp; maxNumSegments &lt; segmentList.size()) {</p>
<blockquote>
<div><p>return segmentList.subList(segmentList.size() - maxNumSegments, segmentList.size());</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>return segmentList;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>&#64;VisibleForTesting
public void setOffensive(long userID, boolean offensive) {</p>
<blockquote>
<div><p>userTable.setOffensive(userID, offensive);</p>
</div></blockquote>
<p>}</p>
<p>&#64;VisibleForTesting
public void setAntisocial(long userID, boolean antisocial) {</p>
<blockquote>
<div><p>userTable.setAntisocial(userID, antisocial);</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns a searcher for all segments.</p></li>
</ul>
<p><a href="#id33"><span class="problematic" id="id34">*</span></a>/</p>
</dd>
<dt>public EarlybirdMultiSegmentSearcher getMultiSearcher(ImmutableSchemaInterface schemaSnapshot)</dt><dd><blockquote>
<div><p>throws IOException {</p>
</div></blockquote>
<dl class="simple">
<dt>return new EarlybirdMultiSegmentSearcher(</dt><dd><p>schemaSnapshot,
getSearchers(schemaSnapshot, Filter.All, Order.NEW_TO_OLD),
searcherStats,
clock);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns a new searcher for the given segment.</p></li>
</ul>
<p><a href="#id35"><span class="problematic" id="id36">*</span></a>/</p>
</dd>
</dl>
<p>&#64;Nullable
public EarlybirdLuceneSearcher getSearcher(</p>
<blockquote>
<div><blockquote>
<div><p>Segment segment,
ImmutableSchemaInterface schemaSnapshot) throws IOException {</p>
</div></blockquote>
<p>return getSearcher(segment.getTimeSliceID(), schemaSnapshot);</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Get max tweet id across all enabled segments.</p></li>
<li><p>&#64;return max tweet id or -1 if none found</p></li>
</ul>
<p><a href="#id37"><span class="problematic" id="id38">*</span></a>/</p>
</dd>
<dt>public long getMaxTweetIdFromEnabledSegments() {</dt><dd><dl>
<dt>for (SegmentInfo segmentInfo<span class="classifier">getSegmentInfos(Filter.Enabled, Order.NEW_TO_OLD)) {</span></dt><dd><p>long maxTweetId = segmentInfo.getIndexSegment().getMaxTweetId();
if (maxTweetId != -1) {</p>
<blockquote>
<div><p>return maxTweetId;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>return -1;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Create a tweet index searcher on the segment represented by the timeslice id.  For production</p></li>
<li><p>search session, the schema snapshot should be always passed in to make sure that the schema</p></li>
<li><p>usage inside scoring is consistent.</p></li>
<li></li>
<li><p>For non-production usage, like one-off debugging search, you can use the function call without</p></li>
<li><p>the schema snapshot.</p></li>
<li></li>
<li><p>&#64;param timeSliceID the timeslice id, which represents the index segment</p></li>
<li><p>&#64;param schemaSnapshot the schema snapshot</p></li>
<li><p>&#64;return the tweet index searcher</p></li>
</ul>
<p><a href="#id39"><span class="problematic" id="id40">*</span></a>/</p>
</dd>
</dl>
<p>&#64;Nullable
public EarlybirdSingleSegmentSearcher getSearcher(</p>
<blockquote>
<div><blockquote>
<div><p>long timeSliceID,
ImmutableSchemaInterface schemaSnapshot) throws IOException {</p>
</div></blockquote>
<p>SegmentInfo segmentInfo = getSegmentInfo(timeSliceID);
if (segmentInfo == null) {</p>
<blockquote>
<div><p>return null;</p>
</div></blockquote>
<p>}
return segmentInfo.getIndexSegment().getSearcher(userTable, schemaSnapshot);</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns a new searcher for the segment with the given timeslice ID. If the given timeslice ID</p></li>
<li><p>does not correspond to any active segment, <a class="reference external" href="mailto:{&#37;&#52;&#48;code">{<span>&#64;</span>code</a> null} is returned.</p></li>
<li></li>
<li><p>&#64;param timeSliceID The segment’s timeslice ID.</p></li>
<li><p>&#64;return A new searcher for the segment with the given timeslice ID.</p></li>
</ul>
<p><a href="#id41"><span class="problematic" id="id42">*</span></a>/</p>
</dd>
</dl>
<p>&#64;Nullable
public EarlybirdSingleSegmentSearcher getSearcher(long timeSliceID) throws IOException {</p>
<blockquote>
<div><p>SegmentInfo segmentInfo = getSegmentInfo(timeSliceID);
if (segmentInfo == null) {</p>
<blockquote>
<div><p>return null;</p>
</div></blockquote>
<p>}
return segmentInfo.getIndexSegment().getSearcher(userTable);</p>
</div></blockquote>
<p>}</p>
<p>&#64;Nullable
public EarlybirdResponseCode checkSegment(Segment segment) {</p>
<blockquote>
<div><p>return checkSegmentInternal(getSegmentInfo(segment.getTimeSliceID()));</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private static EarlybirdResponseCode checkSegmentInternal(SegmentInfo info) {</dt><dd><dl class="simple">
<dt>if (info == null) {</dt><dd><p>return EarlybirdResponseCode.PARTITION_NOT_FOUND;</p>
</dd>
<dt>} else if (info.isEnabled()) {</dt><dd><p>return EarlybirdResponseCode.SUCCESS;</p>
</dd>
<dt>} else {</dt><dd><p>return EarlybirdResponseCode.PARTITION_DISABLED;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private List&lt;EarlybirdSingleSegmentSearcher&gt; getSearchers(</dt><dd><blockquote>
<div><p>ImmutableSchemaInterface schemaSnapshot,
Filter filter,
Order order) throws IOException {</p>
</div></blockquote>
<p>List&lt;EarlybirdSingleSegmentSearcher&gt; searchers = Lists.newArrayList();
for (SegmentInfo segmentInfo : getSegmentInfos(filter, order)) {</p>
<blockquote>
<div><dl class="simple">
<dt>EarlybirdSingleSegmentSearcher searcher =</dt><dd><p>segmentInfo.getIndexSegment().getSearcher(userTable, schemaSnapshot);</p>
</dd>
<dt>if (searcher != null) {</dt><dd><p>searchers.add(searcher);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return searchers;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Gets metadata for segments for debugging purposes.</p></li>
</ul>
<p><a href="#id43"><span class="problematic" id="id44">*</span></a>/</p>
</dd>
<dt>public List&lt;String&gt; getSegmentMetadata() {</dt><dd><p>List&lt;String&gt; segmentMetadata = new ArrayList&lt;&gt;();
for (SegmentInfo segment : getSegmentInfos(Filter.All, Order.OLD_TO_NEW)) {</p>
<blockquote>
<div><p>segmentMetadata.add(segment.getSegmentMetadata());</p>
</div></blockquote>
<p>}
return segmentMetadata;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Gets info for query caches to be displayed in an admin page.</p></li>
</ul>
<p><a href="#id45"><span class="problematic" id="id46">*</span></a>/</p>
</dd>
<dt>public String getQueryCachesData() {</dt><dd><p>StringBuilder output = new StringBuilder();
for (SegmentInfo segment : getSegmentInfos(Filter.All, Order.OLD_TO_NEW)) {</p>
<blockquote>
<div><p>output.append(segment.getQueryCachesData() + “n”);</p>
</div></blockquote>
<p>}
return output.toString();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Index the given user update. Returns false if the given update is skipped.</p></li>
</ul>
<p><a href="#id47"><span class="problematic" id="id48">*</span></a>/</p>
</dd>
<dt>public boolean indexUserUpdate(UserUpdate userUpdate) {</dt><dd><p>return userTable.indexUserUpdate(userUpdatesChecker, userUpdate);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Index the given UserScrubGeoEvent.</p></li>
<li><p>&#64;param userScrubGeoEvent</p></li>
</ul>
<p><a href="#id49"><span class="problematic" id="id50">*</span></a>/</p>
</dd>
<dt>public void indexUserScrubGeoEvent(UserScrubGeoEvent userScrubGeoEvent) {</dt><dd><p>userScrubGeoMap.indexUserScrubGeoEvent(userScrubGeoEvent);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Return how many documents this segment manager has indexed in all of its enabled segments.</p></li>
</ul>
<p><a href="#id51"><span class="problematic" id="id52">*</span></a>/</p>
</dd>
<dt>public long getNumIndexedDocuments() {</dt><dd><p>// Order here doesn’t matter, we just want all enabled segments, and allocate
// as little as needed.
long indexedDocs = 0;
for (SegmentInfo segmentInfo : getSegmentInfos(Filter.Enabled, Order.OLD_TO_NEW)) {</p>
<blockquote>
<div><p>indexedDocs += segmentInfo.getIndexSegment().getIndexStats().getStatusCount();</p>
</div></blockquote>
<p>}
return indexedDocs;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Return how many partial updates this segment manager has applied</p></li>
<li><p>in all of its enabled segments.</p></li>
</ul>
<p><a href="#id53"><span class="problematic" id="id54">*</span></a>/</p>
</dd>
<dt>public long getNumPartialUpdates() {</dt><dd><p>long partialUpdates = 0;
for (SegmentInfo segmentInfo : getSegmentInfos(Filter.Enabled, Order.OLD_TO_NEW)) {</p>
<blockquote>
<div><p>partialUpdates += segmentInfo.getIndexSegment().getIndexStats().getPartialUpdateCount();</p>
</div></blockquote>
<p>}
return partialUpdates;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the segment info for the segment containing the given tweet ID.</p></li>
</ul>
<p><a href="#id55"><span class="problematic" id="id56">*</span></a>/</p>
</dd>
<dt>public SegmentInfo getSegmentInfoForID(long tweetID) {</dt><dd><p>ISegmentWriter segmentWriter = getSegmentWriterForID(tweetID);
return segmentWriter == null ? null : segmentWriter.getSegmentInfo();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the segment writer for the segment containing the given tweet ID.</p></li>
</ul>
<p><a href="#id57"><span class="problematic" id="id58">*</span></a>/</p>
</dd>
</dl>
<p>&#64;Nullable
public ISegmentWriter getSegmentWriterForID(long tweetID) {</p>
<blockquote>
<div><p>Map.Entry&lt;Long, ISegmentWriter&gt; entry = segmentWriters.floorEntry(tweetID);
return entry == null ? null : entry.getValue();</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Remove old segments until we have less than or equal to the number of max enabled segments.</p></li>
</ul>
<p><a href="#id59"><span class="problematic" id="id60">*</span></a>/</p>
</dd>
<dt>public void removeExcessSegments() {</dt><dd><p>int removedSegmentCount = 0;
while (segmentWriters.size() &gt; getMaxEnabledSegments()) {</p>
<blockquote>
<div><p>long timesliceID = getOldestEnabledTimeSliceID();
disableSegment(timesliceID);
removeSegmentInfo(timesliceID);
removedSegmentCount += 1;</p>
</div></blockquote>
<p>}
LOG.info(“Segment manager removed {} excess segments”, removedSegmentCount);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns total index size on disk across all enabled segments in this segment manager.</p></li>
</ul>
<p><a href="#id61"><span class="problematic" id="id62">*</span></a>/</p>
</dd>
<dt>private long getTotalSegmentSizeOnDisk() {</dt><dd><p>long totalIndexSize = 0;
for (SegmentInfo segmentInfo : getSegmentInfos(Filter.Enabled, Order.OLD_TO_NEW)) {</p>
<blockquote>
<div><p>totalIndexSize += segmentInfo.getIndexSegment().getIndexStats().getIndexSizeOnDiskInBytes();</p>
</div></blockquote>
<p>}
return totalIndexSize;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;VisibleForTesting
ISegmentWriter getSegmentWriterWithoutCreationForTests(long timesliceID) {</p>
<blockquote>
<div><p>return segmentWriters.get(timesliceID);</p>
</div></blockquote>
<p>}</p>
<p>&#64;VisibleForTesting
ArrayList&lt;Long&gt; getTimeSliceIdsForTests() {</p>
<blockquote>
<div><p>return new ArrayList&lt;Long&gt;(segmentWriters.keySet());</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../_sources/src/java/com/twitter/search/earlybird/partition/SegmentManager.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>