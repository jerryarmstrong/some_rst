<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../" id="documentation_options" src="../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.earlybird.search.facets;</p>
<p>import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;</p>
<p>import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;</p>
<p>import org.apache.commons.lang.StringUtils;
import org.apache.lucene.index.PostingsEnum;
import org.apache.lucene.index.Term;
import org.apache.lucene.index.Terms;
import org.apache.lucene.index.TermsEnum;
import org.apache.lucene.search.DocIdSetIterator;</p>
<p>import com.twitter.common.util.Clock;
import com.twitter.search.common.metrics.SearchCounter;
import com.twitter.search.common.metrics.SearchResultsStats;
import com.twitter.search.common.schema.SchemaUtil;
import com.twitter.search.common.schema.base.ImmutableSchemaInterface;
import com.twitter.search.common.schema.base.Schema;
import com.twitter.search.common.search.EarlyTerminationState;
import com.twitter.search.common.util.earlybird.TermStatisticsUtil;
import com.twitter.search.core.earlybird.index.TimeMapper;
import com.twitter.search.earlybird.index.EarlybirdSingleSegmentSearcher;
import com.twitter.search.earlybird.search.AbstractResultsCollector;
import com.twitter.search.earlybird.search.SearchResultsInfo;
import com.twitter.search.earlybird.stats.EarlybirdSearcherStats;
import com.twitter.search.earlybird.thrift.ThriftHistogramSettings;
import com.twitter.search.earlybird.thrift.ThriftTermRequest;
import com.twitter.search.earlybird.thrift.ThriftTermResults;</p>
<dl>
<dt>public class TermStatisticsCollector extends AbstractResultsCollector</dt><dd><blockquote>
<div><p>&lt;TermStatisticsRequestInfo, TermStatisticsCollector.TermStatisticsSearchResults&gt; {</p>
</div></blockquote>
<dl class="simple">
<dt>private static final EarlyTerminationState TERMINATED_TERM_STATS_COUNTING_DONE =</dt><dd><p>new EarlyTerminationState(“terminated_term_stats_counting_done”, true);</p>
</dd>
</dl>
<p>// Stats for tracking histogram results.
private static final SearchResultsStats TERM_STATS_HISTOGRAM_REQUESTS_WITH_MOVED_BACK_BINS =</p>
<blockquote>
<div><p>SearchResultsStats.export(“term_statistics_collector_queries_with_moved_back_bins”);</p>
</div></blockquote>
<dl class="simple">
<dt>private static final SearchCounter TERM_STATS_SKIPPED_LARGER_OUT_OF_BOUNDS_HITS =</dt><dd><p>SearchCounter.export(“term_statistics_collector_skipped_larger_out_of_bounds_hits”);</p>
</dd>
</dl>
<p>&#64;VisibleForTesting
static final class TermStatistics {</p>
<blockquote>
<div><p>private final ThriftTermRequest termRequest;
private final Term term;  // could be null, for count across all fields
private int termDF = 0;
private int termCount = 0;
private final int[] histogramBins;</p>
<p>// Per-segment information.
private PostingsEnum segmentDocsEnum;  // could be null, for count across all fields
private boolean segmentDone;</p>
<p>&#64;VisibleForTesting
TermStatistics(ThriftTermRequest termRequest, Term term, int numBins) {</p>
<blockquote>
<div><p>this.termRequest = termRequest;
this.term = term;
this.histogramBins = new int[numBins];</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Take the currently accumulated counts and “move them back” to make room for counts from more</p></li>
<li><p>recent binIds.</p></li>
<li></li>
<li><p>For example, if the oldFirstBinID was set to 10, and the histogramBins were {3, 4, 5, 6, 7},</p></li>
<li><p>after this call with newFirstBinID set to 12, the histogramBins will be set</p></li>
<li><p>to {5, 6, 7, 0, 0}.</p></li>
<li></li>
<li><p>&#64;param oldFirstBinID the binId of the firstBin that’s been used up to now.</p></li>
<li><p>&#64;param newFirstBinID the new binId of the firstBin that will be used from now on.</p></li>
<li><p>The newFirstBinID is presumed to be larger than the oldFirstBinID, and is asserted.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
</dl>
<p>&#64;VisibleForTesting
void moveBackTermCounts(int oldFirstBinID, int newFirstBinID) {</p>
<blockquote>
<div><p>Preconditions.checkState(oldFirstBinID &lt; newFirstBinID);
// move counts back by this many bins
final int moveBackBy = newFirstBinID - oldFirstBinID;</p>
<p>this.termCount = 0;
for (int i = 0; i &lt; histogramBins.length; i++) {</p>
<blockquote>
<div><p>int oldCount = histogramBins[i];
histogramBins[i] = 0;
int newIndex = i - moveBackBy;
if (newIndex &gt;= 0) {</p>
<blockquote>
<div><p>histogramBins[newIndex] = oldCount;
this.termCount += oldCount;</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>&#64;VisibleForTesting void countHit(int bin) {</dt><dd><p>termCount++;
histogramBins[bin]++;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>&#64;VisibleForTesting int getTermCount() {</dt><dd><p>return termCount;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>&#64;VisibleForTesting int[] getHistogramBins() {</dt><dd><p>return histogramBins;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>private TermStatistics[] termStatistics;</p>
<p>// Histogram fields.
private int numBins;
private int binSize;</p>
<p>private int numTimesBinsWereMovedBack = 0;
private int numLargerOutOfBoundsBinsSkipped = 0;</p>
<p>private static final int SEEN_OUT_OF_RANGE_THRESHOLD = 10;</p>
<p>private int seenOutOfRange = 0;</p>
<p>// ID of the first bin - effectively time / binSize.  This is calculated
// relative to the first collected in-order hit.
private int firstBinID = -1;
// List of per-segment debug information specifically useful for termstat request debugging.
private List&lt;String&gt; termStatisticsDebugInfo = new ArrayList&lt;&gt;();</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Creates a new term stats collector.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>public TermStatisticsCollector(</dt><dd><blockquote>
<div><p>ImmutableSchemaInterface schema,
TermStatisticsRequestInfo searchRequestInfo,
EarlybirdSearcherStats searcherStats,
Clock clock,
int requestDebugMode) {</p>
</div></blockquote>
<p>super(schema, searchRequestInfo, clock, searcherStats, requestDebugMode);</p>
<p>// Set up the histogram bins.
if (searchRequestInfo.isReturnHistogram()) {</p>
<blockquote>
<div><p>ThriftHistogramSettings histogramSettings = searchRequestInfo.getHistogramSettings();
this.numBins = histogramSettings.getNumBins();
binSize = TermStatisticsUtil.determineBinSize(histogramSettings);</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>this.numBins = 0;
this.binSize = 0;</p>
</dd>
</dl>
<p>}</p>
<p>// Set up the term statistics array.
List&lt;ThriftTermRequest&gt; termRequests = searchRequestInfo.getTermRequests();
if (termRequests == null) {</p>
<blockquote>
<div><p>this.termStatistics = new TermStatistics[0];
return;</p>
</div></blockquote>
<p>}</p>
<p>this.termStatistics = new TermStatistics[searchRequestInfo.getTermRequests().size()];
for (int i = 0; i &lt; searchRequestInfo.getTermRequests().size(); i++) {</p>
<blockquote>
<div><p>final ThriftTermRequest termRequest = searchRequestInfo.getTermRequests().get(i);</p>
<p>Term term = null;
String fieldName = termRequest.getFieldName();
if (!StringUtils.isBlank(fieldName)) {</p>
<blockquote>
<div><p>// First check if it’s a facet field.
Schema.FieldInfo facetField = schema.getFacetFieldByFacetName(termRequest.getFieldName());
if (facetField != null) {</p>
<blockquote>
<div><p>term = new Term(facetField.getName(), termRequest.getTerm());</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>// EarlybirdSearcher.validateRequest() should’ve already checked that the field exists in
// the schema, and that the term can be converted to the type of this field. However, if
// that did not happen for some reason, an exception will be thrown here, which will be
// converted to a TRANSIENT_ERROR response code.
Schema.FieldInfo fieldInfo = schema.getFieldInfo(fieldName);
Preconditions.checkNotNull(</p>
<blockquote>
<div><p>fieldInfo,
“Found a ThriftTermRequest for a field that’s not in the schema: “ + fieldName
+ “. This should’ve been caught by EarlybirdSearcher.validateRequest()!”);</p>
</div></blockquote>
<p>term = new Term(fieldName, SchemaUtil.toBytesRef(fieldInfo, termRequest.getTerm()));</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>// NOTE: if the fieldName is empty, this is a catch-all term request for the count across
// all fields. We’ll just use a null term in the TermStatistics object.</p>
</dd>
</dl>
<p>}</p>
<p>termStatistics[i] = new TermStatistics(termRequest, term, numBins);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public void startSegment() throws IOException {</p>
<blockquote>
<div><dl>
<dt>termStatisticsDebugInfo.add(</dt><dd><p>“Starting segment in timestamp range: [” + timeMapper.getFirstTime()
+ “, “ + timeMapper.getLastTime() + “]”);</p>
</dd>
<dt>for (TermStatistics termStats<span class="classifier">termStatistics) {</span></dt><dd><p>termStats.segmentDone = true;  // until we know it’s false later.
TermsEnum termsEnum = null;
if (termStats.term != null) {</p>
<blockquote>
<div><p>Terms terms = currTwitterReader.terms(termStats.term.field());
if (terms != null) {</p>
<blockquote>
<div><p>termsEnum = terms.iterator();
if (termsEnum != null &amp;&amp; termsEnum.seekExact(termStats.term.bytes())) {</p>
<blockquote>
<div><p>termStats.termDF += termsEnum.docFreq();  // Only meaningful for matchAll queries.
termStats.segmentDocsEnum =</p>
<blockquote>
<div><p>termsEnum.postings(termStats.segmentDocsEnum, PostingsEnum.FREQS);</p>
</div></blockquote>
<dl class="simple">
<dt>termStats.segmentDone = termStats.segmentDocsEnum == null</dt><dd><p>|| termStats.segmentDocsEnum.nextDoc() == DocIdSetIterator.NO_MORE_DOCS;</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>// this term doesn’t exist in this segment.</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>// Catch-all case
termStats.termDF += currTwitterReader.numDocs();   // Only meaningful for matchAll queries.
termStats.segmentDocsEnum = null;
termStats.segmentDone = false;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private int calculateBin(final int tweetTime) {</dt><dd><dl class="simple">
<dt>if (tweetTime == TimeMapper.ILLEGAL_TIME) {</dt><dd><p>return -1;</p>
</dd>
</dl>
<p>}</p>
<p>final int binID = Math.abs(tweetTime) / binSize;
final int expectedFirstBinId = binID - numBins + 1;</p>
<dl>
<dt>if (firstBinID == -1) {</dt><dd><p>firstBinID = expectedFirstBinId;</p>
</dd>
<dt>} else if (expectedFirstBinId &gt; firstBinID) {</dt><dd><p>numTimesBinsWereMovedBack++;
final int oldOutOfOrderFirstBinID = firstBinID;
firstBinID = expectedFirstBinId;
// We got a more recent out of order bin, move previous counts back.
for (TermStatistics ts : termStatistics) {</p>
<blockquote>
<div><p>ts.moveBackTermCounts(oldOutOfOrderFirstBinID, firstBinID);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>final int binIndex = binID - firstBinID;
if (binIndex &gt;= numBins) {</p>
<blockquote>
<div><p>// In-order times should be decreasing,
// and out of order times seen after an in-order tweet should also be smaller than the
// first in-order tweet’s time. Will track these and export as a stat.
numLargerOutOfBoundsBinsSkipped++;
return -1;</p>
</div></blockquote>
<dl class="simple">
<dt>} else if (binIndex &lt; 0) {</dt><dd><p>// Early termination criteria.
seenOutOfRange++;</p>
</dd>
<dt>} else {</dt><dd><p>// Reset the counter, since we want to see consecutive tweets that are out of our bin range
// not single anomalies.
seenOutOfRange = 0;</p>
</dd>
</dl>
<p>}</p>
<p>return binIndex;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public void doCollect(long tweetID) throws IOException {</p>
<blockquote>
<div><dl>
<dt>if (searchRequestInfo.isReturnHistogram()) {</dt><dd><p>final int tweetTime = timeMapper.getTime(curDocId);
final int binIndex = calculateBin(tweetTime);
if (binIndex &gt;= 0) {</p>
<blockquote>
<div><dl>
<dt>for (TermStatistics ts<span class="classifier">termStatistics) {</span></dt><dd><dl class="simple">
<dt>if (!ts.segmentDone) {</dt><dd><p>countHist(ts, binIndex);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>} else {</dt><dd><dl>
<dt>for (TermStatistics ts<span class="classifier">termStatistics) {</span></dt><dd><dl class="simple">
<dt>if (!ts.segmentDone) {</dt><dd><p>countNoHist(ts);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public void skipSegment(EarlybirdSingleSegmentSearcher searcher) {</p>
<blockquote>
<div><p>// Do nothing here.
// We don’t do accounting that’s done in AbstractResultsCollector for Term Stats
// requests because otherwise the bin ID calculation will be confused.</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private boolean advance(TermStatistics ts) throws IOException {</dt><dd><p>PostingsEnum docsEnum = ts.segmentDocsEnum;
if (docsEnum.docID() &lt; curDocId) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (docsEnum.advance(curDocId) == DocIdSetIterator.NO_MORE_DOCS) {</dt><dd><p>ts.segmentDone = true;
return false;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
return docsEnum.docID() == curDocId;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private boolean countHist(TermStatistics ts, int bin) throws IOException {</dt><dd><dl class="simple">
<dt>if (ts.term != null &amp;&amp; !advance(ts)) {</dt><dd><p>return false;</p>
</dd>
</dl>
<p>}
ts.countHit(bin);
return true;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private boolean countNoHist(TermStatistics ts) throws IOException {</dt><dd><dl class="simple">
<dt>if (ts.term != null &amp;&amp; !advance(ts)) {</dt><dd><p>return false;</p>
</dd>
</dl>
<p>}
ts.termCount++;
return true;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public EarlyTerminationState innerShouldCollectMore() {</p>
<blockquote>
<div><dl class="simple">
<dt>if (readyToTerminate()) {</dt><dd><p>return setEarlyTerminationState(TERMINATED_TERM_STATS_COUNTING_DONE);</p>
</dd>
</dl>
<p>}
return EarlyTerminationState.COLLECTING;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>The termination logic is simple - we know what our earliest bin is and once we see a result</p></li>
<li><p>that’s before our earliest bin, we terminate.</p></li>
<li></li>
<li><p>Our results come with increasing internal doc ids, which should correspond to decreasing</p></li>
<li><p>timestamps. See SEARCH-27729, TWEETYPIE-7031.</p></li>
<li></li>
<li><p>We early terminate after we have seen enough tweets that are outside of the bin</p></li>
<li><p>range that we want to return. This way we’re not terminating too early because of single tweets</p></li>
<li><p>with wrong timestamps.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
</dl>
<p>&#64;VisibleForTesting
boolean readyToTerminate() {</p>
<blockquote>
<div><p>return this.seenOutOfRange &gt;= SEEN_OUT_OF_RANGE_THRESHOLD;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public TermStatisticsSearchResults doGetResults() {</p>
<blockquote>
<div><p>return new TermStatisticsSearchResults();</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>public final class TermStatisticsSearchResults extends SearchResultsInfo {</dt><dd><p>public final List&lt;Integer&gt; binIds;
public final Map&lt;ThriftTermRequest, ThriftTermResults&gt; results;
public final int lastCompleteBinId;
public final List&lt;String&gt;  termStatisticsDebugInfo;</p>
<dl>
<dt>private TermStatisticsSearchResults() {</dt><dd><p>// Initialize term stat debug info
termStatisticsDebugInfo = TermStatisticsCollector.this.termStatisticsDebugInfo;</p>
<dl>
<dt>if (termStatistics.length &gt; 0) {</dt><dd><p>results = new HashMap&lt;&gt;();</p>
<dl>
<dt>if (searchRequestInfo.isReturnHistogram()) {</dt><dd><p>binIds = new ArrayList&lt;&gt;(numBins);
int minSearchedTime = TermStatisticsCollector.this.getMinSearchedTime();</p>
<dl class="simple">
<dt>if (shouldCollectDetailedDebugInfo()) {</dt><dd><p>termStatisticsDebugInfo.add(“minSearchedTime: “ + minSearchedTime);
int maxSearchedTime = TermStatisticsCollector.this.getMaxSearchedTime();
termStatisticsDebugInfo.add(“maxSearchedTime: “ + maxSearchedTime);</p>
</dd>
</dl>
<p>}</p>
<p>int lastCompleteBin = -1;</p>
<p>computeFirstBinId(TermStatisticsCollector.this.isSetMinSearchedTime(), minSearchedTime);
trackHistogramResultStats();</p>
<p>// Example:
//  minSearchTime = 53s
//  binSize = 10
//  firstBinId = 5
//  numBins = 4
//  binId = 5, 6, 7, 8
//  binTimeStamp = 50s, 60s, 70s, 80s
for (int i = 0; i &lt; numBins; i++) {</p>
<blockquote>
<div><p>int binId = firstBinID + i;
int binTimeStamp = binId * binSize;
binIds.add(binId);
if (lastCompleteBin == -1 &amp;&amp; binTimeStamp &gt; minSearchedTime) {</p>
<blockquote>
<div><p>lastCompleteBin = binId;</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>if (!getEarlyTerminationState().isTerminated()) {</dt><dd><p>// only if we didn’t early terminate we can be sure to use the firstBinID as
// lastCompleteBinId
lastCompleteBinId = firstBinID;
if (shouldCollectDetailedDebugInfo()) {</p>
<blockquote>
<div><p>termStatisticsDebugInfo.add(“no early termination”);</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>lastCompleteBinId = lastCompleteBin;
if (shouldCollectDetailedDebugInfo()) {</p>
<blockquote>
<div><dl class="simple">
<dt>termStatisticsDebugInfo.add(</dt><dd><p>“early terminated for reason: “ + getEarlyTerminationReason());</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}
if (shouldCollectDetailedDebugInfo()) {</p>
<blockquote>
<div><p>termStatisticsDebugInfo.add(“lastCompleteBinId: “ + lastCompleteBinId);</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>binIds = null;
lastCompleteBinId = -1;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>for (TermStatistics ts<span class="classifier">termStatistics) {</span></dt><dd><p>ThriftTermResults termResults = new ThriftTermResults().setTotalCount(ts.termCount);</p>
<dl>
<dt>if (searchRequestInfo.isReturnHistogram()) {</dt><dd><p>List&lt;Integer&gt; list = new ArrayList&lt;&gt;();
for (int count : ts.histogramBins) {</p>
<blockquote>
<div><p>list.add(count);</p>
</div></blockquote>
<p>}
termResults.setHistogramBins(list);</p>
</dd>
</dl>
<p>}</p>
<p>results.put(ts.termRequest, termResults);</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>binIds = null;
results = null;
lastCompleteBinId = -1;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public String toString() {</p>
<blockquote>
<div><p>StringBuilder res = new StringBuilder();
res.append(“TermStatisticsSearchResults(n”);
if (binIds != null) {</p>
<blockquote>
<div><p>res.append(”  binIds=”).append(binIds).append(”n”);</p>
</div></blockquote>
<p>}
res.append(”  lastCompleteBinId=”).append(lastCompleteBinId).append(”n”);
if (results != null) {</p>
<blockquote>
<div><p>res.append(”  results=”).append(results).append(”n”);</p>
</div></blockquote>
<p>}
res.append(“)”);
return res.toString();</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>public List&lt;String&gt; getTermStatisticsDebugInfo() {</dt><dd><p>return termStatisticsDebugInfo;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Figure out what the actual firstBinId is for this query.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>private void computeFirstBinId(boolean isSetMinSearchedTime, int minSearchedTime) {</dt><dd><dl>
<dt>if (firstBinID == -1) {</dt><dd><dl class="simple">
<dt>if (!isSetMinSearchedTime) {</dt><dd><p>// This would only happen if we don’t search any segments, which for now we have
// only seen happening if since_time or until_time don’t intersect at all with
// the range of the served segments.
firstBinID = 0;</p>
</dd>
<dt>} else {</dt><dd><p>// Example:
//    minSearchedTime = 54
//    binSize = 10
//    firstBinId = 5
firstBinID = minSearchedTime / binSize;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (shouldCollectDetailedDebugInfo()) {</dt><dd><p>termStatisticsDebugInfo.add(“firstBinId: “ + firstBinID);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>&#64;VisibleForTesting
int getSeenOutOfRange() {</p>
<blockquote>
<div><p>return seenOutOfRange;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private void trackHistogramResultStats() {</dt><dd><dl class="simple">
<dt>if (numLargerOutOfBoundsBinsSkipped &gt; 0) {</dt><dd><p>TERM_STATS_SKIPPED_LARGER_OUT_OF_BOUNDS_HITS.increment();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (numTimesBinsWereMovedBack &gt; 0) {</dt><dd><p>TERM_STATS_HISTOGRAM_REQUESTS_WITH_MOVED_BACK_BINS.recordResults(numTimesBinsWereMovedBack);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../_sources/src/java/com/twitter/search/earlybird/search/facets/TermStatisticsCollector.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>