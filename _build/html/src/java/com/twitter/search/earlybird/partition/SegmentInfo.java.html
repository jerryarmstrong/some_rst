<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../" id="documentation_options" src="../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.earlybird.partition;</p>
<p>import java.io.File;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;</p>
<p>import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;</p>
<p>import org.apache.commons.io.FileUtils;
import org.apache.lucene.store.Directory;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;</p>
<p>import com.twitter.common.collections.Pair;
import com.twitter.search.common.partitioning.base.Segment;
import com.twitter.search.common.partitioning.base.TimeSlice;
import com.twitter.search.common.schema.earlybird.FlushVersion;
import com.twitter.search.common.util.LogFormatUtil;
import com.twitter.search.common.util.io.flushable.FlushInfo;
import com.twitter.search.common.util.io.flushable.PersistentFile;
import com.twitter.search.earlybird.EarlybirdIndexConfig;
import com.twitter.search.earlybird.common.config.EarlybirdConfig;
import com.twitter.search.earlybird.index.EarlybirdSegment;
import com.twitter.search.earlybird.index.EarlybirdSegmentFactory;</p>
<dl>
<dt>public class SegmentInfo implements Comparable&lt;SegmentInfo&gt; {</dt><dd><p>private static final Logger LOG = LoggerFactory.getLogger(SegmentInfo.class);</p>
<p>private static final String UPDATE_STREAM_OFFSET_TIMESTAMP = “updateStreamOffsetTimestamp”;
public static final int INVALID_ID = -1;</p>
<p>// Delay before deleting a segment
private final long timeToWaitBeforeClosingMillis = EarlybirdConfig.getLong(</p>
<blockquote>
<div><p>“defer_index_closing_time_millis”, 600000L);</p>
</div></blockquote>
<p>// How many times deletions are retired.
private final AtomicInteger deletionRetries = new AtomicInteger(5);</p>
<p>// Base segment information, including database name, minStatusId.
private final Segment segment;</p>
<p>// Bits managed by various SegmentProcessors and PartitionManager.
private volatile boolean isEnabled   = true;   // True if the segment is enabled.
private volatile boolean isIndexing  = false;  // True during indexing.
private volatile boolean isComplete  = false;  // True when indexing is complete.
private volatile boolean isClosed    = false;  // True if indexSegment is closed.
private volatile boolean wasIndexed  = false;  // True if the segment was indexed from scratch.
private volatile boolean failedOptimize = false;  // optimize attempt failed.
private AtomicBoolean beingUploaded = new AtomicBoolean();  // segment is being copied to HDFS</p>
<p>private final SegmentSyncInfo segmentSyncInfo;
private final EarlybirdIndexConfig earlybirdIndexConfig;</p>
<p>private final EarlybirdSegment indexSegment;</p>
<p>private final AtomicLong updatesStreamOffsetTimestamp = new AtomicLong(0);</p>
<dl>
<dt>public SegmentInfo(Segment segment,</dt><dd><blockquote>
<div><p>EarlybirdSegmentFactory earlybirdSegmentFactory,
SegmentSyncConfig syncConfig) throws IOException {</p>
</div></blockquote>
<p>this(segment, earlybirdSegmentFactory, new SegmentSyncInfo(syncConfig, segment));</p>
</dd>
</dl>
<p>}</p>
<p>&#64;VisibleForTesting
public SegmentInfo(Segment segment,</p>
<blockquote>
<div><blockquote>
<div><p>EarlybirdSegmentFactory earlybirdSegmentFactory,
SegmentSyncInfo segmentSyncInfo) throws IOException {</p>
</div></blockquote>
<dl class="simple">
<dt>this(earlybirdSegmentFactory.newEarlybirdSegment(segment, segmentSyncInfo),</dt><dd><p>segmentSyncInfo,
segment,
earlybirdSegmentFactory.getEarlybirdIndexConfig());</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>public SegmentInfo(</dt><dd><p>EarlybirdSegment earlybirdSegment,
SegmentSyncInfo segmentSyncInfo,
Segment segment,
EarlybirdIndexConfig earlybirdIndexConfig</p>
</dd>
<dt>) {</dt><dd><p>this.indexSegment = earlybirdSegment;
this.segmentSyncInfo = segmentSyncInfo;
this.earlybirdIndexConfig = earlybirdIndexConfig;
this.segment = segment;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public EarlybirdSegment getIndexSegment() {</dt><dd><p>return indexSegment;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public SegmentIndexStats getIndexStats() {</dt><dd><p>return indexSegment.getIndexStats();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public EarlybirdIndexConfig getEarlybirdIndexConfig() {</dt><dd><p>return earlybirdIndexConfig;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public long getTimeSliceID() {</dt><dd><p>return segment.getTimeSliceID();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getSegmentName() {</dt><dd><p>return segment.getSegmentName();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public int getNumPartitions() {</dt><dd><p>return segment.getNumHashPartitions();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean isEnabled() {</dt><dd><p>return isEnabled;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setIsEnabled(boolean isEnabled) {</dt><dd><p>this.isEnabled = isEnabled;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean isOptimized() {</dt><dd><p>return indexSegment.isOptimized();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean wasIndexed() {</dt><dd><p>return wasIndexed;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setWasIndexed(boolean wasIndexed) {</dt><dd><p>this.wasIndexed = wasIndexed;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean isFailedOptimize() {</dt><dd><p>return failedOptimize;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setFailedOptimize() {</dt><dd><p>this.failedOptimize = true;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean isIndexing() {</dt><dd><p>return isIndexing;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setIndexing(boolean indexing) {</dt><dd><p>this.isIndexing = indexing;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean isComplete() {</dt><dd><p>return isComplete;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean isClosed() {</dt><dd><p>return isClosed;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean isBeingUploaded() {</dt><dd><p>return beingUploaded.get();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setBeingUploaded(boolean beingUploaded) {</dt><dd><p>this.beingUploaded.set(beingUploaded);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean casBeingUploaded(boolean expectation, boolean updateValue) {</dt><dd><p>return beingUploaded.compareAndSet(expectation, updateValue);</p>
</dd>
</dl>
<p>}</p>
<p>&#64;VisibleForTesting
public void setComplete(boolean complete) {</p>
<blockquote>
<div><p>this.isComplete = complete;</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>public boolean needsIndexing() {</dt><dd><p>return isEnabled &amp;&amp; !isIndexing &amp;&amp; !isComplete;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public int compareTo(SegmentInfo other) {</p>
<blockquote>
<div><p>return Long.compare(getTimeSliceID(), other.getTimeSliceID());</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public boolean equals(Object obj) {</p>
<blockquote>
<div><p>return obj instanceof SegmentInfo &amp;&amp; compareTo((SegmentInfo) obj) == 0;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public int hashCode() {</p>
<blockquote>
<div><p>return new Long(getTimeSliceID()).hashCode();</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>public long getUpdatesStreamOffsetTimestamp() {</dt><dd><p>return updatesStreamOffsetTimestamp.get();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setUpdatesStreamOffsetTimestamp(long timestamp) {</dt><dd><p>updatesStreamOffsetTimestamp.set(timestamp);</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public String toString() {</p>
<blockquote>
<div><p>StringBuilder builder = new StringBuilder();
builder.append(getSegmentName()).append(” [“);
builder.append(isEnabled ? “enabled, “ : “disabled, “);</p>
<dl class="simple">
<dt>if (isIndexing) {</dt><dd><p>builder.append(“indexing, “);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (isComplete) {</dt><dd><p>builder.append(“complete, “);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (isOptimized()) {</dt><dd><p>builder.append(“optimized, “);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (wasIndexed) {</dt><dd><p>builder.append(“wasIndexed, “);</p>
</dd>
</dl>
<p>}</p>
<p>builder.append(“IndexSync:”);
this.segmentSyncInfo.addDebugInfo(builder);</p>
<p>return builder.append(“]”).toString();</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>public Segment getSegment() {</dt><dd><p>return segment;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Delete the index segment directory corresponding to this segment info. Return true if deleted</p></li>
<li><p>successfully; otherwise, false.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public boolean deleteLocalIndexedSegmentDirectoryImmediately() {</dt><dd><dl class="simple">
<dt>if (isClosed) {</dt><dd><p>LOG.info(“SegmentInfo is already closed: “ + toString());
return true;</p>
</dd>
</dl>
<p>}</p>
<p>Preconditions.checkNotNull(indexSegment, “indexSegment should never be null.”);
isClosed = true;
indexSegment.destroyImmediately();</p>
<p>SegmentSyncConfig sync = getSyncInfo().getSegmentSyncConfig();
try {</p>
<blockquote>
<div><p>String dirToClear = sync.getLocalSyncDirName(segment);
FileUtils.forceDelete(new File(dirToClear));
LOG.info(“Deleted segment directory: “ + toString());
return true;</p>
</div></blockquote>
<dl class="simple">
<dt>} catch (IOException e) {</dt><dd><p>LOG.error(“Cannot clean up segment directory for segment: “ + toString(), e);
return false;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Delete the index segment directory after some configured delay.</p></li>
<li><p>Note that we don’t delete segments that are being uploaded.</p></li>
<li><p>If a segment is being uploaded when we try to delete, close() retries the deletion later.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>public void deleteIndexSegmentDirectoryAfterDelay() {</dt><dd><p>LOG.info(“Scheduling SegmentInfo for deletion: “ + toString());
getEarlybirdIndexConfig().getResourceCloser().closeResourceQuietlyAfterDelay(</p>
<blockquote>
<div><dl>
<dt>timeToWaitBeforeClosingMillis, () -&gt; {</dt><dd><p>// Atomically check and set the being uploaded flag, if it is not set.
if (beingUploaded.compareAndSet(false, true)) {</p>
<blockquote>
<div><p>// If successfully set the flag to true, we can delete immediately
setIsEnabled(false);
deleteLocalIndexedSegmentDirectoryImmediately();
LOG.info(“Deleted index segment dir for segment: “</p>
<blockquote>
<div><ul class="simple">
<li><p>getSegment().getSegmentName());</p></li>
</ul>
</div></blockquote>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>// If the flag is already true (compareAndSet fails), we need to reschedule.
if (deletionRetries.decrementAndGet() &gt; 0) {</p>
<blockquote>
<div><dl class="simple">
<dt>LOG.warn(“Segment is being uploaded, will retry deletion later. SegmentInfo: “</dt><dd><ul class="simple">
<li><p>getSegment().getSegmentName());</p></li>
</ul>
</dd>
</dl>
<p>deleteIndexSegmentDirectoryAfterDelay();</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><dl class="simple">
<dt>LOG.warn(“Failed to cleanup index segment dir for segment: “</dt><dd><ul class="simple">
<li><p>getSegment().getSegmentName());</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>});</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public SegmentSyncInfo getSyncInfo() {</dt><dd><p>return segmentSyncInfo;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public FlushVersion getFlushVersion() {</dt><dd><p>return FlushVersion.CURRENT_FLUSH_VERSION;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getZkNodeName() {</dt><dd><p>return getSegmentName() + getFlushVersion().getVersionFileExtension();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>static String getSyncDirName(String parentDir, String dbName, String version) {</dt><dd><p>return parentDir + “/” + dbName + version;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Parses the segment name from the name of the flushed directory.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>public static String getSegmentNameFromFlushedDir(String flushedDir) {</dt><dd><p>String segmentName = null;
String[] fields = flushedDir.split(“/”);
if (fields.length &gt; 0) {</p>
<blockquote>
<div><p>segmentName = fields[fields.length - 1];
segmentName = segmentName.replaceAll(FlushVersion.DELIMITER + “.*”, “”);</p>
</div></blockquote>
<p>}
return segmentName;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Flushes this segment to the given directory.</p></li>
<li></li>
<li><p>&#64;param dir The directory to flush the segment to.</p></li>
<li><p>&#64;throws IOException If the segment could not be flushed.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>public void flush(Directory dir) throws IOException {</dt><dd><p>LOG.info(“Flushing segment: {}”, getSegmentName());
try (PersistentFile.Writer writer = PersistentFile.getWriter(dir, getSegmentName())) {</p>
<blockquote>
<div><p>FlushInfo flushInfo = new FlushInfo();
flushInfo.addLongProperty(UPDATE_STREAM_OFFSET_TIMESTAMP, getUpdatesStreamOffsetTimestamp());
getIndexSegment().flush(flushInfo, writer.getDataSerializer());</p>
<p>OutputStreamWriter infoFileWriter = new OutputStreamWriter(writer.getInfoFileOutputStream());
FlushInfo.flushAsYaml(flushInfo, infoFileWriter);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Makes a new SegmentInfo out of the current segment info, except that we switch the underlying</p></li>
<li><p>segment.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>public SegmentInfo copyWithEarlybirdSegment(EarlybirdSegment optimizedSegment) {</dt><dd><p>// Take everything from the current segment info that doesn’t change for the new segment
// info and rebuild everything that can change.
TimeSlice newTimeSlice = new TimeSlice(</p>
<blockquote>
<div><p>getTimeSliceID(),
EarlybirdConfig.getMaxSegmentSize(),
segment.getHashPartitionID(),
segment.getNumHashPartitions()</p>
</div></blockquote>
<p>);
Segment newSegment = newTimeSlice.getSegment();</p>
<dl>
<dt>return new SegmentInfo(</dt><dd><p>optimizedSegment,
new SegmentSyncInfo(</p>
<blockquote>
<div><p>segmentSyncInfo.getSegmentSyncConfig(),
newSegment),</p>
</div></blockquote>
<p>newSegment,
earlybirdIndexConfig</p>
</dd>
</dl>
<p>);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Loads the segment from the given directory.</p></li>
<li></li>
<li><p>&#64;param dir The directory to load the segment from.</p></li>
<li><p>&#64;throws IOException If the segment could not be loaded.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>public void load(Directory dir) throws IOException {</dt><dd><p>LOG.info(“Loading segment: {}”, getSegmentName());
try (PersistentFile.Reader reader = PersistentFile.getReader(dir, getSegmentName())) {</p>
<blockquote>
<div><p>FlushInfo flushInfo = FlushInfo.loadFromYaml(reader.getInfoInputStream());
setUpdatesStreamOffsetTimestamp(flushInfo.getLongProperty(UPDATE_STREAM_OFFSET_TIMESTAMP));
getIndexSegment().load(reader.getDataInputStream(), flushInfo);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private String getShortStatus() {</dt><dd><dl class="simple">
<dt>if (!isEnabled()) {</dt><dd><p>return “disabled”;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (isIndexing()) {</dt><dd><p>return “indexing”;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (isComplete()) {</dt><dd><p>return “indexed”;</p>
</dd>
</dl>
<p>}</p>
<p>return “pending”;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Get a string to be shown in admin commands which shows the query caches’ sizes for this</p></li>
<li><p>segment.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>public String getQueryCachesData() {</dt><dd><p>StringBuilder out = new StringBuilder();
out.append(“Segment: “ + getSegmentName() + “n”);
out.append(“Total documents: “ + LogFormatUtil.formatInt(</p>
<blockquote>
<div><p>getIndexStats().getStatusCount()) + “n”);</p>
</div></blockquote>
<p>out.append(“Query caches:n”);
for (Pair&lt;String, Long&gt; data : indexSegment.getQueryCachesData()) {</p>
<blockquote>
<div><p>out.append(”  “ + data.getFirst());
out.append(”: “);
out.append(LogFormatUtil.formatInt(data.getSecond()));
out.append(”n”);</p>
</div></blockquote>
<p>}
return out.toString();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getSegmentMetadata() {</dt><dd><dl class="simple">
<dt>return “status: “ + getShortStatus() + “n”</dt><dd><ul class="simple">
<li><p>“id: “ + getTimeSliceID() + “n”</p></li>
<li><p>“name: “ + getSegmentName() + “n”</p></li>
<li><p>“statusCount: “ + getIndexStats().getStatusCount() + “n”</p></li>
<li><p>“deleteCount: “ + getIndexStats().getDeleteCount() + “n”</p></li>
<li><p>“partialUpdateCount: “ + getIndexStats().getPartialUpdateCount() + “n”</p></li>
<li><p>“outOfOrderUpdateCount: “ + getIndexStats().getOutOfOrderUpdateCount() + “n”</p></li>
<li><p>“isEnabled: “ + isEnabled() + “n”</p></li>
<li><p>“isIndexing: “ + isIndexing() + “n”</p></li>
<li><p>“isComplete: “ + isComplete() + “n”</p></li>
<li><p>“isFlushed: “ + getSyncInfo().isFlushed() + “n”</p></li>
<li><p>“isOptimized: “ + isOptimized() + “n”</p></li>
<li><p>“isLoaded: “ + getSyncInfo().isLoaded() + “n”</p></li>
<li><p>“wasIndexed: “ + wasIndexed() + “n”</p></li>
<li><p>“queryCachesCardinality: “ + indexSegment.getQueryCachesCardinality() + “n”;</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../_sources/src/java/com/twitter/search/earlybird/partition/SegmentInfo.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>