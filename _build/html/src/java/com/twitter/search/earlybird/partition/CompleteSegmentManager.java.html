<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../" id="documentation_options" src="../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.earlybird.partition;</p>
<p>import java.io.IOException;
import java.util.Iterator;
import java.util.List;
import java.util.function.Supplier;</p>
<p>import com.google.common.collect.Lists;</p>
<p>import org.slf4j.Logger;
import org.slf4j.LoggerFactory;</p>
<p>import com.twitter.common.util.Clock;
import com.twitter.search.common.indexing.thriftjava.ThriftVersionedEvents;
import com.twitter.search.common.schema.earlybird.EarlybirdCluster;
import com.twitter.search.common.util.io.recordreader.RecordReader;
import com.twitter.search.common.util.zktrylock.ZooKeeperTryLockFactory;
import com.twitter.search.earlybird.EarlybirdStatus;
import com.twitter.search.earlybird.common.config.EarlybirdProperty;
import com.twitter.search.earlybird.document.TweetDocument;
import com.twitter.search.earlybird.exception.CriticalExceptionHandler;
import com.twitter.search.earlybird.segment.SegmentDataProvider;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>CompleteSegmentManager is used to parallelize indexing of complete (not partial) segments</p></li>
<li><p>on startup.  It also populates the fields used by the PartitionManager.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public class CompleteSegmentManager {</dt><dd><p>private static final Logger LOG = LoggerFactory.getLogger(CompleteSegmentManager.class);</p>
<dl class="simple">
<dt>private static final String INDEX_COMPLETED_SEGMENTS =</dt><dd><p>“indexing, optimizing and flushing complete segments”;</p>
</dd>
</dl>
<p>private static final String LOAD_COMPLETED_SEGMENTS = “loading complete segments”;
private static final String INDEX_UPDATES_FOR_COMPLETED_SEGMENTS =</p>
<blockquote>
<div><p>“indexing updates for complete segments”;</p>
</div></blockquote>
<dl class="simple">
<dt>private static final String BUILD_MULTI_SEGMENT_TERM_DICT =</dt><dd><p>“build multi segment term dictionaries”;</p>
</dd>
</dl>
<p>// Max number of segments being loaded / indexed concurrently.
private final int maxConcurrentSegmentIndexers =</p>
<blockquote>
<div><p>EarlybirdProperty.MAX_CONCURRENT_SEGMENT_INDEXERS.get(3);</p>
</div></blockquote>
<p>// The state we are building.
protected final SegmentDataProvider segmentDataProvider;
private final InstrumentedQueue&lt;ThriftVersionedEvents&gt; retryQueue;</p>
<p>private final UserUpdatesStreamIndexer userUpdatesStreamIndexer;
private final UserScrubGeoEventStreamIndexer userScrubGeoEventStreamIndexer;</p>
<p>private final SegmentManager segmentManager;
private final ZooKeeperTryLockFactory zkTryLockFactory;
private final SearchIndexingMetricSet searchIndexingMetricSet;
private final Clock clock;
private MultiSegmentTermDictionaryManager multiSegmentTermDictionaryManager;
private final SegmentSyncConfig segmentSyncConfig;</p>
<p>private final CriticalExceptionHandler criticalExceptionHandler;</p>
<p>private boolean interrupted = false;</p>
<dl>
<dt>public CompleteSegmentManager(</dt><dd><blockquote>
<div><p>ZooKeeperTryLockFactory zooKeeperTryLockFactory,
SegmentDataProvider segmentDataProvider,
UserUpdatesStreamIndexer userUpdatesStreamIndexer,
UserScrubGeoEventStreamIndexer userScrubGeoEventStreamIndexer,
SegmentManager segmentManager,
InstrumentedQueue&lt;ThriftVersionedEvents&gt; retryQueue,
SearchIndexingMetricSet searchIndexingMetricSet,
Clock clock,
MultiSegmentTermDictionaryManager multiSegmentTermDictionaryManager,
SegmentSyncConfig segmentSyncConfig,
CriticalExceptionHandler criticalExceptionHandler) {</p>
</div></blockquote>
<p>this.zkTryLockFactory = zooKeeperTryLockFactory;
this.segmentDataProvider = segmentDataProvider;
this.userUpdatesStreamIndexer = userUpdatesStreamIndexer;
this.userScrubGeoEventStreamIndexer = userScrubGeoEventStreamIndexer;
this.segmentManager = segmentManager;
this.searchIndexingMetricSet = searchIndexingMetricSet;
this.clock = clock;
this.multiSegmentTermDictionaryManager = multiSegmentTermDictionaryManager;
this.segmentSyncConfig = segmentSyncConfig;
this.retryQueue = retryQueue;
this.criticalExceptionHandler = criticalExceptionHandler;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Indexes all user events.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>public void indexUserEvents() {</dt><dd><p>LOG.info(“Loading/indexing user events.”);
StartupUserEventIndexer startupUserEventIndexer = new StartupUserEventIndexer(</p>
<blockquote>
<div><p>searchIndexingMetricSet,
userUpdatesStreamIndexer,
userScrubGeoEventStreamIndexer,
segmentManager,
clock</p>
</div></blockquote>
<p>);</p>
<p>startupUserEventIndexer.indexAllEvents();
LOG.info(“Finished loading/indexing user events.”);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Loads or indexes from scratch all complete segments.</p></li>
<li></li>
<li><p>&#64;param segmentsToIndexProvider A supplier that provides the list of all complete segments.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>public void indexCompleteSegments(</dt><dd><blockquote>
<div><p>Supplier&lt;Iterable&lt;SegmentInfo&gt;&gt; segmentsToIndexProvider) throws Exception {</p>
</div></blockquote>
<p>List&lt;Thread&gt; segmentIndexers = Lists.newArrayList();</p>
<dl>
<dt>EarlybirdStatus.beginEvent(</dt><dd><p>INDEX_COMPLETED_SEGMENTS, searchIndexingMetricSet.startupInIndexCompletedSegments);</p>
</dd>
<dt>while (!interrupted &amp;&amp; !Thread.currentThread().isInterrupted()) {</dt><dd><dl>
<dt>try {</dt><dd><p>// Get the refreshed list of local segment databases.
segmentManager.updateSegments(segmentDataProvider.newSegmentList());
Iterator&lt;SegmentInfo&gt; segmentsToIndex = segmentsToIndexProvider.get().iterator();</p>
<p>// Start up to max concurrent segment indexers.
segmentIndexers.clear();
while (segmentsToIndex.hasNext() &amp;&amp; segmentIndexers.size() &lt; maxConcurrentSegmentIndexers) {</p>
<blockquote>
<div><p>SegmentInfo nextSegment = segmentsToIndex.next();
if (!nextSegment.isComplete()) {</p>
<blockquote>
<div><dl class="simple">
<dt>Thread thread = new Thread(new SingleSegmentIndexer(nextSegment),</dt><dd><p>“startup-segment-indexer-” + nextSegment.getSegmentName());</p>
</dd>
</dl>
<p>thread.start();
segmentIndexers.add(thread);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// No remaining indexer threads, we’re done.
if (segmentIndexers.size() == 0) {</p>
<blockquote>
<div><p>LOG.info(“Finished indexing complete segments”);
EarlybirdStatus.endEvent(</p>
<blockquote>
<div><p>INDEX_COMPLETED_SEGMENTS, searchIndexingMetricSet.startupInIndexCompletedSegments);</p>
</div></blockquote>
<p>break;</p>
</div></blockquote>
<p>}</p>
<p>// Wait for threads to complete fully.
LOG.info(“Started {} indexing threads”, segmentIndexers.size());
for (Thread thread : segmentIndexers) {</p>
<blockquote>
<div><p>thread.join();</p>
</div></blockquote>
<p>}
LOG.info(“Joined all {} indexing threads”, segmentIndexers.size());</p>
</dd>
<dt>} catch (IOException e) {</dt><dd><p>LOG.error(“IOException in SegmentStartupManager loop”, e);</p>
</dd>
<dt>} catch (InterruptedException e) {</dt><dd><p>interrupted = true;
LOG.error(“Interrupted joining segment indexer thread”, e);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Loads all given complete segments.</p></li>
<li></li>
<li><p>&#64;param completeSegments The list of all complete segments to be loaded.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>public void loadCompleteSegments(List&lt;SegmentInfo&gt; completeSegments) throws Exception {</dt><dd><dl>
<dt>if (!interrupted &amp;&amp; !Thread.currentThread().isInterrupted()) {</dt><dd><p>LOG.info(“Starting to load {} complete segments.”, completeSegments.size());
EarlybirdStatus.beginEvent(</p>
<blockquote>
<div><p>LOAD_COMPLETED_SEGMENTS, searchIndexingMetricSet.startupInLoadCompletedSegments);</p>
</div></blockquote>
<p>List&lt;Thread&gt; segmentThreads = Lists.newArrayList();
List&lt;SegmentInfo&gt; segmentsToBeLoaded = Lists.newArrayList();
for (SegmentInfo segmentInfo : completeSegments) {</p>
<blockquote>
<div><dl>
<dt>if (segmentInfo.isEnabled()) {</dt><dd><p>segmentsToBeLoaded.add(segmentInfo);
Thread segmentLoaderThread = new Thread(</p>
<blockquote>
<div><dl class="simple">
<dt>() -&gt; new SegmentLoader(segmentSyncConfig, criticalExceptionHandler)</dt><dd><p>.load(segmentInfo),</p>
</dd>
</dl>
<p>“startup-segment-loader-” + segmentInfo.getSegmentName());</p>
</div></blockquote>
<p>segmentThreads.add(segmentLoaderThread);
segmentLoaderThread.start();</p>
</dd>
<dt>} else {</dt><dd><p>LOG.info(“Will not load segment {} because it’s disabled.”, segmentInfo.getSegmentName());</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>for (Thread segmentLoaderThread<span class="classifier">segmentThreads) {</span></dt><dd><p>segmentLoaderThread.join();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>for (SegmentInfo segmentInfo<span class="classifier">segmentsToBeLoaded) {</span></dt><dd><dl class="simple">
<dt>if (!segmentInfo.getSyncInfo().isLoaded()) {</dt><dd><p>// Throw an exception if a segment could not be loaded: We do not want earlybirds to
// startup with missing segments.
throw new RuntimeException(“Could not load segment “ + segmentInfo.getSegmentName());</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>LOG.info(“Loaded all complete segments, starting indexing all updates.”);
EarlybirdStatus.beginEvent(</p>
<blockquote>
<div><p>INDEX_UPDATES_FOR_COMPLETED_SEGMENTS,
searchIndexingMetricSet.startupInIndexUpdatesForCompletedSegments);</p>
</div></blockquote>
<p>// Index all updates for all complete segments until we’re fully caught up.
if (!EarlybirdCluster.isArchive(segmentManager.getEarlybirdIndexConfig().getCluster())) {</p>
<blockquote>
<div><p>segmentThreads.clear();
for (SegmentInfo segmentInfo : completeSegments) {</p>
<blockquote>
<div><dl>
<dt>if (segmentInfo.isEnabled()) {</dt><dd><dl>
<dt>Thread segmentUpdatesThread = new Thread(</dt><dd><dl class="simple">
<dt>() -&gt; new SimpleUpdateIndexer(</dt><dd><p>segmentDataProvider.getSegmentDataReaderSet(),
searchIndexingMetricSet,
retryQueue,
criticalExceptionHandler).indexAllUpdates(segmentInfo),</p>
</dd>
</dl>
<p>“startup-complete-segment-update-indexer-” + segmentInfo.getSegmentName());</p>
</dd>
</dl>
<p>segmentThreads.add(segmentUpdatesThread);
segmentUpdatesThread.start();</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>LOG.info(“Will not index updates for segment {} because it’s disabled.”,</dt><dd><p>segmentInfo.getSegmentName());</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>for (Thread segmentUpdatesThread<span class="classifier">segmentThreads) {</span></dt><dd><p>segmentUpdatesThread.join();</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
LOG.info(“Indexed updates for all complete segments.”);
EarlybirdStatus.endEvent(</p>
<blockquote>
<div><p>INDEX_UPDATES_FOR_COMPLETED_SEGMENTS,
searchIndexingMetricSet.startupInIndexUpdatesForCompletedSegments);</p>
</div></blockquote>
<dl class="simple">
<dt>EarlybirdStatus.endEvent(</dt><dd><p>LOAD_COMPLETED_SEGMENTS, searchIndexingMetricSet.startupInLoadCompletedSegments);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Builds the term dictionary that spans all earlybird segments. Some fields share the term</p></li>
<li><p>dictionary across segments as an optimization.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>public void buildMultiSegmentTermDictionary() {</dt><dd><dl class="simple">
<dt>EarlybirdStatus.beginEvent(</dt><dd><p>BUILD_MULTI_SEGMENT_TERM_DICT,
searchIndexingMetricSet.startupInMultiSegmentTermDictionaryUpdates);</p>
</dd>
<dt>if (!interrupted &amp;&amp; !Thread.currentThread().isInterrupted()) {</dt><dd><p>LOG.info(“Building multi segment term dictionaries.”);
boolean built = multiSegmentTermDictionaryManager.buildDictionary();
LOG.info(“Done building multi segment term dictionaries, result: {}”, built);</p>
</dd>
</dl>
<p>}
EarlybirdStatus.endEvent(</p>
<blockquote>
<div><p>BUILD_MULTI_SEGMENT_TERM_DICT,
searchIndexingMetricSet.startupInMultiSegmentTermDictionaryUpdates);</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Warms up the data in the given segments. The warm up will usually make sure that all necessary</p></li>
<li><p>is loaded in RAM and all relevant data structures are created before the segments starts</p></li>
<li><p>serving real requests.</p></li>
<li></li>
<li><p>&#64;param segments The list of segments to warm up.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>public final void warmSegments(Iterable&lt;SegmentInfo&gt; segments) throws InterruptedException {</dt><dd><p>int threadId = 1;
Iterator&lt;SegmentInfo&gt; it = segments.iterator();</p>
<dl>
<dt>try {</dt><dd><p>List&lt;Thread&gt; segmentWarmers = Lists.newLinkedList();
while (it.hasNext()) {</p>
<blockquote>
<div><p>segmentWarmers.clear();
while (it.hasNext() &amp;&amp; segmentWarmers.size() &lt; maxConcurrentSegmentIndexers) {</p>
<blockquote>
<div><p>final SegmentInfo segment = it.next();
Thread t = new Thread(() -&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>new SegmentWarmer(criticalExceptionHandler).warmSegmentIfNecessary(segment),</dt><dd><p>“startup-warmer-” + threadId++);</p>
</dd>
</dl>
</div></blockquote>
<p>t.start();
segmentWarmers.add(t);</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>for (Thread t<span class="classifier">segmentWarmers) {</span></dt><dd><p>t.join();</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>} catch (InterruptedException e) {</dt><dd><p>LOG.error(“Interrupted segment warmer thread”, e);
Thread.currentThread().interrupt();
throw e;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Indexes a complete segment.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>private class SingleSegmentIndexer implements Runnable {</dt><dd><p>private final SegmentInfo segmentInfo;</p>
<dl class="simple">
<dt>public SingleSegmentIndexer(SegmentInfo segmentInfo) {</dt><dd><p>this.segmentInfo = segmentInfo;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public void run() {</p>
<blockquote>
<div><p>// 0) Check if the segment can be loaded. This might copy the segment from HDFS.
if (new SegmentLoader(segmentSyncConfig, criticalExceptionHandler)</p>
<blockquote>
<div><blockquote>
<div><p>.downloadSegment(segmentInfo)) {</p>
</div></blockquote>
<dl class="simple">
<dt>LOG.info(“Will not index segment {} because it was downloaded from HDFS.”,</dt><dd><p>segmentInfo.getSegmentName());</p>
</dd>
</dl>
<p>segmentInfo.setComplete(true);
return;</p>
</div></blockquote>
<p>}</p>
<p>LOG.info(“SingleSegmentIndexer starting for segment: “ + segmentInfo);</p>
<p>// 1) Index all tweets in this segment.
RecordReader&lt;TweetDocument&gt; tweetReader;
try {</p>
<blockquote>
<div><p>tweetReader = segmentDataProvider.getSegmentDataReaderSet().newDocumentReader(segmentInfo);
if (tweetReader != null) {</p>
<blockquote>
<div><p>tweetReader.setExhaustStream(true);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} catch (Exception e) {</dt><dd><p>throw new RuntimeException(“Could not create tweet reader for segment: “ + segmentInfo, e);</p>
</dd>
</dl>
<p>}</p>
<p>new SimpleSegmentIndexer(tweetReader, searchIndexingMetricSet).indexSegment(segmentInfo);</p>
<dl class="simple">
<dt>if (!segmentInfo.isComplete() || segmentInfo.isIndexing()) {</dt><dd><p>throw new RuntimeException(“Segment does not appear to be complete: “ + segmentInfo);</p>
</dd>
</dl>
<p>}</p>
<p>// 2) Index all updates in this segment (archive earlybirds don’t have updates).
if (!EarlybirdCluster.isArchive(segmentManager.getEarlybirdIndexConfig().getCluster())) {</p>
<blockquote>
<div><dl class="simple">
<dt>new SimpleUpdateIndexer(</dt><dd><p>segmentDataProvider.getSegmentDataReaderSet(),
searchIndexingMetricSet,
retryQueue,
criticalExceptionHandler).indexAllUpdates(segmentInfo);</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>// 3) Optimize the segment.
SegmentOptimizer.optimize(segmentInfo);</p>
<p>// 4) Flush to HDFS if necessary.
new SegmentHdfsFlusher(zkTryLockFactory, segmentSyncConfig)</p>
<blockquote>
<div><p>.flushSegmentToDiskAndHDFS(segmentInfo);</p>
</div></blockquote>
<p>// 5) Unload the segment from memory.
segmentInfo.getIndexSegment().close();</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../_sources/src/java/com/twitter/search/earlybird/partition/CompleteSegmentManager.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>