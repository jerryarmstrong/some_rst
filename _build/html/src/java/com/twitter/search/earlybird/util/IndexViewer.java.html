<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../" id="documentation_options" src="../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.earlybird.util;</p>
<p>import java.io.IOException;
import java.io.PrintWriter;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.List;
import java.util.Locale;
import java.util.Set;
import java.util.TreeSet;</p>
<p>import com.google.common.collect.ImmutableSet;
import com.google.common.collect.Lists;</p>
<p>import org.apache.lucene.index.IndexOptions;
import org.apache.lucene.index.NumericDocValues;
import org.apache.lucene.index.PostingsEnum;
import org.apache.lucene.index.Terms;
import org.apache.lucene.index.TermsEnum;
import org.apache.lucene.search.DocIdSetIterator;
import org.apache.lucene.util.BytesRef;</p>
<p>import com.twitter.search.common.constants.thriftjava.ThriftLanguage;
import com.twitter.search.common.schema.base.Schema;
import com.twitter.search.common.schema.earlybird.EarlybirdFieldConstants.EarlybirdFieldConstant;
import com.twitter.search.common.schema.thriftjava.ThriftCSFType;
import com.twitter.search.common.util.analysis.IntTermAttributeImpl;
import com.twitter.search.common.util.analysis.LongTermAttributeImpl;
import com.twitter.search.common.util.analysis.SortableLongTermAttributeImpl;
import com.twitter.search.common.util.spatial.GeoUtil;
import com.twitter.search.core.earlybird.index.DocIDToTweetIDMapper;
import com.twitter.search.core.earlybird.index.EarlybirdIndexSegmentAtomicReader;
import com.twitter.search.core.earlybird.index.inverted.MPHTermDictionary;
import com.twitter.search.core.earlybird.index.inverted.RealtimeIndexTerms;
import com.twitter.search.earlybird.index.EarlybirdSingleSegmentSearcher;</p>
<p>import geo.google.datamodel.GeoCoordinate;</p>
<dl>
<dt>public class IndexViewer {</dt><dd><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Fields whose terms are indexed using</p></li>
<li><p><a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> com.twitter.search.common.util.analysis.IntTermAttribute}</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>private static final Set&lt;String&gt; INT_TERM_ATTRIBUTE_FIELDS = ImmutableSet.of(</dt><dd><p>EarlybirdFieldConstant.CREATED_AT_FIELD.getFieldName(),
EarlybirdFieldConstant.LINK_CATEGORY_FIELD.getFieldName(),
EarlybirdFieldConstant</p>
<blockquote>
<div><p>.NORMALIZED_FAVORITE_COUNT_GREATER_THAN_OR_EQUAL_TO_FIELD.getFieldName(),</p>
</div></blockquote>
<dl class="simple">
<dt>EarlybirdFieldConstant</dt><dd><p>.NORMALIZED_REPLY_COUNT_GREATER_THAN_OR_EQUAL_TO_FIELD.getFieldName(),</p>
</dd>
<dt>EarlybirdFieldConstant</dt><dd><p>.NORMALIZED_RETWEET_COUNT_GREATER_THAN_OR_EQUAL_TO_FIELD.getFieldName(),</p>
</dd>
</dl>
<p>EarlybirdFieldConstant.COMPOSER_SOURCE.getFieldName());</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Fields whose terms are indexed using</p></li>
<li><p><a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> com.twitter.search.common.util.analysis.LongTermAttribute}</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>private static final Set&lt;String&gt; LONG_TERM_ATTRIBUTE_FIELDS = ImmutableSet.of(</dt><dd><p>EarlybirdFieldConstant.CONVERSATION_ID_FIELD.getFieldName(),
EarlybirdFieldConstant.LIKED_BY_USER_ID_FIELD.getFieldName(),
EarlybirdFieldConstant.QUOTED_TWEET_ID_FIELD.getFieldName(),
EarlybirdFieldConstant.QUOTED_USER_ID_FIELD.getFieldName(),
EarlybirdFieldConstant.REPLIED_TO_BY_USER_ID.getFieldName(),
EarlybirdFieldConstant.RETWEETED_BY_USER_ID.getFieldName(),
EarlybirdFieldConstant.DIRECTED_AT_USER_ID_FIELD.getFieldName(),
EarlybirdFieldConstant.FROM_USER_ID_FIELD.getFieldName(),
EarlybirdFieldConstant.IN_REPLY_TO_TWEET_ID_FIELD.getFieldName(),
EarlybirdFieldConstant.IN_REPLY_TO_USER_ID_FIELD.getFieldName(),
EarlybirdFieldConstant.RETWEET_SOURCE_TWEET_ID_FIELD.getFieldName(),
EarlybirdFieldConstant.RETWEET_SOURCE_USER_ID_FIELD.getFieldName());</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Fields whose terms index using SORTED</p></li>
<li><p><a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> com.twitter.search.common.util.analysis.LongTermAttribute}</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>private static final Set&lt;String&gt; SORTED_LONG_TERM_ATTRIBUTE_FIELDS =</dt><dd><p>ImmutableSet.of(EarlybirdFieldConstant.ID_FIELD.getFieldName());</p>
</dd>
</dl>
<p>private final EarlybirdSingleSegmentSearcher searcher;
private final EarlybirdIndexSegmentAtomicReader twitterReader;</p>
<dl class="simple">
<dt>public long getTimeSliceId() {</dt><dd><p>return searcher.getTimeSliceID();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>public static class Options {</dt><dd><p>private boolean dumpHexTerms = false;
private String charset;
private double[] histogramBuckets;
private boolean termLengthHistogram;</p>
<dl class="simple">
<dt>public Options setDumpHexTerms(boolean dumpHexTermsParam) {</dt><dd><p>this.dumpHexTerms = dumpHexTermsParam;
return this;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Options setCharset(String charsetParam) {</dt><dd><p>this.charset = charsetParam;
return this;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Options setHistogramBuckets(double[] histogramBucketsParam) {</dt><dd><p>this.histogramBuckets = histogramBucketsParam;
return this;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Options setTermLengthHistogram(boolean termLengthHistogramParam) {</dt><dd><p>this.termLengthHistogram = termLengthHistogramParam;
return this;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Data Transfer Object for Terms, encapsulates the “json” serialization</p></li>
<li><p>while maintaining streaming mode</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
</dl>
<p>private static class TermDto {</p>
<blockquote>
<div><p>private final String field;
private final String term;
private final String docFreq;
private final String percent;
private final PostingsEnum docsEnum;
private final TermsEnum termsEnum;
private final Integer maxDocs;</p>
<dl>
<dt>public TermDto(String field, String term, String docFreq, String percent,</dt><dd><blockquote>
<div><p>PostingsEnum docsEnum, TermsEnum termsEnum, Integer maxDocs) {</p>
</div></blockquote>
<p>this.field = field;
this.term = term;
this.docFreq = docFreq;
this.percent = percent;
this.docsEnum = docsEnum;
this.termsEnum = termsEnum;
this.maxDocs = maxDocs;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>public void write(ViewerWriter writer,</dt><dd><blockquote>
<div><p>EarlybirdIndexSegmentAtomicReader twitterReader) throws IOException {</p>
</div></blockquote>
<p>writer.beginObject();
writer.name(“field”).value(field);
writer.name(“term”).value(term);
writer.name(“docFreq”).value(docFreq);
writer.name(“percent”).value(percent);
if (docsEnum != null) {</p>
<blockquote>
<div><p>appendFrequencyAndPositions(writer, field, docsEnum, twitterReader);</p>
</div></blockquote>
<p>}
if (maxDocs != null) {</p>
<blockquote>
<div><p>appendDocs(writer, termsEnum, maxDocs, twitterReader);</p>
</div></blockquote>
<p>}
writer.endObject();</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Data Transfer Object for Terms, encapsulates the “json” serialization</p></li>
<li><p>while maintaining streaming mode</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
</dl>
<p>private static class StatsDto {</p>
<blockquote>
<div><p>private final String field;
private final String numTerms;
private final String terms;</p>
<dl class="simple">
<dt>public StatsDto(String field, String numTerms, String terms) {</dt><dd><p>this.field = field;
this.numTerms = numTerms;
this.terms = terms;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>public void write(ViewerWriter writer) throws IOException {</dt><dd><p>writer.beginObject();</p>
<p>writer.name(“field”).value(field);
writer.name(“numTerms”).value(numTerms);
writer.name(“terms”).value(terms);</p>
<p>writer.endObject();</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>public IndexViewer(EarlybirdSingleSegmentSearcher searcher) {</dt><dd><p>this.searcher = searcher;
this.twitterReader = searcher.getTwitterIndexReader();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private boolean shouldSeekExact(Terms terms, TermsEnum termsEnum) {</dt><dd><dl class="simple">
<dt>return terms instanceof RealtimeIndexTerms</dt><dd><p>|| termsEnum instanceof MPHTermDictionary.MPHTermsEnum;</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Dumps all terms for a given tweet id.</p></li>
<li><p>&#64;param writer writer being used</p></li>
<li><p>&#64;param tweetId the tweet id to use</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>public void dumpTweetDataByTweetId(ViewerWriter writer, long tweetId, Options options)</dt><dd><blockquote>
<div><p>throws IOException {</p>
</div></blockquote>
<p>int docId = twitterReader.getSegmentData().getDocIDToTweetIDMapper().getDocID(tweetId);
dumpTweetDataByDocId(writer, docId, options);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Dumps all terms for a given doc id.</p></li>
<li><p>&#64;param writer writer being used</p></li>
<li><p>&#64;param docId the document id to use.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>public void dumpTweetDataByDocId(ViewerWriter writer, int docId, Options options)</dt><dd><blockquote>
<div><p>throws IOException {</p>
</div></blockquote>
<p>writer.beginObject();</p>
<p>printHeader(writer);
long tweetID = twitterReader.getSegmentData().getDocIDToTweetIDMapper().getTweetID(docId);
if (docId &lt; twitterReader.maxDoc() &amp;&amp; tweetID &gt;= 0) {</p>
<blockquote>
<div><p>writer.name(“docId”).value(Integer.toString(docId));
writer.name(“tweetId”).value(Long.toString(tweetID));
dumpIndexedFields(writer, docId, options);
dumpCsfFields(writer, docId);</p>
</div></blockquote>
<p>}
writer.endObject();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Dumps all tweet IDs in the current segment to the given file.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>public void dumpTweetIds(ViewerWriter writer, String logFile, PrintWriter logWriter)</dt><dd><blockquote>
<div><p>throws IOException {</p>
</div></blockquote>
<p>writeTweetIdsToLogFile(logWriter);</p>
<p>writer.beginObject();
writer.name(Long.toString(searcher.getTimeSliceID())).value(logFile);
writer.endObject();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void writeTweetIdsToLogFile(PrintWriter logWriter) {</dt><dd><p>DocIDToTweetIDMapper mapper = twitterReader.getSegmentData().getDocIDToTweetIDMapper();
int docId = Integer.MIN_VALUE;
while ((docId = mapper.getNextDocID(docId)) != DocIDToTweetIDMapper.ID_NOT_FOUND) {</p>
<blockquote>
<div><p>long tweetId = mapper.getTweetID(docId);</p>
<p>// Ensure tweet ID is valid and non-deleted
if ((tweetId &gt; 0) &amp;&amp; !twitterReader.getDeletesView().isDeleted(docId)) {</p>
<blockquote>
<div><p>logWriter.println(tweetId);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void dumpIndexedFields(ViewerWriter writer, int docId,</dt><dd><blockquote>
<div><p>Options options) throws IOException {</p>
</div></blockquote>
<p>writer.name(“indexedFields”);
writer.beginArray();
writer.newline();
for (String field : sortedFields()) {</p>
<blockquote>
<div><p>dumpTweetData(writer, field, docId, options);</p>
</div></blockquote>
<p>}
writer.endArray();
writer.newline();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void dumpCsfFields(ViewerWriter writer, int docId) throws IOException {</dt><dd><p>writer.name(“csfFields”);
writer.beginArray();
writer.newline();
dumpCSFData(writer, docId);</p>
<p>writer.endArray();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Dumps all CSF values for a given doc id.</p></li>
<li><p>&#64;param writer writer being used</p></li>
<li><p>&#64;param docId the document id to use.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>private void dumpCSFData(ViewerWriter writer, int docId) throws IOException {</dt><dd><p>Schema tweetSchema = twitterReader.getSchema();</p>
<p>// Sort the FieldInfo objects to generate fixed order to make testing easier
List&lt;Schema.FieldInfo&gt; sortedFieldInfos = new ArrayList&lt;&gt;(tweetSchema.getFieldInfos());
sortedFieldInfos.sort(Comparator.comparing(Schema.FieldInfo::getFieldId));</p>
<dl>
<dt>for (Schema.FieldInfo fieldInfo: sortedFieldInfos) {</dt><dd><p>String csfFieldInfoName = fieldInfo.getName();
ThriftCSFType csfType = tweetSchema.getCSFFieldType(csfFieldInfoName);
NumericDocValues csfDocValues = twitterReader.getNumericDocValues(csfFieldInfoName);
// If twitterReader.getNumericDocValues(value.getName()) == null,
// means no NumericDocValue was indexed for the field so ignore
if (csfType != null &amp;&amp; csfDocValues != null &amp;&amp; csfDocValues.advanceExact(docId)) {</p>
<blockquote>
<div><p>long csfValue = csfDocValues.longValue();
writer.beginObject();
writer.name(“field”).value(formatField(csfFieldInfoName));
writer.name(“value”);
if (csfFieldInfoName.equals(EarlybirdFieldConstant.LAT_LON_CSF_FIELD.getFieldName())) {</p>
<blockquote>
<div><p>writer.value(latlongDecode(csfValue));</p>
</div></blockquote>
<dl class="simple">
<dt>} else if (csfFieldInfoName.equals(EarlybirdFieldConstant.LANGUAGE.getFieldName())) {</dt><dd><p>writer.value(languageDecode(csfValue));</p>
</dd>
<dt>} else if (csfFieldInfoName.equals(EarlybirdFieldConstant.CARD_LANG_CSF.getFieldName())) {</dt><dd><p>writer.value(languageDecode(csfValue));</p>
</dd>
<dt>} else {</dt><dd><p>writer.value(Long.toString(csfValue));</p>
</dd>
</dl>
<p>}
writer.endObject();
writer.newline();</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Decipher long value gotten, put into format (lat, lon)</p></li>
<li><p>Decode the stored long value by creating a geocode</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>private String latlongDecode(long csfValue) {</dt><dd><p>StringBuilder sb = new StringBuilder();
GeoCoordinate geoCoordinate = new GeoCoordinate();
if (GeoUtil.decodeLatLonFromInt64(csfValue, geoCoordinate)) {</p>
<blockquote>
<div><p>sb.append(geoCoordinate.getLatitude()).append(”, “).append(geoCoordinate.getLongitude());</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>sb.append(csfValue).append(” (Value Unset or Invalid Coordinate)”);</p>
</dd>
</dl>
<p>}
return sb.toString();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Decipher long value gotten into string of tweet’s language</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
<dt>private String languageDecode(long csfValue) {</dt><dd><p>StringBuilder sb = new StringBuilder();
ThriftLanguage languageType = ThriftLanguage.findByValue((int) csfValue);
sb.append(csfValue).append(” (“).append(languageType).append(“)”);
return sb.toString();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void dumpTweetData(ViewerWriter writer,</dt><dd><blockquote>
<div><p>String field,
int docId,
Options options) throws IOException {</p>
</div></blockquote>
<p>Terms terms = twitterReader.terms(field);
if (terms != null) {</p>
<blockquote>
<div><p>TermsEnum termsEnum = terms.iterator();
if (shouldSeekExact(terms, termsEnum)) {</p>
<blockquote>
<div><p>long numTerms = terms.size();
for (int i = 0; i &lt; numTerms; i++) {</p>
<blockquote>
<div><p>termsEnum.seekExact(i);
dumpTweetDataTerm(writer, field, termsEnum, docId, options);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><dl class="simple">
<dt>while (termsEnum.next() != null) {</dt><dd><p>dumpTweetDataTerm(writer, field, termsEnum, docId, options);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void dumpTweetDataTerm(ViewerWriter writer, String field, TermsEnum termsEnum,</dt><dd><blockquote>
<div><p>int docId, Options options) throws IOException {</p>
</div></blockquote>
<p>PostingsEnum docsAndPositionsEnum = termsEnum.postings(null, PostingsEnum.ALL);
if (docsAndPositionsEnum != null &amp;&amp; docsAndPositionsEnum.advance(docId) == docId) {</p>
<blockquote>
<div><p>printTerm(writer, field, termsEnum, docsAndPositionsEnum, null, options);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Prints the histogram for the currently viewed index.</p></li>
<li><p>&#64;param writer current viewerWriter</p></li>
<li><p>&#64;param field if null, will use all fields</p></li>
<li><p>&#64;param options options for dumping out text</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>public void dumpHistogram(ViewerWriter writer, String field, Options options) throws IOException {</dt><dd><p>writer.beginObject();
printHeader(writer);
writer.name(“histogram”);
writer.beginArray();
writer.newline();
if (field == null) {</p>
<blockquote>
<div><dl class="simple">
<dt>for (String field2<span class="classifier">sortedFields()) {</span></dt><dd><p>dumpFieldHistogram(writer, field2, options);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>dumpFieldHistogram(writer, field, options);</p>
</dd>
</dl>
<p>}
writer.endArray();
writer.endObject();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void dumpFieldHistogram(ViewerWriter writer, String field, Options options)</dt><dd><blockquote>
<div><p>throws IOException {</p>
</div></blockquote>
<p>Histogram histo = new Histogram(options.histogramBuckets);</p>
<p>Terms terms = twitterReader.terms(field);
if (terms != null) {</p>
<blockquote>
<div><p>TermsEnum termsEnum = terms.iterator();
if (shouldSeekExact(terms, termsEnum)) {</p>
<blockquote>
<div><p>long numTerms = terms.size();
for (int i = 0; i &lt; numTerms; i++) {</p>
<blockquote>
<div><p>termsEnum.seekExact(i);
countHistogram(options, histo, termsEnum);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><dl class="simple">
<dt>while (termsEnum.next() != null) {</dt><dd><p>countHistogram(options, histo, termsEnum);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
printHistogram(writer, field, options, histo);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void printHistogram(ViewerWriter writer, String field, Options options,</dt><dd><blockquote>
<div><p>Histogram histo) throws IOException {</p>
</div></blockquote>
<p>String bucket = options.termLengthHistogram ? “termLength” : “df”;
for (Histogram.Entry histEntry : histo.entries()) {</p>
<blockquote>
<div><dl>
<dt>String format =</dt><dd><dl>
<dt>String.format(Locale.US,</dt><dd><dl class="simple">
<dt>“field: %s %sBucket: %11s count: %10d “</dt><dd><ul class="simple">
<li><p>“percent: %6.2f%% cumulative: %6.2f%% totalCount: %10d”</p></li>
<li><p>“ sum: %15d percent: %6.2f%% cumulative: %6.2f%% totalSum: %15d”,</p></li>
</ul>
</dd>
</dl>
<p>formatField(field),
bucket,
histEntry.getBucketName(),
histEntry.getCount(),
histEntry.getCountPercent() * 100.0,
histEntry.getCountCumulative() * 100.0,
histo.getTotalCount(),
histEntry.getSum(),
histEntry.getSumPercent() * 100.0,
histEntry.getSumCumulative() * 100.0,
histo.getTotalSum()</p>
</dd>
</dl>
<p>);</p>
</dd>
</dl>
<p>writer.value(format);
writer.newline();</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void countHistogram(Options options, Histogram histo, TermsEnum termsEnum)</dt><dd><blockquote>
<div><p>throws IOException {</p>
</div></blockquote>
<dl class="simple">
<dt>if (options.termLengthHistogram) {</dt><dd><p>final BytesRef bytesRef = termsEnum.term();
histo.addItem(bytesRef.length);</p>
</dd>
<dt>} else {</dt><dd><p>histo.addItem(termsEnum.docFreq());</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Prints terms and optionally documents for the currently viewed index.</p></li>
<li><p>&#64;param writer writer being used</p></li>
<li><p>&#64;param field if null, will use all fields</p></li>
<li><p>&#64;param term if null will use all terms</p></li>
<li><p>&#64;param maxTerms will print at most this many terms per field. If null will print 0 terms.</p></li>
<li><p>&#64;param maxDocs will print at most this many documents, If null, will not print docs.</p></li>
<li><p>&#64;param options options for dumping out text</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
<dt>public void dumpData(ViewerWriter writer, String field, String term, Integer maxTerms,</dt><dd><blockquote>
<div><p>Integer maxDocs, Options options, boolean shouldSeekToTerm) throws IOException {</p>
</div></blockquote>
<p>writer.beginObject();
printHeader(writer);</p>
<p>writer.name(“terms”);
writer.beginArray();
writer.newline();
dumpDataInternal(writer, field, term, maxTerms, maxDocs, options, shouldSeekToTerm);
writer.endArray();
writer.endObject();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void dumpDataInternal(ViewerWriter writer, String field, String term, Integer maxTerms,</dt><dd><blockquote>
<div><p>Integer maxDocs, Options options, boolean shouldSeekToTerm) throws IOException {</p>
</div></blockquote>
<dl class="simple">
<dt>if (field == null) {</dt><dd><p>dumpDataForAllFields(writer, term, maxTerms, maxDocs, options);
return;</p>
</dd>
</dl>
<p>}
if (term == null) {</p>
<blockquote>
<div><p>dumpDataForAllTerms(writer, field, maxTerms, maxDocs, options);
return;</p>
</div></blockquote>
<p>}
Terms terms = twitterReader.terms(field);
if (terms != null) {</p>
<blockquote>
<div><p>TermsEnum termsEnum = terms.iterator();
TermsEnum.SeekStatus status = termsEnum.seekCeil(new BytesRef(term));
if (status == TermsEnum.SeekStatus.FOUND) {</p>
<blockquote>
<div><p>printTerm(writer, field, termsEnum, null, maxDocs, options);</p>
</div></blockquote>
<p>}
if (shouldSeekToTerm) {</p>
<blockquote>
<div><p>dumpTermsAfterSeek(writer, field, terms, maxTerms, maxDocs, options, termsEnum, status);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>if term (cursor) is found for an indexed segment - dump the next termsLeft words</p></li>
<li><p>starting from the current position in the enum.  For an indexed segment,</p></li>
<li><p>seekCeil will place the enum at the word or the next “ceiling” term.  For</p></li>
<li><p>a realtime index, if the word is not found we do not paginate anything</p></li>
<li><p>We also only paginate if the TermsEnum is not at the end.</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
<dt>private void dumpTermsAfterSeek(ViewerWriter writer, String field, Terms terms, Integer maxTerms,</dt><dd><blockquote>
<div><p>Integer maxDocs, Options options, TermsEnum termsEnum, TermsEnum.SeekStatus status)
throws IOException {</p>
</div></blockquote>
<dl>
<dt>if (status != TermsEnum.SeekStatus.END) {</dt><dd><p>// for realtime, to not repeat the found word
if (shouldSeekExact(terms, termsEnum)) {</p>
<blockquote>
<div><p>termsEnum.next();</p>
</div></blockquote>
<p>}
if (status != TermsEnum.SeekStatus.FOUND) {</p>
<blockquote>
<div><p>// if not found, print out curr term before calling next()
printTerm(writer, field, termsEnum, null, maxDocs, options);</p>
</div></blockquote>
<p>}
for (int termsLeft = maxTerms - 1; termsLeft &gt; 0 &amp;&amp; termsEnum.next() != null; termsLeft–) {</p>
<blockquote>
<div><p>printTerm(writer, field, termsEnum, null, maxDocs, options);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void dumpDataForAllFields(ViewerWriter writer, String term, Integer maxTerms,</dt><dd><blockquote>
<div><p>Integer maxDocs, Options options) throws IOException {</p>
</div></blockquote>
<dl class="simple">
<dt>for (String field<span class="classifier">sortedFields()) {</span></dt><dd><p>dumpDataInternal(writer, field, term, maxTerms, maxDocs, options, false);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private List&lt;String&gt; sortedFields() {</dt><dd><p>// Tweet facets are added to a special $facets field, which is not part of the schema.
// We include it here, because seeing the facets for a tweet is generally useful.
List&lt;String&gt; fields = Lists.newArrayList(“$facets”);
for (Schema.FieldInfo fieldInfo : twitterReader.getSchema().getFieldInfos()) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (fieldInfo.getFieldType().indexOptions() != IndexOptions.NONE) {</dt><dd><p>fields.add(fieldInfo.getName());</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
Collections.sort(fields);
return fields;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void dumpDataForAllTerms(ViewerWriter writer,</dt><dd><blockquote>
<div><p>String field,
Integer maxTerms,
Integer maxDocs,
Options options) throws IOException {</p>
</div></blockquote>
<p>Terms terms = twitterReader.terms(field);
if (terms != null) {</p>
<blockquote>
<div><p>TermsEnum termsEnum = terms.iterator();
if (shouldSeekExact(terms, termsEnum)) {</p>
<blockquote>
<div><p>long numTerms = terms.size();
long termToDump = maxTerms == null ? 0 : Math.min(numTerms, maxTerms);
for (int i = 0; i &lt; termToDump; i++) {</p>
<blockquote>
<div><p>termsEnum.seekExact(i);
printTerm(writer, field, termsEnum, null, maxDocs, options);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>int max = maxTerms == null ? 0 : maxTerms;
while (max &gt; 0 &amp;&amp; termsEnum.next() != null) {</p>
<blockquote>
<div><p>printTerm(writer, field, termsEnum, null, maxDocs, options);
max–;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private String termToString(String field, BytesRef bytesTerm, Options options)</dt><dd><blockquote>
<div><p>throws UnsupportedEncodingException {</p>
</div></blockquote>
<dl>
<dt>if (INT_TERM_ATTRIBUTE_FIELDS.contains(field)) {</dt><dd><p>return Integer.toString(IntTermAttributeImpl.copyBytesRefToInt(bytesTerm));</p>
</dd>
<dt>} else if (LONG_TERM_ATTRIBUTE_FIELDS.contains(field)) {</dt><dd><p>return Long.toString(LongTermAttributeImpl.copyBytesRefToLong(bytesTerm));</p>
</dd>
<dt>} else if (SORTED_LONG_TERM_ATTRIBUTE_FIELDS.contains(field)) {</dt><dd><p>return Long.toString(SortableLongTermAttributeImpl.copyBytesRefToLong(bytesTerm));</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>if (options != null &amp;&amp; options.charset != null &amp;&amp; !options.charset.isEmpty()) {</dt><dd><p>return new String(bytesTerm.bytes, bytesTerm.offset, bytesTerm.length, options.charset);</p>
</dd>
<dt>} else {</dt><dd><p>return bytesTerm.utf8ToString();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void printTerm(ViewerWriter writer, String field, TermsEnum termsEnum,</dt><dd><blockquote>
<div><blockquote>
<div><p>PostingsEnum docsEnum, Integer maxDocs, Options options)</p>
</div></blockquote>
<p>throws IOException {</p>
</div></blockquote>
<p>final BytesRef bytesRef = termsEnum.term();
StringBuilder termToString = new StringBuilder();
termToString.append(termToString(field, bytesRef, options));
if (options != null &amp;&amp; options.dumpHexTerms) {</p>
<blockquote>
<div><p>termToString.append(” “).append(bytesRef.toString());</p>
</div></blockquote>
<p>}
final int df = termsEnum.docFreq();
double dfPercent = ((double) df / this.twitterReader.numDocs()) * 100.0;
TermDto termDto = new TermDto(field, termToString.toString(), Integer.toString(df),</p>
<blockquote>
<div><p>String.format(Locale.US, “%.2f%%”, dfPercent),
docsEnum, termsEnum, maxDocs);</p>
</div></blockquote>
<p>termDto.write(writer, twitterReader);
writer.newline();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private static void appendFrequencyAndPositions(ViewerWriter writer, String field,</dt><dd><blockquote>
<div><p>PostingsEnum docsEnum, EarlybirdIndexSegmentAtomicReader twitterReader) throws IOException {</p>
</div></blockquote>
<p>final int frequency = docsEnum.freq();
writer.name(“freq”).value(Integer.toString(frequency));</p>
<p>Schema schema = twitterReader.getSchema();
Schema.FieldInfo fieldInfo = schema.getFieldInfo(field);</p>
<dl>
<dt>if (fieldInfo != null</dt><dd><blockquote>
<div><p>&amp;&amp; (fieldInfo.getFieldType().indexOptions() == IndexOptions.DOCS_AND_FREQS_AND_POSITIONS
|| fieldInfo.getFieldType().indexOptions()</p>
<blockquote>
<div><p>== IndexOptions.DOCS_AND_FREQS_AND_POSITIONS_AND_OFFSETS)) {</p>
</div></blockquote>
</div></blockquote>
<p>appendPositions(writer, docsEnum);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private static void appendPositions(ViewerWriter writer, PostingsEnum docsAndPositionsEnum)</dt><dd><blockquote>
<div><p>throws IOException {</p>
</div></blockquote>
<p>writer.name(“positions”);</p>
<p>writer.beginArray();
final int frequency = docsAndPositionsEnum.freq();
for (int i = 0; i &lt; frequency; i++) {</p>
<blockquote>
<div><p>int position = docsAndPositionsEnum.nextPosition();
writer.value(Integer.toString(position));</p>
</div></blockquote>
<p>}
writer.endArray();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private static void appendDocs(ViewerWriter writer, TermsEnum termsEnum, int maxDocs,</dt><dd><blockquote>
<div><blockquote>
<div><p>EarlybirdIndexSegmentAtomicReader twitterReader)</p>
</div></blockquote>
<p>throws IOException {</p>
</div></blockquote>
<p>writer.name(“docIds”);</p>
<p>writer.beginArray();</p>
<p>PostingsEnum docs = termsEnum.postings(null, 0);
int docsReturned = 0;
int docId;
boolean endedEarly = false;
DocIDToTweetIDMapper mapper = twitterReader.getSegmentData().getDocIDToTweetIDMapper();
while ((docId = docs.nextDoc()) != DocIdSetIterator.NO_MORE_DOCS) {</p>
<blockquote>
<div><dl>
<dt>if (docsReturned &lt; maxDocs) {</dt><dd><p>docsReturned++;
long tweetID = mapper.getTweetID(docId);</p>
<p>writer.beginObject();
writer.name(“docId”).value(Long.toString(docId));
writer.name(“tweetId”).value(Long.toString(tweetID));
writer.endObject();</p>
</dd>
<dt>} else {</dt><dd><p>endedEarly = true;
break;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if (endedEarly) {</p>
<blockquote>
<div><p>writer.beginObject();
writer.name(“status”).value(“ended early”);
writer.endObject();</p>
</div></blockquote>
<p>}
writer.endArray();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Prints generic stats for all fields in the currently viewed index.</p></li>
</ul>
<p><a href="#id29"><span class="problematic" id="id30">*</span></a>/</p>
</dd>
<dt>public void dumpStats(ViewerWriter writer) throws IOException {</dt><dd><p>writer.beginObject();</p>
<p>printHeader(writer);
// stats section
writer.name(“stats”);
writer.beginArray();
writer.newline();
for (String field : sortedFields()) {</p>
<blockquote>
<div><p>Terms terms = twitterReader.terms(field);
if (terms != null) {</p>
<blockquote>
<div><p>printStats(writer, field, terms);</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}
writer.endArray();
writer.endObject();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void printStats(ViewerWriter writer, String field, Terms terms) throws IOException {</dt><dd><dl class="simple">
<dt>StatsDto statsDto = new StatsDto(</dt><dd><p>field, String.valueOf(terms.size()), terms.getClass().getCanonicalName());</p>
</dd>
</dl>
<p>statsDto.write(writer);
writer.newline();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private void printHeader(ViewerWriter writer) throws IOException {</dt><dd><p>writer.name(“timeSliceId”).value(Long.toString(this.searcher.getTimeSliceID()));
writer.name(“maxDocNumber”).value(Integer.toString(this.twitterReader.maxDoc()));
writer.newline();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private static String formatField(String field) {</dt><dd><p>return String.format(“%20s”, field);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Dumps out the schema of the current segment.</p></li>
<li><p>&#64;param writer to be used for printing</p></li>
</ul>
<p><a href="#id31"><span class="problematic" id="id32">*</span></a>/</p>
</dd>
<dt>public void dumpSchema(ViewerWriter writer) throws IOException {</dt><dd><p>writer.beginObject();
printHeader(writer);
writer.name(“schemaFields”);
writer.beginArray();
writer.newline();
Schema schema = this.twitterReader.getSchema();
// The fields in the schema are not sorted. Sort them so that the output is deterministic
Set&lt;String&gt; fieldNameSet = new TreeSet&lt;&gt;();
for (Schema.FieldInfo fieldInfo: schema.getFieldInfos()) {</p>
<blockquote>
<div><p>fieldNameSet.add(fieldInfo.getName());</p>
</div></blockquote>
<p>}
for (String fieldName : fieldNameSet) {</p>
<blockquote>
<div><p>writer.value(fieldName);
writer.newline();</p>
</div></blockquote>
<p>}
writer.endArray();
writer.endObject();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Dumps out the indexed fields inside the current segment.</p></li>
<li><p>Mainly used to help the front end populate the fields.</p></li>
<li><p>&#64;param writer writer to be used for printing</p></li>
</ul>
<p><a href="#id33"><span class="problematic" id="id34">*</span></a>/</p>
</dd>
<dt>public void dumpFields(ViewerWriter writer) throws IOException {</dt><dd><p>writer.beginObject();
printHeader(writer);
writer.name(“fields”);
writer.beginArray();
writer.newline();
for (String field : sortedFields()) {</p>
<blockquote>
<div><p>writer.value(field);
writer.newline();</p>
</div></blockquote>
<p>}
writer.endArray();
writer.endObject();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Dumps out the mapping of the tweet/tweetId to</p></li>
<li><p>a docId as well as segment/timeslide pair.</p></li>
<li><p>&#64;param writer writer to be used for writing</p></li>
<li><p>&#64;param tweetId tweetId that is input by user</p></li>
</ul>
<p><a href="#id35"><span class="problematic" id="id36">*</span></a>/</p>
</dd>
<dt>public void dumpTweetIdToDocIdMapping(ViewerWriter writer, long tweetId) throws IOException {</dt><dd><p>writer.beginObject();
printHeader(writer);
writer.name(“tweetId”).value(Long.toString(tweetId));
int docId = twitterReader.getSegmentData().getDocIDToTweetIDMapper().getDocID(tweetId);</p>
<p>writer.name(“docId”).value(Integer.toString(docId));
writer.endObject();
writer.newline();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Dumps out the mapping of the docId to</p></li>
<li><p>tweetId and timeslice/segmentId pairs.</p></li>
<li><p>&#64;param writer writer to be used for writing</p></li>
<li><p>&#64;param docid docId that is input by user</p></li>
</ul>
<p><a href="#id37"><span class="problematic" id="id38">*</span></a>/</p>
</dd>
<dt>public void dumpDocIdToTweetIdMapping(ViewerWriter writer, int docid) throws IOException {</dt><dd><p>writer.beginObject();
printHeader(writer);
long tweetId = twitterReader.getSegmentData().getDocIDToTweetIDMapper().getTweetID(docid);</p>
<p>writer.name(“tweetId”);
if (tweetId &gt;= 0) {</p>
<blockquote>
<div><p>writer.value(Long.toString(tweetId));</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>writer.value(“Does not exist in segment”);</p>
</dd>
</dl>
<p>}
writer.name(“docid”).value(Integer.toString(docid));
writer.endObject();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Print a response indicating that the given tweet id is not found in the index.</p></li>
<li></li>
<li><p>Note that this method does not actually need the underlying index, and hence is setup as</p></li>
<li><p>a util function.</p></li>
</ul>
<p><a href="#id39"><span class="problematic" id="id40">*</span></a>/</p>
</dd>
<dt>public static void writeTweetDoesNotExistResponse(ViewerWriter writer, long tweetId)</dt><dd><blockquote>
<div><p>throws IOException {</p>
</div></blockquote>
<p>writer.beginObject();
writer.name(“tweetId”);
writer.value(Long.toString(tweetId));
writer.name(“docId”);
writer.value(“does not exist on this earlybird.”);
writer.endObject();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../_sources/src/java/com/twitter/search/earlybird/util/IndexViewer.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>