<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.common.util.ml.models_manager;</p>
<p>import java.io.BufferedReader;
import java.io.IOException;
import java.io.UncheckedIOException;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.function.Function;
import java.util.function.Supplier;
import java.util.stream.Collectors;</p>
<p>import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.base.Strings;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Sets;
import com.google.common.util.concurrent.ThreadFactoryBuilder;</p>
<p>import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.yaml.snakeyaml.Yaml;</p>
<p>import com.twitter.search.common.file.AbstractFile;
import com.twitter.search.common.file.FileUtils;
import com.twitter.search.common.metrics.SearchCounter;
import com.twitter.search.common.metrics.SearchLongGauge;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Loads models from HDFS and provides an interface for reloading them periodically.</p></li>
<li></li>
<li><p>There are 2 possible ways of detecting the active models:</p></li>
<li></li>
<li><ul>
<li><p>DirectorySupplier: Uses all the subdirectories of a base path</p></li>
</ul>
</li>
<li><ul>
<li><p>ConfigSupplier: Gets the list from from a configuration file</p></li>
</ul>
</li>
<li></li>
<li><p>Models can be updated or added. Depending on the selected method, existing models can be removed</p></li>
<li><p>if they are no longer active.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public abstract class BaseModelsManager&lt;T&gt; implements Runnable {</dt><dd><p>private static final Logger LOG = LoggerFactory.getLogger(BaseModelsManager.class);</p>
<p>protected final Map&lt;String, Long&gt; lastModifiedMsByModel = new ConcurrentHashMap&lt;&gt;();
protected final Map&lt;String, T&gt; loadedModels = new ConcurrentHashMap&lt;&gt;();
protected final Supplier&lt;Map&lt;String, AbstractFile&gt;&gt; activeModelsSupplier;</p>
<p>protected Map&lt;String, T&gt; prevLoadedModels = new ConcurrentHashMap&lt;&gt;();</p>
<p>// This flag determines whether models are unloaded immediately when they’re removed from
// activeModelsSupplier. If false, old models stay in memory until the process is restarted.
// This may be useful to safely change model configuration without restarting.
protected final boolean shouldUnloadInactiveModels;</p>
<p>protected final SearchLongGauge numModels;
protected final SearchCounter numErrors;
protected final SearchLongGauge lastLoadedMs;</p>
<p>protected Supplier&lt;Boolean&gt; shouldServeModels;
protected Supplier&lt;Boolean&gt; shouldLoadModels;</p>
<dl>
<dt>public BaseModelsManager(</dt><dd><p>Supplier&lt;Map&lt;String, AbstractFile&gt;&gt; activeModelsSupplier,
boolean shouldUnloadInactiveModels,
String statsPrefix</p>
</dd>
<dt>) {</dt><dd><dl class="simple">
<dt>this(</dt><dd><p>activeModelsSupplier,
shouldUnloadInactiveModels,
statsPrefix,
() -&gt; true,
() -&gt; true</p>
</dd>
</dl>
<p>);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>public BaseModelsManager(</dt><dd><p>Supplier&lt;Map&lt;String, AbstractFile&gt;&gt; activeModelsSupplier,
boolean shouldUnloadInactiveModels,
String statsPrefix,
Supplier&lt;Boolean&gt; shouldServeModels,
Supplier&lt;Boolean&gt; shouldLoadModels</p>
</dd>
<dt>) {</dt><dd><p>this.activeModelsSupplier = activeModelsSupplier;
this.shouldUnloadInactiveModels = shouldUnloadInactiveModels;</p>
<p>this.shouldServeModels = shouldServeModels;
this.shouldLoadModels = shouldLoadModels;</p>
<dl class="simple">
<dt>numModels = SearchLongGauge.export(</dt><dd><p>String.format(“model_loader_%s_num_models”, statsPrefix));</p>
</dd>
<dt>numErrors = SearchCounter.export(</dt><dd><p>String.format(“model_loader_%s_num_errors”, statsPrefix));</p>
</dd>
<dt>lastLoadedMs = SearchLongGauge.export(</dt><dd><p>String.format(“model_loader_%s_last_loaded_timestamp_ms”, statsPrefix));</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Retrieves a particular model.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>public Optional&lt;T&gt; getModel(String name) {</dt><dd><dl class="simple">
<dt>if (shouldServeModels.get()) {</dt><dd><p>return Optional.ofNullable(loadedModels.get(name));</p>
</dd>
<dt>} else {</dt><dd><p>return Optional.empty();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Reads a model instance from the directory file instance.</p></li>
<li></li>
<li><p>&#64;param modelBaseDir AbstractFile instance representing the directory.</p></li>
<li><p>&#64;return Model instance parsed from the directory.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
</dl>
<p>public abstract T readModelFromDirectory(AbstractFile modelBaseDir) throws Exception;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Cleans up any resources used by the model instance.</p></li>
<li><p>This method is called after removing the model from the in-memory map.</p></li>
<li><p>Sub-classes can provide custom overridden implementation as required.</p></li>
<li></li>
<li><p>&#64;param unloadedModel Model instance that would be unloaded from the manager.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
</dl>
<p>protected void cleanUpUnloadedModel(T unloadedModel) { }</p>
<p>&#64;Override
public void run() {</p>
<blockquote>
<div><p>// Get available models, either from the config file or by listing the base directory
final Map&lt;String, AbstractFile&gt; modelPathsFromConfig;
if (!shouldLoadModels.get()) {</p>
<blockquote>
<div><p>LOG.info(“Loading models is currently disabled.”);
return;</p>
</div></blockquote>
<p>}</p>
<p>modelPathsFromConfig = activeModelsSupplier.get();
for (Map.Entry&lt;String, AbstractFile&gt; nameAndPath : modelPathsFromConfig.entrySet()) {</p>
<blockquote>
<div><p>String modelName = nameAndPath.getKey();
try {</p>
<blockquote>
<div><p>AbstractFile modelDirectory = nameAndPath.getValue();
if (!modelDirectory.exists() &amp;&amp; loadedModels.containsKey(modelName)) {</p>
<blockquote>
<div><dl class="simple">
<dt>LOG.warn(“Loaded model ‘{}’ no longer exists at HDFS path {}, keeping loaded version; “</dt><dd><ul class="simple">
<li><p>“replace directory in HDFS to update model.”, modelName, modelDirectory);</p></li>
</ul>
</dd>
</dl>
<p>continue;</p>
</div></blockquote>
<p>}</p>
<p>long previousModifiedTimestamp = lastModifiedMsByModel.getOrDefault(modelName, 0L);
long lastModifiedMs = modelDirectory.getLastModified();
if (previousModifiedTimestamp == lastModifiedMs) {</p>
<blockquote>
<div><p>continue;</p>
</div></blockquote>
<p>}</p>
<p>LOG.info(“Starting to load model. name={} path={}”, modelName, modelDirectory.getPath());
T model = Preconditions.checkNotNull(readModelFromDirectory(modelDirectory));
LOG.info(“Model initialized: {}. Last modified: {} ({})”,</p>
<blockquote>
<div><p>modelName, lastModifiedMs, new Date(lastModifiedMs));</p>
</div></blockquote>
<p>T previousModel = loadedModels.put(modelName, model);
lastModifiedMsByModel.put(modelName, lastModifiedMs);</p>
<dl class="simple">
<dt>if (previousModel != null) {</dt><dd><p>cleanUpUnloadedModel(previousModel);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} catch (Exception e) {</dt><dd><p>numErrors.increment();
LOG.error(“Error initializing model: {}”, modelName, e);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Remove any currently loaded models not present in the latest list
if (shouldUnloadInactiveModels) {</p>
<blockquote>
<div><dl>
<dt>Set&lt;String&gt; inactiveModels =</dt><dd><p>Sets.difference(loadedModels.keySet(), modelPathsFromConfig.keySet()).immutableCopy();</p>
</dd>
<dt>for (String modelName<span class="classifier">inactiveModels) {</span></dt><dd><p>T modelToUnload = loadedModels.get(modelName);
loadedModels.remove(modelName);</p>
<dl class="simple">
<dt>if (modelToUnload != null) {</dt><dd><p>// We could have an inactive model key without a model (value) if the
// initial readModelFromDirectory failed for the model entry.
// Checking for null to avoid exception.
cleanUpUnloadedModel(modelToUnload);</p>
</dd>
</dl>
<p>}
LOG.info(“Unloaded model that is no longer active: {}”, modelName);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>if (!prevLoadedModels.keySet().equals(loadedModels.keySet())) {</dt><dd><p>LOG.info(“Finished loading models: {}”, loadedModels.keySet());</p>
</dd>
</dl>
<p>}
prevLoadedModels = loadedModels;
numModels.set(loadedModels.size());
lastLoadedMs.set(System.currentTimeMillis());</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Schedules the loader to run periodically.</p></li>
<li><p>&#64;param period Period between executions</p></li>
<li><p>&#64;param timeUnit The time unit the period parameter.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>public final void scheduleAtFixedRate(</dt><dd><blockquote>
<div><p>long period, TimeUnit timeUnit, String builderThreadName) {</p>
</div></blockquote>
<dl>
<dt>Executors.newSingleThreadScheduledExecutor(</dt><dd><dl class="simple">
<dt>new ThreadFactoryBuilder()</dt><dd><p>.setDaemon(true)
.setNameFormat(builderThreadName)
.build())</p>
</dd>
</dl>
<p>.scheduleAtFixedRate(this, 0, period, timeUnit);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Gets the active list of models from the subdirectories in a base directory.</p></li>
<li></li>
<li><p>Each model is identified by the name of the subdirectory.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
</dl>
<p>&#64;VisibleForTesting
public static class DirectorySupplier implements Supplier&lt;Map&lt;String, AbstractFile&gt;&gt; {</p>
<blockquote>
<div><p>private static final Logger LOG = LoggerFactory.getLogger(DirectorySupplier.class);
private final AbstractFile baseDir;</p>
<dl class="simple">
<dt>public DirectorySupplier(AbstractFile baseDir) {</dt><dd><p>this.baseDir = baseDir;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public Map&lt;String, AbstractFile&gt; get() {</p>
<blockquote>
<div><dl>
<dt>try {</dt><dd><p>LOG.info(“Loading models from the directories in: {}”, baseDir.getPath());
List&lt;AbstractFile&gt; modelDirs =</p>
<blockquote>
<div><p>ImmutableList.copyOf(baseDir.listFiles(AbstractFile.IS_DIRECTORY));</p>
</div></blockquote>
<p>LOG.info(“Found {} model directories: {}”, modelDirs.size(), modelDirs);
return modelDirs.stream()</p>
<blockquote>
<div><dl class="simple">
<dt>.collect(Collectors.toMap(</dt><dd><p>AbstractFile::getName,
Function.identity()</p>
</dd>
</dl>
<p>));</p>
</div></blockquote>
</dd>
<dt>} catch (IOException e) {</dt><dd><p>throw new UncheckedIOException(e);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Gets the active list of models by reading a YAML config file.</p></li>
<li></li>
<li><p>The keys are the model names, the values are dictionaries with a single entry for the path</p></li>
<li><p>of the model in HDFS (without the HDFS name node prefix). For example:</p></li>
<li></li>
<li><p>model_a:</p></li>
<li><p>path: /path/to/model_a</p></li>
<li><p>model_b:</p></li>
<li><p>path: /path/to/model_b</p></li>
<li></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
</dl>
<p>&#64;VisibleForTesting
public static class ConfigSupplier implements Supplier&lt;Map&lt;String, AbstractFile&gt;&gt; {</p>
<blockquote>
<div><p>private final AbstractFile configFile;</p>
<dl class="simple">
<dt>public ConfigSupplier(AbstractFile configFile) {</dt><dd><p>this.configFile = configFile;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;SuppressWarnings(“unchecked”)
&#64;Override
public Map&lt;String, AbstractFile&gt; get() {</p>
<blockquote>
<div><dl>
<dt>try (BufferedReader configReader = configFile.getCharSource().openBufferedStream()) {</dt><dd><p>Yaml yamlParser = new Yaml();
//noinspection unchecked
Map&lt;String, Map&lt;String, String&gt;&gt; config =</p>
<blockquote>
<div><p>(Map&lt;String, Map&lt;String, String&gt;&gt;) yamlParser.load(configReader);</p>
</div></blockquote>
<dl class="simple">
<dt>if (config == null || config.isEmpty()) {</dt><dd><p>return Collections.emptyMap();</p>
</dd>
</dl>
<p>}</p>
<p>Map&lt;String, AbstractFile&gt; modelPaths = new HashMap&lt;&gt;();
for (Map.Entry&lt;String, Map&lt;String, String&gt;&gt; nameAndConfig : config.entrySet()) {</p>
<blockquote>
<div><p>String path = Strings.emptyToNull(nameAndConfig.getValue().get(“path”));
Preconditions.checkNotNull(path, “Missing path for model: %s”, nameAndConfig.getKey());
modelPaths.put(nameAndConfig.getKey(), FileUtils.getHdfsFileHandle(path));</p>
</div></blockquote>
<p>}
return modelPaths;</p>
</dd>
<dt>} catch (IOException e) {</dt><dd><p>throw new UncheckedIOException(e);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/src/java/com/twitter/search/common/util/ml/models_manager/BaseModelsManager.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>