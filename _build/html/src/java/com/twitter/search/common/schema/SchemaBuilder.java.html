<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../" id="documentation_options" src="../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.common.schema;</p>
<p>import java.util.Map;
import java.util.Set;
import javax.annotation.Nullable;</p>
<p>import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Sets;</p>
<p>import com.twitter.common.text.util.CharSequenceTermAttributeSerializer;
import com.twitter.common.text.util.PositionIncrementAttributeSerializer;
import com.twitter.common.text.util.TokenStreamSerializer;
import com.twitter.common.text.util.TokenTypeAttributeSerializer;
import com.twitter.search.common.schema.base.FeatureConfiguration;
import com.twitter.search.common.schema.base.FieldNameToIdMapping;
import com.twitter.search.common.schema.thriftjava.ThriftCSFFieldSettings;
import com.twitter.search.common.schema.thriftjava.ThriftCSFType;
import com.twitter.search.common.schema.thriftjava.ThriftCSFViewSettings;
import com.twitter.search.common.schema.thriftjava.ThriftFacetFieldSettings;
import com.twitter.search.common.schema.thriftjava.ThriftFeatureNormalizationType;
import com.twitter.search.common.schema.thriftjava.ThriftFeatureUpdateConstraint;
import com.twitter.search.common.schema.thriftjava.ThriftFieldConfiguration;
import com.twitter.search.common.schema.thriftjava.ThriftFieldSettings;
import com.twitter.search.common.schema.thriftjava.ThriftFixedLengthCSFSettings;
import com.twitter.search.common.schema.thriftjava.ThriftIndexOptions;
import com.twitter.search.common.schema.thriftjava.ThriftIndexedFieldSettings;
import com.twitter.search.common.schema.thriftjava.ThriftIndexedNumericFieldSettings;
import com.twitter.search.common.schema.thriftjava.ThriftNumericType;
import com.twitter.search.common.schema.thriftjava.ThriftSchema;
import com.twitter.search.common.schema.thriftjava.ThriftSearchFieldSettings;
import com.twitter.search.common.schema.thriftjava.ThriftTokenStreamSerializer;
import com.twitter.search.common.util.analysis.CharTermAttributeSerializer;
import com.twitter.search.common.util.analysis.IntTermAttributeSerializer;
import com.twitter.search.common.util.analysis.LongTermAttributeSerializer;
import com.twitter.search.common.util.analysis.PayloadAttributeSerializer;</p>
<p>public class SchemaBuilder {</p>
<blockquote>
<div><p>public static final String CSF_VIEW_NAME_SEPARATOR = “.”;
protected final ThriftSchema schema = new ThriftSchema();
protected final FieldNameToIdMapping idMapping;
protected final int tokenStreamSerializerVersion;</p>
<p>// As of now, we do not allow two fields to share the same field name.
// This set is used to perform this check.
private final Set&lt;String&gt; fieldNameSet = Sets.newHashSet();</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Construct a schema builder with the given FieldNameToIdMapper.</p></li>
<li><p>A SchemaBuilder is used to build a ThriftSchema incrementally.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public SchemaBuilder(FieldNameToIdMapping idMapping,</dt><dd><blockquote>
<div><p>TokenStreamSerializer.Version tokenStreamSerializerVersion) {</p>
</div></blockquote>
<p>this.idMapping = idMapping;
Preconditions.checkArgument(</p>
<blockquote>
<div><p>tokenStreamSerializerVersion == TokenStreamSerializer.Version.VERSION_2);</p>
</div></blockquote>
<p>this.tokenStreamSerializerVersion = tokenStreamSerializerVersion.ordinal();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Build ThriftSchema using settings accumulated so far.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>public final ThriftSchema build() {</dt><dd><p>return schema;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Uses fieldName also as facetName.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>public final SchemaBuilder withFacetConfigs(String fieldName,</dt><dd><blockquote>
<div><p>boolean storeSkipList,
boolean storeOffensiveCounters,
boolean useCSFForFacetCounting) {</p>
</div></blockquote>
<dl class="simple">
<dt>return withFacetConfigs(</dt><dd><p>fieldName,
fieldName,
storeSkipList,
storeOffensiveCounters,
useCSFForFacetCounting);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Add facet field configuration.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>public final SchemaBuilder withFacetConfigs(String fieldName,</dt><dd><blockquote>
<div><p>String facetName,
boolean storeSkipList,
boolean storeOffensiveCounters,
boolean useCSFForFacetCounting) {</p>
</div></blockquote>
<dl class="simple">
<dt>if (!shouldIncludeField(fieldName)) {</dt><dd><p>return this;</p>
</dd>
</dl>
<p>}
ThriftFacetFieldSettings facetSettings = new ThriftFacetFieldSettings();
// As of now, all our facet names are the same as field names
facetSettings.setFacetName(facetName);
facetSettings.setStoreSkiplist(storeSkipList);
facetSettings.setStoreOffensiveCounters(storeOffensiveCounters);
facetSettings.setUseCSFForFacetCounting(useCSFForFacetCounting);</p>
<p>int fieldId = idMapping.getFieldID(fieldName);
ThriftFieldConfiguration fieldConfiguration = schema.getFieldConfigs().get(fieldId);
Preconditions.checkNotNull(fieldConfiguration,</p>
<blockquote>
<div><dl class="simple">
<dt>“In Earlybird, a facet field must be indexed. “</dt><dd><ul class="simple">
<li><p>“No ThriftIndexedFieldSettings found for field “ + fieldName);</p></li>
</ul>
</dd>
</dl>
</div></blockquote>
<p>fieldConfiguration.getSettings().setFacetFieldSettings(facetSettings);
return this;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Configure the given field ID to be used for partitioning.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>public final SchemaBuilder withPartitionFieldId(int partitionFieldId) {</dt><dd><p>schema.setPartitionFieldId(partitionFieldId);
return this;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Add a column stride field into schema.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>public final SchemaBuilder withColumnStrideField(String fieldName,</dt><dd><blockquote>
<div><p>ThriftCSFType type,
int numValuesPerDoc,
boolean updatable,
boolean loadIntoRam) {</p>
</div></blockquote>
<p>return withColumnStrideField(fieldName, type, numValuesPerDoc, updatable, loadIntoRam, null);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Add a column stride field into schema that is variable length.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>public final SchemaBuilder withBinaryColumnStrideField(String fieldName,</dt><dd><blockquote>
<div><p>boolean loadIntoRam) {</p>
</div></blockquote>
<dl class="simple">
<dt>if (!shouldIncludeField(fieldName)) {</dt><dd><p>return this;</p>
</dd>
</dl>
<p>}
ThriftCSFFieldSettings csfFieldSettings = new ThriftCSFFieldSettings();
csfFieldSettings.setCsfType(ThriftCSFType.BYTE)</p>
<blockquote>
<div><p>.setVariableLength(true)
.setLoadIntoRAM(loadIntoRam);</p>
</div></blockquote>
<dl class="simple">
<dt>ThriftFieldSettings fieldSettings =</dt><dd><p>new ThriftFieldSettings().setCsfFieldSettings(csfFieldSettings);</p>
</dd>
<dt>ThriftFieldConfiguration fieldConf =</dt><dd><p>new ThriftFieldConfiguration(fieldName).setSettings(fieldSettings);</p>
</dd>
</dl>
<p>putIntoFieldConfigs(idMapping.getFieldID(fieldName), fieldConf);
return this;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Add a column stride field into schema which has a default value.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>public final SchemaBuilder withColumnStrideField(String fieldName,</dt><dd><blockquote>
<div><p>ThriftCSFType type,
int numValuesPerDoc,
boolean updatable,
boolean loadIntoRam,
Long defaultValue) {</p>
</div></blockquote>
<dl class="simple">
<dt>if (!shouldIncludeField(fieldName)) {</dt><dd><p>return this;</p>
</dd>
</dl>
<p>}
ThriftCSFFieldSettings csfFieldSettings = new ThriftCSFFieldSettings();
csfFieldSettings.setCsfType(type)</p>
<blockquote>
<div><p>.setVariableLength(false)
.setFixedLengthSettings(</p>
<blockquote>
<div><dl class="simple">
<dt>new ThriftFixedLengthCSFSettings()</dt><dd><p>.setNumValuesPerDoc(numValuesPerDoc)
.setUpdateable(updatable))</p>
</dd>
</dl>
</div></blockquote>
<p>.setLoadIntoRAM(loadIntoRam);</p>
</div></blockquote>
<dl class="simple">
<dt>if (defaultValue != null) {</dt><dd><p>csfFieldSettings.setDefaultValue(defaultValue);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>ThriftFieldSettings fieldSettings =</dt><dd><p>new ThriftFieldSettings().setCsfFieldSettings(csfFieldSettings);</p>
</dd>
<dt>ThriftFieldConfiguration fieldConf =</dt><dd><p>new ThriftFieldConfiguration(fieldName).setSettings(fieldSettings);</p>
</dd>
</dl>
<p>putIntoFieldConfigs(idMapping.getFieldID(fieldName), fieldConf);
return this;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Add a CSF view into schema. A view is a portion of another CSF.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>public final SchemaBuilder withColumnStrideFieldView(</dt><dd><blockquote>
<div><p>String fieldName,
ThriftCSFType csfType,
ThriftCSFType outputCSFType,
String baseFieldName,
int valueIndex,
int bitStartPosition,
int bitLength,
ThriftFeatureNormalizationType featureNormalizationType,
&#64;Nullable Set&lt;ThriftFeatureUpdateConstraint&gt; constraints) {</p>
</div></blockquote>
<dl class="simple">
<dt>if (!shouldIncludeField(fieldName)) {</dt><dd><p>return this;</p>
</dd>
</dl>
<p>}</p>
<p>int baseFieldConfigID = idMapping.getFieldID(baseFieldName);</p>
<dl class="simple">
<dt>ThriftCSFViewSettings csfViewSettings = new ThriftCSFViewSettings()</dt><dd><p>.setBaseFieldConfigId(baseFieldConfigID)
.setCsfType(csfType)
.setValueIndex(valueIndex)
.setBitStartPosition(bitStartPosition)
.setBitLength(bitLength);</p>
</dd>
<dt>if (outputCSFType != null) {</dt><dd><p>csfViewSettings.setOutputCSFType(outputCSFType);</p>
</dd>
</dl>
<p>}
if (featureNormalizationType != ThriftFeatureNormalizationType.NONE) {</p>
<blockquote>
<div><p>csfViewSettings.setNormalizationType(featureNormalizationType);</p>
</div></blockquote>
<p>}
if (constraints != null) {</p>
<blockquote>
<div><p>csfViewSettings.setFeatureUpdateConstraints(constraints);</p>
</div></blockquote>
<p>}
ThriftFieldSettings fieldSettings = new ThriftFieldSettings()</p>
<blockquote>
<div><p>.setCsfViewSettings(csfViewSettings);</p>
</div></blockquote>
<dl class="simple">
<dt>ThriftFieldConfiguration fieldConf = new ThriftFieldConfiguration(fieldName)</dt><dd><p>.setSettings(fieldSettings);</p>
</dd>
</dl>
<p>Map&lt;Integer, ThriftFieldConfiguration&gt; fieldConfigs = schema.getFieldConfigs();
verifyCSFViewSettings(fieldConfigs, fieldConf);</p>
<p>putIntoFieldConfigs(idMapping.getFieldID(fieldName), fieldConf);
return this;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Sanity checks for CSF view settings.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>public static void verifyCSFViewSettings(Map&lt;Integer, ThriftFieldConfiguration&gt; fieldConfigs,</dt><dd><blockquote>
<div><p>ThriftFieldConfiguration fieldConf) {</p>
</div></blockquote>
<p>Preconditions.checkNotNull(fieldConf.getSettings());
Preconditions.checkNotNull(fieldConf.getSettings().getCsfViewSettings());
ThriftCSFViewSettings csfViewSettings = fieldConf.getSettings().getCsfViewSettings();</p>
<dl>
<dt>if (fieldConfigs != null) {</dt><dd><dl>
<dt>ThriftFieldConfiguration baseFieldConfig = fieldConfigs.get(</dt><dd><p>csfViewSettings.getBaseFieldConfigId());</p>
</dd>
<dt>if (baseFieldConfig != null) {</dt><dd><p>String baseFieldName = baseFieldConfig.getFieldName();
String expectedViewNamePrefix = baseFieldName + CSF_VIEW_NAME_SEPARATOR;
if (fieldConf.getFieldName().startsWith(expectedViewNamePrefix)) {</p>
<blockquote>
<div><p>ThriftFieldSettings baseFieldSettings = baseFieldConfig.getSettings();
ThriftCSFFieldSettings baseFieldCSFSettings = baseFieldSettings.getCsfFieldSettings();</p>
<dl>
<dt>if (baseFieldCSFSettings != null) {</dt><dd><dl>
<dt>if (!baseFieldCSFSettings.isVariableLength()</dt><dd><blockquote>
<div><p>&amp;&amp; baseFieldCSFSettings.getFixedLengthSettings() != null) {</p>
</div></blockquote>
<p>ThriftCSFType baseCSFType = baseFieldCSFSettings.getCsfType();
switch (baseCSFType) {</p>
<blockquote>
<div><dl class="simple">
<dt>case BYTE:</dt><dd><p>checkCSFViewPositions(baseFieldCSFSettings, 8, csfViewSettings);
break;</p>
</dd>
<dt>case INT:</dt><dd><p>checkCSFViewPositions(baseFieldCSFSettings, 32, csfViewSettings);
break;</p>
</dd>
<dt>default:</dt><dd><dl class="simple">
<dt>throw new IllegalStateException(“Base field: “ + baseFieldName</dt><dd><ul class="simple">
<li><p>“ is of a non-supported CSFType: “ + baseCSFType);</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>throw new IllegalStateException(“Base field: “ + baseFieldName</dt><dd><ul class="simple">
<li><p>“ must be a fixed-length CSF field”);</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>throw new IllegalStateException(“Base field: “ + baseFieldName + “ is not a CSF field”);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><dl class="simple">
<dt>throw new IllegalStateException(“View field name for baseFieldConfigID: “</dt><dd><ul class="simple">
<li><p>csfViewSettings.getBaseFieldConfigId() + “ must start with: ‘”</p></li>
<li><p>expectedViewNamePrefix + “’”);</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>throw new IllegalStateException(“Can’t add a view, no field defined for base fieldID: “</dt><dd><ul class="simple">
<li><p>csfViewSettings.getBaseFieldConfigId());</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>throw new IllegalStateException(“Can’t add a view, no field configs defined.”);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private static void checkCSFViewPositions(ThriftCSFFieldSettings baseFieldCSFSettings,</dt><dd><blockquote>
<div><p>int bitsPerValue,
ThriftCSFViewSettings csfViewSettings) {</p>
</div></blockquote>
<dl class="simple">
<dt>ThriftFixedLengthCSFSettings fixedLengthCSFSettings =</dt><dd><p>baseFieldCSFSettings.getFixedLengthSettings();</p>
</dd>
</dl>
<p>Preconditions.checkNotNull(fixedLengthCSFSettings);</p>
<p>int numValues = fixedLengthCSFSettings.getNumValuesPerDoc();
Preconditions.checkState(csfViewSettings.getValueIndex() &gt;= 0,</p>
<blockquote>
<div><p>“value index must be positive: “ + csfViewSettings.getValueIndex());</p>
</div></blockquote>
<dl class="simple">
<dt>Preconditions.checkState(csfViewSettings.getValueIndex() &lt; numValues, “value index “</dt><dd><ul class="simple">
<li><p>csfViewSettings.getValueIndex() + “ must be less than numValues: “ + numValues);</p></li>
</ul>
</dd>
<dt>Preconditions.checkState(csfViewSettings.getBitStartPosition() &gt;= 0,</dt><dd><p>“bitStartPosition must be positive: “ + csfViewSettings.getBitStartPosition());</p>
</dd>
<dt>Preconditions.checkState(csfViewSettings.getBitStartPosition() &lt; bitsPerValue,</dt><dd><dl class="simple">
<dt>“bitStartPosition “ + csfViewSettings.getBitStartPosition()</dt><dd><ul class="simple">
<li><p>“ must be less than bitsPerValue “ + bitsPerValue);</p></li>
</ul>
</dd>
</dl>
</dd>
<dt>Preconditions.checkState(csfViewSettings.getBitLength() &gt;= 1,</dt><dd><p>“bitLength must be positive: “ + csfViewSettings.getBitLength());</p>
</dd>
<dt>Preconditions.checkState(</dt><dd><p>csfViewSettings.getBitStartPosition() + csfViewSettings.getBitLength() &lt;= bitsPerValue,
String.format(“bitStartPosition (%d) + bitLength (%d) must be less than bitsPerValue (%d)”,
csfViewSettings.getBitStartPosition(), csfViewSettings.getBitLength(), bitsPerValue));</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>// No position; no freq; not pretokenized; not tokenized.
/**</p>
<blockquote>
<div><ul class="simple">
<li><p>Norm is disabled as default. Like Lucene string field, or int/long fields.</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</div></blockquote>
<dl class="simple">
<dt>public final SchemaBuilder withIndexedNotTokenizedField(String fieldName) {</dt><dd><p>return withIndexedNotTokenizedField(fieldName, false);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Add an indexed but not tokenized field. This is similar to Lucene’s StringField.</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>public final SchemaBuilder withIndexedNotTokenizedField(String fieldName,</dt><dd><blockquote>
<div><p>boolean supportOutOfOrderAppends) {</p>
</div></blockquote>
<p>return withIndexedNotTokenizedField(fieldName, supportOutOfOrderAppends, true);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private final SchemaBuilder withIndexedNotTokenizedField(String fieldName,</dt><dd><blockquote>
<div><p>boolean supportOutOfOrderAppends,
boolean omitNorms) {</p>
</div></blockquote>
<dl class="simple">
<dt>if (!shouldIncludeField(fieldName)) {</dt><dd><p>return this;</p>
</dd>
</dl>
<p>}
ThriftFieldSettings settings = getNoPositionNoFreqSettings(supportOutOfOrderAppends);
settings.getIndexedFieldSettings().setOmitNorms(omitNorms);
ThriftFieldConfiguration config = new ThriftFieldConfiguration(fieldName)</p>
<blockquote>
<div><p>.setSettings(settings);</p>
</div></blockquote>
<p>putIntoFieldConfigs(idMapping.getFieldID(fieldName), config);
return this;</p>
</dd>
</dl>
<p>}</p>
<p>/** Makes the given field searchable by default, with the given weight. <a href="#id25"><span class="problematic" id="id26">*</span></a>/
public final SchemaBuilder withSearchFieldByDefault(</p>
<blockquote>
<div><blockquote>
<div><p>String fieldName, float textSearchableFieldWeight) {</p>
</div></blockquote>
<dl class="simple">
<dt>if (!shouldIncludeField(fieldName)) {</dt><dd><p>return this;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>ThriftFieldSettings settings =</dt><dd><p>schema.getFieldConfigs().get(idMapping.getFieldID(fieldName)).getSettings();</p>
</dd>
<dt>settings.setSearchFieldSettings(</dt><dd><dl class="simple">
<dt>new ThriftSearchFieldSettings()</dt><dd><p>.setTextSearchableFieldWeight(textSearchableFieldWeight)
.setTextDefaultSearchable(true));</p>
</dd>
</dl>
</dd>
</dl>
<p>return this;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Similar to Lucene’s TextField. The string is analyzed using the default/override analyzer.</p></li>
<li><p>&#64;param fieldName</p></li>
<li><p>&#64;param addHfPairIfHfFieldsArePresent Add hfPair fields if they exists in the schema.</p></li>
<li><p>For certain text fields, adding hfPair fields are usually preferred, but they may</p></li>
<li><p>not exist in the schema, in which case the hfPair fields will not be added.</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
<dt>public final SchemaBuilder withTextField(String fieldName,</dt><dd><blockquote>
<div><p>boolean addHfPairIfHfFieldsArePresent) {</p>
</div></blockquote>
<dl class="simple">
<dt>if (!shouldIncludeField(fieldName)) {</dt><dd><p>return this;</p>
</dd>
</dl>
<p>}
ThriftFieldConfiguration config = new ThriftFieldConfiguration(fieldName).setSettings(</p>
<blockquote>
<div><p>getDefaultSettings(ThriftIndexOptions.DOCS_AND_FREQS_AND_POSITIONS));</p>
</div></blockquote>
<dl>
<dt>if (addHfPairIfHfFieldsArePresent) {</dt><dd><p>// Add hfPair fields only if they exist in the schema for the cluster
boolean hfPair = shouldIncludeField(ImmutableSchema.HF_TERM_PAIRS_FIELD)</p>
<blockquote>
<div><p>&amp;&amp; shouldIncludeField(ImmutableSchema.HF_PHRASE_PAIRS_FIELD);</p>
</div></blockquote>
<p>config.getSettings().getIndexedFieldSettings().setIndexHighFreqTermPairs(hfPair);</p>
</dd>
</dl>
<p>}</p>
<p>config.getSettings().getIndexedFieldSettings().setTokenized(true);
putIntoFieldConfigs(idMapping.getFieldID(fieldName), config);
return this;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Marked the given field as having per position payload.</p></li>
</ul>
<p><a href="#id29"><span class="problematic" id="id30">*</span></a>/</p>
</dd>
<dt>public final SchemaBuilder withPerPositionPayload(String fieldName, int defaultPayloadLength) {</dt><dd><dl class="simple">
<dt>if (!shouldIncludeField(fieldName)) {</dt><dd><p>return this;</p>
</dd>
</dl>
<p>}
ThriftFieldSettings settings =</p>
<blockquote>
<div><p>schema.getFieldConfigs().get(idMapping.getFieldID(fieldName)).getSettings();</p>
</div></blockquote>
<p>settings.getIndexedFieldSettings().setStorePerPositionPayloads(true);
settings.getIndexedFieldSettings().setDefaultPerPositionPayloadLength(defaultPayloadLength);
return this;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Add field into schema that is pre-tokenized and does not have position.</p></li>
<li><p>E.g. hashtags / stocks / card_domain</p></li>
</ul>
<p><a href="#id31"><span class="problematic" id="id32">*</span></a>/</p>
</dd>
<dt>public final SchemaBuilder withPretokenizedNoPositionField(String fieldName) {</dt><dd><dl class="simple">
<dt>if (!shouldIncludeField(fieldName)) {</dt><dd><p>return this;</p>
</dd>
</dl>
<p>}
ThriftFieldConfiguration config = new ThriftFieldConfiguration(fieldName)</p>
<blockquote>
<div><p>.setSettings(getPretokenizedNoPositionFieldSetting());</p>
</div></blockquote>
<p>// Add hfPair fields only if they exist in the schema for the cluster
boolean hfPair = shouldIncludeField(ImmutableSchema.HF_TERM_PAIRS_FIELD)</p>
<blockquote>
<div><p>&amp;&amp; shouldIncludeField(ImmutableSchema.HF_PHRASE_PAIRS_FIELD);</p>
</div></blockquote>
<p>config.getSettings().getIndexedFieldSettings().setIndexHighFreqTermPairs(hfPair);
putIntoFieldConfigs(idMapping.getFieldID(fieldName), config);
return this;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Mark the field to have ordered term dictionary.</p></li>
<li><p>In Lucene, term dictionary is sorted. In Earlybird, term dictionary order is not</p></li>
<li><p>guaranteed unless this is turned on.</p></li>
</ul>
<p><a href="#id33"><span class="problematic" id="id34">*</span></a>/</p>
</dd>
<dt>public final SchemaBuilder withOrderedTerms(String fieldName) {</dt><dd><dl class="simple">
<dt>if (!shouldIncludeField(fieldName)) {</dt><dd><p>return this;</p>
</dd>
</dl>
<p>}
ThriftFieldSettings settings =</p>
<blockquote>
<div><p>schema.getFieldConfigs().get(idMapping.getFieldID(fieldName)).getSettings();</p>
</div></blockquote>
<p>settings.getIndexedFieldSettings().setSupportOrderedTerms(true);
return this;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Support lookup of term text by term id in the term dictionary.</p></li>
</ul>
<p><a href="#id35"><span class="problematic" id="id36">*</span></a>/</p>
</dd>
<dt>public final SchemaBuilder withTermTextLookup(String fieldName) {</dt><dd><dl class="simple">
<dt>if (!shouldIncludeField(fieldName)) {</dt><dd><p>return this;</p>
</dd>
</dl>
<p>}
ThriftFieldSettings settings =</p>
<blockquote>
<div><p>schema.getFieldConfigs().get(idMapping.getFieldID(fieldName)).getSettings();</p>
</div></blockquote>
<p>settings.getIndexedFieldSettings().setSupportTermTextLookup(true);
return this;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Add a text field that is pre-tokenized, so not analyzed again in the index (e.g. Earlybird).</p></li>
<li></li>
<li><p>Note that the token streams MUST be created using the attributes defined in</p></li>
<li><p><a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> com.twitter.search.common.util.text.TweetTokenStreamSerializer}.</p></li>
</ul>
<p><a href="#id37"><span class="problematic" id="id38">*</span></a>/</p>
</dd>
<dt>public final SchemaBuilder withPretokenizedTextField(</dt><dd><blockquote>
<div><p>String fieldName,
boolean addHfPairIfHfFieldsArePresent) {</p>
</div></blockquote>
<dl class="simple">
<dt>if (!shouldIncludeField(fieldName)) {</dt><dd><p>return this;</p>
</dd>
</dl>
<p>}
ThriftFieldConfiguration config = new ThriftFieldConfiguration(fieldName)</p>
<blockquote>
<div><dl class="simple">
<dt>.setSettings(getDefaultPretokenizedSettings(</dt><dd><p>ThriftIndexOptions.DOCS_AND_FREQS_AND_POSITIONS));</p>
</dd>
</dl>
</div></blockquote>
<p>putIntoFieldConfigs(idMapping.getFieldID(fieldName), config);
// Add hfPair fields only if they exist in the schema for the cluster
if (addHfPairIfHfFieldsArePresent) {</p>
<blockquote>
<div><p>// Add hfPair fields only if they exist in the schema for the cluster
boolean hfPair = shouldIncludeField(ImmutableSchema.HF_TERM_PAIRS_FIELD)</p>
<blockquote>
<div><p>&amp;&amp; shouldIncludeField(ImmutableSchema.HF_PHRASE_PAIRS_FIELD);</p>
</div></blockquote>
<p>config.getSettings().getIndexedFieldSettings().setIndexHighFreqTermPairs(hfPair);</p>
</div></blockquote>
<p>}
return this;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Add a feature configuration</p></li>
</ul>
<p><a href="#id39"><span class="problematic" id="id40">*</span></a>/</p>
</dd>
<dt>public final SchemaBuilder withFeatureConfiguration(String baseFieldName, String viewName,</dt><dd><blockquote>
<div><p>FeatureConfiguration featureConfiguration) {</p>
</div></blockquote>
<dl class="simple">
<dt>return withColumnStrideFieldView(</dt><dd><p>viewName,
// Defaulting all encoded tweet features to int since the underlying encoded tweet features
// are ints.
ThriftCSFType.INT,
featureConfiguration.getOutputType(),
baseFieldName,
featureConfiguration.getValueIndex(),
featureConfiguration.getBitStartPosition(),
featureConfiguration.getBitLength(),
featureConfiguration.getFeatureNormalizationType(),
featureConfiguration.getUpdateConstraints()</p>
</dd>
</dl>
<p>);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Add a long field in schema. This field uses LongTermAttribute.</p></li>
</ul>
<p><a href="#id41"><span class="problematic" id="id42">*</span></a>/</p>
</dd>
<dt>private SchemaBuilder addLongTermField(String fieldName, boolean useSortableEncoding) {</dt><dd><dl class="simple">
<dt>if (!shouldIncludeField(fieldName)) {</dt><dd><p>return this;</p>
</dd>
</dl>
<p>}
ThriftFieldSettings longTermSettings = getEarlybirdNumericFieldSettings();
ThriftTokenStreamSerializer tokenStreamSerializer =</p>
<blockquote>
<div><p>new ThriftTokenStreamSerializer(tokenStreamSerializerVersion);</p>
</div></blockquote>
<dl class="simple">
<dt>tokenStreamSerializer.setAttributeSerializerClassNames(</dt><dd><p>ImmutableList.&lt;String&gt;of(LongTermAttributeSerializer.class.getName()));</p>
</dd>
</dl>
<p>longTermSettings.getIndexedFieldSettings().setTokenStreamSerializer(tokenStreamSerializer);</p>
<dl class="simple">
<dt>ThriftIndexedNumericFieldSettings numericFieldSettings =</dt><dd><p>new ThriftIndexedNumericFieldSettings(true);</p>
</dd>
</dl>
<p>numericFieldSettings.setNumericType(ThriftNumericType.LONG);
numericFieldSettings.setUseSortableEncoding(useSortableEncoding);
longTermSettings.getIndexedFieldSettings().setNumericFieldSettings(numericFieldSettings);</p>
<dl class="simple">
<dt>putIntoFieldConfigs(idMapping.getFieldID(fieldName),</dt><dd><p>new ThriftFieldConfiguration(fieldName).setSettings(longTermSettings));</p>
</dd>
</dl>
<p>return this;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public final SchemaBuilder withSortableLongTermField(String fieldName) {</dt><dd><p>return addLongTermField(fieldName, true);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public final SchemaBuilder withLongTermField(String fieldName) {</dt><dd><p>return addLongTermField(fieldName, false);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Add an int field in schema. This field uses IntTermAttribute.</p></li>
</ul>
<p><a href="#id43"><span class="problematic" id="id44">*</span></a>/</p>
</dd>
<dt>public final SchemaBuilder withIntTermField(String fieldName) {</dt><dd><dl class="simple">
<dt>if (!shouldIncludeField(fieldName)) {</dt><dd><p>return this;</p>
</dd>
</dl>
<p>}
ThriftFieldSettings intTermSettings = getEarlybirdNumericFieldSettings();
ThriftTokenStreamSerializer attributeSerializer =</p>
<blockquote>
<div><p>new ThriftTokenStreamSerializer(tokenStreamSerializerVersion);</p>
</div></blockquote>
<dl class="simple">
<dt>attributeSerializer.setAttributeSerializerClassNames(</dt><dd><p>ImmutableList.&lt;String&gt;of(IntTermAttributeSerializer.class.getName()));</p>
</dd>
</dl>
<p>intTermSettings.getIndexedFieldSettings().setTokenStreamSerializer(attributeSerializer);</p>
<dl class="simple">
<dt>ThriftIndexedNumericFieldSettings numericFieldSettings =</dt><dd><p>new ThriftIndexedNumericFieldSettings(true);</p>
</dd>
</dl>
<p>numericFieldSettings.setNumericType(ThriftNumericType.INT);
intTermSettings.getIndexedFieldSettings().setNumericFieldSettings(numericFieldSettings);</p>
<dl class="simple">
<dt>putIntoFieldConfigs(idMapping.getFieldID(fieldName),</dt><dd><p>new ThriftFieldConfiguration(fieldName).setSettings(intTermSettings));</p>
</dd>
</dl>
<p>return this;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Timeline and ExpertSearch uses</p></li>
<li><p><a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> com.twitter.search.common.util.analysis.PayloadWeightedTokenizer} to store weighted</p></li>
<li><p>values.</p></li>
<li></li>
<li><p>E.g. for the PRODUCED_LANGUAGES and CONSUMED_LANGUAGES fields, they contain not a single,</p></li>
<li><p>value, but instead a list of values with a weight associated with each value.</p></li>
<li></li>
<li><p>This method adds an indexed field that uses</p></li>
<li><p><a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> com.twitter.search.common.util.analysis.PayloadWeightedTokenizer}.</p></li>
</ul>
<p><a href="#id45"><span class="problematic" id="id46">*</span></a>/</p>
</dd>
<dt>public final SchemaBuilder withCharTermPayloadWeightedField(String fieldName) {</dt><dd><dl class="simple">
<dt>ThriftFieldConfiguration config = new ThriftFieldConfiguration(fieldName)</dt><dd><p>.setSettings(getPayloadWeightedSettings(ThriftIndexOptions.DOCS_AND_FREQS_AND_POSITIONS));</p>
</dd>
</dl>
<p>putIntoFieldConfigs(idMapping.getFieldID(fieldName), config);
return this;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Set the version and description of this schema.</p></li>
</ul>
<p><a href="#id47"><span class="problematic" id="id48">*</span></a>/</p>
</dd>
<dt>public final SchemaBuilder withSchemaVersion(</dt><dd><blockquote>
<div><p>int majorVersionNumber,
int minorVersionNumber,
String versionDesc,
boolean isOfficial) {</p>
</div></blockquote>
<p>schema.setMajorVersionNumber(majorVersionNumber);
schema.setMinorVersionNumber(minorVersionNumber);</p>
<p>schema.setVersion(majorVersionNumber + “:” + versionDesc);
schema.setVersionIsOfficial(isOfficial);</p>
<p>return this;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>public final SchemaBuilder withSchemaVersion(</dt><dd><blockquote>
<div><p>int majorVersionNumber,
String versionDesc,
boolean isOfficial) {</p>
</div></blockquote>
<p>return withSchemaVersion(majorVersionNumber, 0, versionDesc, isOfficial);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>protected void putIntoFieldConfigs(int id, ThriftFieldConfiguration config) {</dt><dd><dl class="simple">
<dt>if (schema.getFieldConfigs() != null &amp;&amp; schema.getFieldConfigs().containsKey(id)) {</dt><dd><p>throw new IllegalStateException(“Already have a ThriftFieldConfiguration for field id “ + id);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (fieldNameSet.contains(config.getFieldName())) {</dt><dd><dl class="simple">
<dt>throw new IllegalStateException(“Already have a ThriftFieldConfiguration for field “</dt><dd><ul class="simple">
<li><p>config.getFieldName());</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>}
fieldNameSet.add(config.getFieldName());
schema.putToFieldConfigs(id, config);</p>
</dd>
</dl>
<p>}</p>
<p>// Default field settings. Most field settings are similar to this.
protected ThriftFieldSettings getDefaultSettings(ThriftIndexOptions indexOption) {</p>
<blockquote>
<div><p>return getDefaultSettings(indexOption, false);</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>protected ThriftFieldSettings getDefaultSettings(ThriftIndexOptions indexOption,</dt><dd><blockquote>
<div><p>boolean supportOutOfOrderAppends) {</p>
</div></blockquote>
<p>ThriftFieldSettings fieldSettings = new ThriftFieldSettings();
ThriftIndexedFieldSettings indexedFieldSettings = new ThriftIndexedFieldSettings();
indexedFieldSettings</p>
<blockquote>
<div><p>.setIndexed(true)
.setStored(false)
.setTokenized(false)
.setStoreTermVectors(false)
.setStoreTermVectorOffsets(false)
.setStoreTermVectorPayloads(false)
.setStoreTermVectorPositions(false)
.setSupportOutOfOrderAppends(supportOutOfOrderAppends)
.setIndexOptions(indexOption)
.setOmitNorms(true); // All Earlybird fields omit norms.</p>
</div></blockquote>
<p>fieldSettings.setIndexedFieldSettings(indexedFieldSettings);
return fieldSettings;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Default field settings for fields that are pretokenized</p></li>
<li></li>
<li><p>The fields that use these settings will need to be tokenized using a serializer with the</p></li>
<li><p>attributes defined in <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> com.twitter.search.common.util.text.TweetTokenStreamSerializer}.</p></li>
</ul>
<p><a href="#id49"><span class="problematic" id="id50">*</span></a>/</p>
</dd>
<dt>protected final ThriftFieldSettings getDefaultPretokenizedSettings(</dt><dd><blockquote>
<div><p>ThriftIndexOptions indexOption) {</p>
</div></blockquote>
<p>ThriftFieldSettings fieldSettings = getDefaultSettings(indexOption);
fieldSettings.getIndexedFieldSettings().setTokenized(true);
ThriftTokenStreamSerializer attributeSerializer =</p>
<blockquote>
<div><p>new ThriftTokenStreamSerializer(tokenStreamSerializerVersion);</p>
</div></blockquote>
<dl class="simple">
<dt>attributeSerializer.setAttributeSerializerClassNames(</dt><dd><dl class="simple">
<dt>ImmutableList.&lt;String&gt;of(</dt><dd><p>CharSequenceTermAttributeSerializer.class.getName(),
PositionIncrementAttributeSerializer.class.getName(),
TokenTypeAttributeSerializer.class.getName()));</p>
</dd>
</dl>
</dd>
</dl>
<p>fieldSettings.getIndexedFieldSettings().setTokenStreamSerializer(attributeSerializer);
return fieldSettings;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>protected final ThriftFieldSettings getPretokenizedNoPositionFieldSetting() {</dt><dd><p>return getDefaultPretokenizedSettings(ThriftIndexOptions.DOCS_AND_FREQS);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>protected final ThriftFieldSettings getNoPositionNoFreqSettings() {</dt><dd><p>return getNoPositionNoFreqSettings(false);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>protected final ThriftFieldSettings getNoPositionNoFreqSettings(</dt><dd><blockquote>
<div><p>boolean supportOutOfOrderAppends) {</p>
</div></blockquote>
<p>return getDefaultSettings(ThriftIndexOptions.DOCS_ONLY, supportOutOfOrderAppends);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>protected final ThriftFieldSettings getEarlybirdNumericFieldSettings() {</dt><dd><p>// Supposedly numeric fields are not tokenized.
// However, Earlybird uses SingleTokenTokenStream to handle int/long fields.
// So we need to set indexed to true for these fields.
ThriftFieldSettings settings = getNoPositionNoFreqSettings();
settings.getIndexedFieldSettings().setTokenized(true);
return settings;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private ThriftFieldSettings getPayloadWeightedSettings(ThriftIndexOptions indexOption) {</dt><dd><p>ThriftFieldSettings fieldSettings = getDefaultSettings(indexOption);
fieldSettings.getIndexedFieldSettings().setTokenized(true);
ThriftTokenStreamSerializer attributeSerializer =</p>
<blockquote>
<div><p>new ThriftTokenStreamSerializer(tokenStreamSerializerVersion);</p>
</div></blockquote>
<dl class="simple">
<dt>attributeSerializer.setAttributeSerializerClassNames(</dt><dd><dl class="simple">
<dt>ImmutableList.&lt;String&gt;of(CharTermAttributeSerializer.class.getName(),</dt><dd><p>PositionIncrementAttributeSerializer.class.getName(),
PayloadAttributeSerializer.class.getName()));</p>
</dd>
</dl>
</dd>
</dl>
<p>fieldSettings.getIndexedFieldSettings().setTokenStreamSerializer(attributeSerializer);
return fieldSettings;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>protected boolean shouldIncludeField(String fieldName) {</dt><dd><p>return true;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../_sources/src/java/com/twitter/search/common/schema/SchemaBuilder.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>