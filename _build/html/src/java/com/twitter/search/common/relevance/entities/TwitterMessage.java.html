<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../" id="documentation_options" src="../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.common.relevance.entities;</p>
<p>import java.text.DateFormat;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashSet;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import javax.annotation.Nonnull;
import javax.annotation.Nullable;</p>
<p>import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.ComparisonChain;
import com.google.common.collect.Lists;
import com.google.common.collect.Maps;
import com.google.common.collect.Sets;</p>
<p>import org.apache.commons.lang.StringUtils;
import org.apache.commons.lang3.builder.EqualsBuilder;
import org.apache.commons.lang3.builder.HashCodeBuilder;
import org.apache.commons.lang3.builder.ToStringBuilder;
import org.apache.lucene.analysis.TokenStream;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;</p>
<p>import com.twitter.common.text.language.LocaleUtil;
import com.twitter.common.text.pipeline.TwitterLanguageIdentifier;
import com.twitter.common.text.token.TokenizedCharSequence;
import com.twitter.common_internal.text.version.PenguinVersion;
import com.twitter.cuad.ner.plain.thriftjava.NamedEntity;
import com.twitter.search.common.indexing.thriftjava.ThriftExpandedUrl;
import com.twitter.search.common.relevance.features.TweetFeatures;
import com.twitter.search.common.relevance.features.TweetTextFeatures;
import com.twitter.search.common.relevance.features.TweetTextQuality;
import com.twitter.search.common.relevance.features.TweetUserFeatures;
import com.twitter.search.common.util.text.NormalizerHelper;
import com.twitter.service.spiderduck.gen.MediaTypes;
import com.twitter.tweetypie.thriftjava.ComposerSource;
import com.twitter.util.TwitterDateFormat;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A representation of tweets used as an intermediate object during ingestion. As we proceed</p></li>
<li><p>in ingestion, we fill this object with data. We then convert it to ThriftVersionedEvents (which</p></li>
<li><p>itself represents a single tweet too, in different penguin versions potentially).</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public class TwitterMessage {</dt><dd><p>private static final Logger LOG = LoggerFactory.getLogger(TwitterMessage.class);</p>
<dl>
<dt>public static class EscherbirdAnnotation implements Comparable&lt;EscherbirdAnnotation&gt; {</dt><dd><p>public final long groupId;
public final long domainId;
public final long entityId;</p>
<dl class="simple">
<dt>public EscherbirdAnnotation(long groupId, long domainId, long entityId) {</dt><dd><p>this.groupId = groupId;
this.domainId = domainId;
this.entityId = entityId;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public boolean equals(Object o2) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (o2 instanceof EscherbirdAnnotation) {</dt><dd><p>EscherbirdAnnotation a2 = (EscherbirdAnnotation) o2;
return groupId == a2.groupId &amp;&amp; domainId == a2.domainId &amp;&amp; entityId == a2.entityId;</p>
</dd>
</dl>
<p>}
return false;</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public int hashCode() {</p>
<blockquote>
<div><dl class="simple">
<dt>return new HashCodeBuilder()</dt><dd><p>.append(groupId)
.append(domainId)
.append(entityId)
.toHashCode();</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>&#64;Override
public int compareTo(EscherbirdAnnotation o) {</p>
<blockquote>
<div><dl class="simple">
<dt>return ComparisonChain.start()</dt><dd><p>.compare(this.groupId, o.groupId)
.compare(this.domainId, o.domainId)
.compare(this.entityId, o.entityId)
.result();</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>private final List&lt;EscherbirdAnnotation&gt; escherbirdAnnotations = Lists.newArrayList();</p>
<p>// tweet features for multiple penguin versions
private static class VersionedTweetFeatures {</p>
<blockquote>
<div><p>// TweetFeatures populated by relevance classifiers, structure defined
// in src/main/thrift/classifier.thrift.
private TweetFeatures tweetFeatures = new TweetFeatures();
private TokenizedCharSequence tokenizedCharSequence = null;
private Set&lt;String&gt; normalizedHashtags = Sets.newHashSet();</p>
<dl class="simple">
<dt>public TweetFeatures getTweetFeatures() {</dt><dd><p>return this.tweetFeatures;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setTweetFeatures(final TweetFeatures tweetFeatures) {</dt><dd><p>this.tweetFeatures = tweetFeatures;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public TweetTextQuality getTweetTextQuality() {</dt><dd><p>return this.tweetFeatures.getTweetTextQuality();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public TweetTextFeatures getTweetTextFeatures() {</dt><dd><p>return this.tweetFeatures.getTweetTextFeatures();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public TweetUserFeatures getTweetUserFeatures() {</dt><dd><p>return this.tweetFeatures.getTweetUserFeatures();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public TokenizedCharSequence getTokenizedCharSequence() {</dt><dd><p>return this.tokenizedCharSequence;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setTokenizedCharSequence(TokenizedCharSequence sequence) {</dt><dd><p>this.tokenizedCharSequence = sequence;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Set&lt;String&gt; getNormalizedHashtags() {</dt><dd><p>return this.normalizedHashtags;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void addNormalizedHashtags(String normalizedHashtag) {</dt><dd><p>this.normalizedHashtags.add(normalizedHashtag);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>public static final int INT_FIELD_NOT_PRESENT = -1;
public static final long LONG_FIELD_NOT_PRESENT = -1;
public static final double DOUBLE_FIELD_NOT_PRESENT = -1;
public static final int MAX_USER_REPUTATION = 100;</p>
<p>private final long tweetId;</p>
<p>private String text;</p>
<p>private Date date;
&#64;Nonnull
private Optional&lt;TwitterMessageUser&gt; optionalFromUser = Optional.empty();
&#64;Nonnull
private Optional&lt;TwitterMessageUser&gt; optionalToUser = Optional.empty();
private Locale locale = null;
private Locale linkLocale = null;</p>
<p>// Original source text.
private String origSource;
// Source with HTML tags removed and truncated.
private String strippedSource;</p>
<p>// Original location text.
private String origLocation;</p>
<p>// Location truncated for mysql field-width reasons (see TwitterMessageUtil.java).
private String truncatedNormalizedLocation;</p>
<p>// User’s country
private String fromUserLocCountry;</p>
<p>private Integer followersCount = INT_FIELD_NOT_PRESENT;
private boolean deleted = false;</p>
<p>// Fields extracted from entities (in the JSON object)
private List&lt;TwitterMessageUser&gt; mentions = new ArrayList&lt;&gt;();
private Set&lt;String&gt; hashtags = Sets.newHashSet();
// Lat/lon and region accuracy tuples extracted from tweet text, or null.
private GeoObject geoLocation = null;
private boolean uncodeableLocation = false;
// This is set if the tweet is geotagged. (i.e. “geo” or “coordinate” section is present
// in the json)
// This field has only a getter but no setter — it is filled in when the json is parsed.
private GeoObject geoTaggedLocation = null;</p>
<p>private double userReputation = DOUBLE_FIELD_NOT_PRESENT;
private boolean geocodeRequired = false;
private boolean sensitiveContent = false;
private boolean userProtected;
private boolean userVerified;
private boolean userBlueVerified;
private TwitterRetweetMessage retweetMessage;
private TwitterQuotedMessage quotedMessage;
private List&lt;String&gt; places;
// maps from original url (the t.co url) to ThriftExpandedUrl, which contains the
// expanded url and the spiderduck response (canoicalLastHopUrl and mediatype)
private final Map&lt;String, ThriftExpandedUrl&gt; expandedUrls;
// maps the photo status id to the media url
private Map&lt;Long, String&gt; photoUrls;
private Optional&lt;Long&gt; inReplyToStatusId = Optional.empty();
private Optional&lt;Long&gt; directedAtUserId = Optional.empty();</p>
<p>private long conversationId = -1;</p>
<p>// True if tweet is nullcasted.
private boolean nullcast = false;</p>
<p>// True if tweet is a self-threaded tweet
private boolean selfThread = false;</p>
<p>// If the tweet is a part of an exclusive conversation, the author who started
// that conversation.
private Optional&lt;Long&gt; exclusiveConversationAuthorId = Optional.empty();</p>
<p>// tweet features map for multiple versions of penguin
private Map&lt;PenguinVersion, VersionedTweetFeatures&gt; versionedTweetFeaturesMap;</p>
<p>// Engagments count: favorites, retweets and replies
private int numFavorites = 0;
private int numRetweets = 0;
private int numReplies = 0;</p>
<p>// Card information
private String cardName;
private String cardDomain;
private String cardTitle;
private String cardDescription;
private String cardLang;
private String cardUrl;</p>
<p>private String placeId;
private String placeFullName;
private String placeCountryCode;</p>
<p>private Set&lt;NamedEntity&gt; namedEntities = Sets.newHashSet();</p>
<p>// Spaces data
private Set&lt;String&gt; spaceIds = Sets.newHashSet();
private Set&lt;TwitterMessageUser&gt; spaceAdmins = Sets.newHashSet();
private String spaceTitle;</p>
<p>private Optional&lt;ComposerSource&gt; composerSource = Optional.empty();</p>
<p>private final List&lt;PotentialLocationObject&gt; potentialLocations = Lists.newArrayList();</p>
<p>// one or two penguin versions supported by this system
private final List&lt;PenguinVersion&gt; supportedPenguinVersions;</p>
<dl>
<dt>public TwitterMessage(Long tweetId, List&lt;PenguinVersion&gt; supportedPenguinVersions) {</dt><dd><p>this.tweetId = tweetId;
this.places = new ArrayList&lt;&gt;();
this.expandedUrls = new LinkedHashMap&lt;&gt;();
// make sure we support at least one, but no more than two versions of penguin
this.supportedPenguinVersions = supportedPenguinVersions;
this.versionedTweetFeaturesMap = getVersionedTweetFeaturesMap();
Preconditions.checkArgument(this.supportedPenguinVersions.size() &lt;= 2</p>
<blockquote>
<div><p>&amp;&amp; this.supportedPenguinVersions.size() &gt; 0);</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Replace to-user with in-reply-to user if needed.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>public void replaceToUserWithInReplyToUserIfNeeded(</dt><dd><blockquote>
<div><p>String inReplyToScreenName, long inReplyToUserId) {</p>
</div></blockquote>
<dl>
<dt>if (shouldUseReplyUserAsToUser(optionalToUser, inReplyToUserId)) {</dt><dd><dl class="simple">
<dt>TwitterMessageUser replyUser =</dt><dd><p>TwitterMessageUser.createWithNamesAndId(inReplyToScreenName, “”, inReplyToUserId);</p>
</dd>
</dl>
<p>optionalToUser = Optional.of(replyUser);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// To-user could have been inferred from the mention at the position 0.
// But if there is an explicit in-reply-to user, we might need to use it as to-user instead.
private static boolean shouldUseReplyUserAsToUser(</p>
<blockquote>
<div><blockquote>
<div><p>Optional&lt;TwitterMessageUser&gt; currentToUser,
long inReplyToUserId) {</p>
</div></blockquote>
<dl class="simple">
<dt>if (!currentToUser.isPresent()) {</dt><dd><p>// There is no mention in the tweet that qualifies as to-user.
return true;</p>
</dd>
</dl>
<p>}</p>
<p>// We already have a mention in the tweet that qualifies as to-user.
TwitterMessageUser toUser = currentToUser.get();
if (!toUser.getId().isPresent()) {</p>
<blockquote>
<div><p>// The to-user from the mention is a stub.
return true;</p>
</div></blockquote>
<p>}</p>
<p>long toUserId = toUser.getId().get();
if (toUserId != inReplyToUserId) {</p>
<blockquote>
<div><p>// The to-user from the mention is different that the in-reply-to user,
// use in-reply-to user instead.
return true;</p>
</div></blockquote>
<p>}</p>
<p>return false;</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>public double getUserReputation() {</dt><dd><p>return userReputation;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Sets the user reputation.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>public TwitterMessage setUserReputation(double newUserReputation) {</dt><dd><dl class="simple">
<dt>if (newUserReputation &gt; MAX_USER_REPUTATION) {</dt><dd><p>LOG.warn(“Out of bounds user reputation {} for status id {}”, newUserReputation, tweetId);
this.userReputation = (float) MAX_USER_REPUTATION;</p>
</dd>
<dt>} else {</dt><dd><p>this.userReputation = newUserReputation;</p>
</dd>
</dl>
<p>}
return this;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getText() {</dt><dd><p>return text;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Optional&lt;TwitterMessageUser&gt; getOptionalToUser() {</dt><dd><p>return optionalToUser;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setOptionalToUser(Optional&lt;TwitterMessageUser&gt; optionalToUser) {</dt><dd><p>this.optionalToUser = optionalToUser;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setText(String text) {</dt><dd><p>this.text = text;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Date getDate() {</dt><dd><p>return date;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setDate(Date date) {</dt><dd><p>this.date = date;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setFromUser(&#64;Nonnull TwitterMessageUser fromUser) {</dt><dd><p>Preconditions.checkNotNull(fromUser, “Don’t set a null fromUser”);
optionalFromUser = Optional.of(fromUser);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Optional&lt;String&gt; getFromUserScreenName() {</dt><dd><dl class="simple">
<dt>return optionalFromUser.isPresent()</dt><dd><p>? optionalFromUser.get().getScreenName()
: Optional.empty();</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Sets the fromUserScreenName.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>public void setFromUserScreenName(&#64;Nonnull String fromUserScreenName) {</dt><dd><dl class="simple">
<dt>TwitterMessageUser newFromUser = optionalFromUser.isPresent()</dt><dd><p>? optionalFromUser.get().copyWithScreenName(fromUserScreenName)
: TwitterMessageUser.createWithScreenName(fromUserScreenName);</p>
</dd>
</dl>
<p>optionalFromUser = Optional.of(newFromUser);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Optional&lt;TokenStream&gt; getTokenizedFromUserScreenName() {</dt><dd><p>return optionalFromUser.flatMap(TwitterMessageUser::getTokenizedScreenName);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Optional&lt;String&gt; getFromUserDisplayName() {</dt><dd><p>return optionalFromUser.flatMap(TwitterMessageUser::getDisplayName);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Sets the fromUserDisplayName.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>public void setFromUserDisplayName(&#64;Nonnull String fromUserDisplayName) {</dt><dd><dl class="simple">
<dt>TwitterMessageUser newFromUser = optionalFromUser.isPresent()</dt><dd><p>? optionalFromUser.get().copyWithDisplayName(fromUserDisplayName)
: TwitterMessageUser.createWithDisplayName(fromUserDisplayName);</p>
</dd>
</dl>
<p>optionalFromUser = Optional.of(newFromUser);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Optional&lt;Long&gt; getFromUserTwitterId() {</dt><dd><p>return optionalFromUser.flatMap(TwitterMessageUser::getId);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Sets the fromUserId.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>public void setFromUserId(long fromUserId) {</dt><dd><dl class="simple">
<dt>TwitterMessageUser newFromUser = optionalFromUser.isPresent()</dt><dd><p>? optionalFromUser.get().copyWithId(fromUserId)
: TwitterMessageUser.createWithId(fromUserId);</p>
</dd>
</dl>
<p>optionalFromUser = Optional.of(newFromUser);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public long getConversationId() {</dt><dd><p>return conversationId;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setConversationId(long conversationId) {</dt><dd><p>this.conversationId = conversationId;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean isUserProtected() {</dt><dd><p>return this.userProtected;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setUserProtected(boolean userProtected) {</dt><dd><p>this.userProtected = userProtected;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean isUserVerified() {</dt><dd><p>return this.userVerified;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setUserVerified(boolean userVerified) {</dt><dd><p>this.userVerified = userVerified;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean isUserBlueVerified() {</dt><dd><p>return this.userBlueVerified;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setUserBlueVerified(boolean userBlueVerified) {</dt><dd><p>this.userBlueVerified = userBlueVerified;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setIsSensitiveContent(boolean isSensitiveContent) {</dt><dd><p>this.sensitiveContent = isSensitiveContent;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean isSensitiveContent() {</dt><dd><p>return this.sensitiveContent;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Optional&lt;TwitterMessageUser&gt; getToUserObject() {</dt><dd><p>return optionalToUser;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setToUserObject(&#64;Nonnull TwitterMessageUser user) {</dt><dd><p>Preconditions.checkNotNull(user, “Don’t set a null to-user”);
optionalToUser = Optional.of(user);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Optional&lt;Long&gt; getToUserTwitterId() {</dt><dd><p>return optionalToUser.flatMap(TwitterMessageUser::getId);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Sets toUserId.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>public void setToUserTwitterId(long toUserId) {</dt><dd><dl class="simple">
<dt>TwitterMessageUser newToUser = optionalToUser.isPresent()</dt><dd><p>? optionalToUser.get().copyWithId(toUserId)
: TwitterMessageUser.createWithId(toUserId);</p>
</dd>
</dl>
<p>optionalToUser = Optional.of(newToUser);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Optional&lt;String&gt; getToUserLowercasedScreenName() {</dt><dd><p>return optionalToUser.flatMap(TwitterMessageUser::getScreenName).map(String::toLowerCase);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Optional&lt;String&gt; getToUserScreenName() {</dt><dd><p>return optionalToUser.flatMap(TwitterMessageUser::getScreenName);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Sets toUserScreenName.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>public void setToUserScreenName(&#64;Nonnull String screenName) {</dt><dd><p>Preconditions.checkNotNull(screenName, “Don’t set a null to-user screenname”);</p>
<dl class="simple">
<dt>TwitterMessageUser newToUser = optionalToUser.isPresent()</dt><dd><p>? optionalToUser.get().copyWithScreenName(screenName)
: TwitterMessageUser.createWithScreenName(screenName);</p>
</dd>
</dl>
<p>optionalToUser = Optional.of(newToUser);</p>
</dd>
</dl>
<p>}</p>
<p>// to use from TweetEventParseHelper
public void setDirectedAtUserId(Optional&lt;Long&gt; directedAtUserId) {</p>
<blockquote>
<div><p>this.directedAtUserId = directedAtUserId;</p>
</div></blockquote>
<p>}</p>
<p>&#64;VisibleForTesting
public Optional&lt;Long&gt; getDirectedAtUserId() {</p>
<blockquote>
<div><p>return directedAtUserId;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the referenceAuthorId.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>public Optional&lt;Long&gt; getReferenceAuthorId() {</dt><dd><p>// The semantics of reference-author-id:
// - if the tweet is a retweet, it should be the user id of the author of the original tweet
// - else, if the tweet is directed at a user, it should be the id of the user it’s directed at.
// - else, if the tweet is a reply in a root self-thread, directed-at is not set, so it’s
//   the id of the user who started the self-thread.
//
// For definitive info on replies and directed-at, take a look at go/replies. To view these
// for a certain tweet, use <a class="reference external" href="http://go/t">http://go/t</a>.
//
// Note that if directed-at is set, reply is always set.
// If reply is set, directed-at is not necessarily set.
if (isRetweet() &amp;&amp; retweetMessage.hasSharedUserTwitterId()) {</p>
<blockquote>
<div><p>long retweetedUserId = retweetMessage.getSharedUserTwitterId();
return Optional.of(retweetedUserId);</p>
</div></blockquote>
<dl>
<dt>} else if (directedAtUserId.isPresent()) {</dt><dd><p>// Why not replace directedAtUserId with reply and make this function depend
// on the “reply” field of TweetCoreData?
// Well, verified by counters, it seems for ~1% of tweets, which contain both directed-at
// and reply, directed-at-user is different than the reply-to-user id. This happens in the
// following case:
//
//       author / reply-to / directed-at
//  T1   A        -          -
//  T2   B        A          A
//  T3   B        B          A
//
//  T2 is a reply to T1, T3 is a reply to T2.
//
// It’s up to us to decide who this tweet is “referencing”, but with the current code,
// we choose that T3 is referencing user A.
return directedAtUserId;</p>
</dd>
<dt>} else {</dt><dd><p>// This is the case of a root self-thread reply. directed-at is not set.
Optional&lt;Long&gt; fromUserId = this.getFromUserTwitterId();
Optional&lt;Long&gt; toUserId = this.getToUserTwitterId();</p>
<dl class="simple">
<dt>if (fromUserId.isPresent() &amp;&amp; fromUserId.equals(toUserId)) {</dt><dd><p>return fromUserId;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
return Optional.empty();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setNumFavorites(int numFavorites) {</dt><dd><p>this.numFavorites = numFavorites;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setNumRetweets(int numRetweets) {</dt><dd><p>this.numRetweets = numRetweets;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setNumReplies(int numRepliess) {</dt><dd><p>this.numReplies = numRepliess;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void addEscherbirdAnnotation(EscherbirdAnnotation annotation) {</dt><dd><p>escherbirdAnnotations.add(annotation);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public List&lt;EscherbirdAnnotation&gt; getEscherbirdAnnotations() {</dt><dd><p>return escherbirdAnnotations;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public List&lt;PotentialLocationObject&gt; getPotentialLocations() {</dt><dd><p>return potentialLocations;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setPotentialLocations(Collection&lt;PotentialLocationObject&gt; potentialLocations) {</dt><dd><p>this.potentialLocations.clear();
this.potentialLocations.addAll(potentialLocations);</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public String toString() {</p>
<blockquote>
<div><p>return ToStringBuilder.reflectionToString(this);</p>
</div></blockquote>
<p>}</p>
<p>// Tweet language related getters and setters.</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the locale.</p></li>
<li><p>&lt;p&gt;</p></li>
<li><p>Note the getLocale() will never return null, this is for the convenience of text related</p></li>
<li><p>processing in the ingester. If you want the real locale, you need to check isSetLocale()</p></li>
<li><p>first to see if we really have any information about the locale of this tweet.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>public Locale getLocale() {</dt><dd><dl class="simple">
<dt>if (locale == null) {</dt><dd><p>return TwitterLanguageIdentifier.UNKNOWN;</p>
</dd>
<dt>} else {</dt><dd><p>return locale;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setLocale(Locale locale) {</dt><dd><p>this.locale = locale;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Determines if the locate is set.</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
<dt>public boolean isSetLocale() {</dt><dd><p>return locale != null;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the language of the locale. E.g. zh</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>public String getLanguage() {</dt><dd><dl class="simple">
<dt>if (isSetLocale()) {</dt><dd><p>return getLocale().getLanguage();</p>
</dd>
<dt>} else {</dt><dd><p>return null;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the IETF BCP 47 Language Tag of the locale. E.g. zh-CN</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
<dt>public String getBCP47LanguageTag() {</dt><dd><dl class="simple">
<dt>if (isSetLocale()) {</dt><dd><p>return getLocale().toLanguageTag();</p>
</dd>
<dt>} else {</dt><dd><p>return null;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>public void setLanguage(String language) {</dt><dd><dl class="simple">
<dt>if (language != null) {</dt><dd><p>locale = LocaleUtil.getLocaleOf(language);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// Tweet link language related getters and setters.
public Locale getLinkLocale() {</p>
<blockquote>
<div><p>return linkLocale;</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>public void setLinkLocale(Locale linkLocale) {</dt><dd><p>this.linkLocale = linkLocale;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the language of the link locale.</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
<dt>public String getLinkLanguage() {</dt><dd><dl class="simple">
<dt>if (this.linkLocale == null) {</dt><dd><p>return null;</p>
</dd>
<dt>} else {</dt><dd><p>return this.linkLocale.getLanguage();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getOrigSource() {</dt><dd><p>return origSource;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setOrigSource(String origSource) {</dt><dd><p>this.origSource = origSource;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getStrippedSource() {</dt><dd><p>return strippedSource;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setStrippedSource(String strippedSource) {</dt><dd><p>this.strippedSource = strippedSource;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getOrigLocation() {</dt><dd><p>return origLocation;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getLocation() {</dt><dd><p>return truncatedNormalizedLocation;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setOrigLocation(String origLocation) {</dt><dd><p>this.origLocation = origLocation;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setTruncatedNormalizedLocation(String truncatedNormalizedLocation) {</dt><dd><p>this.truncatedNormalizedLocation = truncatedNormalizedLocation;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean hasFromUserLocCountry() {</dt><dd><p>return fromUserLocCountry != null;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getFromUserLocCountry() {</dt><dd><p>return fromUserLocCountry;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setFromUserLocCountry(String fromUserLocCountry) {</dt><dd><p>this.fromUserLocCountry = fromUserLocCountry;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getTruncatedNormalizedLocation() {</dt><dd><p>return truncatedNormalizedLocation;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Integer getFollowersCount() {</dt><dd><p>return followersCount;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setFollowersCount(Integer followersCount) {</dt><dd><p>this.followersCount = followersCount;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean hasFollowersCount() {</dt><dd><p>return followersCount != INT_FIELD_NOT_PRESENT;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean isDeleted() {</dt><dd><p>return deleted;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setDeleted(boolean deleted) {</dt><dd><p>this.deleted = deleted;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean hasCard() {</dt><dd><p>return !StringUtils.isBlank(getCardName());</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
public int hashCode() {</p>
<blockquote>
<div><p>return ((Long) getId()).hashCode();</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Parses the given date using the TwitterDateFormat.</p></li>
</ul>
<p><a href="#id29"><span class="problematic" id="id30">*</span></a>/</p>
</dd>
<dt>public static Date parseDate(String date) {</dt><dd><p>DateFormat parser = TwitterDateFormat.apply(“EEE MMM d HH:mm:ss Z yyyy”);
try {</p>
<blockquote>
<div><p>return parser.parse(date);</p>
</div></blockquote>
<dl class="simple">
<dt>} catch (Exception e) {</dt><dd><p>return null;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean hasGeoLocation() {</dt><dd><p>return geoLocation != null;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setGeoLocation(GeoObject location) {</dt><dd><p>this.geoLocation = location;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public GeoObject getGeoLocation() {</dt><dd><p>return geoLocation;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getPlaceId() {</dt><dd><p>return placeId;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setPlaceId(String placeId) {</dt><dd><p>this.placeId = placeId;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getPlaceFullName() {</dt><dd><p>return placeFullName;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setPlaceFullName(String placeFullName) {</dt><dd><p>this.placeFullName = placeFullName;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getPlaceCountryCode() {</dt><dd><p>return placeCountryCode;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setPlaceCountryCode(String placeCountryCode) {</dt><dd><p>this.placeCountryCode = placeCountryCode;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setGeoTaggedLocation(GeoObject geoTaggedLocation) {</dt><dd><p>this.geoTaggedLocation = geoTaggedLocation;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public GeoObject getGeoTaggedLocation() {</dt><dd><p>return geoTaggedLocation;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setLatLon(double latitude, double longitude) {</dt><dd><p>geoLocation = new GeoObject(latitude, longitude, null);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Double getLatitude() {</dt><dd><p>return hasGeoLocation() ? geoLocation.getLatitude() : null;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Double getLongitude() {</dt><dd><p>return hasGeoLocation() ? geoLocation.getLongitude() : null;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean isUncodeableLocation() {</dt><dd><p>return uncodeableLocation;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setUncodeableLocation() {</dt><dd><p>uncodeableLocation = true;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setGeocodeRequired() {</dt><dd><p>this.geocodeRequired = true;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean isGeocodeRequired() {</dt><dd><p>return geocodeRequired;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Map&lt;Long, String&gt; getPhotoUrls() {</dt><dd><p>return photoUrls;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Associates the given mediaUrl with the given photoStatusId.</p></li>
</ul>
<p><a href="#id31"><span class="problematic" id="id32">*</span></a>/</p>
</dd>
<dt>public void addPhotoUrl(long photoStatusId, String mediaUrl) {</dt><dd><dl class="simple">
<dt>if (photoUrls == null) {</dt><dd><p>photoUrls = new LinkedHashMap&lt;&gt;();</p>
</dd>
</dl>
<p>}
photoUrls.putIfAbsent(photoStatusId, mediaUrl);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Map&lt;String, ThriftExpandedUrl&gt; getExpandedUrlMap() {</dt><dd><p>return expandedUrls;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public int getExpandedUrlMapSize() {</dt><dd><p>return expandedUrls.size();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Associates the given originalUrl with the given expanderUrl.</p></li>
</ul>
<p><a href="#id33"><span class="problematic" id="id34">*</span></a>/</p>
</dd>
<dt>public void addExpandedUrl(String originalUrl, ThriftExpandedUrl expandedUrl) {</dt><dd><p>this.expandedUrls.put(originalUrl, expandedUrl);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Replaces urls with resolved ones.</p></li>
</ul>
<p><a href="#id35"><span class="problematic" id="id36">*</span></a>/</p>
</dd>
<dt>public String getTextReplacedWithResolvedURLs() {</dt><dd><p>String retText = text;
for (Map.Entry&lt;String, ThriftExpandedUrl&gt; entry : expandedUrls.entrySet()) {</p>
<blockquote>
<div><p>ThriftExpandedUrl urlInfo = entry.getValue();
String resolvedUrl;
String canonicalLastHopUrl = urlInfo.getCanonicalLastHopUrl();
String expandedUrl = urlInfo.getExpandedUrl();
if (canonicalLastHopUrl != null) {</p>
<blockquote>
<div><p>resolvedUrl = canonicalLastHopUrl;
LOG.debug(“{} has canonical last hop url set”, urlInfo);</p>
</div></blockquote>
<dl class="simple">
<dt>} else if (expandedUrl != null) {</dt><dd><p>LOG.debug(“{} has no canonical last hop url set, using expanded url instead”, urlInfo);
resolvedUrl = expandedUrl;</p>
</dd>
<dt>} else {</dt><dd><p>LOG.debug(“{} has no canonical last hop url or expanded url set, skipping”, urlInfo);
continue;</p>
</dd>
</dl>
<p>}
retText = retText.replace(entry.getKey(), resolvedUrl);</p>
</div></blockquote>
<p>}
return retText;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public long getId() {</dt><dd><p>return tweetId;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean isRetweet() {</dt><dd><p>return retweetMessage != null;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean hasQuote() {</dt><dd><p>return quotedMessage != null;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean isReply() {</dt><dd><dl class="simple">
<dt>return getToUserScreenName().isPresent()</dt><dd><p>|| getToUserTwitterId().isPresent()
|| getInReplyToStatusId().isPresent();</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean isReplyToTweet() {</dt><dd><p>return getInReplyToStatusId().isPresent();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public TwitterRetweetMessage getRetweetMessage() {</dt><dd><p>return retweetMessage;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setRetweetMessage(TwitterRetweetMessage retweetMessage) {</dt><dd><p>this.retweetMessage = retweetMessage;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public TwitterQuotedMessage getQuotedMessage() {</dt><dd><p>return quotedMessage;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setQuotedMessage(TwitterQuotedMessage quotedMessage) {</dt><dd><p>this.quotedMessage = quotedMessage;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public List&lt;String&gt; getPlaces() {</dt><dd><p>return places;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void addPlace(String place) {</dt><dd><p>// Places are used for earlybird serialization
places.add(place);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Optional&lt;Long&gt; getInReplyToStatusId() {</dt><dd><p>return inReplyToStatusId;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setInReplyToStatusId(long inReplyToStatusId) {</dt><dd><p>Preconditions.checkArgument(inReplyToStatusId &gt; 0, “In-reply-to status ID should be positive”);
this.inReplyToStatusId = Optional.of(inReplyToStatusId);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean getNullcast() {</dt><dd><p>return nullcast;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setNullcast(boolean nullcast) {</dt><dd><p>this.nullcast = nullcast;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public List&lt;PenguinVersion&gt; getSupportedPenguinVersions() {</dt><dd><p>return supportedPenguinVersions;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private VersionedTweetFeatures getVersionedTweetFeatures(PenguinVersion penguinVersion) {</dt><dd><p>VersionedTweetFeatures versionedTweetFeatures = versionedTweetFeaturesMap.get(penguinVersion);
return Preconditions.checkNotNull(versionedTweetFeatures);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public TweetFeatures getTweetFeatures(PenguinVersion penguinVersion) {</dt><dd><p>return getVersionedTweetFeatures(penguinVersion).getTweetFeatures();</p>
</dd>
</dl>
<p>}</p>
<p>&#64;VisibleForTesting
// only used in Tests
public void setTweetFeatures(PenguinVersion penguinVersion, TweetFeatures tweetFeatures) {</p>
<blockquote>
<div><p>versionedTweetFeaturesMap.get(penguinVersion).setTweetFeatures(tweetFeatures);</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>public int getTweetSignature(PenguinVersion penguinVersion) {</dt><dd><p>return getVersionedTweetFeatures(penguinVersion).getTweetTextFeatures().getSignature();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public TweetTextQuality getTweetTextQuality(PenguinVersion penguinVersion) {</dt><dd><p>return getVersionedTweetFeatures(penguinVersion).getTweetTextQuality();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public TweetTextFeatures getTweetTextFeatures(PenguinVersion penguinVersion) {</dt><dd><p>return getVersionedTweetFeatures(penguinVersion).getTweetTextFeatures();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public TweetUserFeatures getTweetUserFeatures(PenguinVersion penguinVersion) {</dt><dd><p>return getVersionedTweetFeatures(penguinVersion).getTweetUserFeatures();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public TokenizedCharSequence getTokenizedCharSequence(PenguinVersion penguinVersion) {</dt><dd><p>return getVersionedTweetFeatures(penguinVersion).getTokenizedCharSequence();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>public void setTokenizedCharSequence(PenguinVersion penguinVersion,</dt><dd><blockquote>
<div><p>TokenizedCharSequence sequence) {</p>
</div></blockquote>
<p>getVersionedTweetFeatures(penguinVersion).setTokenizedCharSequence(sequence);</p>
</dd>
</dl>
<p>}</p>
<p>// True if the features contain multiple hash tags or multiple trends.
// This is intended as an anti-trend-spam measure.
public static boolean hasMultipleHashtagsOrTrends(TweetTextFeatures textFeatures) {</p>
<blockquote>
<div><p>// Allow at most 1 trend and 2 hashtags.
return textFeatures.getTrendingTermsSize() &gt; 1 || textFeatures.getHashtagsSize() &gt; 2;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the expanded URLs.</p></li>
</ul>
<p><a href="#id37"><span class="problematic" id="id38">*</span></a>/</p>
</dd>
<dt>public Collection&lt;ThriftExpandedUrl&gt; getExpandedUrls() {</dt><dd><p>return expandedUrls.values();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the canonical last hop URLs.</p></li>
</ul>
<p><a href="#id39"><span class="problematic" id="id40">*</span></a>/</p>
</dd>
<dt>public Set&lt;String&gt; getCanonicalLastHopUrls() {</dt><dd><p>Set&lt;String&gt; result = new HashSet&lt;&gt;(expandedUrls.size());
for (ThriftExpandedUrl url : expandedUrls.values()) {</p>
<blockquote>
<div><p>result.add(url.getCanonicalLastHopUrl());</p>
</div></blockquote>
<p>}
return result;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getCardName() {</dt><dd><p>return cardName;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setCardName(String cardName) {</dt><dd><p>this.cardName = cardName;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getCardDomain() {</dt><dd><p>return cardDomain;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setCardDomain(String cardDomain) {</dt><dd><p>this.cardDomain = cardDomain;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getCardTitle() {</dt><dd><p>return cardTitle;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setCardTitle(String cardTitle) {</dt><dd><p>this.cardTitle = cardTitle;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getCardDescription() {</dt><dd><p>return cardDescription;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setCardDescription(String cardDescription) {</dt><dd><p>this.cardDescription = cardDescription;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getCardLang() {</dt><dd><p>return cardLang;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setCardLang(String cardLang) {</dt><dd><p>this.cardLang = cardLang;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getCardUrl() {</dt><dd><p>return cardUrl;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setCardUrl(String cardUrl) {</dt><dd><p>this.cardUrl = cardUrl;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public List&lt;TwitterMessageUser&gt; getMentions() {</dt><dd><p>return this.mentions;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setMentions(List&lt;TwitterMessageUser&gt; mentions) {</dt><dd><p>this.mentions = mentions;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>public List&lt;String&gt; getLowercasedMentions() {</dt><dd><dl class="simple">
<dt>return Lists.transform(getMentions(), user -&gt; {</dt><dd><p>// This condition is also checked in addUserToMentions().
Preconditions.checkState(user.getScreenName().isPresent(), “Invalid mention”);
return user.getScreenName().get().toLowerCase();</p>
</dd>
</dl>
<p>});</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Set&lt;String&gt; getHashtags() {</dt><dd><p>return this.hashtags;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Set&lt;String&gt; getNormalizedHashtags(PenguinVersion penguinVersion) {</dt><dd><p>return getVersionedTweetFeatures(penguinVersion).getNormalizedHashtags();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void addNormalizedHashtag(String normalizedHashtag, PenguinVersion penguinVersion) {</dt><dd><p>getVersionedTweetFeatures(penguinVersion).addNormalizedHashtags(normalizedHashtag);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Optional&lt;ComposerSource&gt; getComposerSource() {</dt><dd><p>return composerSource;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setComposerSource(ComposerSource composerSource) {</dt><dd><p>Preconditions.checkNotNull(composerSource, “composerSource should not be null”);
this.composerSource = Optional.of(composerSource);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean isSelfThread() {</dt><dd><p>return selfThread;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setSelfThread(boolean selfThread) {</dt><dd><p>this.selfThread = selfThread;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean isExclusive() {</dt><dd><p>return exclusiveConversationAuthorId.isPresent();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public long getExclusiveConversationAuthorId() {</dt><dd><p>return exclusiveConversationAuthorId.get();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setExclusiveConversationAuthorId(long exclusiveConversationAuthorId) {</dt><dd><p>this.exclusiveConversationAuthorId = Optional.of(exclusiveConversationAuthorId);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Adds an expanded media url based on the given parameters.</p></li>
</ul>
<p><a href="#id41"><span class="problematic" id="id42">*</span></a>/</p>
</dd>
<dt>public void addExpandedMediaUrl(String originalUrl,</dt><dd><blockquote>
<div><p>String expandedUrl,
&#64;Nullable MediaTypes mediaType) {</p>
</div></blockquote>
<dl>
<dt>if (!StringUtils.isBlank(originalUrl) &amp;&amp; !StringUtils.isBlank(expandedUrl)) {</dt><dd><p>ThriftExpandedUrl thriftExpandedUrl = new ThriftExpandedUrl();
if (mediaType != null) {</p>
<blockquote>
<div><p>thriftExpandedUrl.setMediaType(mediaType);</p>
</div></blockquote>
<p>}
thriftExpandedUrl.setOriginalUrl(originalUrl);
thriftExpandedUrl.setExpandedUrl(expandedUrl);  // This will be tokenized and indexed
// Note that the mediaURL is not indexed. We could also index it, but it is not indexed
// to reduce RAM usage.
thriftExpandedUrl.setCanonicalLastHopUrl(expandedUrl); // This will be tokenized and indexed
addExpandedUrl(originalUrl, thriftExpandedUrl);
thriftExpandedUrl.setConsumerMedia(true);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Adds an expanded non-media url based on the given parameters.</p></li>
</ul>
<p><a href="#id43"><span class="problematic" id="id44">*</span></a>/</p>
</dd>
<dt>public void addExpandedNonMediaUrl(String originalUrl, String expandedUrl) {</dt><dd><dl>
<dt>if (!StringUtils.isBlank(originalUrl)) {</dt><dd><p>ThriftExpandedUrl thriftExpandedUrl = new ThriftExpandedUrl(originalUrl);
if (!StringUtils.isBlank(expandedUrl)) {</p>
<blockquote>
<div><p>thriftExpandedUrl.setExpandedUrl(expandedUrl);</p>
</div></blockquote>
<p>}
addExpandedUrl(originalUrl, thriftExpandedUrl);
thriftExpandedUrl.setConsumerMedia(false);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Only used in tests.</p></li>
<li></li>
<li><p>Simulates resolving compressed URLs, which is usually done by ResolveCompressedUrlsStage.</p></li>
</ul>
<p><a href="#id45"><span class="problematic" id="id46">*</span></a>/</p>
</dd>
</dl>
<p>&#64;VisibleForTesting
public void replaceUrlsWithResolvedUrls(Map&lt;String, String&gt; resolvedUrls) {</p>
<blockquote>
<div><dl>
<dt>for (Map.Entry&lt;String, ThriftExpandedUrl&gt; urlEntry<span class="classifier">expandedUrls.entrySet()) {</span></dt><dd><p>String tcoUrl = urlEntry.getKey();
if (resolvedUrls.containsKey(tcoUrl)) {</p>
<blockquote>
<div><p>ThriftExpandedUrl expandedUrl = urlEntry.getValue();
expandedUrl.setCanonicalLastHopUrl(resolvedUrls.get(tcoUrl));</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Adds a mention for a user with the given screen name.</p></li>
</ul>
<p><a href="#id47"><span class="problematic" id="id48">*</span></a>/</p>
</dd>
<dt>public void addMention(String screenName) {</dt><dd><p>TwitterMessageUser user = TwitterMessageUser.createWithScreenName(screenName);
addUserToMentions(user);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Adds the given user to mentions.</p></li>
</ul>
<p><a href="#id49"><span class="problematic" id="id50">*</span></a>/</p>
</dd>
<dt>public void addUserToMentions(TwitterMessageUser user) {</dt><dd><p>Preconditions.checkArgument(user.getScreenName().isPresent(), “Don’t add invalid mentions”);
this.mentions.add(user);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Adds the given hashtag.</p></li>
</ul>
<p><a href="#id51"><span class="problematic" id="id52">*</span></a>/</p>
</dd>
<dt>public void addHashtag(String hashtag) {</dt><dd><p>this.hashtags.add(hashtag);
for (PenguinVersion penguinVersion : supportedPenguinVersions) {</p>
<blockquote>
<div><dl class="simple">
<dt>addNormalizedHashtag(NormalizerHelper.normalize(hashtag, getLocale(), penguinVersion),</dt><dd><p>penguinVersion);</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private Map&lt;PenguinVersion, VersionedTweetFeatures&gt; getVersionedTweetFeaturesMap() {</dt><dd><dl class="simple">
<dt>Map&lt;PenguinVersion, VersionedTweetFeatures&gt; versionedMap =</dt><dd><p>Maps.newEnumMap(PenguinVersion.class);</p>
</dd>
<dt>for (PenguinVersion penguinVersion<span class="classifier">getSupportedPenguinVersions()) {</span></dt><dd><p>versionedMap.put(penguinVersion, new VersionedTweetFeatures());</p>
</dd>
</dl>
<p>}</p>
<p>return versionedMap;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public int getNumFavorites() {</dt><dd><p>return numFavorites;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public int getNumRetweets() {</dt><dd><p>return numRetweets;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public int getNumReplies() {</dt><dd><p>return numReplies;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Set&lt;NamedEntity&gt; getNamedEntities() {</dt><dd><p>return namedEntities;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void addNamedEntity(NamedEntity namedEntity) {</dt><dd><p>namedEntities.add(namedEntity);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Set&lt;String&gt; getSpaceIds() {</dt><dd><p>return spaceIds;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setSpaceIds(Set&lt;String&gt; spaceIds) {</dt><dd><p>this.spaceIds = Sets.newHashSet(spaceIds);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Set&lt;TwitterMessageUser&gt; getSpaceAdmins() {</dt><dd><p>return spaceAdmins;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void addSpaceAdmin(TwitterMessageUser admin) {</dt><dd><p>spaceAdmins.add(admin);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public String getSpaceTitle() {</dt><dd><p>return spaceTitle;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void setSpaceTitle(String spaceTitle) {</dt><dd><p>this.spaceTitle = spaceTitle;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private static boolean equals(List&lt;EscherbirdAnnotation&gt; l1, List&lt;EscherbirdAnnotation&gt; l2) {</dt><dd><p>EscherbirdAnnotation[] arr1 = l1.toArray(new EscherbirdAnnotation[l1.size()]);
Arrays.sort(arr1);
EscherbirdAnnotation[] arr2 = l1.toArray(new EscherbirdAnnotation[l2.size()]);
Arrays.sort(arr2);
return Arrays.equals(arr1, arr2);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Compares the given messages using reflection and determines if they’re approximately equal.</p></li>
</ul>
<p><a href="#id53"><span class="problematic" id="id54">*</span></a>/</p>
</dd>
<dt>public static boolean reflectionApproxEquals(</dt><dd><blockquote>
<div><p>TwitterMessage a,
TwitterMessage b,
List&lt;String&gt; additionalExcludeFields) {</p>
</div></blockquote>
<dl class="simple">
<dt>List&lt;String&gt; excludeFields = Lists.newArrayList(</dt><dd><p>“versionedTweetFeaturesMap”,
“geoLocation”,
“geoTaggedLocation”,
“escherbirdAnnotations”</p>
</dd>
</dl>
<p>);
excludeFields.addAll(additionalExcludeFields);</p>
<dl class="simple">
<dt>return EqualsBuilder.reflectionEquals(a, b, excludeFields)</dt><dd><p>&amp;&amp; GeoObject.approxEquals(a.getGeoLocation(), b.getGeoLocation())
&amp;&amp; GeoObject.approxEquals(a.getGeoTaggedLocation(), b.getGeoTaggedLocation())
&amp;&amp; equals(a.getEscherbirdAnnotations(), b.getEscherbirdAnnotations());</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public static boolean reflectionApproxEquals(TwitterMessage a, TwitterMessage b) {</dt><dd><p>return reflectionApproxEquals(a, b, Collections.emptyList());</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../_sources/src/java/com/twitter/search/common/relevance/entities/TwitterMessage.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>