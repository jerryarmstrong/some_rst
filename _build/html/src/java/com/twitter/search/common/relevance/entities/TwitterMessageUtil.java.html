<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../" id="documentation_options" src="../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.common.relevance.entities;</p>
<p>import java.text.Normalizer;
import java.util.Map;
import java.util.NavigableMap;
import java.util.Set;
import java.util.TreeMap;
import java.util.concurrent.ConcurrentMap;</p>
<p>import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.Maps;</p>
<p>import org.apache.commons.lang.StringUtils;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;</p>
<p>import com.twitter.common.text.transformer.HTMLTagRemovalTransformer;
import com.twitter.common_internal.text.extractor.EmojiExtractor;
import com.twitter.search.common.metrics.SearchRateCounter;
import com.twitter.search.common.partitioning.snowflakeparser.SnowflakeIdParser;</p>
<dl>
<dt>public final class TwitterMessageUtil {</dt><dd><p>private static final Logger LOG = LoggerFactory.getLogger(TwitterMessageUtil.class);</p>
<p>private TwitterMessageUtil() {
}</p>
<p>&#64;VisibleForTesting
static final ConcurrentMap&lt;Field, Counters&gt; COUNTERS_MAP = Maps.newConcurrentMap();
// We truncate the location string because we used to use a MySQL table to store the geocoding
// information.  In the MySQL table, the location string was fix width of 30 characters.
// We have migrated to Manhattan and the location string is no longer limited to 30 character.
// However, in order to correctly lookup location geocode from Manhattan, we still need to
// truncate the location just like we did before.
private static final int MAX_LOCATION_LEN = 30;</p>
<p>// Note: we strip tags to index source, as typically source contains &lt;a href=…&gt; tags.
// Sometimes we get a source where stripping fails, as the URL in the tag was
// excessively long.  We drop these sources, as there is little reason to index them.
private static final int MAX_SOURCE_LEN = 64;</p>
<p>private static HTMLTagRemovalTransformer tagRemovalTransformer = new HTMLTagRemovalTransformer();</p>
<p>private static final String STAT_PREFIX = “<a href="#id15"><span class="problematic" id="id16">twitter_message_</span></a>”;</p>
<dl>
<dt>public enum Field {</dt><dd><p>FROM_USER_DISPLAY_NAME,
NORMALIZED_LOCATION,
ORIG_LOCATION,
ORIG_SOURCE,
SHARED_USER_DISPLAY_NAME,
SOURCE,
TEXT,
TO_USER_SCREEN_NAME;</p>
<dl class="simple">
<dt>public String getNameForStats() {</dt><dd><p>return name().toLowerCase();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>&#64;VisibleForTesting
static class Counters {</p>
<blockquote>
<div><p>private final SearchRateCounter truncatedCounter;
private final SearchRateCounter tweetsWithStrippedSupplementaryCharsCounter;
private final SearchRateCounter strippedSupplementaryCharsCounter;
private final SearchRateCounter nonStrippedEmojiCharsCounter;
private final SearchRateCounter emojisAtTruncateBoundaryCounter;</p>
<dl>
<dt>Counters(Field field) {</dt><dd><p>String fieldNameForStats = field.getNameForStats();
truncatedCounter = SearchRateCounter.export(</p>
<blockquote>
<div><p>STAT_PREFIX + “<a href="#id17"><span class="problematic" id="id18">truncated_</span></a>” + fieldNameForStats);</p>
</div></blockquote>
<dl class="simple">
<dt>tweetsWithStrippedSupplementaryCharsCounter = SearchRateCounter.export(</dt><dd><p>STAT_PREFIX + “<a href="#id19"><span class="problematic" id="id20">tweets_with_stripped_supplementary_chars_</span></a>” + fieldNameForStats);</p>
</dd>
<dt>strippedSupplementaryCharsCounter = SearchRateCounter.export(</dt><dd><p>STAT_PREFIX + “<a href="#id21"><span class="problematic" id="id22">stripped_supplementary_chars_</span></a>” + fieldNameForStats);</p>
</dd>
<dt>nonStrippedEmojiCharsCounter = SearchRateCounter.export(</dt><dd><p>STAT_PREFIX + “<a href="#id23"><span class="problematic" id="id24">non_stripped_emoji_chars_</span></a>” + fieldNameForStats);</p>
</dd>
<dt>emojisAtTruncateBoundaryCounter = SearchRateCounter.export(</dt><dd><p>STAT_PREFIX + “<a href="#id25"><span class="problematic" id="id26">emojis_at_truncate_boundary_</span></a>” + fieldNameForStats);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>SearchRateCounter getTruncatedCounter() {</dt><dd><p>return truncatedCounter;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>SearchRateCounter getTweetsWithStrippedSupplementaryCharsCounter() {</dt><dd><p>return tweetsWithStrippedSupplementaryCharsCounter;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>SearchRateCounter getStrippedSupplementaryCharsCounter() {</dt><dd><p>return strippedSupplementaryCharsCounter;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>SearchRateCounter getNonStrippedEmojiCharsCounter() {</dt><dd><p>return nonStrippedEmojiCharsCounter;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>SearchRateCounter getEmojisAtTruncateBoundaryCounter() {</dt><dd><p>return emojisAtTruncateBoundaryCounter;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>static {</dt><dd><dl class="simple">
<dt>for (Field field<span class="classifier">Field.values()) {</span></dt><dd><p>COUNTERS_MAP.put(field, new Counters(field));</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// Note: the monorail enforces a limit of 15 characters for screen names,
// but some users with up to 20 character names were grandfathered-in.  To allow
// those users to be searchable, support up to 20 chars.
private static final int MAX_SCREEN_NAME_LEN = 20;</p>
<p>// Note: we expect the current limit to be 10K. Also, all supplementary unicode characters (with
// the exception of emojis, maybe) will be removed and not counted as total length. Added alert
// for text truncation rate as well. SEARCH-9512
private static final int MAX_TWEET_TEXT_LEN = 10000;</p>
<p>&#64;VisibleForTesting
static final SearchRateCounter FILTERED_NO_STATUS_ID =</p>
<blockquote>
<div><p>SearchRateCounter.export(STAT_PREFIX + “filtered_no_status_id”);</p>
</div></blockquote>
<p>&#64;VisibleForTesting
static final SearchRateCounter FILTERED_NO_FROM_USER =</p>
<blockquote>
<div><p>SearchRateCounter.export(STAT_PREFIX + “filtered_no_from_user”);</p>
</div></blockquote>
<p>&#64;VisibleForTesting
static final SearchRateCounter FILTERED_LONG_SCREEN_NAME =</p>
<blockquote>
<div><p>SearchRateCounter.export(STAT_PREFIX + “filtered_long_screen_name”);</p>
</div></blockquote>
<p>&#64;VisibleForTesting
static final SearchRateCounter FILTERED_NO_TEXT =</p>
<blockquote>
<div><p>SearchRateCounter.export(STAT_PREFIX + “filtered_no_text”);</p>
</div></blockquote>
<p>&#64;VisibleForTesting
static final SearchRateCounter FILTERED_NO_DATE =</p>
<blockquote>
<div><p>SearchRateCounter.export(STAT_PREFIX + “filtered_no_date”);</p>
</div></blockquote>
<p>&#64;VisibleForTesting
static final SearchRateCounter NULLCAST_TWEET =</p>
<blockquote>
<div><p>SearchRateCounter.export(STAT_PREFIX + “filter_nullcast_tweet”);</p>
</div></blockquote>
<p>&#64;VisibleForTesting
static final SearchRateCounter NULLCAST_TWEET_ACCEPTED =</p>
<blockquote>
<div><p>SearchRateCounter.export(STAT_PREFIX + “nullcast_tweet_accepted”);</p>
</div></blockquote>
<p>&#64;VisibleForTesting
static final SearchRateCounter INCONSISTENT_TWEET_ID_AND_CREATED_AT =</p>
<blockquote>
<div><p>SearchRateCounter.export(STAT_PREFIX + “inconsistent_tweet_id_and_created_at_ms”);</p>
</div></blockquote>
<p>/** Strips the given source from the message with the given ID. <a href="#id1"><span class="problematic" id="id2">*</span></a>/
private static String stripSource(String source, Long messageId) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (source == null) {</dt><dd><p>return null;</p>
</dd>
</dl>
<p>}
// Always strip emojis from sources: they don’t really make sense in this field.
String strippedSource = stripSupplementaryChars(</p>
<blockquote>
<div><p>tagRemovalTransformer.transform(source).toString(), Field.SOURCE, true);</p>
</div></blockquote>
<dl>
<dt>if (strippedSource.length() &gt; MAX_SOURCE_LEN) {</dt><dd><dl class="simple">
<dt>LOG.warn(“Message “</dt><dd><ul class="simple">
<li><p>messageId</p></li>
<li><p>“ contains stripped source that exceeds MAX_SOURCE_LEN. Removing: “</p></li>
<li><p>strippedSource);</p></li>
</ul>
</dd>
</dl>
<p>COUNTERS_MAP.get(Field.SOURCE).getTruncatedCounter().increment();
return null;</p>
</dd>
</dl>
<p>}
return strippedSource;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Strips and truncates the location of the message with the given ID.</p></li>
<li></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>private static String stripAndTruncateLocation(String location) {</dt><dd><p>// Always strip emojis from locations: they don’t really make sense in this field.
String strippedLocation = stripSupplementaryChars(location, Field.NORMALIZED_LOCATION, true);
return truncateString(strippedLocation, MAX_LOCATION_LEN, Field.NORMALIZED_LOCATION, true);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Sets the origSource and strippedSource fields on a TwitterMessage</p></li>
<li></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>public static void setSourceOnMessage(TwitterMessage message, String modifiedDeviceSource) {</dt><dd><p>// Always strip emojis from sources: they don’t really make sense in this field.
message.setOrigSource(stripSupplementaryChars(modifiedDeviceSource, Field.ORIG_SOURCE, true));
message.setStrippedSource(stripSource(modifiedDeviceSource, message.getId()));</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Sets the origLocation to the stripped location, and sets</p></li>
<li><p>the truncatedNormalizedLocation to the truncated and normalized location.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>public static void setAndTruncateLocationOnMessage(</dt><dd><blockquote>
<div><p>TwitterMessage message,
String newOrigLocation) {</p>
</div></blockquote>
<p>// Always strip emojis from locations: they don’t really make sense in this field.
message.setOrigLocation(stripSupplementaryChars(newOrigLocation, Field.ORIG_LOCATION, true));</p>
<p>// Locations in the new locations table require additional normalization. It can also change
// the length of the string, so we must do this before truncation.
if (newOrigLocation != null) {</p>
<blockquote>
<div><dl class="simple">
<dt>String normalized =</dt><dd><p>Normalizer.normalize(newOrigLocation, Normalizer.Form.NFKC).toLowerCase().trim();</p>
</dd>
</dl>
<p>message.setTruncatedNormalizedLocation(stripAndTruncateLocation(normalized));</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>message.setTruncatedNormalizedLocation(null);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Validates the given TwitterMessage.</p></li>
<li></li>
<li><p>&#64;param message The message to validate.</p></li>
<li><p>&#64;param stripEmojisForFields The set of fields for which emojis should be stripped.</p></li>
<li><p>&#64;param acceptNullcastMessage Determines if this message should be accepted, if it’s a nullcast</p></li>
<li><p>message.</p></li>
<li><p>&#64;return <a class="reference external" href="mailto:{&#37;&#52;&#48;code">{<span>&#64;</span>code</a> true} if the given message is valid; <a class="reference external" href="mailto:{&#37;&#52;&#48;code">{<span>&#64;</span>code</a> false} otherwise.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>public static boolean validateTwitterMessage(</dt><dd><blockquote>
<div><p>TwitterMessage message,
Set&lt;Field&gt; stripEmojisForFields,
boolean acceptNullcastMessage) {</p>
</div></blockquote>
<dl>
<dt>if (message.getNullcast()) {</dt><dd><p>NULLCAST_TWEET.increment();
if (!acceptNullcastMessage) {</p>
<blockquote>
<div><p>LOG.info(“Dropping nullcasted message “ + message.getId());
return false;</p>
</div></blockquote>
<p>}
NULLCAST_TWEET_ACCEPTED.increment();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>if (!message.getFromUserScreenName().isPresent()</dt><dd><blockquote>
<div><p>|| StringUtils.isBlank(message.getFromUserScreenName().get())) {</p>
</div></blockquote>
<p>LOG.error(“Message “ + message.getId() + “ contains no from user. Skipping.”);
FILTERED_NO_FROM_USER.increment();
return false;</p>
</dd>
</dl>
<p>}
String fromUserScreenName = message.getFromUserScreenName().get();</p>
<dl>
<dt>if (fromUserScreenName.length() &gt; MAX_SCREEN_NAME_LEN) {</dt><dd><dl class="simple">
<dt>LOG.warn(“Message “ + message.getId() + “ has a user screen name longer than “</dt><dd><ul class="simple">
<li><p>MAX_SCREEN_NAME_LEN + “ characters: “ + message.getFromUserScreenName()</p></li>
<li><p>“. Skipping.”);</p></li>
</ul>
</dd>
</dl>
<p>FILTERED_LONG_SCREEN_NAME.increment();
return false;</p>
</dd>
</dl>
<p>}</p>
<p>// Remove supplementary characters and truncate these text fields.
if (message.getFromUserDisplayName().isPresent()) {</p>
<blockquote>
<div><dl class="simple">
<dt>message.setFromUserDisplayName(stripSupplementaryChars(</dt><dd><p>message.getFromUserDisplayName().get(),
Field.FROM_USER_DISPLAY_NAME,
stripEmojisForFields.contains(Field.FROM_USER_DISPLAY_NAME)));</p>
</dd>
</dl>
</div></blockquote>
<p>}
if (message.getToUserScreenName().isPresent()) {</p>
<blockquote>
<div><dl class="simple">
<dt>String strippedToUserScreenName = stripSupplementaryChars(</dt><dd><p>message.getToUserLowercasedScreenName().get(),
Field.TO_USER_SCREEN_NAME,
stripEmojisForFields.contains(Field.TO_USER_SCREEN_NAME));</p>
</dd>
<dt>message.setToUserScreenName(</dt><dd><dl class="simple">
<dt>truncateString(</dt><dd><p>strippedToUserScreenName,
MAX_SCREEN_NAME_LEN,
Field.TO_USER_SCREEN_NAME,
stripEmojisForFields.contains(Field.TO_USER_SCREEN_NAME)));</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>String strippedText = stripSupplementaryChars(</dt><dd><p>message.getText(),
Field.TEXT,
stripEmojisForFields.contains(Field.TEXT));</p>
</dd>
<dt>message.setText(truncateString(</dt><dd><p>strippedText,
MAX_TWEET_TEXT_LEN,
Field.TEXT,
stripEmojisForFields.contains(Field.TEXT)));</p>
</dd>
<dt>if (StringUtils.isBlank(message.getText())) {</dt><dd><p>FILTERED_NO_TEXT.increment();
return false;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (message.getDate() == null) {</dt><dd><p>LOG.error(“Message “ + message.getId() + “ contains no date. Skipping.”);
FILTERED_NO_DATE.increment();
return false;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (message.isRetweet()) {</dt><dd><p>return validateRetweetMessage(message.getRetweetMessage(), stripEmojisForFields);</p>
</dd>
</dl>
<p>}</p>
<p>// Track if both the snowflake ID and created at timestamp are consistent.
if (!SnowflakeIdParser.isTweetIDAndCreatedAtConsistent(message.getId(), message.getDate())) {</p>
<blockquote>
<div><dl class="simple">
<dt>LOG.error(“Found inconsistent tweet ID and created at timestamp: [messageID=”</dt><dd><ul class="simple">
<li><p>message.getId() + “], [messageDate=” + message.getDate() + “].”);</p></li>
</ul>
</dd>
</dl>
<p>INCONSISTENT_TWEET_ID_AND_CREATED_AT.increment();</p>
</div></blockquote>
<p>}</p>
<p>return true;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private static boolean validateRetweetMessage(</dt><dd><blockquote>
<div><p>TwitterRetweetMessage message, Set&lt;Field&gt; stripEmojisForFields) {</p>
</div></blockquote>
<dl class="simple">
<dt>if (message.getSharedId() == null || message.getRetweetId() == null) {</dt><dd><p>LOG.error(“Retweet Message contains a null twitter id. Skipping.”);
FILTERED_NO_STATUS_ID.increment();
return false;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (message.getSharedDate() == null) {</dt><dd><p>LOG.error(“Retweet Message “ + message.getRetweetId() + “ contains no date. Skipping.”);
return false;</p>
</dd>
</dl>
<p>}</p>
<p>// Remove supplementary characters from these text fields.
message.setSharedUserDisplayName(stripSupplementaryChars(</p>
<blockquote>
<div><p>message.getSharedUserDisplayName(),
Field.SHARED_USER_DISPLAY_NAME,
stripEmojisForFields.contains(Field.SHARED_USER_DISPLAY_NAME)));</p>
</div></blockquote>
<p>return true;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Strips non indexable chars from the text.</p></li>
<li></li>
<li><p>Returns the resulting string, which may be the same object as the text argument when</p></li>
<li><p>no stripping or truncation is necessary.</p></li>
<li></li>
<li><p>Non-indexed characters are “supplementary unicode” that are not emojis. Note that</p></li>
<li><p>supplementary unicode are still characters that seem worth indexing, as many characters</p></li>
<li><p>in CJK languages are supplementary. However this would make the size of our index</p></li>
<li><p>explode (~186k supplementary characters exist), so it’s not feasible.</p></li>
<li></li>
<li><p>&#64;param text The text to strip</p></li>
<li><p>&#64;param field The field this text is from</p></li>
<li><p>&#64;param stripSupplementaryEmojis Whether or not to strip supplementary emojis. Note that this</p></li>
<li><p>parameter name isn’t 100% accurate. This parameter is meant to replicate behavior prior to</p></li>
<li><p>adding support for <em>not</em> stripping supplementary emojis. The prior behavior would turn an</p></li>
<li><p>emoji such as a keycap “1uFE0Fu20E3” (<a class="reference external" href="http://www.iemoji.com/view/emoji/295/symbols/keycap-1">http://www.iemoji.com/view/emoji/295/symbols/keycap-1</a>)</p></li>
<li><p>into just ‘1’. So the keycap emoji is not completely stripped, only the portion after the ‘1’.</p></li>
<li></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
</dl>
<p>&#64;VisibleForTesting
public static String stripSupplementaryChars(</p>
<blockquote>
<div><blockquote>
<div><p>String text,
Field field,
boolean stripSupplementaryEmojis) {</p>
</div></blockquote>
<dl class="simple">
<dt>if (text == null || text.isEmpty()) {</dt><dd><p>return text;</p>
</dd>
</dl>
<p>}</p>
<p>// Initialize an empty map so that if we choose not to strip emojis,
// then no emojipositions will be found and we don’t need a null
// check before checking if an emoji is at a certain spot.
NavigableMap&lt;Integer, Integer&gt; emojiPositions = new TreeMap&lt;&gt;();</p>
<dl class="simple">
<dt>if (!stripSupplementaryEmojis) {</dt><dd><p>emojiPositions = EmojiExtractor.getEmojiPositions(text);</p>
</dd>
</dl>
<p>}</p>
<p>StringBuilder strippedTextBuilder = new StringBuilder();
int sequenceStart = 0;
int i = 0;
while (i &lt; text.length()) {</p>
<blockquote>
<div><dl>
<dt>if (Character.isSupplementaryCodePoint(text.codePointAt(i))) {</dt><dd><p>// Check if this supplementary character is an emoji
if (!emojiPositions.containsKey(i)) {</p>
<blockquote>
<div><p>// It’s not an emoji, or we want to strip emojis, so strip it</p>
<p>// text[i] and text[i + 1] are part of a supplementary code point.
strippedTextBuilder.append(text.substring(sequenceStart, i));
sequenceStart = i + 2;  // skip 2 chars
i = sequenceStart;
COUNTERS_MAP.get(field).getStrippedSupplementaryCharsCounter().increment();</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>// It’s an emoji, keep it
i += emojiPositions.get(i);
COUNTERS_MAP.get(field).getNonStrippedEmojiCharsCounter().increment();</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>++i;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
if (sequenceStart &lt; text.length()) {</p>
<blockquote>
<div><p>strippedTextBuilder.append(text.substring(sequenceStart));</p>
</div></blockquote>
<p>}</p>
<p>String strippedText = strippedTextBuilder.toString();
if (strippedText.length() &lt; text.length()) {</p>
<blockquote>
<div><p>COUNTERS_MAP.get(field).getTweetsWithStrippedSupplementaryCharsCounter().increment();</p>
</div></blockquote>
<p>}
return strippedText;</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Truncates the given string to the given length.</p></li>
<li></li>
<li><p>Note that we are truncating based on the # of UTF-16 characters a given emoji takes up.</p></li>
<li><p>So if a single emoji takes up 4 UTF-16 characters, that counts as 4 for the truncation,</p></li>
<li><p>not just 1.</p></li>
<li></li>
<li><p>&#64;param text The text to truncate</p></li>
<li><p>&#64;param maxLength The maximum length of the string after truncation</p></li>
<li><p>&#64;param field The field from which this string cames</p></li>
<li><p>&#64;param splitEmojisAtMaxLength If true, don’t worry about emojis and just truncate at maxLength,</p></li>
<li><p>potentially splitting them. If false, truncate before the emoji if truncating at maxLength</p></li>
<li><p>would cause the emoji to be split.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
</dl>
<p>&#64;VisibleForTesting
static String truncateString(</p>
<blockquote>
<div><blockquote>
<div><p>String text,
int maxLength,
Field field,
boolean splitEmojisAtMaxLength) {</p>
</div></blockquote>
<p>Preconditions.checkArgument(maxLength &gt; 0);</p>
<dl class="simple">
<dt>if ((text == null) || (text.length() &lt;= maxLength)) {</dt><dd><p>return text;</p>
</dd>
</dl>
<p>}</p>
<p>int truncatePoint = maxLength;
NavigableMap&lt;Integer, Integer&gt; emojiPositions;
// If we want to consider emojis we should not strip on an emoji boundary.
if (!splitEmojisAtMaxLength) {</p>
<blockquote>
<div><p>emojiPositions = EmojiExtractor.getEmojiPositions(text);</p>
<p>// Get the last emoji before maxlength.
Map.Entry&lt;Integer, Integer&gt; lastEmojiBeforeMaxLengthEntry =</p>
<blockquote>
<div><p>emojiPositions.lowerEntry(maxLength);</p>
</div></blockquote>
<dl>
<dt>if (lastEmojiBeforeMaxLengthEntry != null) {</dt><dd><dl class="simple">
<dt>int lowerEmojiEnd = lastEmojiBeforeMaxLengthEntry.getKey()</dt><dd><ul class="simple">
<li><p>lastEmojiBeforeMaxLengthEntry.getValue();</p></li>
</ul>
</dd>
</dl>
<p>// If the last emoji would be truncated, truncate before the last emoji.
if (lowerEmojiEnd &gt; truncatePoint) {</p>
<blockquote>
<div><p>truncatePoint = lastEmojiBeforeMaxLengthEntry.getKey();
COUNTERS_MAP.get(field).getEmojisAtTruncateBoundaryCounter().increment();</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>COUNTERS_MAP.get(field).getTruncatedCounter().increment();
return text.substring(0, truncatePoint);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../_sources/src/java/com/twitter/search/common/relevance/entities/TwitterMessageUtil.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>