<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../" id="documentation_options" src="../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.common.schema;</p>
<p>import java.io.IOException;
import java.io.StringReader;
import java.util.Collections;
import java.util.List;
import java.util.Set;</p>
<p>import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;
import com.google.common.collect.ImmutableList;
import com.google.common.collect.Sets;</p>
<p>import org.apache.lucene.analysis.Analyzer;
import org.apache.lucene.analysis.TokenStream;
import org.apache.lucene.analysis.tokenattributes.CharTermAttribute;
import org.apache.lucene.analysis.tokenattributes.TermToBytesRefAttribute;
import org.apache.lucene.document.Document;
import org.apache.lucene.document.Field;
import org.apache.lucene.facet.sortedset.SortedSetDocValuesFacetField;
import org.apache.lucene.util.BytesRef;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;</p>
<p>import com.twitter.common.text.token.TwitterTokenStream;
import com.twitter.search.common.schema.base.EarlybirdFieldType;
import com.twitter.search.common.schema.base.IndexedNumericFieldSettings;
import com.twitter.search.common.schema.base.Schema;
import com.twitter.search.common.schema.thriftjava.ThriftDocument;
import com.twitter.search.common.schema.thriftjava.ThriftField;
import com.twitter.search.common.schema.thriftjava.ThriftFieldData;
import com.twitter.search.common.schema.thriftjava.ThriftGeoCoordinate;
import com.twitter.search.common.util.analysis.IntTermAttribute;
import com.twitter.search.common.util.analysis.LongTermAttribute;
import com.twitter.search.common.util.analysis.SortableLongTermAttribute;
import com.twitter.search.common.util.spatial.GeoUtil;
import com.twitter.search.common.util.text.HighFrequencyTermPairs;
import com.twitter.search.common.util.text.OmitNormTextField;
import com.twitter.search.common.util.text.SingleTokenStream;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A document factory that converts <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> ThriftDocument} into Lucene <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> Document}s</p></li>
<li><p>using the provided <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> com.twitter.search.common.schema.base.Schema}.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public class SchemaDocumentFactory {</dt><dd><p>private static final Logger LOG = LoggerFactory.getLogger(SchemaDocumentFactory.class);</p>
<p>private final Schema schema;
private final ImmutableList&lt;TokenStreamRewriter&gt; tokenStreamRewriters;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Creates a SchemaDocumentFactory with a schema and the tokenStreamRewriters.</p></li>
<li></li>
<li><p>&#64;param tokenStreamRewriters a list of token stream rewriters, which will be applied in order.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>public SchemaDocumentFactory(</dt><dd><blockquote>
<div><p>Schema schema,
List&lt;TokenStreamRewriter&gt; tokenStreamRewriters) {</p>
</div></blockquote>
<p>this.schema = schema;
this.tokenStreamRewriters = ImmutableList.copyOf(tokenStreamRewriters);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Creates a SchemaDocumentFactory with no tokenStreamRewriters.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>public SchemaDocumentFactory(Schema schema) {</dt><dd><p>this(schema, Collections.EMPTY_LIST);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public final Document newDocument(ThriftDocument document) throws IOException {</dt><dd><p>return innerNewDocument(document);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Create a Lucene document from the ThriftDocument.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
</dl>
<p>&#64;VisibleForTesting
public Document innerNewDocument(ThriftDocument document) throws IOException {</p>
<blockquote>
<div><p>Document luceneDocument = new Document();
Set&lt;String&gt; hfTerms = Sets.newHashSet();
Set&lt;String&gt; hfPhrases = Sets.newHashSet();</p>
<p>Analyzer defaultAnalyzer = schema.getDefaultAnalyzer(document.getDefaultAnalyzerOverride());</p>
<dl>
<dt>for (ThriftField field<span class="classifier">document.getFields()) {</span></dt><dd><p>boolean successful = false;
try {</p>
<blockquote>
<div><p>addLuceneFields(field, defaultAnalyzer, luceneDocument, hfTerms, hfPhrases);
successful = true;</p>
</div></blockquote>
<dl>
<dt>} finally {</dt><dd><dl class="simple">
<dt>if (!successful) {</dt><dd><dl class="simple">
<dt>LOG.warn(“Unexpected exception while trying to add field. Field ID: “</dt><dd><ul class="simple">
<li><p>field.getFieldConfigId() + “ Field Name: “</p></li>
<li><p>schema.getFieldName(field.getFieldConfigId()));</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>for (String token<span class="classifier">hfTerms) {</span></dt><dd><dl>
<dt>for (String token2<span class="classifier">hfTerms) {</span></dt><dd><dl class="simple">
<dt>if (token.compareTo(token2) &lt; 0) {</dt><dd><dl class="simple">
<dt>luceneDocument.add(new Field(ImmutableSchema.HF_TERM_PAIRS_FIELD,</dt><dd><p>HighFrequencyTermPairs.createPair(token, token2),
OmitNormTextField.TYPE_NOT_STORED));</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>for (String phrase<span class="classifier">hfPhrases) {</span></dt><dd><p>// Tokens in the phrase set are not terms and have already been processed with
// HighFrequencyTermPairs.createPhrasePair.
luceneDocument.add(new Field(ImmutableSchema.HF_PHRASE_PAIRS_FIELD, phrase,</p>
<blockquote>
<div><p>OmitNormTextField.TYPE_NOT_STORED));</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<p>return schema.getFacetsConfig().build(luceneDocument);</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private void addLuceneFields(ThriftField field, Analyzer analyzer, Document doc,</dt><dd><blockquote>
<div><p>Set&lt;String&gt; hfTerms, Set&lt;String&gt; hfPhrases) throws IOException {</p>
</div></blockquote>
<dl class="simple">
<dt>Schema.FieldInfo fieldInfo =</dt><dd><p>schema.getFieldInfo(field.getFieldConfigId(), field.getFieldConfigOverride());</p>
</dd>
<dt>if (fieldInfo == null) {</dt><dd><p>// field not defined in schema - skip it
return;</p>
</dd>
</dl>
<p>}</p>
<p>ThriftFieldData fieldData = field.getFieldData();
if (fieldInfo.getFieldType().getCsfType() !=  null) {</p>
<blockquote>
<div><p>addCSFField(doc, fieldInfo, fieldData);
return;</p>
</div></blockquote>
<p>}</p>
<p>// Checking which data type is set is not sufficient here. We also need to check schema to
// see what the type the field is configured to be. See SEARCH-5173 for more details.
// The problem is that Pig, while converting Tuples to Thrift, sets all primitive type
// fields to 0. (i.e. the isSet calls will return true).
IndexedNumericFieldSettings numericSettings =</p>
<blockquote>
<div><p>fieldInfo.getFieldType().getNumericFieldSettings();</p>
</div></blockquote>
<dl>
<dt>if (fieldData.isSetTokenStreamValue()) {</dt><dd><p>addTokenField(doc, hfTerms, hfPhrases, fieldInfo, fieldData);</p>
</dd>
<dt>} else if (fieldData.isSetStringValue()) {</dt><dd><p>addStringField(analyzer, doc, hfTerms, hfPhrases, fieldInfo, fieldData);</p>
</dd>
<dt>} else if (fieldData.isSetBytesValue()) {</dt><dd><p>addBytesField(doc, fieldInfo, fieldData);</p>
</dd>
<dt>} else if (fieldData.isSetGeoCoordinate()) {</dt><dd><p>addGeoField(doc, fieldInfo, fieldData);</p>
</dd>
<dt>} else if (numericSettings != null) {</dt><dd><p>// handle numeric fields.
switch (numericSettings.getNumericType()) {</p>
<blockquote>
<div><dl>
<dt>case INT:</dt><dd><dl class="simple">
<dt>Preconditions.checkState(fieldData.isSetIntValue(),</dt><dd><p>“Int field does not have int value set. Field name: %s”, fieldInfo.getName());</p>
</dd>
</dl>
<p>addIntField(doc, fieldInfo, fieldData);
break;</p>
</dd>
<dt>case LONG:</dt><dd><dl class="simple">
<dt>Preconditions.checkState(fieldData.isSetLongValue(),</dt><dd><p>“Long field does not have long value set. Field name: %s”, fieldInfo.getName());</p>
</dd>
</dl>
<p>addLongField(doc, fieldInfo, fieldData);
break;</p>
</dd>
<dt>case FLOAT:</dt><dd><dl class="simple">
<dt>Preconditions.checkState(fieldData.isSetFloatValue(),</dt><dd><p>“Float field does not have float value set. Field name: %s “, fieldInfo.getName());</p>
</dd>
</dl>
<p>addFloatField();
break;</p>
</dd>
<dt>case DOUBLE:</dt><dd><dl class="simple">
<dt>Preconditions.checkState(fieldData.isSetDoubleValue(),</dt><dd><p>“Double field does not have double value set. Field name: %s”, fieldInfo.getName());</p>
</dd>
</dl>
<p>addDoubleFIeld();
break;</p>
</dd>
<dt>default:</dt><dd><dl class="simple">
<dt>throw new UnsupportedOperationException(“Earlybird does not know how to handle field “</dt><dd><ul class="simple">
<li><p>field.getFieldConfigId() + “ “ + field);</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>throw new UnsupportedOperationException(“Earlybird does not know how to handle field “</dt><dd><ul class="simple">
<li><p>field.getFieldConfigId() + “ “ + field);</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void addCSFField(Document doc, Schema.FieldInfo fieldInfo, ThriftFieldData fieldData) {</dt><dd><p>if (fieldInfo.getFieldType().getCsfFixedLengthNumValuesPerDoc() &gt; 1) {</p>
<blockquote>
<div><p>// As an optimization, TBinaryProtocol stores a byte array field as a part of a larger byte
// array field.  Must call fieldData.getBytesValue().  fieldData.bytesValue.array() will
// return extraneous data. See: SEARCH-3996
doc.add(new Field(fieldInfo.getName(), fieldData.getBytesValue(), fieldInfo.getFieldType()));</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>doc.add(new CSFField(fieldInfo.getName(), fieldInfo.getFieldType(), fieldData));</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void addTokenField(</dt><dd><blockquote>
<div><p>Document doc,
Set&lt;String&gt; hfTerms,
Set&lt;String&gt; hfPhrases,
Schema.FieldInfo fieldInfo,
ThriftFieldData fieldData) throws IOException {</p>
</div></blockquote>
<dl>
<dt>TwitterTokenStream twitterTokenStream</dt><dd><p>= fieldInfo.getFieldType().getTokenStreamSerializer().deserialize(
fieldData.getTokenStreamValue(), fieldData.getStringValue());</p>
</dd>
<dt>try {</dt><dd><dl class="simple">
<dt>for (TokenStreamRewriter rewriter<span class="classifier">tokenStreamRewriters) {</span></dt><dd><p>twitterTokenStream = rewriter.rewrite(fieldInfo, twitterTokenStream);</p>
</dd>
</dl>
<p>}</p>
<p>expandStream(doc, fieldInfo, twitterTokenStream, hfTerms, hfPhrases);
doc.add(new Field(fieldInfo.getName(), twitterTokenStream, fieldInfo.getFieldType()));</p>
</dd>
<dt>} finally {</dt><dd><p>twitterTokenStream.close();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void addStringField(Analyzer analyzer, Document doc, Set&lt;String&gt; hfTerms,</dt><dd><blockquote>
<div><p>Set&lt;String&gt; hfPhrases, Schema.FieldInfo fieldInfo,
ThriftFieldData fieldData) {</p>
</div></blockquote>
<p>doc.add(new Field(fieldInfo.getName(), fieldData.getStringValue(), fieldInfo.getFieldType()));
if (fieldInfo.getFieldType().tokenized()) {</p>
<blockquote>
<div><dl>
<dt>try {</dt><dd><dl class="simple">
<dt>TokenStream tokenStream = analyzer.tokenStream(fieldInfo.getName(),</dt><dd><p>new StringReader(fieldData.getStringValue()));</p>
</dd>
<dt>try {</dt><dd><dl class="simple">
<dt>expandStream(</dt><dd><p>doc,
fieldInfo,
tokenStream,
hfTerms,
hfPhrases);</p>
</dd>
</dl>
</dd>
<dt>} finally {</dt><dd><p>tokenStream.close();</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} catch (IOException e) {</dt><dd><p>LOG.error(“IOException expanding token stream”, e);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>addFacetField(doc, fieldInfo, fieldData.getStringValue());</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private void addBytesField(Document doc, Schema.FieldInfo fieldInfo, ThriftFieldData fieldData) {</dt><dd><p>doc.add(new Field(fieldInfo.getName(), fieldData.getBytesValue(), fieldInfo.getFieldType()));</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void addIntField(Document doc, Schema.FieldInfo fieldInfo,</dt><dd><blockquote>
<div><p>ThriftFieldData fieldData) {</p>
</div></blockquote>
<p>int value = fieldData.getIntValue();
addFacetField(doc, fieldInfo, String.valueOf(value));</p>
<dl class="simple">
<dt>if (fieldInfo.getFieldType().getNumericFieldSettings() == null) {</dt><dd><p>// No NumericFieldSettings. Even though the data is numeric, this field is not
// really a numerical field. Just add as a string.
doc.add(new Field(fieldInfo.getName(), String.valueOf(value), fieldInfo.getFieldType()));</p>
</dd>
<dt>} else if (fieldInfo.getFieldType().getNumericFieldSettings().isUseTwitterFormat()) {</dt><dd><p>addIntTermAttributeField(value, fieldInfo, doc);</p>
</dd>
<dt>} else {</dt><dd><p>// Use lucene style numerical fields
doc.add(NumericField.newIntField(fieldInfo.getName(), value));</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void addIntTermAttributeField(int value,</dt><dd><blockquote>
<div><p>Schema.FieldInfo fieldInfo,
Document doc) {</p>
</div></blockquote>
<p>SingleTokenStream singleToken = new SingleTokenStream();
IntTermAttribute termAtt = singleToken.addAttribute(IntTermAttribute.class);
termAtt.setTerm(value);
doc.add(new Field(fieldInfo.getName(), singleToken, fieldInfo.getFieldType()));</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void addLongField(Document doc, Schema.FieldInfo fieldInfo,</dt><dd><blockquote>
<div><p>ThriftFieldData fieldData) {</p>
</div></blockquote>
<p>long value = fieldData.getLongValue();
addFacetField(doc, fieldInfo, String.valueOf(value));</p>
<dl class="simple">
<dt>if (fieldInfo.getFieldType().getNumericFieldSettings() == null) {</dt><dd><p>// No NumericFieldSettings. Even though the data is numeric, this field is not
// really a numerical field. Just add as a string.
doc.add(new Field(fieldInfo.getName(), String.valueOf(value), fieldInfo.getFieldType()));</p>
</dd>
<dt>} else if (fieldInfo.getFieldType().getNumericFieldSettings().isUseTwitterFormat()) {</dt><dd><p>// Twitter style numerical field: use LongTermAttribute
addLongTermAttributeField(value, fieldInfo, doc);</p>
</dd>
<dt>} else {</dt><dd><p>// Use lucene style numerical fields
doc.add(NumericField.newLongField(fieldInfo.getName(), value));</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void addLongTermAttributeField(long value,</dt><dd><blockquote>
<div><p>Schema.FieldInfo fieldInfo,
Document doc) {</p>
</div></blockquote>
<p>SingleTokenStream singleToken = new SingleTokenStream();
boolean useSortableEncoding =</p>
<blockquote>
<div><p>fieldInfo.getFieldType().getNumericFieldSettings().isUseSortableEncoding();</p>
</div></blockquote>
<dl class="simple">
<dt>if (useSortableEncoding) {</dt><dd><p>SortableLongTermAttribute termAtt = singleToken.addAttribute(SortableLongTermAttribute.class);
termAtt.setTerm(value);</p>
</dd>
<dt>} else {</dt><dd><p>LongTermAttribute termAtt = singleToken.addAttribute(LongTermAttribute.class);
termAtt.setTerm(value);</p>
</dd>
</dl>
<p>}
doc.add(new Field(fieldInfo.getName(), singleToken, fieldInfo.getFieldType()));</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private void addFloatField() {</dt><dd><p>throw new UnsupportedOperationException(“Earlybird does not support float values yet.”);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private void addDoubleFIeld() {</dt><dd><p>throw new UnsupportedOperationException(“Earlybird does not support double values yet.”);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void addGeoField(Document doc, Schema.FieldInfo fieldInfo, ThriftFieldData fieldData) {</dt><dd><p>ThriftGeoCoordinate coord = fieldData.getGeoCoordinate();
if (GeoUtil.validateGeoCoordinates(coord.getLat(), coord.getLon())) {</p>
<blockquote>
<div><dl class="simple">
<dt>GeoUtil.fillGeoFields(doc, fieldInfo.getName(),</dt><dd><p>coord.getLat(), coord.getLon(), coord.getAccuracy());</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private void addFacetField(Document doc, Schema.FieldInfo fieldInfo, String value) {</dt><dd><p>Preconditions.checkArgument(doc != null);
Preconditions.checkArgument(fieldInfo != null);
Preconditions.checkArgument(value != null);</p>
<dl class="simple">
<dt>if (fieldInfo.getFieldType().getFacetName() != null) {</dt><dd><p>doc.add(new SortedSetDocValuesFacetField(fieldInfo.getFieldType().getFacetName(), value));</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private String getTerm(TermToBytesRefAttribute attr) {</dt><dd><dl class="simple">
<dt>if (attr instanceof CharTermAttribute) {</dt><dd><p>return ((CharTermAttribute) attr).toString();</p>
</dd>
<dt>} else if (attr instanceof IntTermAttribute) {</dt><dd><p>return String.valueOf(((IntTermAttribute) attr).getTerm());</p>
</dd>
<dt>} else if (attr instanceof LongTermAttribute) {</dt><dd><p>return String.valueOf(((LongTermAttribute) attr).getTerm());</p>
</dd>
<dt>} else {</dt><dd><p>return attr.getBytesRef().utf8ToString();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Expand the TwitterTokenStream and populate high-frequency terms, phrases and/or facet category paths.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>private void expandStream(</dt><dd><blockquote>
<div><p>Document doc,
Schema.FieldInfo fieldInfo,
TokenStream stream,
Set&lt;String&gt; hfTerms,
Set&lt;String&gt; hfPhrases) throws IOException {</p>
</div></blockquote>
<p>// Checkstyle does not allow assignment to parameters.
Set&lt;String&gt; facetHfTerms = hfTerms;
Set&lt;String&gt; facetHfPhrases = hfPhrases;</p>
<dl>
<dt>if (!(HighFrequencyTermPairs.INDEX_HF_TERM_PAIRS</dt><dd><blockquote>
<div><p>&amp;&amp; fieldInfo.getFieldType().isIndexHFTermPairs())) {</p>
</div></blockquote>
<p>// high-frequency terms and phrases are not needed
if (fieldInfo.getFieldType().getFacetName() == null) {</p>
<blockquote>
<div><p>// Facets are not needed either, simply return, would do nothing otherwise
return;</p>
</div></blockquote>
<p>}
facetHfTerms = null;
facetHfPhrases = null;</p>
</dd>
</dl>
<p>}</p>
<p>final TermToBytesRefAttribute attr = stream.getAttribute(TermToBytesRefAttribute.class);
stream.reset();</p>
<p>String lastHFTerm = null;
while (stream.incrementToken()) {</p>
<blockquote>
<div><p>String term = getTerm(attr);
if (fieldInfo.getFieldType().getFacetName() != null) {</p>
<blockquote>
<div><p>addFacetField(doc, fieldInfo, term);</p>
</div></blockquote>
<p>}
if (HighFrequencyTermPairs.HF_TERM_SET.contains(term)) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (facetHfTerms != null) {</dt><dd><p>facetHfTerms.add(term);</p>
</dd>
</dl>
<p>}
if (lastHFTerm != null) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (facetHfPhrases != null) {</dt><dd><p>facetHfPhrases.add(HighFrequencyTermPairs.createPhrasePair(lastHFTerm, term));</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
lastHFTerm = term;</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>lastHFTerm = null;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>public static final class CSFField extends Field {</dt><dd><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Create a CSFField with the given fieldType, containing the given field data.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>public CSFField(String name, EarlybirdFieldType fieldType, ThriftFieldData data) {</dt><dd><p>super(name, fieldType);</p>
<dl>
<dt>if (fieldType.isCsfVariableLength()) {</dt><dd><p>fieldsData = new BytesRef(data.getBytesValue());</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>switch (fieldType.getCsfType()) {</dt><dd><dl class="simple">
<dt>case BYTE:</dt><dd><p>fieldsData = Long.valueOf(data.getByteValue());
break;</p>
</dd>
<dt>case INT:</dt><dd><p>fieldsData = Long.valueOf(data.getIntValue());
break;</p>
</dd>
<dt>case LONG:</dt><dd><p>fieldsData = Long.valueOf(data.getLongValue());
break;</p>
</dd>
<dt>case FLOAT:</dt><dd><p>fieldsData = Long.valueOf(Float.floatToRawIntBits((float) data.getFloatValue()));
break;</p>
</dd>
<dt>case DOUBLE:</dt><dd><p>fieldsData = Long.valueOf(Double.doubleToRawLongBits(data.getDoubleValue()));
break;</p>
</dd>
<dt>default:</dt><dd><p>throw new IllegalArgumentException(“Unknown csf type: “ + fieldType.getCsfType());</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>public interface TokenStreamRewriter {</dt><dd><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Rewrite the token stream.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
</dl>
<p>TwitterTokenStream rewrite(Schema.FieldInfo fieldInfo, TwitterTokenStream stream);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../_sources/src/java/com/twitter/search/common/schema/SchemaDocumentFactory.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>