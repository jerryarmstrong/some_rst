<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.core.earlybird.index.inverted;</p>
<p>import java.io.IOException;
import java.util.Random;</p>
<p>import javax.annotation.Nullable;</p>
<p>import com.google.common.annotations.VisibleForTesting;
import com.google.common.base.Preconditions;</p>
<p>import com.twitter.search.common.util.io.flushable.DataDeserializer;
import com.twitter.search.common.util.io.flushable.DataSerializer;
import com.twitter.search.common.util.io.flushable.FlushInfo;
import com.twitter.search.common.util.io.flushable.Flushable;</p>
<p>import static com.twitter.search.core.earlybird.index.inverted.PayloadUtil.EMPTY_PAYLOAD;</p>
<dl>
<dt>/**</dt><dd><ul>
<li><p>This is a skip list container implementation backed by <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> IntBlockPool}.</p></li>
<li></li>
<li><p>Skip list is a data structure similar to linked list, but with a hierarchy of lists</p></li>
<li><p>each skipping over fewer elements, and the bottom hierarchy does NOT skip any elements.</p></li>
<li><p>&#64;see &lt;a href=”<a class="reference external" href="http://en.wikipedia.org/wiki/Skip_list">http://en.wikipedia.org/wiki/Skip_list</a>”&gt;Skip List Wikipedia&lt;/a&gt;</p></li>
<li></li>
<li><p>This implementation is lock free and thread safe with ONE writer thread and MULTIPLE reader</p></li>
<li><p>threads.</p></li>
<li></li>
<li><p>This implementation could contain one or more skip lists, and they are all backed by</p></li>
<li><p>the same <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> IntBlockPool}.</p></li>
<li></li>
<li><p>Values are actually stored as integers; however search key is implemented as a generic type.</p></li>
<li><p>Inserts of values that already exist are stored as subsequent elements. This is used to support</p></li>
<li><p>positions and term frequency.</p></li>
<li></li>
<li><p>Also reserve the integer after value to store next ordinal pointer information. We avoid storing</p></li>
<li><p>pointers to the next element in the tower by allocating them contiguously. To descend the tower,</p></li>
<li><p>we just increment the pointer.</p></li>
<li></li>
<li><p>This skip list can also store positions as integers. It allocates them before it allocates the</p></li>
<li><p>value (the value is a doc ID if we are using positions). This means that we can access the</p></li>
<li><p>position by simply decrementing the value pointer.</p></li>
<li></li>
<li><p>To understand how the skip list works, first understand how insert works, then the rest will be</p></li>
<li><p>more comprehendable.</p></li>
<li></li>
<li><p>A skip list will be implemented in a circle linked way:</p></li>
<li><ul class="simple">
<li><p>the list head node will have the sentinel value, which is the advisory greatest value</p></li>
</ul>
</li>
<li><p>provided by comparator.</p></li>
<li><ul class="simple">
<li><p>Real first value will be pointed by the list head node.</p></li>
</ul>
</li>
<li><ul class="simple">
<li><p>Real last value will point to the list head.</p></li>
</ul>
</li>
<li></li>
<li><p>Constraints:</p></li>
<li><ul class="simple">
<li><p>Does NOT support negative value.</p></li>
</ul>
</li>
<li></li>
<li><p>Simple Viz:</p></li>
<li></li>
<li><p>Empty list with max tower height 5. S = Sentinel value, I = Initial value.</p></li>
<li><div class="line-block">
<div class="line">s| 0| 0| 0| 0| 0| i| i| i| i| i| i| i| i| i| i|</div>
</div>
</li>
<li></li>
<li><p>One possible situation after inserting 4, 6, 5.</p></li>
<li><div class="line-block">
<div class="line">s| 6| 6| 9| 0| 0| 4|13|13| 6| 0| 0| 0| 5| 9| 9|</div>
</div>
</li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public class SkipListContainer&lt;K&gt; implements Flushable {</dt><dd><blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>The list head of first skip list in the container, this is for convenient usage,</p></li>
<li><p>so application use only one skip list does not need to keep track of the list head.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
</dl>
<p>static final int FIRST_LIST_HEAD = 0;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Initial value used when initialize int block pool. Notice -1 is not used here in order to give</p></li>
<li><p>application more freedom because -1 is a special value when doing bit manipulations.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
</dl>
<p>static final int INITIAL_VALUE = -2;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Maximum tower height of this skip list and chance to grow tower by level.</p></li>
<li></li>
<li><p>Notice these two values could affect the memory usage and the performance.</p></li>
<li><p>Ideally they should be calculated based on the potential size of the skip list.</p></li>
<li></li>
<li><p>Given n is the number of elements in the skip list, the memory usage is in O(n).</p></li>
<li></li>
<li><p>More precisely,</p></li>
<li></li>
<li><p>the memory is mainly used for the following data:</p></li>
<li></li>
<li><p>header_tower  = O(maxTowerHeight + 1)</p></li>
<li><p>value         = O(n)</p></li>
<li><p>next_pointers = O(n * (1 - growTowerChance^(maxTowerHeight + 1)) / (1 - growTowerChance))</p></li>
<li></li>
<li><p>thus, the total memory usage is in O(header_tower + value + next_pointers).</p></li>
<li></li>
<li><p>Default value for maximum tower height and grow tower chance, these two numbers are chosen</p></li>
<li><p>arbitrarily now.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
</dl>
<p>&#64;VisibleForTesting
public static final int MAX_TOWER_HEIGHT = 10;
private static final float GROW_TOWER_CHANCE = 0.2f;</p>
<dl class="simple">
<dt>public enum HasPositions {</dt><dd><p>YES,
NO</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public enum HasPayloads {</dt><dd><p>YES,
NO</p>
</dd>
</dl>
<p>}</p>
<p>static final int INVALID_POSITION = -3;</p>
<p>/** Memory barrier. <a href="#id9"><span class="problematic" id="id10">*</span></a>/
private volatile int maxPoolPointer;</p>
<p>/** Actual storage data structure. <a href="#id11"><span class="problematic" id="id12">*</span></a>/
private final IntBlockPool blockPool;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Default comparator used to determine the order between two given values or between one key and</p></li>
<li><p>another value.</p></li>
<li></li>
<li><p>Notice this comparator is shared by all threads using this skip list, so it is not thread safe</p></li>
<li><p>if it is maintaining some states. However, <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #search}, <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #insert}, and</p></li>
<li><p><a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #searchCeil} support passed in comparator as a parameter, which should be thread safe if</p></li>
<li><p>managed by the caller properly.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
</dl>
<p>private final SkipListComparator&lt;K&gt; defaultComparator;</p>
<p>/** Random generator used to decide if to grow tower by one level or not. <a href="#id15"><span class="problematic" id="id16">*</span></a>/
private final Random random = new Random();</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Used by writer thread to record last pointers at each level. Notice it is ok to have it as an</p></li>
<li><p>instance field because we would only have one writer thread.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
</dl>
<p>private final int[] lastPointers;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Whether the skip list contains positions. Used for text fields.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
</dl>
<p>private final HasPositions hasPositions;</p>
<p>private final HasPayloads hasPayloads;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Creates a new probabilistic skip list, using the provided comparator to compare keys</p></li>
<li><p>of type K.</p></li>
<li></li>
<li><p>&#64;param comparator a comparator used to compare integer values.</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
<dt>public SkipListContainer(</dt><dd><p>SkipListComparator&lt;K&gt; comparator,
HasPositions hasPositions,
HasPayloads hasPayloads,
String name</p>
</dd>
<dt>) {</dt><dd><p>this(comparator, new IntBlockPool(INITIAL_VALUE, name), hasPositions, hasPayloads);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Base constructor, also used by flush handler.</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>private SkipListContainer(</dt><dd><blockquote>
<div><p>SkipListComparator&lt;K&gt; comparator,
IntBlockPool blockPool,
HasPositions hasPositions,
HasPayloads hasPayloads) {</p>
</div></blockquote>
<p>// Sentinel value specified by the comparator cannot equal to INITIAL_VALUE.
Preconditions.checkArgument(comparator.getSentinelValue() != INITIAL_VALUE);</p>
<p>this.defaultComparator = comparator;
this.lastPointers = new int[MAX_TOWER_HEIGHT];
this.blockPool = blockPool;
this.hasPositions = hasPositions;
this.hasPayloads = hasPayloads;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Search for the index of the greatest value which has key less than or equal to the given key.</p></li>
<li></li>
<li><p>This is more like a floor search function. See <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #searchCeil} for ceil search.</p></li>
<li></li>
<li><p>&#64;param key target key will be searched.</p></li>
<li><p>&#64;param skipListHead index of the header tower of the skip list will be searched.</p></li>
<li><p>&#64;param comparator comparator used for comparison when traversing through the skip list.</p></li>
<li><p>&#64;param searchFinger <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> SkipListSearchFinger} to accelerate search speed,</p></li>
<li><p>notice the search finger must be before the key.</p></li>
<li><p>&#64;return the index of the greatest value which is less than or equal to given value,</p></li>
<li><p>will return skipListHead if given value has no greater or equal values.</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
<dt>public int search(</dt><dd><blockquote>
<div><p>K key,
int skipListHead,
SkipListComparator&lt;K&gt; comparator,
&#64;Nullable SkipListSearchFinger searchFinger) {</p>
</div></blockquote>
<p>assert comparator != null;
// Start at the header tower.
int currentPointer = skipListHead;</p>
<p>// Instantiate nextPointer and nextValue outside of the for loop so we can use the value
// directly after for loop.
int nextPointer = getForwardPointer(currentPointer, MAX_TOWER_HEIGHT - 1);
int nextValue = getValue(nextPointer);</p>
<p>// Top down traversal.
for (int currentLevel = MAX_TOWER_HEIGHT - 1; currentLevel &gt;= 0; currentLevel–) {</p>
<blockquote>
<div><p>nextPointer = getForwardPointer(currentPointer, currentLevel);
nextValue = getValue(nextPointer);</p>
<p>// Jump to search finger at current level.
if (searchFinger != null) {</p>
<blockquote>
<div><dl>
<dt>final int fingerPointer = searchFinger.getPointer(currentLevel);</dt><dd><dl class="simple">
<dt>assert searchFinger.isInitialPointer(fingerPointer)</dt><dd><p>|| comparator.compareKeyWithValue(key, getValue(fingerPointer), INVALID_POSITION) &gt;= 0;</p>
</dd>
</dl>
</dd>
<dt>if (!searchFinger.isInitialPointer(fingerPointer)</dt><dd><blockquote>
<div><p>&amp;&amp; comparator.compareValues(getValue(fingerPointer), nextValue) &gt;= 0) {</p>
</div></blockquote>
<p>currentPointer = fingerPointer;
nextPointer = getForwardPointer(currentPointer, currentLevel);
nextValue = getValue(nextPointer);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Move forward.
while (comparator.compareKeyWithValue(key, nextValue, INVALID_POSITION) &gt; 0) {</p>
<blockquote>
<div><p>currentPointer = nextPointer;</p>
<p>nextPointer = getForwardPointer(currentPointer, currentLevel);
nextValue = getValue(nextPointer);</p>
</div></blockquote>
<p>}</p>
<p>// Advance search finger.
if (searchFinger != null &amp;&amp; currentPointer != skipListHead) {</p>
<blockquote>
<div><p>final int currentValue = getValue(currentPointer);
final int fingerPointer = searchFinger.getPointer(currentLevel);</p>
<dl>
<dt>if (searchFinger.isInitialPointer(fingerPointer)</dt><dd><blockquote>
<div><p>|| comparator.compareValues(currentValue, getValue(fingerPointer)) &gt; 0) {</p>
</div></blockquote>
<p>searchFinger.setPointer(currentLevel, currentPointer);</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Return next pointer if next value matches searched value; otherwise return currentPointer.
return comparator.compareKeyWithValue(key, nextValue, INVALID_POSITION) == 0</p>
<blockquote>
<div><p>? nextPointer : currentPointer;</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Perform search with <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #defaultComparator}.</p></li>
<li><p>Notice <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #defaultComparator} is not thread safe if it is keeping some states.</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
<dt>public int search(K key, int skipListHead, &#64;Nullable SkipListSearchFinger searchFinger) {</dt><dd><p>return search(key, skipListHead, this.defaultComparator, searchFinger);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Ceil search on given <a class="reference external" href="mailto:{&#37;&#52;&#48;param">{<span>&#64;</span>param</a> key}.</p></li>
<li></li>
<li><p>&#64;param key target key will be searched.</p></li>
<li><p>&#64;param skipListHead index of the header tower of the skip list will be searched.</p></li>
<li><p>&#64;param comparator comparator used for comparison when traversing through the skip list.</p></li>
<li><p>&#64;param searchFinger <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> SkipListSearchFinger} to accelerate search speed.</p></li>
<li><p>&#64;return index of the smallest value with key greater or equal to the given key.</p></li>
</ul>
<p><a href="#id29"><span class="problematic" id="id30">*</span></a>/</p>
</dd>
<dt>public int searchCeil(</dt><dd><blockquote>
<div><p>K key,
int skipListHead,
SkipListComparator&lt;K&gt; comparator,
&#64;Nullable SkipListSearchFinger searchFinger) {</p>
</div></blockquote>
<p>assert comparator != null;</p>
<p>// Perform regular search.
final int foundPointer = search(key, skipListHead, comparator, searchFinger);</p>
<p>// Return foundPointer if it is not the list head and the pointed value has key equal to the
// given key; otherwise, return next pointer.
if (foundPointer != skipListHead</p>
<blockquote>
<div><blockquote>
<div><p>&amp;&amp; comparator.compareKeyWithValue(key, getValue(foundPointer), INVALID_POSITION) == 0) {</p>
</div></blockquote>
<p>return foundPointer;</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>return getNextPointer(foundPointer);</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Perform searchCeil with <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #defaultComparator}.</p></li>
<li><p>Notice <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #defaultComparator} is not thread safe if it is keeping some states.</p></li>
</ul>
<p><a href="#id31"><span class="problematic" id="id32">*</span></a>/</p>
</dd>
<dt>public int searchCeil(</dt><dd><blockquote>
<div><p>K key, int skipListHead, &#64;Nullable SkipListSearchFinger searchFinger) {</p>
</div></blockquote>
<p>return searchCeil(key, skipListHead, this.defaultComparator, searchFinger);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Insert a new value into the skip list.</p></li>
<li></li>
<li><p>Notice inserting supports duplicate keys and duplicate values.</p></li>
<li></li>
<li><p>Duplicate keys with different values or positions will be inserted consecutively.</p></li>
<li><p>Duplciate keys with identical values will be ignored, and the duplicate will not be stored in</p></li>
<li><p>the posting list.</p></li>
<li></li>
<li><p>&#64;param key is the key of the given value.</p></li>
<li><p>&#64;param value is the value will be inserted, cannot be <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #getSentinelValue()}.</p></li>
<li><p>&#64;param skipListHead index of the header tower of the skip list will accept the new value.</p></li>
<li><p>&#64;param comparator comparator used for comparison when traversing through the skip list.</p></li>
<li><p>&#64;return whether this value exists in the posting list. Note that this will return true even</p></li>
<li><p>if it is a new position.</p></li>
</ul>
<p><a href="#id33"><span class="problematic" id="id34">*</span></a>/</p>
</dd>
<dt>public boolean insert(K key, int value, int position, int[] payload, int skipListHead,</dt><dd><blockquote>
<div><p>SkipListComparator&lt;K&gt; comparator) {</p>
</div></blockquote>
<p>Preconditions.checkArgument(comparator != null);
Preconditions.checkArgument(value != getSentinelValue());</p>
<p>// Start at the header tower.
int currentPointer = skipListHead;</p>
<p>// Initialize lastPointers.
for (int i = 0; i &lt; MAX_TOWER_HEIGHT; i++) {</p>
<blockquote>
<div><p>this.lastPointers[i] = INITIAL_VALUE;</p>
</div></blockquote>
<p>}
int nextPointer = INITIAL_VALUE;</p>
<p>// Top down traversal.
for (int currentLevel = MAX_TOWER_HEIGHT - 1; currentLevel &gt;= 0; currentLevel–) {</p>
<blockquote>
<div><p>nextPointer = getForwardPointer(currentPointer, currentLevel);
int nextValue = getValue(nextPointer);</p>
<p>int nextPosition = getPosition(nextPointer);
while (comparator.compareKeyWithValue(key, nextValue, nextPosition) &gt; 0) {</p>
<blockquote>
<div><p>currentPointer = nextPointer;</p>
<p>nextPointer = getForwardPointer(currentPointer, currentLevel);
nextValue = getValue(nextPointer);
nextPosition = getPosition(nextPointer);</p>
</div></blockquote>
<p>}</p>
<p>// Store last pointers.
lastPointers[currentLevel] = currentPointer;</p>
</div></blockquote>
<p>}</p>
<p>// we use isDuplicateValue to determine if a value already exists in a posting list (even if it
// is a new position). We need to check both current pointer and next pointer in case this is
// the largest position we have seen for this value in this skip list. In that case, nextPointer
// will point to a larger value, but we want to check the smaller one to see if it is the same
// value. For example, if we have [(1, 2), (2, 4)] and we want to insert (1, 3), then
// nextPointer will point to (2, 4), but we want to check the doc ID of (1, 2) to see if it has
// the same document ID.
boolean isDuplicateValue = getValue(currentPointer) == value || getValue(nextPointer) == value;</p>
<dl>
<dt>if (comparator.compareKeyWithValue(key, getValue(nextPointer), getPosition(nextPointer)) != 0) {</dt><dd><dl>
<dt>if (hasPayloads == HasPayloads.YES) {</dt><dd><p>Preconditions.checkNotNull(payload);
// If this skip list has payloads, we store the payload immediately before the document ID
// and position (iff the position exists) in the block pool. We store payloads before
// positions because they are variable length, and reading past them would require knowing
// the size of the payload. We don’t store payloads after the doc ID because we have a
// variable number of pointers after the doc ID, and we would have no idea where the
// pointers stop and the payload starts.
for (int n : payload) {</p>
<blockquote>
<div><p>this.blockPool.add(n);</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (hasPositions == HasPositions.YES) {</dt><dd><p>// If this skip list has positions, we store the position before the document ID in the
// block pool.
this.blockPool.add(position);</p>
</dd>
</dl>
<p>}</p>
<p>// Insert value.
final int insertedPointer = this.blockPool.add(value);</p>
<p>// Insert outgoing pointers.
final int height = getRandomTowerHeight();
for (int currentLevel = 0; currentLevel &lt; height; currentLevel++) {</p>
<blockquote>
<div><p>this.blockPool.add(getForwardPointer(lastPointers[currentLevel], currentLevel));</p>
</div></blockquote>
<p>}</p>
<p>this.sync();</p>
<p>// Update incoming pointers.
for (int currentLevel = 0; currentLevel &lt; height; currentLevel++) {</p>
<blockquote>
<div><p>setForwardPointer(lastPointers[currentLevel], currentLevel, insertedPointer);</p>
</div></blockquote>
<p>}</p>
<p>this.sync();</p>
</dd>
</dl>
<p>}</p>
<p>return isDuplicateValue;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Delete a given key from skip list</p></li>
<li></li>
<li><p>&#64;param key the key of the given value</p></li>
<li><p>&#64;param skipListHead index of the header tower of the skip list will accept the new value</p></li>
<li><p>&#64;param comparator comparator used for comparison when traversing through the skip list</p></li>
<li><p>&#64;return smallest value in the container. Returns <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #INITIAL_VALUE} if the</p></li>
<li><p>key does not exist.</p></li>
</ul>
<p><a href="#id35"><span class="problematic" id="id36">*</span></a>/</p>
</dd>
<dt>public int delete(K key, int skipListHead, SkipListComparator&lt;K&gt; comparator) {</dt><dd><p>boolean foundKey = false;</p>
<dl>
<dt>for (int currentLevel = MAX_TOWER_HEIGHT - 1; currentLevel &gt;= 0; currentLevel–) {</dt><dd><p>int currentPointer = skipListHead;
int nextValue = getValue(getForwardPointer(currentPointer, currentLevel));</p>
<p>// First we skip over all the nodes that are smaller than our key.
while (comparator.compareKeyWithValue(key, nextValue, INVALID_POSITION) &gt; 0) {</p>
<blockquote>
<div><p>currentPointer = getForwardPointer(currentPointer, currentLevel);
nextValue = getValue(getForwardPointer(currentPointer, currentLevel));</p>
</div></blockquote>
<p>}</p>
<p>Preconditions.checkState(currentPointer != INITIAL_VALUE);</p>
<p>// If we don’t find the node at this level that’s OK, keep searching on a lower one.
if (comparator.compareKeyWithValue(key, nextValue, INVALID_POSITION) != 0) {</p>
<blockquote>
<div><p>continue;</p>
</div></blockquote>
<p>}</p>
<p>// We found an element to delete.
foundKey = true;</p>
<p>// Otherwise, save the current pointer. Right now, current pointer points to the first element
// that has the same value as key.
int savedPointer = currentPointer;</p>
<p>currentPointer = getForwardPointer(currentPointer, currentLevel);
// Then, walk over every element that is equal to the key.
while (comparator.compareKeyWithValue(key, getValue(currentPointer), INVALID_POSITION) == 0) {</p>
<blockquote>
<div><p>currentPointer = getForwardPointer(currentPointer, currentLevel);</p>
</div></blockquote>
<p>}</p>
<p>// update the saved pointer to point to the first non-equal element of the skip list.
setForwardPointer(savedPointer, currentLevel, currentPointer);</p>
</dd>
</dl>
<p>}</p>
<p>// Something has changed, need to sync up here.
if (foundKey) {</p>
<blockquote>
<div><p>this.sync();
// return smallest value, might be used as first postings later
return getSmallestValue(skipListHead);</p>
</div></blockquote>
<p>}</p>
<p>return INITIAL_VALUE;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Perform insert with <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #defaultComparator}.</p></li>
<li><p>Notice <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #defaultComparator} is not thread safe if it is keeping some states.</p></li>
</ul>
<p><a href="#id37"><span class="problematic" id="id38">*</span></a>/</p>
</dd>
<dt>public boolean insert(K key, int value, int skipListHead) {</dt><dd><dl class="simple">
<dt>return insert(key, value, INVALID_POSITION, EMPTY_PAYLOAD, skipListHead,</dt><dd><p>this.defaultComparator);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public boolean insert(K key, int value, int position, int[] payload, int skipListHead) {</dt><dd><p>return insert(key, value, position, payload, skipListHead, this.defaultComparator);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Perform delete with <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #defaultComparator}.</p></li>
<li><p>Notice <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #defaultComparator} is not thread safe if it is keeping some states.</p></li>
</ul>
<p><a href="#id39"><span class="problematic" id="id40">*</span></a>/</p>
</dd>
<dt>public int delete(K key, int skipListHead) {</dt><dd><p>return delete(key, skipListHead, this.defaultComparator);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Get the pointer of next value pointed by the given pointer.</p></li>
<li></li>
<li><p>&#64;param pointer reference to the current value.</p></li>
<li><p>&#64;return pointer of next value.</p></li>
</ul>
<p><a href="#id41"><span class="problematic" id="id42">*</span></a>/</p>
</dd>
<dt>public int getNextPointer(int pointer) {</dt><dd><p>return getForwardPointer(pointer, 0);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Get the value pointed by a pointer, this is a dereference process.</p></li>
<li></li>
<li><p>&#64;param pointer is an array index on this.blockPool.</p></li>
<li><p>&#64;return value pointed pointed by the pointer.</p></li>
</ul>
<p><a href="#id43"><span class="problematic" id="id44">*</span></a>/</p>
</dd>
<dt>public int getValue(int pointer) {</dt><dd><p>int value = blockPool.get(pointer);</p>
<p>// Visibility race
if (value == INITIAL_VALUE) {</p>
<blockquote>
<div><p>// Volatile read to cross the memory barrier again.
final boolean isSafe = isPointerSafe(pointer);
assert isSafe;</p>
<p>// Re-read the pointer again
value = blockPool.get(pointer);</p>
</div></blockquote>
<p>}</p>
<p>return value;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public int getSmallestValue(int skipListHeader) {</dt><dd><p>return getValue(getForwardPointer(skipListHeader, 0));</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Builder of a forward search finger with header tower index.</p></li>
<li></li>
<li><p>&#64;return a new <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> SkipListSearchFinger} object.</p></li>
</ul>
<p><a href="#id45"><span class="problematic" id="id46">*</span></a>/</p>
</dd>
<dt>public SkipListSearchFinger buildSearchFinger() {</dt><dd><p>return new SkipListSearchFinger(MAX_TOWER_HEIGHT);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Added another skip list into the int pool.</p></li>
<li></li>
<li><p>&#64;return index of the header tower of the newly created skip list.</p></li>
</ul>
<p><a href="#id47"><span class="problematic" id="id48">*</span></a>/</p>
</dd>
<dt>public int newSkipList() {</dt><dd><p>// Virtual value of header.
final int sentinelValue = getSentinelValue();
if (hasPositions == HasPositions.YES) {</p>
<blockquote>
<div><p>this.blockPool.add(INVALID_POSITION);</p>
</div></blockquote>
<p>}
final int skipListHead = this.blockPool.add(sentinelValue);</p>
<p>// Build header tower, initially point all the pointers to
//   itself since no value has been inserted.
for (int i = 0; i &lt; MAX_TOWER_HEIGHT; i++) {</p>
<blockquote>
<div><p>this.blockPool.add(skipListHead);</p>
</div></blockquote>
<p>}</p>
<p>this.sync();</p>
<p>return skipListHead;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Check if the block pool has been initiated by <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> #newSkipList}.</p></li>
</ul>
<p><a href="#id49"><span class="problematic" id="id50">*</span></a>/</p>
</dd>
<dt>public boolean isEmpty() {</dt><dd><p>return this.blockPool.length() == 0;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Write to the volatile variable to cross memory barrier. maxPoolPointer is the memory barrier</p></li>
<li><p>for new appends.</p></li>
</ul>
<p><a href="#id51"><span class="problematic" id="id52">*</span></a>/</p>
</dd>
<dt>private void sync() {</dt><dd><p>this.maxPoolPointer = this.blockPool.length();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Read from volatile variable to cross memory barrier.</p></li>
<li></li>
<li><p>&#64;param pointer is an block pool index.</p></li>
<li><p>&#64;return boolean indicate if given pointer is within the range of max pool pointer.</p></li>
</ul>
<p><a href="#id53"><span class="problematic" id="id54">*</span></a>/</p>
</dd>
<dt>private boolean isPointerSafe(int pointer) {</dt><dd><p>return pointer &lt;= this.maxPoolPointer;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Get the position associated with the doc ID pointed to by pointer.</p></li>
<li><p>&#64;param pointer aka doc ID pointer.</p></li>
<li><p>&#64;return The value of the position for that doc ID. Returns INVALID_POSITION if the skip list</p></li>
<li><p>does not have positions, or if there is no position for that pointer.</p></li>
</ul>
<p><a href="#id55"><span class="problematic" id="id56">*</span></a>/</p>
</dd>
<dt>public int getPosition(int pointer) {</dt><dd><dl class="simple">
<dt>if (hasPositions == HasPositions.NO) {</dt><dd><p>return INVALID_POSITION;</p>
</dd>
</dl>
<p>}
// if this skip list has positions, the position will always be inserted into the block pool
// immediately before the doc ID.
return getValue(pointer - 1);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Get the payload pointer from a normal pointer (e.g. one returned from the <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> this#search}</p></li>
<li><p>method).</p></li>
</ul>
<p><a href="#id57"><span class="problematic" id="id58">*</span></a>/</p>
</dd>
<dt>public int getPayloadPointer(int pointer) {</dt><dd><dl class="simple">
<dt>Preconditions.checkState(hasPayloads == HasPayloads.YES,</dt><dd><p>“getPayloadPointer() should only be called on a skip list that supports payloads.”);</p>
</dd>
</dl>
<p>// if this skip list has payloads, the payload will always be inserted into the block pool
// before the doc ID, and before the position if there is a position.
int positionOffset = hasPositions == HasPositions.YES ? 1 : 0;</p>
<p>return pointer - 1 - positionOffset;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>int getPoolSize() {</dt><dd><p>return this.blockPool.length();</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>IntBlockPool getBlockPool() {</dt><dd><p>return blockPool;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public HasPayloads getHasPayloads() {</dt><dd><p>return hasPayloads;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/<strong>**************</strong></dt><dd><ul class="simple">
<li><p>Helper Methods *</p></li>
</ul>
<p><strong>**************</strong>/</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Get the next forward pointer on a given level.</p></li>
<li></li>
<li><p>&#64;param pointer is an array index on this.blockPool, might be SENTINEL_VALUE.</p></li>
<li><p>&#64;param level indicates the level of the forward pointer will be acquired. It is zero indexed.</p></li>
<li><p>&#64;return next forward pointer on the given level, might be SENTINEL_VALUE.</p></li>
</ul>
<p><a href="#id59"><span class="problematic" id="id60">*</span></a>/</p>
</dd>
<dt>private int getForwardPointer(int pointer, int level) {</dt><dd><p>final int pointerIndex = pointer + level + 1;</p>
<p>int forwardPointer = blockPool.get(pointerIndex);</p>
<p>// Visibility race
if (forwardPointer == INITIAL_VALUE) {</p>
<blockquote>
<div><p>// Volatile read to cross the memory barrier again.
final boolean isSafe = isPointerSafe(pointerIndex);
assert isSafe;</p>
<p>// Re-read the pointer again
forwardPointer = blockPool.get(pointerIndex);</p>
</div></blockquote>
<p>}</p>
<p>return forwardPointer;</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>/**</dt><dd><blockquote>
<div><ul class="simple">
<li><p>Set the next forward pointer on a given level.</p></li>
<li></li>
<li><p>&#64;param pointer points to the value, of which the pointer value will be updated.</p></li>
<li><p>&#64;param level indicates the level of the forward pointer will be set. It is zero indexed.</p></li>
<li><p>&#64;param target the value fo the target pointer which will be set.</p></li>
</ul>
<p><a href="#id61"><span class="problematic" id="id62">*</span></a>/</p>
</div></blockquote>
<dl class="simple">
<dt>private void setForwardPointer(int pointer, int level, int target) {</dt><dd><p>// Update header tower if given pointer points to headerTower.
setPointer(pointer + level + 1, target);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Set the value pointed by pointer</p></li>
<li><p>&#64;param pointer point to the actual position in the pool</p></li>
<li><p>&#64;param target the value we are going to set</p></li>
</ul>
<p><a href="#id63"><span class="problematic" id="id64">*</span></a>/</p>
</dd>
<dt>private void setPointer(int pointer, int target) {</dt><dd><p>blockPool.set(pointer, target);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Getter of the sentinel value used by this skip list. The sentinel value should be provided</p></li>
<li><p>by the comparator.</p></li>
<li></li>
<li><p>&#64;return sentinel value used by this skip list.</p></li>
</ul>
<p><a href="#id65"><span class="problematic" id="id66">*</span></a>/</p>
</dd>
<dt>int getSentinelValue() {</dt><dd><p>return defaultComparator.getSentinelValue();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Return a height h in range [1, maxTowerHeight], each number with chance</p></li>
<li><p>growTowerChance ^ (h - 1).</p></li>
<li></li>
<li><p>&#64;return a integer indicating height.</p></li>
</ul>
<p><a href="#id67"><span class="problematic" id="id68">*</span></a>/</p>
</dd>
<dt>private int getRandomTowerHeight() {</dt><dd><p>int height = 1;
while (height &lt; MAX_TOWER_HEIGHT &amp;&amp; random.nextFloat() &lt; GROW_TOWER_CHANCE) {</p>
<blockquote>
<div><p>height++;</p>
</div></blockquote>
<p>}
return height;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;SuppressWarnings(“unchecked”)
&#64;Override
public FlushHandler&lt;K&gt; getFlushHandler() {</p>
<blockquote>
<div><p>return new FlushHandler&lt;&gt;(this);</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>public static class FlushHandler&lt;K&gt; extends Flushable.Handler&lt;SkipListContainer&lt;K&gt;&gt; {</dt><dd><p>private final SkipListComparator&lt;K&gt; comparator;
private static final String BLOCK_POOL_PROP_NAME = “blockPool”;
private static final String HAS_POSITIONS_PROP_NAME = “hasPositions”;
private static final String HAS_PAYLOADS_PROP_NAME = “hasPayloads”;</p>
<dl class="simple">
<dt>public FlushHandler(SkipListContainer&lt;K&gt; objectToFlush) {</dt><dd><p>super(objectToFlush);
this.comparator = objectToFlush.defaultComparator;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public FlushHandler(SkipListComparator&lt;K&gt; comparator) {</dt><dd><p>this.comparator = comparator;</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
protected void doFlush(FlushInfo flushInfo, DataSerializer out) throws IOException {</p>
<blockquote>
<div><p>long startTime = getClock().nowMillis();
SkipListContainer&lt;K&gt; objectToFlush = getObjectToFlush();
flushInfo.addBooleanProperty(HAS_POSITIONS_PROP_NAME,</p>
<blockquote>
<div><p>objectToFlush.hasPositions == HasPositions.YES);</p>
</div></blockquote>
<dl class="simple">
<dt>flushInfo.addBooleanProperty(HAS_PAYLOADS_PROP_NAME,</dt><dd><p>objectToFlush.hasPayloads == HasPayloads.YES);</p>
</dd>
<dt>objectToFlush.blockPool.getFlushHandler()</dt><dd><p>.flush(flushInfo.newSubProperties(BLOCK_POOL_PROP_NAME), out);</p>
</dd>
</dl>
<p>getFlushTimerStats().timerIncrement(getClock().nowMillis() - startTime);</p>
</div></blockquote>
<p>}</p>
<p>&#64;Override
protected SkipListContainer&lt;K&gt; doLoad(FlushInfo flushInfo, DataDeserializer in)</p>
<blockquote>
<div><blockquote>
<div><p>throws IOException {</p>
</div></blockquote>
<p>long startTime = getClock().nowMillis();
IntBlockPool blockPool = (new IntBlockPool.FlushHandler()).load(</p>
<blockquote>
<div><p>flushInfo.getSubProperties(BLOCK_POOL_PROP_NAME), in);</p>
</div></blockquote>
<p>getLoadTimerStats().timerIncrement(getClock().nowMillis() - startTime);</p>
<dl class="simple">
<dt>HasPositions hasPositions = flushInfo.getBooleanProperty(HAS_POSITIONS_PROP_NAME)</dt><dd><p>? HasPositions.YES : HasPositions.NO;</p>
</dd>
<dt>HasPayloads hasPayloads = flushInfo.getBooleanProperty(HAS_PAYLOADS_PROP_NAME)</dt><dd><p>? HasPayloads.YES : HasPayloads.NO;</p>
</dd>
<dt>return new SkipListContainer&lt;&gt;(</dt><dd><p>this.comparator,
blockPool,
hasPositions,
hasPayloads);</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/src/java/com/twitter/search/core/earlybird/index/inverted/SkipListContainer.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>