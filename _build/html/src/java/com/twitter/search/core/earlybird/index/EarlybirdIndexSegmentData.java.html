<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../" id="documentation_options" src="../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.search.core.earlybird.index;</p>
<p>import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;</p>
<p>import com.google.common.base.Preconditions;</p>
<p>import org.apache.lucene.index.DirectoryReader;
import org.apache.lucene.index.IndexWriterConfig;
import org.apache.lucene.index.LeafReader;
import org.apache.lucene.index.LeafReaderContext;
import org.apache.lucene.store.Directory;</p>
<p>import com.twitter.common.collections.Pair;
import com.twitter.search.common.schema.base.EarlybirdFieldType;
import com.twitter.search.common.schema.base.Schema;
import com.twitter.search.common.util.io.flushable.DataDeserializer;
import com.twitter.search.common.util.io.flushable.DataSerializer;
import com.twitter.search.common.util.io.flushable.FlushInfo;
import com.twitter.search.common.util.io.flushable.Flushable;
import com.twitter.search.core.earlybird.facets.AbstractFacetCountingArray;
import com.twitter.search.core.earlybird.facets.FacetCountingArrayWriter;
import com.twitter.search.core.earlybird.facets.FacetIDMap;
import com.twitter.search.core.earlybird.facets.FacetLabelProvider;
import com.twitter.search.core.earlybird.index.column.ColumnStrideByteIndex;
import com.twitter.search.core.earlybird.index.column.DocValuesManager;
import com.twitter.search.core.earlybird.index.extensions.EarlybirdIndexExtensionsData;
import com.twitter.search.core.earlybird.index.extensions.EarlybirdIndexExtensionsFactory;
import com.twitter.search.core.earlybird.index.inverted.DeletedDocs;
import com.twitter.search.core.earlybird.index.inverted.InvertedIndex;
import com.twitter.search.core.earlybird.index.inverted.InvertedRealtimeIndex;
import com.twitter.search.core.earlybird.index.inverted.OptimizedMemoryIndex;
import com.twitter.search.core.earlybird.index.inverted.TermPointerEncoding;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Base class that references data structures belonging to an Earlybird segment.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>public abstract class EarlybirdIndexSegmentData implements Flushable {</dt><dd><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>This class has a map which contains a snapshot of max published pointers, to distinguish the</p></li>
<li><p>documents in the skip lists that are fully indexed, and safe to return to searchers and those</p></li>
<li><p>that are in progress and should not be returned to searchers. See</p></li>
<li><p>“Earlybird Indexing Latency Design Document”</p></li>
<li><p>for rationale and design.</p></li>
<li></li>
<li><p>It also has the smallestDocID, which determines the smallest assigned doc ID in the tweet ID</p></li>
<li><p>mapper that is safe to traverse.</p></li>
<li></li>
<li><p>The pointer map and smallestDocID need to be updated atomically. See SEARCH-27650.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>public static class SyncData {</dt><dd><p>private final Map&lt;InvertedIndex, Integer&gt; indexPointers;
private final int smallestDocID;</p>
<dl class="simple">
<dt>public SyncData(Map&lt;InvertedIndex, Integer&gt; indexPointers, int smallestDocID) {</dt><dd><p>this.indexPointers = indexPointers;
this.smallestDocID = smallestDocID;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Map&lt;InvertedIndex, Integer&gt; getIndexPointers() {</dt><dd><p>return indexPointers;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public int getSmallestDocID() {</dt><dd><p>return smallestDocID;</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>private volatile SyncData syncData;</p>
<p>private final int maxSegmentSize;
private final long timeSliceID;</p>
<dl class="simple">
<dt>private final ConcurrentHashMap&lt;String, QueryCacheResultForSegment&gt; queryCacheMap =</dt><dd><p>new ConcurrentHashMap&lt;&gt;();</p>
</dd>
</dl>
<p>private final AbstractFacetCountingArray facetCountingArray;
private final boolean isOptimized;
private final ConcurrentHashMap&lt;String, InvertedIndex&gt; perFieldMap;
private final ConcurrentHashMap&lt;String, ColumnStrideByteIndex&gt; normsMap;</p>
<p>private final Map&lt;String, FacetLabelProvider&gt; facetLabelProviders;
private final FacetIDMap facetIDMap;</p>
<p>private final Schema schema;
private final DocValuesManager docValuesManager;</p>
<p>private final DeletedDocs deletedDocs;</p>
<p>private final DocIDToTweetIDMapper docIdToTweetIdMapper;
private final TimeMapper timeMapper;</p>
<dl>
<dt>static LeafReader getLeafReaderFromOptimizedDirectory(Directory directory) throws IOException {</dt><dd><p>List&lt;LeafReaderContext&gt; leaves = DirectoryReader.open(directory).getContext().leaves();
int leavesSize = leaves.size();
Preconditions.checkState(1 == leavesSize,</p>
<blockquote>
<div><p>“Expected one leaf reader in directory %s, but found %s”, directory, leavesSize);</p>
</div></blockquote>
<p>return leaves.get(0).reader();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Creates a new SegmentData instance using the provided data.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>public EarlybirdIndexSegmentData(</dt><dd><blockquote>
<div><p>int maxSegmentSize,
long timeSliceID,
Schema schema,
boolean isOptimized,
int smallestDocID,
ConcurrentHashMap&lt;String, InvertedIndex&gt; perFieldMap,
ConcurrentHashMap&lt;String, ColumnStrideByteIndex&gt; normsMap,
AbstractFacetCountingArray facetCountingArray,
DocValuesManager docValuesManager,
Map&lt;String, FacetLabelProvider&gt; facetLabelProviders,
FacetIDMap facetIDMap,
DeletedDocs deletedDocs,
DocIDToTweetIDMapper docIdToTweetIdMapper,
TimeMapper timeMapper) {</p>
</div></blockquote>
<p>this.maxSegmentSize = maxSegmentSize;
this.timeSliceID = timeSliceID;
this.schema = schema;
this.isOptimized = isOptimized;
this.facetCountingArray = facetCountingArray;
this.perFieldMap = perFieldMap;
this.syncData = new SyncData(buildIndexPointers(), smallestDocID);
this.normsMap = normsMap;
this.docValuesManager = docValuesManager;
this.facetLabelProviders = facetLabelProviders;
this.facetIDMap = facetIDMap;
this.deletedDocs = deletedDocs;
this.docIdToTweetIdMapper = docIdToTweetIdMapper;
this.timeMapper = timeMapper;</p>
<p>Preconditions.checkNotNull(schema);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public final Schema getSchema() {</dt><dd><p>return schema;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns all <a class="reference external" href="mailto:{&#37;&#52;&#48;link">{<span>&#64;</span>link</a> EarlybirdIndexExtensionsData} instances contained in this segment.</p></li>
<li><p>Since index extensions are optional, the returned map might be null or empty.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
</dl>
<p>public abstract &lt;S extends EarlybirdIndexExtensionsData&gt; S getIndexExtensionsData();</p>
<dl class="simple">
<dt>public DocIDToTweetIDMapper getDocIDToTweetIDMapper() {</dt><dd><p>return docIdToTweetIdMapper;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public TimeMapper getTimeMapper() {</dt><dd><p>return timeMapper;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public final DocValuesManager getDocValuesManager() {</dt><dd><p>return docValuesManager;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Map&lt;String, FacetLabelProvider&gt; getFacetLabelProviders() {</dt><dd><p>return facetLabelProviders;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public FacetIDMap getFacetIDMap() {</dt><dd><p>return facetIDMap;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the QueryCacheResult for the given filter for this segment.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>public QueryCacheResultForSegment getQueryCacheResult(String queryCacheFilterName) {</dt><dd><p>return queryCacheMap.get(queryCacheFilterName);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public long getQueryCachesCardinality() {</dt><dd><p>return queryCacheMap.values().stream().mapToLong(q -&gt; q.getCardinality()).sum();</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Get cache cardinality for each query cache.</p></li>
<li><p>&#64;return</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>public List&lt;Pair&lt;String, Long&gt;&gt; getPerQueryCacheCardinality() {</dt><dd><p>ArrayList&lt;Pair&lt;String, Long&gt;&gt; result = new ArrayList&lt;&gt;();</p>
<dl class="simple">
<dt>queryCacheMap.forEach((cacheName, queryCacheResult) -&gt; {</dt><dd><p>result.add(Pair.of(cacheName, queryCacheResult.getCardinality()));</p>
</dd>
</dl>
<p>});
return result;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Updates the QueryCacheResult stored for the given filter for this segment</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>public QueryCacheResultForSegment updateQueryCacheResult(</dt><dd><blockquote>
<div><p>String queryCacheFilterName, QueryCacheResultForSegment queryCacheResultForSegment) {</p>
</div></blockquote>
<p>return queryCacheMap.put(queryCacheFilterName, queryCacheResultForSegment);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Subclasses are allowed to return null here to disable writing to a FacetCountingArray.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>public FacetCountingArrayWriter createFacetCountingArrayWriter() {</dt><dd><dl class="simple">
<dt>return getFacetCountingArray() != null</dt><dd><p>? new FacetCountingArrayWriter(getFacetCountingArray()) : null;</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public int getMaxSegmentSize() {</dt><dd><p>return maxSegmentSize;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public long getTimeSliceID() {</dt><dd><p>return timeSliceID;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void updateSmallestDocID(int smallestDocID) {</dt><dd><p>// Atomic swap
syncData = new SyncData(Collections.unmodifiableMap(buildIndexPointers()), smallestDocID);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private Map&lt;InvertedIndex, Integer&gt; buildIndexPointers() {</dt><dd><p>Map&lt;InvertedIndex, Integer&gt; newIndexPointers = new HashMap&lt;&gt;();
for (InvertedIndex index : perFieldMap.values()) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (index.hasMaxPublishedPointer()) {</dt><dd><p>newIndexPointers.put(index, index.getMaxPublishedPointer());</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>return newIndexPointers;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public SyncData getSyncData() {</dt><dd><p>return syncData;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public AbstractFacetCountingArray getFacetCountingArray() {</dt><dd><p>return facetCountingArray;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public void addField(String fieldName, InvertedIndex field) {</dt><dd><p>perFieldMap.put(fieldName, field);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Map&lt;String, InvertedIndex&gt; getPerFieldMap() {</dt><dd><p>return Collections.unmodifiableMap(perFieldMap);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public InvertedIndex getFieldIndex(String fieldName) {</dt><dd><p>return perFieldMap.get(fieldName);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public Map&lt;String, ColumnStrideByteIndex&gt; getNormsMap() {</dt><dd><p>return Collections.unmodifiableMap(normsMap);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public DeletedDocs getDeletedDocs() {</dt><dd><p>return deletedDocs;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the norms index for the given field name.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>public ColumnStrideByteIndex getNormIndex(String fieldName) {</dt><dd><p>return normsMap == null ? null : normsMap.get(fieldName);</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns the norms index for the given field name, add if not exist.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>public ColumnStrideByteIndex createNormIndex(String fieldName) {</dt><dd><dl class="simple">
<dt>if (normsMap == null) {</dt><dd><p>return null;</p>
</dd>
</dl>
<p>}
ColumnStrideByteIndex csf = normsMap.get(fieldName);
if (csf == null) {</p>
<blockquote>
<div><p>csf = new ColumnStrideByteIndex(fieldName, maxSegmentSize);
normsMap.put(fieldName, csf);</p>
</div></blockquote>
<p>}
return csf;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Flushes this segment to disk.</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
<dt>public void flushSegment(FlushInfo flushInfo, DataSerializer out) throws IOException {</dt><dd><p>getFlushHandler().flush(flushInfo, out);</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public final boolean isOptimized() {</dt><dd><p>return this.isOptimized;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns a new atomic reader for this segment.</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>public EarlybirdIndexSegmentAtomicReader createAtomicReader() throws IOException {</dt><dd><p>EarlybirdIndexSegmentAtomicReader reader = doCreateAtomicReader();
EarlybirdIndexExtensionsData indexExtension = getIndexExtensionsData();
if (indexExtension != null) {</p>
<blockquote>
<div><p>indexExtension.setupExtensions(reader);</p>
</div></blockquote>
<p>}
return reader;</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Creates a new atomic reader for this segment.</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
</dl>
<p>protected abstract EarlybirdIndexSegmentAtomicReader doCreateAtomicReader() throws IOException;</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Creates a new segment writer for this segment.</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
<dt>public abstract EarlybirdIndexSegmentWriter createEarlybirdIndexSegmentWriter(</dt><dd><p>IndexWriterConfig indexWriterConfig) throws IOException;</p>
</dd>
<dt>public abstract static class AbstractSegmentDataFlushHandler</dt><dd><blockquote>
<div><p>&lt;S extends EarlybirdIndexExtensionsData&gt;
extends Flushable.Handler&lt;EarlybirdIndexSegmentData&gt; {</p>
</div></blockquote>
<p>protected static final String MAX_SEGMENT_SIZE_PROP_NAME = “maxSegmentSize”;
protected static final String TIME_SLICE_ID_PROP_NAME = “time_slice_id”;
protected static final String SMALLEST_DOCID_PROP_NAME = “smallestDocID”;
protected static final String DOC_ID_MAPPER_SUBPROPS_NAME = “doc_id_mapper”;
protected static final String TIME_MAPPER_SUBPROPS_NAME = “time_mapper”;
public static final String IS_OPTIMIZED_PROP_NAME = “isOptimized”;</p>
<p>// Abstract methods child classes should implement:
// 1. How to additional data structures
protected abstract void flushAdditionalDataStructures(</p>
<blockquote>
<div><dl class="simple">
<dt>FlushInfo flushInfo, DataSerializer out, EarlybirdIndexSegmentData toFlush)</dt><dd><p>throws IOException;</p>
</dd>
</dl>
</div></blockquote>
<p>// 2. Load additional data structures and construct SegmentData.
// Common data structures should be passed into this method to avoid code duplication.
// Subclasses should load additional data structures and construct a SegmentData.
protected abstract EarlybirdIndexSegmentData constructSegmentData(</p>
<blockquote>
<div><p>FlushInfo flushInfo,
ConcurrentHashMap&lt;String, InvertedIndex&gt; perFieldMap,
int maxSegmentSize,
S indexExtension,
DocIDToTweetIDMapper docIdToTweetIdMapper,
TimeMapper timeMapper,
DataDeserializer in) throws IOException;</p>
</div></blockquote>
<p>protected abstract S newIndexExtension();</p>
<p>protected final Schema schema;
protected final EarlybirdIndexExtensionsFactory indexExtensionsFactory;
private final Flushable.Handler&lt;? extends DocIDToTweetIDMapper&gt; docIdMapperFlushHandler;
private final Flushable.Handler&lt;? extends TimeMapper&gt; timeMapperFlushHandler;</p>
<dl>
<dt>public AbstractSegmentDataFlushHandler(</dt><dd><blockquote>
<div><p>Schema schema,
EarlybirdIndexExtensionsFactory indexExtensionsFactory,
Flushable.Handler&lt;? extends DocIDToTweetIDMapper&gt; docIdMapperFlushHandler,
Flushable.Handler&lt;? extends TimeMapper&gt; timeMapperFlushHandler) {</p>
</div></blockquote>
<p>super();
this.schema = schema;
this.indexExtensionsFactory = indexExtensionsFactory;
this.docIdMapperFlushHandler = docIdMapperFlushHandler;
this.timeMapperFlushHandler = timeMapperFlushHandler;</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public AbstractSegmentDataFlushHandler(EarlybirdIndexSegmentData objectToFlush) {</dt><dd><p>super(objectToFlush);
this.schema = objectToFlush.schema;
this.indexExtensionsFactory = null; // factory only needed for loading SegmentData from disk
this.docIdMapperFlushHandler = null; // docIdMapperFlushHandler needed only for loading data
this.timeMapperFlushHandler = null; // timeMapperFlushHandler needed only for loading data</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
protected void doFlush(FlushInfo flushInfo, DataSerializer out)</p>
<blockquote>
<div><blockquote>
<div><p>throws IOException {</p>
</div></blockquote>
<p>EarlybirdIndexSegmentData segmentData = getObjectToFlush();</p>
<p>Preconditions.checkState(segmentData.docIdToTweetIdMapper instanceof Flushable);
((Flushable) segmentData.docIdToTweetIdMapper).getFlushHandler().flush(</p>
<blockquote>
<div><p>flushInfo.newSubProperties(DOC_ID_MAPPER_SUBPROPS_NAME), out);</p>
</div></blockquote>
<dl class="simple">
<dt>if (segmentData.timeMapper != null) {</dt><dd><dl class="simple">
<dt>segmentData.timeMapper.getFlushHandler()</dt><dd><p>.flush(flushInfo.newSubProperties(TIME_MAPPER_SUBPROPS_NAME), out);</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>flushInfo.addBooleanProperty(IS_OPTIMIZED_PROP_NAME, segmentData.isOptimized());
flushInfo.addIntProperty(MAX_SEGMENT_SIZE_PROP_NAME, segmentData.getMaxSegmentSize());
flushInfo.addLongProperty(TIME_SLICE_ID_PROP_NAME, segmentData.getTimeSliceID());
flushInfo.addIntProperty(SMALLEST_DOCID_PROP_NAME,</p>
<blockquote>
<div><p>segmentData.getSyncData().getSmallestDocID());</p>
</div></blockquote>
<p>flushIndexes(flushInfo, out, segmentData);</p>
<p>// Flush cluster specific data structures:
// FacetCountingArray, TweetIDMapper, LatLonMapper, and TimeMapper
flushAdditionalDataStructures(flushInfo, out, segmentData);</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private void flushIndexes(</dt><dd><blockquote>
<div><p>FlushInfo flushInfo,
DataSerializer out,
EarlybirdIndexSegmentData segmentData) throws IOException {</p>
</div></blockquote>
<p>Map&lt;String, InvertedIndex&gt; perFieldMap = segmentData.getPerFieldMap();
FlushInfo fieldProps = flushInfo.newSubProperties(“fields”);
long sizeBeforeFlush = out.length();
for (Map.Entry&lt;String, InvertedIndex&gt; entry : perFieldMap.entrySet()) {</p>
<blockquote>
<div><p>String fieldName = entry.getKey();
entry.getValue().getFlushHandler().flush(fieldProps.newSubProperties(fieldName), out);</p>
</div></blockquote>
<p>}
fieldProps.setSizeInBytes(out.length() - sizeBeforeFlush);</p>
</dd>
</dl>
<p>}</p>
<p>&#64;Override
protected EarlybirdIndexSegmentData doLoad(FlushInfo flushInfo, DataDeserializer in)</p>
<blockquote>
<div><blockquote>
<div><p>throws IOException {</p>
</div></blockquote>
<dl class="simple">
<dt>DocIDToTweetIDMapper docIdToTweetIdMapper = docIdMapperFlushHandler.load(</dt><dd><p>flushInfo.getSubProperties(DOC_ID_MAPPER_SUBPROPS_NAME), in);</p>
</dd>
</dl>
<p>FlushInfo timeMapperFlushInfo = flushInfo.getSubProperties(TIME_MAPPER_SUBPROPS_NAME);
TimeMapper timeMapper =</p>
<blockquote>
<div><p>timeMapperFlushInfo != null ? timeMapperFlushHandler.load(timeMapperFlushInfo, in) : null;</p>
</div></blockquote>
<p>final int maxSegmentSize = flushInfo.getIntProperty(MAX_SEGMENT_SIZE_PROP_NAME);
ConcurrentHashMap&lt;String, InvertedIndex&gt; perFieldMap = loadIndexes(flushInfo, in);
return constructSegmentData(</p>
<blockquote>
<div><p>flushInfo,
perFieldMap,
maxSegmentSize,
newIndexExtension(),
docIdToTweetIdMapper,
timeMapper,
in);</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
<p>// Move this method into EarlybirdRealtimeIndexSegmentData (careful,
// we may need to increment FlushVersion because EarlybirdLuceneIndexSegmentData
// currently has the ‘fields’ subproperty in its FlushInfo as well)
private ConcurrentHashMap&lt;String, InvertedIndex&gt; loadIndexes(</p>
<blockquote>
<div><blockquote>
<div><p>FlushInfo flushInfo, DataDeserializer in) throws IOException {</p>
</div></blockquote>
<p>ConcurrentHashMap&lt;String, InvertedIndex&gt; perFieldMap = new ConcurrentHashMap&lt;&gt;();</p>
<p>FlushInfo fieldProps = flushInfo.getSubProperties(“fields”);
Iterator&lt;String&gt; fieldIterator = fieldProps.getKeyIterator();
while (fieldIterator.hasNext()) {</p>
<blockquote>
<div><p>String fieldName = fieldIterator.next();
EarlybirdFieldType fieldType = schema.getFieldInfo(fieldName).getFieldType();
FlushInfo subProp = fieldProps.getSubProperties(fieldName);
boolean isOptimized = subProp.getBooleanProperty(</p>
<blockquote>
<div><p>OptimizedMemoryIndex.FlushHandler.IS_OPTIMIZED_PROP_NAME);</p>
</div></blockquote>
<p>final InvertedIndex invertedIndex;
if (isOptimized) {</p>
<blockquote>
<div><dl class="simple">
<dt>if (!fieldType.becomesImmutable()) {</dt><dd><dl class="simple">
<dt>throw new IOException(“Tried to load an optimized field that is not immutable: “</dt><dd><ul class="simple">
<li><p>fieldName);</p></li>
</ul>
</dd>
</dl>
</dd>
</dl>
<p>}
invertedIndex = (new OptimizedMemoryIndex.FlushHandler(fieldType)).load(subProp, in);</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><dl>
<dt>invertedIndex = (new InvertedRealtimeIndex.FlushHandler(</dt><dd><blockquote>
<div><p>fieldType, TermPointerEncoding.DEFAULT_ENCODING))</p>
</div></blockquote>
<p>.load(subProp, in);</p>
</dd>
</dl>
</dd>
</dl>
<p>}
perFieldMap.put(fieldName, invertedIndex);</p>
</div></blockquote>
<p>}
return perFieldMap;</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>public int numDocs() {</dt><dd><p>return docIdToTweetIdMapper.getNumDocs();</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../_sources/src/java/com/twitter/search/core/earlybird/index/EarlybirdIndexSegmentData.java.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>