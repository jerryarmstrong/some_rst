<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../" id="documentation_options" src="../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.interaction_graph.scio.common</p>
<p>import com.spotify.scio.ScioMetrics
import com.spotify.scio.values.SCollection
import com.twitter.interaction_graph.scio.common.FeatureGroups.DWELL_TIME_FEATURE_LIST
import com.twitter.interaction_graph.scio.common.FeatureGroups.STATUS_FEATURE_LIST
import com.twitter.interaction_graph.scio.common.UserUtil.DUMMY_USER_ID
import com.twitter.interaction_graph.thriftscala.Edge
import com.twitter.interaction_graph.thriftscala.EdgeFeature
import com.twitter.interaction_graph.thriftscala.FeatureName
import com.twitter.interaction_graph.thriftscala.TimeSeriesStatistics
import com.twitter.interaction_graph.thriftscala.Vertex
import com.twitter.interaction_graph.thriftscala.VertexFeature</p>
<p>object FeatureGeneratorUtil {</p>
<blockquote>
<div><p>// Initialize a TimeSeriesStatistics object by (value, age) pair
def initializeTSS(featureValue: Double, age: Int = 1): TimeSeriesStatistics =</p>
<blockquote>
<div><dl class="simple">
<dt>TimeSeriesStatistics(</dt><dd><p>mean = featureValue,
m2ForVariance = 0.0,
ewma = featureValue,
numElapsedDays = age,
numNonZeroDays = age,
numDaysSinceLast = Some(age)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Create vertex feature from InteractionGraphRawInput graph (src, dst, feature name, age, featureValue)</p></li>
<li><p>We will represent non-directional features (eg num_create_tweets) as “outgoing” values.</p></li>
<li><p>&#64;return</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>def getVertexFeature(</dt><dd><p>input: SCollection[InteractionGraphRawInput]</p>
</dd>
<dt>): SCollection[Vertex] = {</dt><dd><p>// For vertex features we need to calculate both in and out featureValue
val vertexAggregatedFeatureValues = input</p>
<blockquote>
<div><dl>
<dt>.flatMap { input =&gt;</dt><dd><dl>
<dt>if (input.dst != DUMMY_USER_ID) {</dt><dd><dl class="simple">
<dt>Seq(</dt><dd><p>((input.src, input.name.value), (input.featureValue, 0.0)),
((input.dst, input.name.value), (0.0, input.featureValue))</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>} else {</dt><dd><p>// we put the non-directional features as “outgoing” values
Seq(((input.src, input.name.value), (input.featureValue, 0.0)))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.sumByKey
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case ((userId, nameId), (outEdges, inEdges)) =&gt;</dt><dd><p>(userId, (FeatureName(nameId), outEdges, inEdges))</p>
</dd>
</dl>
</div></blockquote>
<p>}.groupByKey</p>
</div></blockquote>
<dl>
<dt>vertexAggregatedFeatureValues.map {</dt><dd><dl>
<dt>case (userId, records) =&gt;</dt><dd><p>// sort features by FeatureName for deterministic order (esp during testing)
val features = records.toSeq.sortBy(_._1.value).flatMap {</p>
<blockquote>
<div><dl>
<dt>case (name, outEdges, inEdges) =&gt;</dt><dd><p>// create out vertex features
val outFeatures = if (outEdges &gt; 0) {</p>
<blockquote>
<div><p>val outTss = initializeTSS(outEdges)
List(</p>
<blockquote>
<div><dl class="simple">
<dt>VertexFeature(</dt><dd><p>name = name,
outgoing = true,
tss = outTss</p>
</dd>
</dl>
<p>))</p>
</div></blockquote>
</div></blockquote>
<p>} else Nil</p>
<p>// create in vertex features
val inFeatures = if (inEdges &gt; 0) {</p>
<blockquote>
<div><p>val inTss = initializeTSS(inEdges)
List(</p>
<blockquote>
<div><dl class="simple">
<dt>VertexFeature(</dt><dd><p>name = name,
outgoing = false,
tss = inTss</p>
</dd>
</dl>
<p>))</p>
</div></blockquote>
</div></blockquote>
<p>} else Nil</p>
<p>outFeatures ++ inFeatures</p>
</dd>
</dl>
</div></blockquote>
<p>}
Vertex(userId = userId, features = features)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Create edge feature from InteractionGraphRawInput graph (src, dst, feature name, age, featureValue)</p></li>
<li><p>We will exclude all non-directional features (eg num_create_tweets) from all edge aggregates</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>def getEdgeFeature(</dt><dd><p>input: SCollection[InteractionGraphRawInput]</p>
</dd>
<dt>): SCollection[Edge] = {</dt><dd><dl>
<dt>input</dt><dd><p>.withName(“filter non-directional features”)
.flatMap { input =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>if (input.dst != DUMMY_USER_ID) {</dt><dd><p>ScioMetrics.counter(“getEdgeFeature”, s”directional feature ${input.name.name}”).inc()
Some(((input.src, input.dst), (input.name, input.age, input.featureValue)))</p>
</dd>
<dt>} else {</dt><dd><p>ScioMetrics.counter(“getEdgeFeature”, s”non-directional feature ${input.name.name}”).inc()
None</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
.withName(“group features by pairs”)
.groupByKey
.map {</p>
<blockquote>
<div><dl>
<dt>case ((src, dst), records) =&gt;</dt><dd><p>// sort features by FeatureName for deterministic order (esp during testing)
val features = records.toSeq.sortBy(_._1.value).map {</p>
<blockquote>
<div><dl>
<dt>case (name, age, featureValue) =&gt;</dt><dd><p>val tss = initializeTSS(featureValue, age)
EdgeFeature(</p>
<blockquote>
<div><p>name = name,
tss = tss</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>}
Edge(</p>
<blockquote>
<div><p>sourceId = src,
destinationId = dst,
weight = Some(0.0),
features = features.toSeq</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>// For same user id, combine different vertex feature records into one record
// The input will assume for each (userId, featureName, direction), there will be only one record
def combineVertexFeatures(</p>
<blockquote>
<div><p>vertex: SCollection[Vertex],</p>
</div></blockquote>
<dl>
<dt>): SCollection[Vertex] = {</dt><dd><dl>
<dt>vertex</dt><dd><dl class="simple">
<dt>.groupBy { v: Vertex =&gt;</dt><dd><p>v.userId</p>
</dd>
</dl>
<p>}
.map {</p>
<blockquote>
<div><dl>
<dt>case (userId, vertexes) =&gt;</dt><dd><dl class="simple">
<dt>val combiner = vertexes.foldLeft(VertexFeatureCombiner(userId)) {</dt><dd><dl class="simple">
<dt>case (combiner, vertex) =&gt;</dt><dd><p>combiner.addFeature(vertex)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
combiner.getCombinedVertex(0)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def combineEdgeFeatures(</dt><dd><p>edge: SCollection[Edge]</p>
</dd>
<dt>): SCollection[Edge] = {</dt><dd><dl>
<dt>edge</dt><dd><dl class="simple">
<dt>.groupBy { e =&gt;</dt><dd><p>(e.sourceId, e.destinationId)</p>
</dd>
</dl>
<p>}
.withName(“combining edge features for each (src, dst)”)
.map {</p>
<blockquote>
<div><dl>
<dt>case ((src, dst), edges) =&gt;</dt><dd><dl class="simple">
<dt>val combiner = edges.foldLeft(EdgeFeatureCombiner(src, dst)) {</dt><dd><dl class="simple">
<dt>case (combiner, edge) =&gt;</dt><dd><p>combiner.addFeature(edge)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
combiner.getCombinedEdge(0)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def combineVertexFeaturesWithDecay(</dt><dd><p>history: SCollection[Vertex],
daily: SCollection[Vertex],
historyWeight: Double,
dailyWeight: Double</p>
</dd>
</dl>
<p>): SCollection[Vertex] = {</p>
<blockquote>
<div><dl>
<dt>history</dt><dd><p>.keyBy(_.userId)
.cogroup(daily.keyBy(_.userId)).map {</p>
<blockquote>
<div><dl>
<dt>case (userId, (h, d)) =&gt;</dt><dd><p>// Adding history iterators
val historyCombiner = h.toList.foldLeft(VertexFeatureCombiner(userId)) {</p>
<blockquote>
<div><dl class="simple">
<dt>case (combiner, vertex) =&gt;</dt><dd><p>combiner.addFeature(vertex, historyWeight, 0)</p>
</dd>
</dl>
</div></blockquote>
<p>}
// Adding daily iterators
val finalCombiner = d.toList.foldLeft(historyCombiner) {</p>
<blockquote>
<div><dl class="simple">
<dt>case (combiner, vertex) =&gt;</dt><dd><p>combiner.addFeature(vertex, dailyWeight, 1)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>finalCombiner.getCombinedVertex(</dt><dd><p>2</p>
</dd>
</dl>
<p>) // 2 means totally we have 2 days(yesterday and today) data to combine together</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>def combineEdgeFeaturesWithDecay(</dt><dd><p>history: SCollection[Edge],
daily: SCollection[Edge],
historyWeight: Double,
dailyWeight: Double</p>
</dd>
</dl>
<p>): SCollection[Edge] = {</p>
<blockquote>
<div><dl>
<dt>history</dt><dd><dl class="simple">
<dt>.keyBy { e =&gt;</dt><dd><p>(e.sourceId, e.destinationId)</p>
</dd>
</dl>
<p>}
.withName(“combine history and daily edges with decay”)
.cogroup(daily.keyBy { e =&gt;</p>
<blockquote>
<div><p>(e.sourceId, e.destinationId)</p>
</div></blockquote>
<dl>
<dt>}).map {</dt><dd><dl>
<dt>case ((src, dst), (h, d)) =&gt;</dt><dd><p>//val combiner = EdgeFeatureCombiner(src, dst)
// Adding history iterators</p>
<dl class="simple">
<dt>val historyCombiner = h.toList.foldLeft(EdgeFeatureCombiner(src, dst)) {</dt><dd><dl class="simple">
<dt>case (combiner, edge) =&gt;</dt><dd><p>combiner.addFeature(edge, historyWeight, 0)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val finalCombiner = d.toList.foldLeft(historyCombiner) {</dt><dd><dl class="simple">
<dt>case (combiner, edge) =&gt;</dt><dd><p>combiner.addFeature(edge, dailyWeight, 1)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>finalCombiner.getCombinedEdge(</dt><dd><p>2</p>
</dd>
</dl>
<p>) // 2 means totally we have 2 days(yesterday and today) data to combine together</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Create features from following graph (src, dst, age, featureValue)</p></li>
<li><p>Note that we will filter out vertex features represented as edges from the edge output.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>def getFeatures(</dt><dd><p>input: SCollection[InteractionGraphRawInput]</p>
</dd>
<dt>): (SCollection[Vertex], SCollection[Edge]) = {</dt><dd><p>(getVertexFeature(input), getEdgeFeature(input))</p>
</dd>
</dl>
<p>}</p>
<p>// remove the edge features that from flock, address book or sms as we will refresh them on a daily basis
def removeStatusFeatures(e: Edge): Seq[Edge] = {</p>
<blockquote>
<div><dl class="simple">
<dt>val updatedFeatureList = e.features.filter { e =&gt;</dt><dd><p>!STATUS_FEATURE_LIST.contains(e.name)</p>
</dd>
</dl>
<p>}
if (updatedFeatureList.size &gt; 0) {</p>
<blockquote>
<div><dl class="simple">
<dt>val edge = Edge(</dt><dd><p>sourceId = e.sourceId,
destinationId = e.destinationId,
weight = e.weight,
features = updatedFeatureList</p>
</dd>
</dl>
<p>)
Seq(edge)</p>
</div></blockquote>
<dl class="simple">
<dt>} else</dt><dd><p>Nil</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<p>// check if the edge feature has features other than dwell time feature
def edgeWithFeatureOtherThanDwellTime(e: Edge): Boolean = {</p>
<blockquote>
<div><dl class="simple">
<dt>e.features.exists { f =&gt;</dt><dd><p>!DWELL_TIME_FEATURE_LIST.contains(f.name)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../_sources/src/scala/com/twitter/interaction_graph/scio/common/FeatureGeneratorUtil.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>