<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.timelines.prediction.common.aggregates.real_time</p>
<p>import com.twitter.conversions.DurationOps._
import com.twitter.ml.api.Feature
import com.twitter.ml.api.constant.SharedFeatures
import com.twitter.timelines.data_processing.ml_util.aggregation_framework.AggregateGroup
import com.twitter.timelines.data_processing.ml_util.aggregation_framework.AggregateSource
import com.twitter.timelines.data_processing.ml_util.aggregation_framework.AggregateStore
import com.twitter.timelines.data_processing.ml_util.aggregation_framework.heron.OnlineAggregationConfigTrait
import com.twitter.timelines.data_processing.ml_util.aggregation_framework.metrics.CountMetric
import com.twitter.timelines.data_processing.ml_util.aggregation_framework.metrics.SumMetric
import com.twitter.timelines.data_processing.ml_util.transforms.BinaryUnion
import com.twitter.timelines.data_processing.ml_util.transforms.DownsampleTransform
import com.twitter.timelines.data_processing.ml_util.transforms.IsNewUserTransform
import com.twitter.timelines.data_processing.ml_util.transforms.IsPositionTransform
import com.twitter.timelines.data_processing.ml_util.transforms.LogTransform
import com.twitter.timelines.data_processing.ml_util.transforms.PositionCase
import com.twitter.timelines.data_processing.ml_util.transforms.RichITransform
import com.twitter.timelines.data_processing.ml_util.transforms.RichRemoveUnverifiedUserTransform
import com.twitter.timelines.prediction.features.client_log_event.ClientLogEventDataRecordFeatures
import com.twitter.timelines.prediction.features.common.CombinedFeatures
import com.twitter.timelines.prediction.features.common.CombinedFeatures._
import com.twitter.timelines.prediction.features.common.ProfileLabelFeatures
import com.twitter.timelines.prediction.features.common.SearchLabelFeatures
import com.twitter.timelines.prediction.features.common.TimelinesSharedFeatures
import com.twitter.timelines.prediction.features.common.TimelinesSharedFeatures.IS_TOP_FIVE
import com.twitter.timelines.prediction.features.common.TimelinesSharedFeatures.IS_TOP_ONE
import com.twitter.timelines.prediction.features.common.TimelinesSharedFeatures.IS_TOP_TEN
import com.twitter.timelines.prediction.features.common.TimelinesSharedFeatures.LOG_POSITION
import com.twitter.timelines.prediction.features.list_features.ListFeatures
import com.twitter.timelines.prediction.features.recap.RecapFeatures
import com.twitter.util.Duration
import java.lang.{Boolean =&gt; JBoolean}
import java.lang.{Long =&gt; JLong}
import scala.io.Source</p>
<dl>
<dt>object TimelinesOnlineAggregationUtils {</dt><dd><p>val TweetLabels: Set[Feature[JBoolean]] = CombinedFeatures.EngagementsRealTime
val TweetCoreLabels: Set[Feature[JBoolean]] = CombinedFeatures.CoreEngagements
val TweetDwellLabels: Set[Feature[JBoolean]] = CombinedFeatures.DwellEngagements
val TweetCoreAndDwellLabels: Set[Feature[JBoolean]] = TweetCoreLabels ++ TweetDwellLabels
val PrivateEngagementLabelsV2: Set[Feature[JBoolean]] = CombinedFeatures.PrivateEngagementsV2
val ProfileCoreLabels: Set[Feature[JBoolean]] = ProfileLabelFeatures.CoreEngagements
val ProfileNegativeEngagementLabels: Set[Feature[JBoolean]] =</p>
<blockquote>
<div><p>ProfileLabelFeatures.NegativeEngagements</p>
</div></blockquote>
<dl class="simple">
<dt>val ProfileNegativeEngagementUnionLabels: Set[Feature[JBoolean]] = Set(</dt><dd><p>ProfileLabelFeatures.IS_NEGATIVE_FEEDBACK_UNION)</p>
</dd>
</dl>
<p>val SearchCoreLabels: Set[Feature[JBoolean]] = SearchLabelFeatures.CoreEngagements
val TweetNegativeEngagementLabels: Set[Feature[JBoolean]] =</p>
<blockquote>
<div><p>CombinedFeatures.NegativeEngagementsRealTime</p>
</div></blockquote>
<dl class="simple">
<dt>val TweetNegativeEngagementDontLikeLabels: Set[Feature[JBoolean]] =</dt><dd><p>CombinedFeatures.NegativeEngagementsRealTimeDontLike</p>
</dd>
<dt>val TweetNegativeEngagementSecondaryLabels: Set[Feature[JBoolean]] =</dt><dd><p>CombinedFeatures.NegativeEngagementsSecondary</p>
</dd>
<dt>val AllTweetNegativeEngagementLabels: Set[Feature[JBoolean]] =</dt><dd><p>TweetNegativeEngagementLabels ++ TweetNegativeEngagementDontLikeLabels ++ TweetNegativeEngagementSecondaryLabels</p>
</dd>
</dl>
<p>val UserAuthorEngagementLabels: Set[Feature[JBoolean]] = CombinedFeatures.UserAuthorEngagements
val ShareEngagementLabels: Set[Feature[JBoolean]] = CombinedFeatures.ShareEngagements
val BookmarkEngagementLabels: Set[Feature[JBoolean]] = CombinedFeatures.BookmarkEngagements
val AllBCEDwellLabels: Set[Feature[JBoolean]] =</p>
<blockquote>
<div><p>CombinedFeatures.TweetDetailDwellEngagements ++ CombinedFeatures.ProfileDwellEngagements ++ CombinedFeatures.FullscreenVideoDwellEngagements</p>
</div></blockquote>
<dl class="simple">
<dt>val AllTweetUnionLabels: Set[Feature[JBoolean]] = Set(</dt><dd><p>CombinedFeatures.IS_IMPLICIT_POSITIVE_FEEDBACK_UNION,
CombinedFeatures.IS_EXPLICIT_POSITIVE_FEEDBACK_UNION,
CombinedFeatures.IS_ALL_NEGATIVE_FEEDBACK_UNION</p>
</dd>
</dl>
<p>)
val AllTweetLabels: Set[Feature[JBoolean]] =</p>
<blockquote>
<div><p>TweetLabels ++ TweetCoreAndDwellLabels ++ AllTweetNegativeEngagementLabels ++ ProfileCoreLabels ++ ProfileNegativeEngagementLabels ++ ProfileNegativeEngagementUnionLabels ++ UserAuthorEngagementLabels ++ SearchCoreLabels ++ ShareEngagementLabels ++ BookmarkEngagementLabels ++ PrivateEngagementLabelsV2 ++ AllBCEDwellLabels ++ AllTweetUnionLabels</p>
</div></blockquote>
<dl>
<dt>def addFeatureFilterFromResource(</dt><dd><p>prodGroup: AggregateGroup,
aggRemovalPath: String</p>
</dd>
<dt>): AggregateGroup = {</dt><dd><p>val resource = Some(Source.fromResource(aggRemovalPath))
val lines = resource.map(_.getLines.toSeq)
lines match {</p>
<blockquote>
<div><p>case Some(value) =&gt; prodGroup.copy(aggExclusionRegex = value)
case _ =&gt; prodGroup</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>trait TimelinesOnlineAggregationDefinitionsTrait extends OnlineAggregationConfigTrait {</dt><dd><p>import TimelinesOnlineAggregationUtils._</p>
<p>def inputSource: AggregateSource
def ProductionStore: AggregateStore
def StagingStore: AggregateStore</p>
<dl class="simple">
<dt>val TweetFeatures: Set[Feature[_]] = Set(</dt><dd><p>ClientLogEventDataRecordFeatures.HasConsumerVideo,
ClientLogEventDataRecordFeatures.PhotoCount</p>
</dd>
</dl>
<p>)
val CandidateTweetSourceFeatures: Set[Feature[_]] = Set(</p>
<blockquote>
<div><p>ClientLogEventDataRecordFeatures.FromRecap,
ClientLogEventDataRecordFeatures.FromRecycled,
ClientLogEventDataRecordFeatures.FromActivity,
ClientLogEventDataRecordFeatures.FromSimcluster,
ClientLogEventDataRecordFeatures.FromErg,
ClientLogEventDataRecordFeatures.FromCroon,
ClientLogEventDataRecordFeatures.FromList,
ClientLogEventDataRecordFeatures.FromRecTopic</p>
</div></blockquote>
<p>)</p>
<dl>
<dt>def createStagingGroup(prodGroup: AggregateGroup): AggregateGroup =</dt><dd><dl class="simple">
<dt>prodGroup.copy(</dt><dd><p>outputStore = StagingStore</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>// Aggregate user engagements/features by tweet Id.
val tweetEngagement30MinuteCountsProd =</p>
<blockquote>
<div><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_tweet_aggregates_v1”,
keys = Set(TimelinesSharedFeatures.SOURCE_TWEET_ID),
features = Set.empty,
labels = TweetLabels ++ TweetNegativeEngagementDontLikeLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>// Aggregate user engagements/features by tweet Id.
val tweetVerifiedDontLikeEngagementRealTimeAggregatesProd =</p>
<blockquote>
<div><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_tweet_aggregates_v6”,
preTransforms = Seq(RichRemoveUnverifiedUserTransform),
keys = Set(TimelinesSharedFeatures.SOURCE_TWEET_ID),
features = Set.empty,
labels = TweetNegativeEngagementDontLikeLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>val tweetNegativeEngagement6HourCounts =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_tweet_aggregates_v2”,
keys = Set(TimelinesSharedFeatures.SOURCE_TWEET_ID),
features = Set.empty,
labels = TweetNegativeEngagementLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val tweetVerifiedNegativeEngagementCounts =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_tweet_aggregates_v7”,
preTransforms = Seq(RichRemoveUnverifiedUserTransform),
keys = Set(TimelinesSharedFeatures.SOURCE_TWEET_ID),
features = Set.empty,
labels = TweetNegativeEngagementLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val promotedTweetEngagementRealTimeCounts =</dt><dd><dl>
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_tweet_aggregates_v3.is_promoted”,
preTransforms = Seq(</p>
<blockquote>
<div><dl class="simple">
<dt>DownsampleTransform(</dt><dd><p>negativeSamplingRate = 0.0,
keepLabels = Set(ClientLogEventDataRecordFeatures.IsPromoted))),</p>
</dd>
</dl>
</div></blockquote>
<p>keys = Set(TimelinesSharedFeatures.SOURCE_TWEET_ID),
features = Set.empty,
labels = TweetCoreAndDwellLabels,
metrics = Set(CountMetric),
halfLives = Set(2.hours, 24.hours),
outputStore = ProductionStore,
includeAnyFeature = false,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate total engagement counts by tweet Id for non-public</p></li>
<li><p>engagements. Similar to EB’s public engagement counts.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>val tweetEngagementTotalCountsProd =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_tweet_aggregates_v1”,
keys = Set(TimelinesSharedFeatures.SOURCE_TWEET_ID),
features = Set.empty,
labels = TweetLabels ++ TweetNegativeEngagementDontLikeLabels,
metrics = Set(CountMetric),
halfLives = Set(Duration.Top),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val tweetNegativeEngagementTotalCounts =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_tweet_aggregates_v2”,
keys = Set(TimelinesSharedFeatures.SOURCE_TWEET_ID),
features = Set.empty,
labels = TweetNegativeEngagementLabels,
metrics = Set(CountMetric),
halfLives = Set(Duration.Top),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate tweet features grouped by viewer’s user id.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>val userEngagementRealTimeAggregatesProd =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_user_aggregates_v1”,
keys = Set(SharedFeatures.USER_ID),
features = TweetFeatures,
labels = TweetLabels ++ TweetNegativeEngagementDontLikeLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate tweet features grouped by viewer’s user id.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>val userEngagementRealTimeAggregatesV2 =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_user_aggregates_v2”,
keys = Set(SharedFeatures.USER_ID),
features = ClientLogEventDataRecordFeatures.TweetFeaturesV2,
labels = TweetCoreAndDwellLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyFeature = false,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate author’s user state features grouped by viewer’s user id.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>val userEngagementAuthorUserStateRealTimeAggregates =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_user_aggregates_v3”,
preTransforms = Seq.empty,
keys = Set(SharedFeatures.USER_ID),
features = AuthorFeaturesAdapter.UserStateBooleanFeatures,
labels = TweetCoreAndDwellLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyFeature = false,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate author’s user state features grouped by viewer’s user id.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>val userNegativeEngagementAuthorUserStateRealTimeAggregates =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_user_aggregates_v4”,
preTransforms = Seq.empty,
keys = Set(SharedFeatures.USER_ID),
features = AuthorFeaturesAdapter.UserStateBooleanFeatures,
labels = TweetNegativeEngagementLabels ++ TweetNegativeEngagementDontLikeLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyFeature = false,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate tweet features grouped by viewer’s user id, with 48 hour halfLife.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>val userEngagement48HourRealTimeAggregatesProd =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_user_aggregates_v5”,
keys = Set(SharedFeatures.USER_ID),
features = TweetFeatures,
labels = TweetLabels ++ TweetNegativeEngagementDontLikeLabels,
metrics = Set(CountMetric),
halfLives = Set(48.hours),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate author’s user state features grouped by viewer’s user id.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>val userNegativeEngagementAuthorUserState72HourRealTimeAggregates =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_user_aggregates_v6”,
preTransforms = Seq.empty,
keys = Set(SharedFeatures.USER_ID),
features = AuthorFeaturesAdapter.UserStateBooleanFeatures,
labels = TweetNegativeEngagementLabels ++ TweetNegativeEngagementDontLikeLabels,
metrics = Set(CountMetric),
halfLives = Set(72.hours),
outputStore = ProductionStore,
includeAnyFeature = false,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate features grouped by source author id: for each author, aggregate features are created</p></li>
<li><p>to quantify engagements (fav, reply, etc.) which tweets of the author has received.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>val authorEngagementRealTimeAggregatesProd =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_author_aggregates_v1”,
keys = Set(TimelinesSharedFeatures.SOURCE_AUTHOR_ID),
features = Set.empty,
labels = TweetLabels ++ TweetNegativeEngagementDontLikeLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate features grouped by source author id: for each author, aggregate features are created</p></li>
<li><p>to quantify negative engagements (mute, block, etc.) which tweets of the author has received.</p></li>
<li></li>
<li><p>This aggregate group is not used in Home, but it is used in Follow Recommendation Service so need to keep it for now.</p></li>
<li></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>val authorNegativeEngagementRealTimeAggregatesProd =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_author_aggregates_v2”,
keys = Set(TimelinesSharedFeatures.SOURCE_AUTHOR_ID),
features = Set.empty,
labels = TweetNegativeEngagementLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate features grouped by source author id: for each author, aggregate features are created</p></li>
<li><p>to quantify negative engagements (don’t like) which tweets of the author has received from</p></li>
<li><p>verified users.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>val authorVerifiedNegativeEngagementRealTimeAggregatesProd =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_author_aggregates_v3”,
preTransforms = Seq(RichRemoveUnverifiedUserTransform),
keys = Set(TimelinesSharedFeatures.SOURCE_AUTHOR_ID),
features = Set.empty,
labels = TweetNegativeEngagementDontLikeLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate tweet features grouped by topic id.</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
<dt>val topicEngagementRealTimeAggregatesProd =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_topic_aggregates_v1”,
keys = Set(TimelinesSharedFeatures.TOPIC_ID),
features = Set.empty,
labels = TweetLabels ++ AllTweetNegativeEngagementLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate user engagements / user state by topic id.</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>val topicEngagementUserStateRealTimeAggregatesProd =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_topic_aggregates_v2”,
keys = Set(TimelinesSharedFeatures.TOPIC_ID),
features = UserFeaturesAdapter.UserStateBooleanFeatures,
labels = TweetCoreAndDwellLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyFeature = false,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate user negative engagements / user state by topic id.</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
<dt>val topicNegativeEngagementUserStateRealTimeAggregatesProd =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_topic_aggregates_v3”,
keys = Set(TimelinesSharedFeatures.TOPIC_ID),
features = UserFeaturesAdapter.UserStateBooleanFeatures,
labels = TweetNegativeEngagementLabels ++ TweetNegativeEngagementDontLikeLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyFeature = false,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate tweet features grouped by topic id like real_time_topic_aggregates_v1 but 24hour halfLife</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
<dt>val topicEngagement24HourRealTimeAggregatesProd =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_topic_aggregates_v4”,
keys = Set(TimelinesSharedFeatures.TOPIC_ID),
features = Set.empty,
labels = TweetLabels ++ AllTweetNegativeEngagementLabels,
metrics = Set(CountMetric),
halfLives = Set(24.hours),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>// Aggregate user engagements / user state by tweet Id.
val tweetEngagementUserStateRealTimeAggregatesProd =</p>
<blockquote>
<div><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_tweet_aggregates_v3”,
keys = Set(TimelinesSharedFeatures.SOURCE_TWEET_ID),
features = UserFeaturesAdapter.UserStateBooleanFeatures,
labels = TweetCoreAndDwellLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyFeature = false,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>// Aggregate user engagements / user gender by tweet Id.
val tweetEngagementGenderRealTimeAggregatesProd =</p>
<blockquote>
<div><dl>
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_tweet_aggregates_v4”,
keys = Set(TimelinesSharedFeatures.SOURCE_TWEET_ID),
features = UserFeaturesAdapter.GenderBooleanFeatures,
labels =</p>
<blockquote>
<div><p>TweetCoreAndDwellLabels ++ TweetNegativeEngagementLabels ++ TweetNegativeEngagementDontLikeLabels,</p>
</div></blockquote>
<p>metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyFeature = false,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>// Aggregate user negative engagements / user state by tweet Id.
val tweetNegativeEngagementUserStateRealTimeAggregates =</p>
<blockquote>
<div><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_tweet_aggregates_v5”,
keys = Set(TimelinesSharedFeatures.SOURCE_TWEET_ID),
features = UserFeaturesAdapter.UserStateBooleanFeatures,
labels = TweetNegativeEngagementLabels ++ TweetNegativeEngagementDontLikeLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyFeature = false,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>// Aggregate user negative engagements / user state by tweet Id.
val tweetVerifiedNegativeEngagementUserStateRealTimeAggregates =</p>
<blockquote>
<div><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_tweet_aggregates_v8”,
preTransforms = Seq(RichRemoveUnverifiedUserTransform),
keys = Set(TimelinesSharedFeatures.SOURCE_TWEET_ID),
features = UserFeaturesAdapter.UserStateBooleanFeatures,
labels = TweetNegativeEngagementLabels ++ TweetNegativeEngagementDontLikeLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyFeature = false,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate tweet engagement labels and candidate tweet source features grouped by user id.</p></li>
</ul>
<p><a href="#id29"><span class="problematic" id="id30">*</span></a>/</p>
</dd>
<dt>val userCandidateTweetSourceEngagementRealTimeAggregatesProd =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_user_candidate_tweet_source_aggregates_v1”,
keys = Set(SharedFeatures.USER_ID),
features = CandidateTweetSourceFeatures,
labels = TweetCoreAndDwellLabels ++ NegativeEngagementsRealTimeDontLike,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyFeature = false,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate tweet engagement labels and candidate tweet source features grouped by user id.</p></li>
</ul>
<p><a href="#id31"><span class="problematic" id="id32">*</span></a>/</p>
</dd>
<dt>val userCandidateTweetSourceEngagement48HourRealTimeAggregatesProd =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_user_candidate_tweet_source_aggregates_v2”,
keys = Set(SharedFeatures.USER_ID),
features = CandidateTweetSourceFeatures,
labels = TweetCoreAndDwellLabels ++ NegativeEngagementsRealTimeDontLike,
metrics = Set(CountMetric),
halfLives = Set(48.hours),
outputStore = ProductionStore,
includeAnyFeature = false,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate tweet features grouped by viewer’s user id on Profile engagements</p></li>
</ul>
<p><a href="#id33"><span class="problematic" id="id34">*</span></a>/</p>
</dd>
<dt>val userProfileEngagementRealTimeAggregates =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “profile_real_time_user_aggregates_v1”,
preTransforms = Seq(IsNewUserTransform),
keys = Set(SharedFeatures.USER_ID),
features = TweetFeatures,
labels = ProfileCoreLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyFeature = true,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val NegativeEngagementsUnionTransform = RichITransform(</dt><dd><dl class="simple">
<dt>BinaryUnion(</dt><dd><p>featuresToUnify = ProfileNegativeEngagementLabels,
outputFeature = ProfileLabelFeatures.IS_NEGATIVE_FEEDBACK_UNION</p>
</dd>
</dl>
<p>))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate tweet features grouped by viewer’s user id on Profile negative engagements.</p></li>
</ul>
<p><a href="#id35"><span class="problematic" id="id36">*</span></a>/</p>
</dd>
<dt>val userProfileNegativeEngagementRealTimeAggregates =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “profile_negative_engagement_real_time_user_aggregates_v1”,
preTransforms = Seq(NegativeEngagementsUnionTransform),
keys = Set(SharedFeatures.USER_ID),
features = Set.empty,
labels = ProfileNegativeEngagementLabels ++ ProfileNegativeEngagementUnionLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, 72.hours, 14.day),
outputStore = ProductionStore,
includeAnyFeature = true,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate tweet features grouped by viewer’s and author’s user ids and on Profile engagements</p></li>
</ul>
<p><a href="#id37"><span class="problematic" id="id38">*</span></a>/</p>
</dd>
<dt>val userAuthorProfileEngagementRealTimeAggregates =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “user_author_profile_real_time_aggregates_v1”,
keys = Set(SharedFeatures.USER_ID, TimelinesSharedFeatures.SOURCE_AUTHOR_ID),
features = Set.empty,
labels = ProfileCoreLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, 24.hours, 72.hours),
outputStore = ProductionStore,
includeAnyFeature = true,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate tweet features grouped by viewer’s and author’s user ids and on negative Profile engagements</p></li>
</ul>
<p><a href="#id39"><span class="problematic" id="id40">*</span></a>/</p>
</dd>
<dt>val userAuthorProfileNegativeEngagementRealTimeAggregates =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “user_author_profile_negative_engagement_real_time_aggregates_v1”,
preTransforms = Seq(NegativeEngagementsUnionTransform),
keys = Set(SharedFeatures.USER_ID, TimelinesSharedFeatures.SOURCE_AUTHOR_ID),
features = Set.empty,
labels = ProfileNegativeEngagementUnionLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, 72.hours, 14.day),
outputStore = ProductionStore,
includeAnyFeature = true,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val newUserAuthorEngagementRealTimeAggregatesProd =</dt><dd><dl>
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_new_user_author_aggregates_v1”,
preTransforms = Seq(IsNewUserTransform),
keys = Set(SharedFeatures.USER_ID, TimelinesSharedFeatures.SOURCE_AUTHOR_ID),
features = Set.empty,
labels = TweetCoreAndDwellLabels ++ Set(</p>
<blockquote>
<div><p>IS_CLICKED,
IS_PROFILE_CLICKED,
IS_PHOTO_EXPANDED</p>
</div></blockquote>
<p>),
metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyFeature = true,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val userAuthorEngagementRealTimeAggregatesProd = {</dt><dd><p>// Computing user-author real-time aggregates is very expensive so we
// take the union of all major negative feedback engagements to create
// a single negtive label for aggregation. We also include a number of
// core positive engagements.
val BinaryUnionNegativeEngagements =</p>
<blockquote>
<div><dl class="simple">
<dt>BinaryUnion(</dt><dd><p>featuresToUnify = AllTweetNegativeEngagementLabels,
outputFeature = IS_NEGATIVE_FEEDBACK_UNION</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>val BinaryUnionNegativeEngagementsTransform = RichITransform(BinaryUnionNegativeEngagements)</p>
<dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_user_author_aggregates_v1”,
preTransforms = Seq(BinaryUnionNegativeEngagementsTransform),
keys = Set(SharedFeatures.USER_ID, TimelinesSharedFeatures.SOURCE_AUTHOR_ID),
features = Set.empty,
labels = UserAuthorEngagementLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, 1.day),
outputStore = ProductionStore,
includeAnyFeature = true,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate tweet features grouped by list id.</p></li>
</ul>
<p><a href="#id41"><span class="problematic" id="id42">*</span></a>/</p>
</dd>
<dt>val listEngagementRealTimeAggregatesProd =</dt><dd><dl>
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_list_aggregates_v1”,
keys = Set(ListFeatures.LIST_ID),
features = Set.empty,
labels =</p>
<blockquote>
<div><p>TweetCoreAndDwellLabels ++ TweetNegativeEngagementLabels ++ TweetNegativeEngagementDontLikeLabels,</p>
</div></blockquote>
<p>metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>// Aggregate features grouped by topic of tweet and country from user’s location
val topicCountryRealTimeAggregates =</p>
<blockquote>
<div><dl>
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_topic_country_aggregates_v1”,
keys = Set(TimelinesSharedFeatures.TOPIC_ID, UserFeaturesAdapter.USER_COUNTRY_ID),
features = Set.empty,
labels =</p>
<blockquote>
<div><p>TweetCoreAndDwellLabels ++ AllTweetNegativeEngagementLabels ++ PrivateEngagementLabelsV2 ++ ShareEngagementLabels,</p>
</div></blockquote>
<p>metrics = Set(CountMetric),
halfLives = Set(30.minutes, 72.hours),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>// Aggregate features grouped by TweetId_Country from user’s location
val tweetCountryRealTimeAggregates =</p>
<blockquote>
<div><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_tweet_country_aggregates_v1”,
keys = Set(TimelinesSharedFeatures.SOURCE_TWEET_ID, UserFeaturesAdapter.USER_COUNTRY_ID),
features = Set.empty,
labels = TweetCoreAndDwellLabels ++ AllTweetNegativeEngagementLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyLabel = true,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>// Additional aggregate features grouped by TweetId_Country from user’s location
val tweetCountryPrivateEngagementsRealTimeAggregates =</p>
<blockquote>
<div><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_tweet_country_aggregates_v2”,
keys = Set(TimelinesSharedFeatures.SOURCE_TWEET_ID, UserFeaturesAdapter.USER_COUNTRY_ID),
features = Set.empty,
labels = PrivateEngagementLabelsV2 ++ ShareEngagementLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, 72.hours),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>// Aggregate features grouped by TweetId_Country from user’s location
val tweetCountryVerifiedNegativeEngagementsRealTimeAggregates =</p>
<blockquote>
<div><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_tweet_country_aggregates_v3”,
preTransforms = Seq(RichRemoveUnverifiedUserTransform),
keys = Set(TimelinesSharedFeatures.SOURCE_TWEET_ID, UserFeaturesAdapter.USER_COUNTRY_ID),
features = Set.empty,
labels = AllTweetNegativeEngagementLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, Duration.Top),
outputStore = ProductionStore,
includeAnyLabel = true,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl class="simple">
<dt>object positionTranforms extends IsPositionTransform {</dt><dd><dl class="simple">
<dt>override val isInPositionRangeFeature: Seq[PositionCase] =</dt><dd><p>Seq(PositionCase(1, IS_TOP_ONE), PositionCase(5, IS_TOP_FIVE), PositionCase(10, IS_TOP_TEN))</p>
</dd>
<dt>override val decodedPositionFeature: Feature.Discrete =</dt><dd><p>ClientLogEventDataRecordFeatures.InjectedPosition</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val userPositionEngagementsCountsProd =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_position_based_user_aggregates_v1”,
keys = Set(SharedFeatures.USER_ID),
features = Set(IS_TOP_ONE, IS_TOP_FIVE, IS_TOP_TEN),
labels = TweetCoreAndDwellLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, 24.hours),
outputStore = ProductionStore,
preTransforms = Seq(positionTranforms),
includeAnyLabel = false,
includeAnyFeature = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val userPositionEngagementsSumProd =</dt><dd><dl>
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_position_based_user_sum_aggregates_v2”,
keys = Set(SharedFeatures.USER_ID),
features = Set(LOG_POSITION),
labels = TweetCoreAndDwellLabels,
metrics = Set(SumMetric),
halfLives = Set(30.minutes, 24.hours),
outputStore = ProductionStore,
preTransforms =</p>
<blockquote>
<div><p>Seq(new LogTransform(ClientLogEventDataRecordFeatures.InjectedPosition, LOG_POSITION)),</p>
</div></blockquote>
<p>includeAnyLabel = false,
includeAnyFeature = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>// Aggregates for share engagements
val tweetShareEngagementsRealTimeAggregates =</p>
<blockquote>
<div><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_tweet_share_aggregates_v1”,
keys = Set(TimelinesSharedFeatures.SOURCE_TWEET_ID),
features = Set.empty,
labels = ShareEngagementLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, 24.hours),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>val userShareEngagementsRealTimeAggregates =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_user_share_aggregates_v1”,
keys = Set(SharedFeatures.USER_ID),
features = Set.empty,
labels = ShareEngagementLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, 24.hours),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val userAuthorShareEngagementsRealTimeAggregates =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_user_author_share_aggregates_v1”,
keys = Set(SharedFeatures.USER_ID, TimelinesSharedFeatures.SOURCE_AUTHOR_ID),
features = Set.empty,
labels = ShareEngagementLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, 24.hours),
outputStore = ProductionStore,
includeAnyFeature = true,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val topicShareEngagementsRealTimeAggregates =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_topic_share_aggregates_v1”,
keys = Set(TimelinesSharedFeatures.TOPIC_ID),
features = Set.empty,
labels = ShareEngagementLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, 24.hours),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val authorShareEngagementsRealTimeAggregates =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_author_share_aggregates_v1”,
keys = Set(TimelinesSharedFeatures.SOURCE_AUTHOR_ID),
features = Set.empty,
labels = ShareEngagementLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, 24.hours),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>// Bookmark RTAs
val tweetBookmarkEngagementsRealTimeAggregates =</p>
<blockquote>
<div><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_tweet_bookmark_aggregates_v1”,
keys = Set(TimelinesSharedFeatures.SOURCE_TWEET_ID),
features = Set.empty,
labels = BookmarkEngagementLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, 24.hours),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>val userBookmarkEngagementsRealTimeAggregates =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_user_bookmark_aggregates_v1”,
keys = Set(SharedFeatures.USER_ID),
features = Set.empty,
labels = BookmarkEngagementLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, 24.hours),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val userAuthorBookmarkEngagementsRealTimeAggregates =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_user_author_bookmark_aggregates_v1”,
keys = Set(SharedFeatures.USER_ID, TimelinesSharedFeatures.SOURCE_AUTHOR_ID),
features = Set.empty,
labels = BookmarkEngagementLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, 24.hours),
outputStore = ProductionStore,
includeAnyFeature = true,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val authorBookmarkEngagementsRealTimeAggregates =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_author_bookmark_aggregates_v1”,
keys = Set(TimelinesSharedFeatures.SOURCE_AUTHOR_ID),
features = Set.empty,
labels = BookmarkEngagementLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, 24.hours),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate on user level dwell labels from BCE</p></li>
</ul>
<p><a href="#id43"><span class="problematic" id="id44">*</span></a>/</p>
</dd>
<dt>val userBCEDwellEngagementsRealTimeAggregates =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_user_bce_dwell_aggregates”,
keys = Set(SharedFeatures.USER_ID),
features = Set.empty,
labels = AllBCEDwellLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, 24.hours),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate on tweet level dwell labels from BCE</p></li>
</ul>
<p><a href="#id45"><span class="problematic" id="id46">*</span></a>/</p>
</dd>
<dt>val tweetBCEDwellEngagementsRealTimeAggregates =</dt><dd><dl class="simple">
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_tweet_bce_dwell_aggregates”,
keys = Set(TimelinesSharedFeatures.SOURCE_TWEET_ID),
features = Set.empty,
labels = AllBCEDwellLabels,
metrics = Set(CountMetric),
halfLives = Set(30.minutes, 24.hours),
outputStore = ProductionStore,
includeAnyLabel = false,
includeTimestampFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val ImplicitPositiveEngagementsUnionTransform = RichITransform(</dt><dd><dl class="simple">
<dt>BinaryUnion(</dt><dd><p>featuresToUnify = CombinedFeatures.ImplicitPositiveEngagements,
outputFeature = CombinedFeatures.IS_IMPLICIT_POSITIVE_FEEDBACK_UNION</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>val ExplicitPositiveEngagementsUnionTransform = RichITransform(</dt><dd><dl class="simple">
<dt>BinaryUnion(</dt><dd><p>featuresToUnify = CombinedFeatures.ExplicitPositiveEngagements,
outputFeature = CombinedFeatures.IS_EXPLICIT_POSITIVE_FEEDBACK_UNION</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>val AllNegativeEngagementsUnionTransform = RichITransform(</dt><dd><dl class="simple">
<dt>BinaryUnion(</dt><dd><p>featuresToUnify = CombinedFeatures.AllNegativeEngagements,
outputFeature = CombinedFeatures.IS_ALL_NEGATIVE_FEEDBACK_UNION</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Aggregate features for author content preference</p></li>
</ul>
<p><a href="#id47"><span class="problematic" id="id48">*</span></a>/</p>
</dd>
<dt>val authorContentPreferenceRealTimeAggregates =</dt><dd><dl>
<dt>AggregateGroup(</dt><dd><p>inputSource = inputSource,
aggregatePrefix = “real_time_author_content_preference_aggregates”,
preTransforms = Seq(</p>
<blockquote>
<div><p>ImplicitPositiveEngagementsUnionTransform,
ExplicitPositiveEngagementsUnionTransform,
AllNegativeEngagementsUnionTransform),</p>
</div></blockquote>
<p>keys = Set(TimelinesSharedFeatures.SOURCE_AUTHOR_ID),
features =</p>
<blockquote>
<div><p>ClientLogEventDataRecordFeatures.AuthorContentPreferenceTweetTypeFeatures ++ AuthorFeaturesAdapter.UserStateBooleanFeatures,</p>
</div></blockquote>
<p>labels = AllTweetUnionLabels,
metrics = Set(CountMetric),
halfLives = Set(24.hours),
outputStore = ProductionStore,
includeAnyLabel = false,
includeAnyFeature = false,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>val FeaturesGeneratedByPreTransforms = Set(LOG_POSITION, IS_TOP_TEN, IS_TOP_FIVE, IS_TOP_ONE)</p>
<dl class="simple">
<dt>val ProdAggregateGroups = Set(</dt><dd><p>tweetEngagement30MinuteCountsProd,
tweetEngagementTotalCountsProd,
tweetNegativeEngagement6HourCounts,
tweetNegativeEngagementTotalCounts,
userEngagementRealTimeAggregatesProd,
userEngagement48HourRealTimeAggregatesProd,
userNegativeEngagementAuthorUserStateRealTimeAggregates,
userNegativeEngagementAuthorUserState72HourRealTimeAggregates,
authorEngagementRealTimeAggregatesProd,
topicEngagementRealTimeAggregatesProd,
topicEngagement24HourRealTimeAggregatesProd,
tweetEngagementUserStateRealTimeAggregatesProd,
tweetNegativeEngagementUserStateRealTimeAggregates,
userProfileEngagementRealTimeAggregates,
newUserAuthorEngagementRealTimeAggregatesProd,
userAuthorEngagementRealTimeAggregatesProd,
listEngagementRealTimeAggregatesProd,
tweetCountryRealTimeAggregates,
tweetShareEngagementsRealTimeAggregates,
userShareEngagementsRealTimeAggregates,
userAuthorShareEngagementsRealTimeAggregates,
topicShareEngagementsRealTimeAggregates,
authorShareEngagementsRealTimeAggregates,
tweetBookmarkEngagementsRealTimeAggregates,
userBookmarkEngagementsRealTimeAggregates,
userAuthorBookmarkEngagementsRealTimeAggregates,
authorBookmarkEngagementsRealTimeAggregates,
topicCountryRealTimeAggregates,
tweetCountryPrivateEngagementsRealTimeAggregates,
userBCEDwellEngagementsRealTimeAggregates,
tweetBCEDwellEngagementsRealTimeAggregates,
authorContentPreferenceRealTimeAggregates,
authorVerifiedNegativeEngagementRealTimeAggregatesProd,
tweetVerifiedDontLikeEngagementRealTimeAggregatesProd,
tweetVerifiedNegativeEngagementCounts,
tweetVerifiedNegativeEngagementUserStateRealTimeAggregates,
tweetCountryVerifiedNegativeEngagementsRealTimeAggregates</p>
</dd>
<dt>).map(</dt><dd><dl class="simple">
<dt>addFeatureFilterFromResource(</dt><dd><p>_,
“com/twitter/timelines/prediction/common/aggregates/real_time/aggregates_to_drop.txt”))</p>
</dd>
</dl>
</dd>
</dl>
<p>val StagingAggregateGroups = ProdAggregateGroups.map(createStagingGroup)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Contains the fully typed aggregate groups from which important</p></li>
<li><p>values can be derived e.g. the features to be computed, halflives etc.</p></li>
</ul>
<p><a href="#id49"><span class="problematic" id="id50">*</span></a>/</p>
</dd>
</dl>
<p>override val ProdAggregates = ProdAggregateGroups.flatMap(_.buildTypedAggregateGroups())</p>
<p>override val StagingAggregates = StagingAggregateGroups.flatMap(_.buildTypedAggregateGroups())</p>
<dl>
<dt>override val ProdCommonAggregates = ProdAggregates</dt><dd><p>.filter(_.keysToAggregate == Set(SharedFeatures.USER_ID))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>This defines the set of selected features from a candidate</p></li>
<li><p>that we’d like to send to the served features cache by TLM.</p></li>
<li><p>These should include  interesting and necessary features that</p></li>
<li><p>cannot be extracted from LogEvents only by the real-time aggregates</p></li>
<li><p>job. If you are adding new AggregateGroups requiring TLM-side</p></li>
<li><p>candidate features, make sure to add them here.</p></li>
</ul>
<p><a href="#id51"><span class="problematic" id="id52">*</span></a>/</p>
</dd>
<dt>val candidateFeaturesToCache: Set[Feature[_]] = Set(</dt><dd><p>TimelinesSharedFeatures.SOURCE_AUTHOR_ID,
RecapFeatures.HASHTAGS,
RecapFeatures.MENTIONED_SCREEN_NAMES,
RecapFeatures.URL_DOMAINS</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>This config should only be used to access the aggregate features constructed by the</p></li>
<li><p>aggregation config, and not for implementing an online real-time aggregates job.</p></li>
</ul>
<p><a href="#id53"><span class="problematic" id="id54">*</span></a>/</p>
</dd>
<dt>object TimelinesOnlineAggregationFeaturesOnlyConfig</dt><dd><blockquote>
<div><p>extends TimelinesOnlineAggregationDefinitionsTrait {</p>
</div></blockquote>
<dl class="simple">
<dt>private[real_time] case class DummyAggregateSource(name: String, timestampFeature: Feature[JLong])</dt><dd><p>extends AggregateSource</p>
</dd>
</dl>
<p>private[real_time] case class DummyAggregateStore(name: String) extends AggregateStore</p>
<dl class="simple">
<dt>override lazy val inputSource = DummyAggregateSource(</dt><dd><p>name = “timelines_rta”,
timestampFeature = SharedFeatures.TIMESTAMP</p>
</dd>
</dl>
<p>)
override lazy val ProductionStore = DummyAggregateStore(“timelines_rta”)
override lazy val StagingStore = DummyAggregateStore(“timelines_rta”)</p>
<p>override lazy val AggregatesToCompute = ProdAggregates ++ StagingAggregates</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/src/scala/com/twitter/timelines/prediction/common/aggregates/real_time/TimelinesOnlineAggregationConfigBase.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>