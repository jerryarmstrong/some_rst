<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../" id="documentation_options" src="../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.simclusters_v2.scalding</p>
<p>import com.twitter.dal.client.dataset.KeyValDALDataset
import com.twitter.logging.Logger
import com.twitter.scalding._
import com.twitter.scalding.typed.TypedPipe
import com.twitter.scalding_internal.dalv2.DAL
import com.twitter.scalding_internal.dalv2.DALWrite._
import com.twitter.scalding_internal.dalv2.remote_access.{ExplicitLocation, ProcAtla}
import com.twitter.scalding_internal.job.analytics_batch.{</p>
<blockquote>
<div><p>AnalyticsBatchExecution,
AnalyticsBatchExecutionArgs,
BatchDescription,
BatchFirstTime,
BatchIncrement,
TwitterScheduledExecutionApp</p>
</div></blockquote>
<p>}
import com.twitter.scalding_internal.multiformat.format.keyval.KeyVal
import com.twitter.simclusters_v2.common.ModelVersions
import com.twitter.simclusters_v2.hdfs_sources._
import com.twitter.simclusters_v2.scalding.common.Util
import com.twitter.simclusters_v2.thriftscala.{ClustersUserIsKnownFor, UserToKnownForClusterScores}
import com.twitter.usersource.snapshot.flat.UsersourceFlatScalaDataset
import com.twitter.usersource.snapshot.flat.thriftscala.FlatUser
import java.util.TimeZone</p>
<dl>
<dt>object KnownForSources {</dt><dd><p>implicit val tz: TimeZone = DateOps.UTC
implicit val parser: DateParser = DateParser.default</p>
<dl>
<dt>def readDALDataset(</dt><dd><p>d: KeyValDALDataset[KeyVal[Long, ClustersUserIsKnownFor]],
noOlderThan: Duration,
modelVersionToKeep: String</p>
</dd>
<dt>): TypedPipe[(Long, Array[(Int, Float)])] = {</dt><dd><dl>
<dt>fromKeyVal(</dt><dd><dl class="simple">
<dt>DAL</dt><dd><p>.readMostRecentSnapshotNoOlderThan(d, noOlderThan)
.withRemoteReadPolicy(ExplicitLocation(ProcAtla))
.toTypedPipe,</p>
</dd>
</dl>
<p>modelVersionToKeep</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def fromKeyVal(</dt><dd><p>in: TypedPipe[KeyVal[Long, ClustersUserIsKnownFor]],
modelVersionToKeep: String</p>
</dd>
<dt>): TypedPipe[(Long, Array[(Int, Float)])] = {</dt><dd><dl>
<dt>in.collect {</dt><dd><dl>
<dt>case KeyVal(userId, knownForClusters)</dt><dd><blockquote>
<div><p>if knownForClusters.knownForModelVersion == modelVersionToKeep =&gt;</p>
</div></blockquote>
<dl>
<dt>(</dt><dd><p>userId,
knownForClusters.clusterIdToScores.toArray</p>
<blockquote>
<div><dl class="simple">
<dt>.map {</dt><dd><dl class="simple">
<dt>case (clusterId, scores) =&gt;</dt><dd><p>(clusterId, scores.knownForScore.getOrElse(0.0).toFloat)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.sortBy(-_._2))</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def toKeyVal(</dt><dd><p>in: TypedPipe[(Long, Array[(Int, Float)])],
modelVersion: String</p>
</dd>
<dt>): TypedPipe[KeyVal[Long, ClustersUserIsKnownFor]] = {</dt><dd><dl>
<dt>in.map {</dt><dd><dl>
<dt>case (userId, clustersArray) =&gt;</dt><dd><dl class="simple">
<dt>val mappedClusters = clustersArray.map {</dt><dd><dl class="simple">
<dt>case (clusterId, score) =&gt;</dt><dd><p>(clusterId, UserToKnownForClusterScores(Some(score)))</p>
</dd>
</dl>
</dd>
</dl>
<p>}.toMap
KeyVal(userId, ClustersUserIsKnownFor(modelVersion, mappedClusters))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val knownFor_20M_Dec11_145K: TypedPipe[(Long, Array[(Int, Float)])] = readDALDataset(</dt><dd><p>SimclustersV2KnownFor20M145KDec11ScalaDataset,
Days(30),
ModelVersions.Model20M145KDec11</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>val knownFor_20M_145K_updated: TypedPipe[(Long, Array[(Int, Float)])] = readDALDataset(</dt><dd><p>SimclustersV2KnownFor20M145KUpdatedScalaDataset,
Days(30),
ModelVersions.Model20M145KUpdated</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>val clusterToKnownFor_20M_Dec11_145K: TypedPipe[(Int, List[(Long, Float)])] =</dt><dd><dl class="simple">
<dt>transpose(</dt><dd><p>knownFor_20M_Dec11_145K</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val clusterToKnownFor_20M_145K_updated: TypedPipe[(Int, List[(Long, Float)])] =</dt><dd><dl class="simple">
<dt>transpose(</dt><dd><p>knownFor_20M_145K_updated</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>private val log = Logger()</p>
<dl>
<dt>def readKnownFor(textFile: String): TypedPipe[(Long, Array[(Int, Float)])] = {</dt><dd><dl>
<dt>TypedPipe</dt><dd><p>.from(TextLine(textFile))
.flatMap { str =&gt;</p>
<blockquote>
<div><dl>
<dt>if (!str.startsWith(“#”)) {</dt><dd><dl>
<dt>try {</dt><dd><p>val tokens = str.trim.split(”\s+”)
val res = Array.newBuilder[(Int, Float)]
val userId = tokens(0).toLong
for (i &lt;- 1 until tokens.length) {</p>
<blockquote>
<div><p>val Array(cIdStr, scoreStr) = tokens(i).split(“:”)
val clusterId = cIdStr.toInt
val score = scoreStr.toFloat
val newEntry = (clusterId, score)
res += newEntry</p>
</div></blockquote>
<p>}
val result = res.result
if (result.nonEmpty) {</p>
<blockquote>
<div><p>Some((userId, res.result()))</p>
</div></blockquote>
<p>} else None</p>
</dd>
<dt>} catch {</dt><dd><dl>
<dt>case ex: Throwable =&gt;</dt><dd><dl class="simple">
<dt>log.warning(</dt><dd><dl class="simple">
<dt>s”Error while loading knownFor from $textFile for line &lt;$str&gt;: “ +</dt><dd><p>ex.getMessage</p>
</dd>
</dl>
</dd>
</dl>
<p>)
None</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>} else None</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def stringifyKnownFor(</dt><dd><p>input: TypedPipe[(Long, Array[(Int, Float)])]</p>
</dd>
<dt>): TypedPipe[(Long, String)] = {</dt><dd><dl class="simple">
<dt>input.mapValues { arr =&gt;</dt><dd><p>arr.map { case (clusterId, score) =&gt; “%d:%.2g”.format(clusterId, score) }.mkString(”t”)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def writeKnownForTypedTsv(</dt><dd><p>input: TypedPipe[(Long, Array[(Int, Float)])],
outputDir: String</p>
</dd>
<dt>): Execution[Unit] = {</dt><dd><p>stringifyKnownFor(input).writeExecution(TypedTsv(outputDir))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def makeKnownForTypedTsv(</dt><dd><p>input: TypedPipe[(Long, Array[(Int, Float)])],
outputDir: String</p>
</dd>
<dt>): Execution[TypedPipe[(Long, Array[(Int, Float)])]] = {</dt><dd><dl>
<dt>Execution.getMode.flatMap { mode =&gt;</dt><dd><dl class="simple">
<dt>try {</dt><dd><p>val dest = TextLine(outputDir)
dest.validateTaps(mode)
Execution.from(KnownForSources.readKnownFor(outputDir))</p>
</dd>
<dt>} catch {</dt><dd><dl class="simple">
<dt>case ivs: InvalidSourceException =&gt;</dt><dd><p>writeKnownForTypedTsv(input, outputDir).map { _ =&gt; input }</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def transpose(</dt><dd><p>userToCluster: TypedPipe[(Long, Array[(Int, Float)])]</p>
</dd>
<dt>): TypedPipe[(Int, List[(Long, Float)])] = {</dt><dd><dl>
<dt>userToCluster</dt><dd><dl>
<dt>.flatMap {</dt><dd><dl>
<dt>case (userId, clusterWeightPairs) =&gt;</dt><dd><dl class="simple">
<dt>clusterWeightPairs.map {</dt><dd><dl class="simple">
<dt>case (clusterId, weight) =&gt;</dt><dd><p>(clusterId, List(userId -&gt; weight))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.sumByKey
.toTypedPipe</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>/**
capesospy-v2 update –build_locally –start_cron known_for_to_mh </p>
<blockquote>
<div><p>src/scala/com/twitter/simclusters_v2/capesos_config/atla_proc.yaml
<a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</div></blockquote>
<p>object KnownForToMHBatch extends TwitterScheduledExecutionApp {</p>
<blockquote>
<div><p>import KnownForSources._</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A simple update function which updates the source by removing deactivated and suspended users.</p></li>
<li><p>This will be eventually replaced by a regular cluster updating method.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>def updateKnownForSource(</dt><dd><p>knownForSource: TypedPipe[(Long, ClustersUserIsKnownFor)],
userSource: TypedPipe[FlatUser]</p>
</dd>
<dt>)(</dt><dd><p>implicit uniqueID: UniqueID</p>
</dd>
<dt>): TypedPipe[(Long, ClustersUserIsKnownFor)] = {</dt><dd><p>val numValidUsers = Stat(“num_valid_users”)
val numInvalidUsers = Stat(“num_invalid_users”)
val numKnownForUsersLeft = Stat(“num_known_for_users_left”)
val numRemovedKnownForUsers = Stat(“num_removed_known_for_users”)</p>
<dl>
<dt>val validUsers =</dt><dd><dl>
<dt>userSource.flatMap {</dt><dd><dl>
<dt>case flatUser</dt><dd><blockquote>
<div><dl class="simple">
<dt>if !flatUser.deactivated.contains(true) &amp;&amp; !flatUser.suspended</dt><dd><p>.contains(true)
&amp;&amp; flatUser.id.nonEmpty =&gt;</p>
</dd>
</dl>
</div></blockquote>
<p>numValidUsers.inc()
flatUser.id</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>numInvalidUsers.inc()
None</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>knownForSource.leftJoin(validUsers.asKeys).flatMap {</dt><dd><dl class="simple">
<dt>case (userId, (clustersWithScore, Some(_))) =&gt;</dt><dd><p>numKnownForUsersLeft.inc()
Some((userId, clustersWithScore))</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>numRemovedKnownForUsers.inc()
None</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// this should happen before InterestedInFromKnownForBatch
private val firstTime: String = “2019-03-22”</p>
<p>private val batchIncrement: Duration = Days(7)</p>
<p>private val outputPath: String = InternalDataPaths.RawKnownForDec11Path</p>
<dl class="simple">
<dt>private val execArgs = AnalyticsBatchExecutionArgs(</dt><dd><p>batchDesc = BatchDescription(this.getClass.getName.replace(“$”, “”)),
firstTime = BatchFirstTime(RichDate(firstTime)),
lastTime = None,
batchIncrement = BatchIncrement(batchIncrement)</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>override def scheduledJob: Execution[Unit] =</dt><dd><dl>
<dt>AnalyticsBatchExecution(execArgs) { implicit dateRange =&gt;</dt><dd><dl>
<dt>Execution.withId { implicit uniqueId =&gt;</dt><dd><p>val numKnownForUsers = Stat(“num_known_for_users”)</p>
<dl>
<dt>val userSource =</dt><dd><dl class="simple">
<dt>DAL</dt><dd><p>.readMostRecentSnapshotNoOlderThan(UsersourceFlatScalaDataset, Days(7))
.toTypedPipe</p>
</dd>
</dl>
</dd>
<dt>val knownForData = DAL</dt><dd><dl class="simple">
<dt>.readMostRecentSnapshotNoOlderThan(</dt><dd><p>SimclustersV2RawKnownFor20M145KDec11ScalaDataset,
Days(30))</p>
</dd>
</dl>
<p>.toTypedPipe
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case KeyVal(userId, knownForClusters) =&gt;</dt><dd><p>numKnownForUsers.inc()
(userId, knownForClusters)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
<dt>val result = updateKnownForSource(knownForData, userSource).map {</dt><dd><dl class="simple">
<dt>case (userId, knownForClusters) =&gt;</dt><dd><p>KeyVal(userId, knownForClusters)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>Util.printCounters(</dt><dd><dl class="simple">
<dt>result.writeDALVersionedKeyValExecution(</dt><dd><p>dataset = SimclustersV2RawKnownFor20M145KDec11ScalaDataset,
pathLayout = D.Suffix(outputPath)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../_sources/src/scala/com/twitter/simclusters_v2/scalding/KnownForSources.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>