<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../" id="documentation_options" src="../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.simclusters_v2.scalding.evaluation</p>
<p>import com.twitter.scalding.{Execution, TypedPipe, UniqueID}
import com.twitter.simclusters_v2.thriftscala.{</p>
<blockquote>
<div><p>CandidateTweet,
CandidateTweets,
ReferenceTweet,
ReferenceTweets,
TweetLabels</p>
</div></blockquote>
<p>}
import com.twitter.algebird.Aggregator.size
import com.twitter.scalding.typed.{CoGrouped, ValuePipe}
import com.twitter.util.TwitterDateFormat
import java.util.Calendar</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Statistics about the number of users who have engaged with tweets</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>case class UserEngagerCounts(</dt><dd><p>numDistinctTargetUsers: Long,
numDistinctLikeEngagers: Long,
numDistinctRetweetEngagers: Long)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Tweet side statistics, e.x. number of tweets, authors, etc.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>case class TweetStats(</dt><dd><p>numTweets: Long,
numDistinctTweets: Long,
numDistinctAuthors: Option[Long],
avgScore: Option[Double])</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Helper data container class for storing engagement counts</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
</dl>
<p>case class TweetEngagementCounts(like: Long, retweet: Long, click: Long, hasEngagement: Long)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Helper data container class for storing engagement rates</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
</dl>
<p>case class TweetEngagementRates(like: Double, retweet: Double, click: Double, hasEngagement: Double)</p>
<dl>
<dt>case class LabelCorrelations(</dt><dd><p>pearsonCoefficientForLikes: Double,
cosineSimilarityGlobal: Double,
cosineSimilarityPerUserAvg: Double) {
private val f = java.text.NumberFormat.getInstance
def format(): String = {</p>
<blockquote>
<div><dl class="simple">
<dt>Seq(</dt><dd><p>s”tPearson Coefficient: ${f.format(pearsonCoefficientForLikes)}”,
s”tCosine similarity: ${f.format(cosineSimilarityGlobal)}”,
s”tAverage cosine similarity for all users: ${f.format(cosineSimilarityPerUserAvg)}”</p>
</dd>
</dl>
<p>).mkString(”n”)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Helper tweet data container that can hold both the reference label engagements as well as the</p></li>
<li><p>recommendation algorithm’s scores. Helpful for evaluating joint data</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>case class LabeledTweet(</dt><dd><p>targetUserId: Long,
tweetId: Long,
authorId: Long,
labels: TweetLabels,
algorithmScore: Option[Double])</p>
</dd>
<dt>case class LabeledTweetsResults(</dt><dd><p>tweetStats: TweetStats,
userEngagerCounts: UserEngagerCounts,
tweetEngagementCounts: TweetEngagementCounts,
tweetEngagementRates: TweetEngagementRates,
labelCorrelations: Option[LabelCorrelations] = None) {
private val f = java.text.NumberFormat.getInstance</p>
<dl>
<dt>def format(title: String = “”): String = {</dt><dd><dl class="simple">
<dt>val str = Seq(</dt><dd><p>s”Number of tweets: ${f.format(tweetStats.numTweets)}”,
s”Number of distinct tweets: ${f.format(tweetStats.numDistinctTweets)}”,
s”Number of distinct users targeted: ${f.format(userEngagerCounts.numDistinctTargetUsers)}”,
s”Number of distinct authors: ${tweetStats.numDistinctAuthors.map(f.format).getOrElse(“N/A”)}”,
s”Average algorithm score of tweets: ${tweetStats.avgScore.map(f.format).getOrElse(“N/A”)}”,
s”Engager counts:”,
s”tNumber of users who liked tweets: ${f.format(userEngagerCounts.numDistinctLikeEngagers)}”,
s”tNumber of users who retweeted tweets: ${f.format(userEngagerCounts.numDistinctRetweetEngagers)}”,
s”Tweet engagement counts:”,
s”tNumber of Likes: ${f.format(tweetEngagementCounts.like)}”,
s”tNumber of Retweets: ${f.format(tweetEngagementCounts.retweet)}”,
s”tNumber of Clicks: ${f.format(tweetEngagementCounts.click)}”,
s”tNumber of tweets with any engagements: ${f.format(tweetEngagementCounts.hasEngagement)}”,
s”Tweet engagement rates:”,
s”tRate of Likes: ${f.format(tweetEngagementRates.like * 100)}%”,
s”tRate of Retweets: ${f.format(tweetEngagementRates.retweet * 100)}%”,
s”tRate of Clicks: ${f.format(tweetEngagementRates.click * 100)}%”,
s”tRate of any engagement: ${f.format(tweetEngagementRates.hasEngagement * 100)}%”</p>
</dd>
</dl>
<p>).mkString(”n”)</p>
<p>val correlations = labelCorrelations.map(”n” + _.format()).getOrElse(“”)</p>
<p>s”$titlen$str$correlations”</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class CandidateResults(tweetStats: TweetStats, numDistinctTargetUsers: Long) {</dt><dd><p>private val f = java.text.NumberFormat.getInstance</p>
<dl>
<dt>def format(title: String = “”): String = {</dt><dd><dl class="simple">
<dt>val str = Seq(</dt><dd><p>s”Number of tweets: ${f.format(tweetStats.numTweets)}”,
s”Number of distinct tweets: ${f.format(tweetStats.numDistinctTweets)}”,
s”Number of distinct users targeted: ${f.format(numDistinctTargetUsers)}”,
s”Number of distinct authors: ${tweetStats.numDistinctAuthors.map(f.format).getOrElse(“N/A”)}”,
s”Average algorithm score of tweets: ${tweetStats.avgScore.map(f.format).getOrElse(“N/A”)}”</p>
</dd>
</dl>
<p>).mkString(”n”)
s”$titlen$str”</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Helper class for evaluating a given candidate tweet set against a reference tweet set.</p></li>
<li><p>It provides aggregation evaluation metrics such as sum of engagements, rate of engagements, etc.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>object EvaluationMetricHelper {</dt><dd><dl class="simple">
<dt>private def toLong(bool: Boolean): Long = {</dt><dd><p>if (bool) 1L else 0L</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Core engagements are user actions that count towards core metrics, e.x. like, RT, etc</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>private def hasCoreEngagements(labels: TweetLabels): Boolean = {</dt><dd><p>labels.isRetweeted ||
labels.isLiked ||
labels.isQuoted ||
labels.isReplied</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Whether there are core engagements or click on the tweet</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>private def hasCoreEngagementsOrClick(labels: TweetLabels): Boolean = {</dt><dd><p>hasCoreEngagements(labels) || labels.isClicked</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Return outer join of reference tweets and candidate tweets, keyed by (targetUserId, tweetId).</p></li>
<li><p>The output of this can then be reused to fetch the inner join / left / right join,</p></li>
<li><p>without having to redo the expensive join</p></li>
<li></li>
<li><p>NOTE: Assumes the uniqueness of keys (i.e. (targetId, tweetId)). Make sure to dedup tweetIds</p></li>
<li><p>for each targetId, otherwise .join() will yield duplicate results.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>def outerJoinReferenceAndCandidate(</dt><dd><p>referencePipe: TypedPipe[ReferenceTweets],
candidatePipe: TypedPipe[CandidateTweets]</p>
</dd>
</dl>
<p>): CoGrouped[(Long, Long), (Option[ReferenceTweet], Option[CandidateTweet])] = {</p>
<blockquote>
<div><dl>
<dt>val references = referencePipe</dt><dd><dl>
<dt>.flatMap { refTweets =&gt;</dt><dd><dl class="simple">
<dt>refTweets.impressedTweets.map { refTweet =&gt;</dt><dd><p>((refTweets.targetUserId, refTweet.tweetId), refTweet)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>val candidates = candidatePipe</dt><dd><dl>
<dt>.flatMap { candTweets =&gt;</dt><dd><dl class="simple">
<dt>candTweets.recommendedTweets.map { candTweet =&gt;</dt><dd><p>((candTweets.targetUserId, candTweet.tweetId), candTweet)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>references.outerJoin(candidates).withReducers(50)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Convert reference tweets to labeled tweets. We do this so that we can re-use the common</p></li>
<li><p>metric calculations for labeled tweets on reference tweets</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>def getLabeledReference(referencePipe: TypedPipe[ReferenceTweets]): TypedPipe[LabeledTweet] = {</dt><dd><dl>
<dt>referencePipe</dt><dd><dl>
<dt>.flatMap { refTweets =&gt;</dt><dd><dl class="simple">
<dt>refTweets.impressedTweets.map { tweet =&gt;</dt><dd><p>// Reference tweets do not have scores
LabeledTweet(refTweets.targetUserId, tweet.tweetId, tweet.authorId, tweet.labels, None)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def getUniqueCount[T](pipe: TypedPipe[T])(implicit ord: scala.Ordering[T]): Execution[Long] = {</dt><dd><dl class="simple">
<dt>pipe.distinct</dt><dd><p>.aggregate(size)
.toOptionExecution
.map(_.getOrElse(0L))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def countUniqueEngagedUsersBy(</dt><dd><p>labeledTweetsPipe: TypedPipe[LabeledTweet],
f: TweetLabels =&gt; Boolean</p>
</dd>
<dt>): Execution[Long] = {</dt><dd><p>getUniqueCount[Long](labeledTweetsPipe.collect { case t if f(t.labels) =&gt; t.targetUserId })</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def countUniqueLabeledTargetUsers(labeledTweetsPipe: TypedPipe[LabeledTweet]): Execution[Long] = {</dt><dd><p>getUniqueCount[Long](labeledTweetsPipe.map(_.targetUserId))</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def countUniqueCandTargetUsers(candidatePipe: TypedPipe[CandidateTweets]): Execution[Long] = {</dt><dd><p>getUniqueCount[Long](candidatePipe.map(_.targetUserId))</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>def countUniqueLabeledAuthors(labeledTweetPipe: TypedPipe[LabeledTweet]): Execution[Long] = {</dt><dd><p>getUniqueCount[Long](labeledTweetPipe.map(_.authorId))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Helper function to calculate the basic engagement rates</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
<dt>def getEngagementRate(</dt><dd><p>basicStats: TweetStats,
engagementCount: TweetEngagementCounts</p>
</dd>
<dt>): TweetEngagementRates = {</dt><dd><p>val numTweets = basicStats.numTweets.toDouble
if (numTweets &lt;= 0) throw new IllegalArgumentException(“Invalid tweet counts”)
val likeRate = engagementCount.like / numTweets
val rtRate = engagementCount.retweet / numTweets
val clickRate = engagementCount.click / numTweets
val engagementRate = engagementCount.hasEngagement / numTweets
TweetEngagementRates(likeRate, rtRate, clickRate, engagementRate)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Helper function to calculate the basic stats for a pipe of candidate tweets</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>def getTweetStatsForCandidateExec(</dt><dd><p>candidatePipe: TypedPipe[CandidateTweets]</p>
</dd>
<dt>): Execution[TweetStats] = {</dt><dd><dl class="simple">
<dt>val pipe = candidatePipe.map { candTweets =&gt;</dt><dd><p>(candTweets.targetUserId, candTweets.recommendedTweets)</p>
</dd>
</dl>
<p>}.sumByKey // Dedup by targetId, in case there exists multiple entries.</p>
<p>val distinctTweetPipe = pipe.flatMap(_._2.map(_.tweetId)).distinct.aggregate(size)</p>
<dl>
<dt>val otherStats = pipe</dt><dd><dl class="simple">
<dt>.map {</dt><dd><dl class="simple">
<dt>case (uid, recommendedTweets) =&gt;</dt><dd><p>val scoreSum = recommendedTweets.flatMap(_.score).sum
(recommendedTweets.size.toLong, scoreSum)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.sum
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (numTweets, scoreSum) =&gt;</dt><dd><p>if (numTweets &lt;= 0) throw new IllegalArgumentException(“Invalid tweet counts”)
val avgScore = scoreSum / numTweets.toDouble
(numTweets, avgScore)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
<dt>ValuePipe</dt><dd><dl class="simple">
<dt>.fold(distinctTweetPipe, otherStats) {</dt><dd><dl class="simple">
<dt>case (numDistinctTweet, (numTweets, avgScore)) =&gt;</dt><dd><p>// no author side information for candidate tweets yet
TweetStats(numTweets, numDistinctTweet, None, Some(avgScore))</p>
</dd>
</dl>
</dd>
</dl>
<p>}.getOrElseExecution(TweetStats(0L, 0L, None, None))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Helper function to count the total number of engagements</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
<dt>def getLabeledEngagementCountExec(</dt><dd><p>labeledTweets: TypedPipe[LabeledTweet]</p>
</dd>
<dt>): Execution[TweetEngagementCounts] = {</dt><dd><dl>
<dt>labeledTweets</dt><dd><dl>
<dt>.map { labeledTweet =&gt;</dt><dd><p>val like = toLong(labeledTweet.labels.isLiked)
val retweet = toLong(labeledTweet.labels.isRetweeted)
val click = toLong(labeledTweet.labels.isClicked)
val hasEngagement = toLong(hasCoreEngagementsOrClick(labeledTweet.labels))</p>
<p>(like, retweet, click, hasEngagement)</p>
</dd>
</dl>
<p>}
.sum
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (like, retweet, click, hasEngagement) =&gt;</dt><dd><p>TweetEngagementCounts(like, retweet, click, hasEngagement)</p>
</dd>
</dl>
</div></blockquote>
<p>}
.getOrElseExecution(TweetEngagementCounts(0L, 0L, 0L, 0L))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Count the total number of unique users who have engaged with tweets</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
<dt>def getTargetUserStatsForLabeledTweetsExec(</dt><dd><p>labeledTweetsPipe: TypedPipe[LabeledTweet]</p>
</dd>
<dt>): Execution[UserEngagerCounts] = {</dt><dd><p>val numUniqueTargetUsersExec = countUniqueLabeledTargetUsers(labeledTweetsPipe)
val numUniqueLikeUsersExec =</p>
<blockquote>
<div><p>countUniqueEngagedUsersBy(labeledTweetsPipe, labels =&gt; labels.isLiked)</p>
</div></blockquote>
<dl>
<dt>val numUniqueRetweetUsersExec =</dt><dd><p>countUniqueEngagedUsersBy(labeledTweetsPipe, labels =&gt; labels.isRetweeted)</p>
</dd>
<dt>Execution</dt><dd><dl class="simple">
<dt>.zip(</dt><dd><p>numUniqueTargetUsersExec,
numUniqueLikeUsersExec,
numUniqueRetweetUsersExec</p>
</dd>
</dl>
<p>)
.map {</p>
<blockquote>
<div><dl>
<dt>case (numTarget, like, retweet) =&gt;</dt><dd><dl class="simple">
<dt>UserEngagerCounts(</dt><dd><p>numDistinctTargetUsers = numTarget,
numDistinctLikeEngagers = like,
numDistinctRetweetEngagers = retweet</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Helper function to calculate the basic stats for a pipe of labeled tweets.</p></li>
</ul>
<p><a href="#id29"><span class="problematic" id="id30">*</span></a>/</p>
</dd>
<dt>def getTweetStatsForLabeledTweetsExec(</dt><dd><p>labeledTweetPipe: TypedPipe[LabeledTweet]</p>
</dd>
<dt>): Execution[TweetStats] = {</dt><dd><p>val uniqueAuthorsExec = countUniqueLabeledAuthors(labeledTweetPipe)</p>
<dl>
<dt>val uniqueTweetExec =</dt><dd><p>labeledTweetPipe.map(_.tweetId).distinct.aggregate(size).getOrElseExecution(0L)</p>
</dd>
<dt>val scoresExec = labeledTweetPipe</dt><dd><p>.map { t =&gt; (t.targetUserId, (1, t.algorithmScore.getOrElse(0.0))) }
.sumByKey // Dedup by targetId, in case there exists multiple entries.
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (uid, (c1, c2)) =&gt;</dt><dd><p>(c1.toLong, c2)</p>
</dd>
</dl>
</div></blockquote>
<p>}
.sum
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (numTweets, scoreSum) =&gt;</dt><dd><p>if (numTweets &lt;= 0) throw new IllegalArgumentException(“Invalid tweet counts”)
val avgScore = scoreSum / numTweets.toDouble
(numTweets, Option(avgScore))</p>
</dd>
</dl>
</div></blockquote>
<p>}
.getOrElseExecution((0L, None))</p>
</dd>
<dt>Execution</dt><dd><p>.zip(uniqueAuthorsExec, uniqueTweetExec, scoresExec)
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (numDistinctAuthors, numUniqueTweets, (numTweets, avgScores)) =&gt;</dt><dd><p>TweetStats(numTweets, numUniqueTweets, Some(numDistinctAuthors), avgScores)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Print a update message to the stdout when a step is done.</p></li>
</ul>
<p><a href="#id31"><span class="problematic" id="id32">*</span></a>/</p>
</dd>
<dt>private def printOnCompleteMsg(stepDescription: String, startTimeMillis: Long): Unit = {</dt><dd><p>val formatDate = TwitterDateFormat(“yyyy-MM-dd hh:mm:ss”)
val now = Calendar.getInstance().getTime</p>
<p>val secondsSpent = (now.getTime - startTimeMillis) / 1000
println(</p>
<blockquote>
<div><dl class="simple">
<dt>s”- ${formatDate.format(now)}tStep complete: $stepDescriptiont “ +</dt><dd><p>s”Time spent: ${secondsSpent / 60}m${secondsSpent % 60}s”</p>
</dd>
</dl>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Calculate the metrics of a pipe of [[CandidateTweets]]</p></li>
</ul>
<p><a href="#id33"><span class="problematic" id="id34">*</span></a>/</p>
</dd>
<dt>private def getEvaluationResultsForCandidates(</dt><dd><p>candidatePipe: TypedPipe[CandidateTweets]</p>
</dd>
<dt>): Execution[CandidateResults] = {</dt><dd><p>val tweetStatsExec = getTweetStatsForCandidateExec(candidatePipe)
val numDistinctTargetUsersExec = countUniqueCandTargetUsers(candidatePipe)</p>
<dl>
<dt>Execution</dt><dd><p>.zip(tweetStatsExec, numDistinctTargetUsersExec)
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (tweetStats, numDistinctTargetUsers) =&gt;</dt><dd><p>CandidateResults(tweetStats, numDistinctTargetUsers)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Calculate the metrics of a pipe of [[LabeledTweet]]</p></li>
</ul>
<p><a href="#id35"><span class="problematic" id="id36">*</span></a>/</p>
</dd>
<dt>private def getEvaluationResultsForLabeledTweets(</dt><dd><p>labeledTweetPipe: TypedPipe[LabeledTweet],
getLabelCorrelations: Boolean = false</p>
</dd>
<dt>): Execution[LabeledTweetsResults] = {</dt><dd><p>val tweetStatsExec = getTweetStatsForLabeledTweetsExec(labeledTweetPipe)
val userStatsExec = getTargetUserStatsForLabeledTweetsExec(labeledTweetPipe)
val engagementCountExec = getLabeledEngagementCountExec(labeledTweetPipe)</p>
<dl>
<dt>val correlationsExec = if (getLabelCorrelations) {</dt><dd><dl>
<dt>Execution</dt><dd><dl class="simple">
<dt>.zip(</dt><dd><p>LabelCorrelationsHelper.pearsonCoefficientForLike(labeledTweetPipe),
LabelCorrelationsHelper.cosineSimilarityForLike(labeledTweetPipe),
LabelCorrelationsHelper.cosineSimilarityForLikePerUser(labeledTweetPipe)</p>
</dd>
<dt>).map {</dt><dd><dl class="simple">
<dt>case (pearsonCoeff, globalCos, avgCos) =&gt;</dt><dd><p>Some(LabelCorrelations(pearsonCoeff, globalCos, avgCos))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
<dt>} else {</dt><dd><p>ValuePipe(None).getOrElseExecution(None) // Empty pipe with a None value</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>Execution</dt><dd><p>.zip(tweetStatsExec, engagementCountExec, userStatsExec, correlationsExec)
.map {</p>
<blockquote>
<div><dl>
<dt>case (tweetStats, engagementCount, engagerCount, correlationsOpt) =&gt;</dt><dd><p>val engagementRate = getEngagementRate(tweetStats, engagementCount)
LabeledTweetsResults(</p>
<blockquote>
<div><p>tweetStats,
engagerCount,
engagementCount,
engagementRate,
correlationsOpt)</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def runAllEvalForCandidates(</dt><dd><p>candidatePipe: TypedPipe[CandidateTweets],
outerJoinPipe: TypedPipe[((Long, Long), (Option[ReferenceTweet], Option[CandidateTweet]))]</p>
</dd>
<dt>): Execution[(CandidateResults, CandidateResults)] = {</dt><dd><p>val t0 = System.currentTimeMillis()</p>
<dl>
<dt>val candidateNotInIntersectionPipe =</dt><dd><dl>
<dt>outerJoinPipe</dt><dd><dl class="simple">
<dt>.collect {</dt><dd><p>case ((targetUserId, _), (None, Some(candTweet))) =&gt; (targetUserId, Seq(candTweet))</p>
</dd>
</dl>
<p>}
.sumByKey
.map { case (targetUserId, candTweets) =&gt; CandidateTweets(targetUserId, candTweets) }
.forceToDisk</p>
</dd>
</dl>
</dd>
<dt>Execution</dt><dd><dl class="simple">
<dt>.zip(</dt><dd><p>getEvaluationResultsForCandidates(candidatePipe),
getEvaluationResultsForCandidates(candidateNotInIntersectionPipe)</p>
</dd>
</dl>
<p>).onComplete(_ =&gt; printOnCompleteMsg(“runAllEvalForCandidates()”, t0))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def runAllEvalForIntersection(</dt><dd><p>outerJoinPipe: TypedPipe[((Long, Long), (Option[ReferenceTweet], Option[CandidateTweet]))]</p>
</dd>
<dt>)(</dt><dd><p>implicit uniqueID: UniqueID</p>
</dd>
<dt>): Execution[(LabeledTweetsResults, LabeledTweetsResults, LabeledTweetsResults)] = {</dt><dd><p>val t0 = System.currentTimeMillis()
val intersectionTweetsPipe = outerJoinPipe.collect {</p>
<blockquote>
<div><dl class="simple">
<dt>case ((targetUserId, tweetId), (Some(refTweet), Some(candTweet))) =&gt;</dt><dd><p>LabeledTweet(targetUserId, tweetId, refTweet.authorId, refTweet.labels, candTweet.score)</p>
</dd>
</dl>
</div></blockquote>
<p>}.forceToDisk</p>
<p>val likedTweetsPipe = intersectionTweetsPipe.filter(_.labels.isLiked)
val notLikedTweetsPipe = intersectionTweetsPipe.filter(!_.labels.isLiked)</p>
<dl>
<dt>Execution</dt><dd><dl class="simple">
<dt>.zip(</dt><dd><p>getEvaluationResultsForLabeledTweets(intersectionTweetsPipe, getLabelCorrelations = true),
getEvaluationResultsForLabeledTweets(likedTweetsPipe),
getEvaluationResultsForLabeledTweets(notLikedTweetsPipe)</p>
</dd>
</dl>
<p>).onComplete(_ =&gt; printOnCompleteMsg(“runAllEvalForIntersection()”, t0))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def runAllEvalForReferences(</dt><dd><p>referencePipe: TypedPipe[ReferenceTweets],
outerJoinPipe: TypedPipe[((Long, Long), (Option[ReferenceTweet], Option[CandidateTweet]))]</p>
</dd>
<dt>): Execution[(LabeledTweetsResults, LabeledTweetsResults)] = {</dt><dd><p>val t0 = System.currentTimeMillis()
val labeledReferenceNotInIntersectionPipe =</p>
<blockquote>
<div><dl class="simple">
<dt>outerJoinPipe.collect {</dt><dd><dl class="simple">
<dt>case ((targetUserId, _), (Some(refTweet), None)) =&gt;</dt><dd><p>LabeledTweet(targetUserId, refTweet.tweetId, refTweet.authorId, refTweet.labels, None)</p>
</dd>
</dl>
</dd>
</dl>
<p>}.forceToDisk</p>
</div></blockquote>
<dl>
<dt>Execution</dt><dd><dl class="simple">
<dt>.zip(</dt><dd><p>getEvaluationResultsForLabeledTweets(getLabeledReference(referencePipe)),
getEvaluationResultsForLabeledTweets(labeledReferenceNotInIntersectionPipe)</p>
</dd>
</dl>
<p>).onComplete(_ =&gt; printOnCompleteMsg(“runAllEvalForReferences()”, t0))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def runAllEvaluations(</dt><dd><p>referencePipe: TypedPipe[ReferenceTweets],
candidatePipe: TypedPipe[CandidateTweets]</p>
</dd>
<dt>)(</dt><dd><p>implicit uniqueID: UniqueID</p>
</dd>
<dt>): Execution[String] = {</dt><dd><p>val t0 = System.currentTimeMillis()</p>
<p>// Force everything to disk to maximize data re-use
Execution</p>
<blockquote>
<div><dl>
<dt>.zip(</dt><dd><p>referencePipe.forceToDiskExecution,
candidatePipe.forceToDiskExecution</p>
</dd>
<dt>).flatMap {</dt><dd><dl>
<dt>case (referenceDiskPipe, candidateDiskPipe) =&gt;</dt><dd><dl>
<dt>outerJoinReferenceAndCandidate(referenceDiskPipe, candidateDiskPipe).forceToDiskExecution</dt><dd><dl>
<dt>.flatMap { outerJoinPipe =&gt;</dt><dd><p>val referenceResultsExec = runAllEvalForReferences(referenceDiskPipe, outerJoinPipe)
val intersectionResultsExec = runAllEvalForIntersection(outerJoinPipe)
val candidateResultsExec = runAllEvalForCandidates(candidateDiskPipe, outerJoinPipe)</p>
<dl>
<dt>Execution</dt><dd><dl>
<dt>.zip(</dt><dd><p>referenceResultsExec,
intersectionResultsExec,
candidateResultsExec</p>
</dd>
<dt>).map {</dt><dd><dl>
<dt>case (</dt><dd><blockquote>
<div><p>(allReference, referenceNotInIntersection),
(allIntersection, intersectionLiked, intersectionNotLiked),
(allCandidate, candidateNotInIntersection)) =&gt;</p>
</div></blockquote>
<p>val timeSpent = (System.currentTimeMillis() - t0) / 1000
val resultStr = Seq(</p>
<blockquote>
<div><p>“===================================================”,
s”Evaluation complete. Took ${timeSpent / 60}m${timeSpent % 60}s “,
allReference.format(”—–Metrics for all Reference Tweets—–“),
referenceNotInIntersection.format(</p>
<blockquote>
<div><p>“—–Metrics for Reference Tweets that are not in the intersection—–”</p>
</div></blockquote>
<p>),
allIntersection.format(”—–Metrics for all Intersection Tweets—–“),
intersectionLiked.format(”—–Metrics for Liked Intersection Tweets—–“),
intersectionNotLiked.format(</p>
<blockquote>
<div><p>“—–Metrics for not Liked Intersection Tweets—–“),</p>
</div></blockquote>
<p>allCandidate.format(”—–Metrics for all Candidate Tweets—–“),
candidateNotInIntersection.format(</p>
<blockquote>
<div><p>“—–Metrics for Candidate Tweets that are not in the intersection—–”</p>
</div></blockquote>
<p>),
“===================================================n”</p>
</div></blockquote>
<p>).mkString(”n”)
println(resultStr)
resultStr</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.onComplete(_ =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>printOnCompleteMsg(</dt><dd><p>“Evaluation complete. Check stdout or output logs for results.”,
t0))</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../_sources/src/scala/com/twitter/simclusters_v2/scalding/evaluation/EvaluationMetricHelper.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>