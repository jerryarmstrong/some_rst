<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../" id="documentation_options" src="../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.simclusters_v2.scalding.offline_tweets</p>
<p>import com.twitter.algebird.Aggregator.size
import com.twitter.finagle.mtls.authentication.ServiceIdentifier
import com.twitter.scalding.typed.TypedPipe
import com.twitter.scalding.Args
import com.twitter.scalding.DateOps
import com.twitter.scalding.DateParser
import com.twitter.scalding.DateRange
import com.twitter.scalding.Days
import com.twitter.scalding.Duration
import com.twitter.scalding.Execution
import com.twitter.scalding.Hours
import com.twitter.scalding.RichDate
import com.twitter.scalding.TypedTsv
import com.twitter.scalding.UniqueID
import com.twitter.scalding_internal.dalv2.DALWrite.D
import com.twitter.scalding_internal.dalv2.DALWrite.WriteExtension
import com.twitter.scalding_internal.multiformat.format.keyval.KeyVal
import com.twitter.simclusters_v2.common.Timestamp
import com.twitter.simclusters_v2.common.TweetId
import com.twitter.simclusters_v2.hdfs_sources.DataPaths
import com.twitter.simclusters_v2.hdfs_sources.OfflineClusterTopMediaTweets20M145K2020ScalaDataset
import com.twitter.simclusters_v2.scalding.common.LogFavBasedPersistentTweetEmbeddingMhExportSource
import com.twitter.simclusters_v2.scalding.common.Util
import com.twitter.simclusters_v2.scalding.embedding.common.ExternalDataSources
import com.twitter.simclusters_v2.thriftscala.DayPartitionedClusterId
import com.twitter.simclusters_v2.thriftscala.PersistentSimClustersEmbedding
import com.twitter.simclusters_v2.thriftscala.TweetWithScore
import com.twitter.simclusters_v2.thriftscala.TweetsWithScore
import com.twitter.snowflake.id.SnowflakeId
import com.twitter.tweetsource.common.thriftscala.MediaType
import com.twitter.tweetsource.common.thriftscala.UnhydratedFlatTweet
import com.twitter.wtf.scalding.jobs.common.AdhocExecutionApp
import com.twitter.wtf.scalding.jobs.common.ScheduledExecutionApp
import java.util.TimeZone
import java.text.SimpleDateFormat</p>
<p>object ClusterTopTweetsJob {</p>
<blockquote>
<div><dl class="simple">
<dt>def serviceIdentifier(zone: String, env: String): ServiceIdentifier = ServiceIdentifier(</dt><dd><p>role = “cassowary”,
service = “offline_cluster_top_media_tweets_20M_145K_2020”,
environment = env,
zone = zone</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>private def isMediaTweet(tweet: UnhydratedFlatTweet): Boolean = {</dt><dd><dl>
<dt>tweet.media.exists { mediaSeq =&gt;</dt><dd><dl class="simple">
<dt>mediaSeq.exists { e =&gt;</dt><dd><p>e.mediaType.contains(MediaType.Video)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>private val dateFormatter = new SimpleDateFormat(“yyyy-MM-dd”)</p>
<dl>
<dt>def getClusterTopMediaTweets(</dt><dd><p>persistentEmbeddingPipe: TypedPipe[((TweetId, Timestamp), PersistentSimClustersEmbedding)],
tweetSourcePipe: TypedPipe[UnhydratedFlatTweet],
maxTweetsPerClusterPerPartition: Int</p>
</dd>
<dt>): TypedPipe[(DayPartitionedClusterId, Seq[(TweetId, Double)])] = {</dt><dd><dl class="simple">
<dt>val mediaTweetsPipe = tweetSourcePipe.collect {</dt><dd><p>case tweet if isMediaTweet(tweet) =&gt; (tweet.tweetId, ())</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val tweetEmbeddingsPipe: TypedPipe[(TweetId, (Int, Double))] = {</dt><dd><dl>
<dt>persistentEmbeddingPipe.collect {</dt><dd><dl>
<dt>case ((tweetId, timestamp), persistentEmbedding)</dt><dd><blockquote>
<div><p>if timestamp == 1L =&gt; // 1L is the longest L2 embedding</p>
</div></blockquote>
<dl class="simple">
<dt>persistentEmbedding.embedding.embedding.map { clusterWithScore =&gt;</dt><dd><p>(tweetId, (clusterWithScore.clusterId, clusterWithScore.score))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}.flatten</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>mediaTweetsPipe</dt><dd><p>.join(tweetEmbeddingsPipe)
.withReducers(2000)
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (tweetId, ((), (clusterId, score))) =&gt;</dt><dd><p>val dayPartition = dateFormatter.format(SnowflakeId(tweetId).time.inMilliseconds)
((clusterId, dayPartition), Seq((tweetId, score)))</p>
</dd>
</dl>
</div></blockquote>
<p>}
.sumByKey
.mapValues(_.sortBy(-_._2).take(maxTweetsPerClusterPerPartition))
.map { case ((cid, partition), values) =&gt; (DayPartitionedClusterId(cid, partition), values) }</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>// Convert to Manhattan compatible format
def toKeyVal(</p>
<blockquote>
<div><p>clusterTopTweets: TypedPipe[(DayPartitionedClusterId, Seq[(TweetId, Double)])],</p>
</div></blockquote>
<dl>
<dt>): TypedPipe[KeyVal[DayPartitionedClusterId, TweetsWithScore]] = {</dt><dd><dl class="simple">
<dt>clusterTopTweets.map {</dt><dd><dl class="simple">
<dt>case (key, tweetsWithScores) =&gt;</dt><dd><p>val thrift = tweetsWithScores.map { t =&gt; TweetWithScore(t._1, t._2) }
KeyVal(key, TweetsWithScore(thrift))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>/**</dt><dd><ul class="simple">
<li><p>Scheduled job. Runs every couple of hours (check the .yaml for exact cron schedule).</p></li>
<li><p>Reads 21 days of tweets, and the most recent persistent tweet embeddings from a Manhattan dump.</p></li>
<li><p>It outputs a clusterId-&gt; List[tweetId] index.</p></li>
</ul>
</dd>
</dl>
<p>capesospy-v2 update –build_locally –start_cron offline_cluster_top_media_tweets_20M_145K_2020 src/scala/com/twitter/simclusters_v2/capesos_config/atla_proc3.yaml</p>
<blockquote>
<div><p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</div></blockquote>
<dl>
<dt>object ClusterTopMediaTweets20M145K2020BatchJob extends ScheduledExecutionApp {</dt><dd><p>override def firstTime: RichDate = RichDate(“2021-08-29”)</p>
<p>override def batchIncrement: Duration = Hours(3)</p>
<dl class="simple">
<dt>override def runOnDateRange(</dt><dd><p>args: Args</p>
</dd>
<dt>)(</dt><dd><p>implicit dateRange: DateRange,
timeZone: TimeZone,
uniqueID: UniqueID</p>
</dd>
</dl>
<p>): Execution[Unit] = {</p>
<blockquote>
<div><p>// max public tweet has 21 days. read 1 day fewer go give some buffer
val lookbackDateRange = dateRange.prepend(Days(21))</p>
<dl>
<dt>val tweetSource: TypedPipe[UnhydratedFlatTweet] =</dt><dd><p>ExternalDataSources.flatTweetsSource(lookbackDateRange)</p>
</dd>
<dt>val persistentEmbeddingPipe: TypedPipe[</dt><dd><p>((TweetId, Timestamp), PersistentSimClustersEmbedding)</p>
</dd>
<dt>] =</dt><dd><dl>
<dt>TypedPipe.from(</dt><dd><dl class="simple">
<dt>new LogFavBasedPersistentTweetEmbeddingMhExportSource(</dt><dd><p>range = lookbackDateRange,
serviceIdentifier = ClusterTopTweetsJob.serviceIdentifier(args(“zone”), args(“env”))</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
</dl>
<p>val maxTweetsPerClusterPerPartition = 1200</p>
<dl class="simple">
<dt>val dailyClusterTopTweets = ClusterTopTweetsJob.getClusterTopMediaTweets(</dt><dd><p>persistentEmbeddingPipe,
tweetSource,
maxTweetsPerClusterPerPartition</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>val keyValPipe: TypedPipe[KeyVal[DayPartitionedClusterId, TweetsWithScore]] =</dt><dd><p>ClusterTopTweetsJob.toKeyVal(dailyClusterTopTweets)</p>
</dd>
<dt>keyValPipe</dt><dd><dl class="simple">
<dt>.writeDALVersionedKeyValExecution(</dt><dd><p>OfflineClusterTopMediaTweets20M145K2020ScalaDataset,
D.Suffix(DataPaths.OfflineClusterTopMediaTweets2020DatasetPath)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>/**
Adhoc debugging job. Uses Entity Embeddings dataset to infer user interests</p>
<p>./bazel bundle src/scala/com/twitter/simclusters_v2/scalding/offline_tweets/ &amp;&amp;scalding remote run </p>
<blockquote>
<div><blockquote>
<div><p>–main-class com.twitter.simclusters_v2.scalding.offline_tweets.AdhocClusterTopMediaTweetsJob –target src/scala/com/twitter/simclusters_v2/scalding/offline_tweets/:offline_cluster_top_media_tweets_20M_145K_2020-adhoc –user cassowary – –output_dir /scratch_user/cassowary/your_ldap –date 2021-08-30 –zone atla –env prod –email <a class="reference external" href="mailto:your_ldap&#37;&#52;&#48;twitter&#46;com">your_ldap<span>&#64;</span>twitter<span>&#46;</span>com</a></p>
</div></blockquote>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</div></blockquote>
<p>object AdhocClusterTopMediaTweetsJob extends AdhocExecutionApp {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Run some stat analysis on the results, such as the number of tweets in a cluster, tweet score</p></li>
<li><p>distributions, etc.</p></li>
<li></li>
<li><p>Ideally works on 1 day data only. If multiple days data are passed in, it’ll aggregate over</p></li>
<li><p>multiple days anyway</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>def analyzeClusterResults(</dt><dd><p>clusterTopTweets: TypedPipe[(DayPartitionedClusterId, Seq[(TweetId, Double)])]</p>
</dd>
</dl>
<p>): Execution[String] = {</p>
<blockquote>
<div><dl class="simple">
<dt>val tweetSizeExec = Util.printSummaryOfNumericColumn(</dt><dd><p>clusterTopTweets.map { case (_, tweets) =&gt; tweets.size },
columnName = Some(“Tweet size distribution of clusters”)</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>val scoreDistExec = Util.printSummaryOfNumericColumn(</dt><dd><p>clusterTopTweets.flatMap(_._2.map(_._2)),
columnName = Some(“Score distribution of the tweets”)</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>val numClustersExec =</dt><dd><p>clusterTopTweets.map(_._1._1).distinct.aggregate(size).getOrElseExecution(0L)</p>
</dd>
<dt>val numTweetsExec =</dt><dd><p>clusterTopTweets.flatMap(_._2.map(_._1)).distinct.aggregate(size).getOrElseExecution(0L)</p>
</dd>
<dt>Execution.zip(tweetSizeExec, scoreDistExec, numClustersExec, numTweetsExec).map {</dt><dd><dl class="simple">
<dt>case (tweetSizeDist, scoreDist, numClusters, numTweets) =&gt;</dt><dd><dl class="simple">
<dt>s”””</dt><dd><p><a href="#id7"><span class="problematic" id="id8">|</span></a>Number of unique tweets = $numTweets
<a href="#id9"><span class="problematic" id="id10">|</span></a>Number of clusters = $numClusters
<a href="#id11"><span class="problematic" id="id12">|</span></a>————————
<a href="#id13"><span class="problematic" id="id14">|</span></a>$tweetSizeDist
<a href="#id15"><span class="problematic" id="id16">|</span></a>————————
<a href="#id17"><span class="problematic" id="id18">|</span></a>$scoreDist
<a href="#id19"><span class="problematic" id="id20">|</span></a>”””.stripMargin</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>override def runOnDateRange(</dt><dd><p>args: Args</p>
</dd>
<dt>)(</dt><dd><p>implicit dateRange: DateRange,
timeZone: TimeZone,
uniqueID: UniqueID</p>
</dd>
<dt>): Execution[Unit] = {</dt><dd><p>val startTime = System.currentTimeMillis()
Execution.withArgs { args =&gt;</p>
<blockquote>
<div><dl>
<dt>Execution.getMode.flatMap { implicit mode =&gt;</dt><dd><dl class="simple">
<dt>implicit val dateRange: DateRange =</dt><dd><p>DateRange.parse(args.list(“date”))(DateOps.UTC, DateParser.default)</p>
</dd>
</dl>
<p>val outputDir = args(“output_dir”)</p>
<p>val maxTweetsPerCluster = 100</p>
<p>// max public tweet has 21 days. read 1 day fewer go give some buffer
val lookbackDateRange = dateRange.prepend(Days(21))</p>
<dl>
<dt>val tweetSource: TypedPipe[UnhydratedFlatTweet] =</dt><dd><p>ExternalDataSources.flatTweetsSource(lookbackDateRange)</p>
</dd>
<dt>val persistentEmbeddingPipe: TypedPipe[</dt><dd><p>((TweetId, Timestamp), PersistentSimClustersEmbedding)</p>
</dd>
<dt>] =</dt><dd><dl>
<dt>TypedPipe.from(</dt><dd><dl class="simple">
<dt>new LogFavBasedPersistentTweetEmbeddingMhExportSource(</dt><dd><p>range = lookbackDateRange,
serviceIdentifier = ClusterTopTweetsJob.serviceIdentifier(args(“zone”), args(“env”))</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
<dt>val results = ClusterTopTweetsJob.getClusterTopMediaTweets(</dt><dd><p>persistentEmbeddingPipe,
tweetSource,
maxTweetsPerCluster</p>
</dd>
</dl>
<p>)
analyzeClusterResults(TypedPipe.empty)</p>
<blockquote>
<div><dl>
<dt>.flatMap { distributions =&gt;</dt><dd><p>val timeTakenMin = (System.currentTimeMillis() - startTime) / 60000
val text =</p>
<blockquote>
<div><dl>
<dt>s”””</dt><dd><div class="line-block">
<div class="line">AdhocClusterTopMediaTweetsJob finished on: $dateRange.</div>
<div class="line">Time taken: $timeTakenMin minutes.</div>
<div class="line">maxTweetsPerCluster: $maxTweetsPerCluster.</div>
<div class="line">output_dir: $outputDir</div>
<div class="line"><br /></div>
<div class="line">$distributions</div>
</div>
</dd>
</dl>
<p>“””.stripMargin</p>
</div></blockquote>
<p>Util.sendEmail(text, “AdhocClusterTopMediaTweetsJob finished.”, args(“email”))</p>
<dl class="simple">
<dt>results</dt><dd><p>.writeExecution(TypedTsv(outputDir))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../_sources/src/scala/com/twitter/simclusters_v2/scalding/offline_tweets/ClusterTopMediaTweetsJob.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>