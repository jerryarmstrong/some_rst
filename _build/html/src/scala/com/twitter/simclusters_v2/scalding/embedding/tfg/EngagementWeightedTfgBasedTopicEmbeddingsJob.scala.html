<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../" id="documentation_options" src="../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.simclusters_v2.scalding.embedding.tfg</p>
<p>import com.twitter.dal.client.dataset.SnapshotDALDatasetBase
import com.twitter.ml.api.DataSetPipe
import com.twitter.ml.api.Feature.Continuous
import com.twitter.ml.api.constant.SharedFeatures
import com.twitter.ml.api.util.SRichDataRecord
import com.twitter.scalding.Execution
import com.twitter.scalding._
import com.twitter.scalding.typed.UnsortedGrouped
import com.twitter.scalding_internal.dalv2.DAL
import com.twitter.scalding_internal.dalv2.DALWrite.D
import com.twitter.scalding_internal.dalv2.DALWrite.WriteExtension
import com.twitter.scalding_internal.dalv2.remote_access.AllowCrossClusterSameDC
import com.twitter.scalding_internal.multiformat.format.keyval.KeyVal
import com.twitter.simclusters_v2.common.Country
import com.twitter.simclusters_v2.common.Language
import com.twitter.simclusters_v2.common.ModelVersions
import com.twitter.simclusters_v2.hdfs_sources.FavTfgTopicEmbeddings2020ScalaDataset
import com.twitter.simclusters_v2.hdfs_sources.UserTopicWeightedEmbeddingScalaDataset
import com.twitter.simclusters_v2.hdfs_sources.UserTopicWeightedEmbeddingParquetScalaDataset
import com.twitter.simclusters_v2.scalding.embedding.common.EmbeddingUtil
import com.twitter.simclusters_v2.scalding.embedding.common.ExternalDataSources
import com.twitter.simclusters_v2.thriftscala._
import com.twitter.timelines.data_processing.ml_util.aggregation_framework.conversion._
import com.twitter.timelines.prediction.common.aggregates.TimelinesAggregationConfig
import com.twitter.timelines.prediction.features.common.TimelinesSharedFeatures
import com.twitter.wtf.scalding.jobs.common.AdhocExecutionApp
import com.twitter.wtf.scalding.jobs.common.DateRangeExecutionApp
import com.twitter.wtf.scalding.jobs.common.ScheduledExecutionApp
import java.util.TimeZone</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Jobs to generate Fav-based engagement weighted Topic-Follow-Graph (TFG) topic embeddings</p></li>
<li><p>The job uses fav based TFG embeddings and fav based engagement to produce a new embedding</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>./bazel bundle …</p></li>
<li><p>scalding workflow upload –jobs src/scala/com/twitter/simclusters_v2/scalding/embedding/tfg:fav_weighted_user_topic_tfg_embeddings_adhoc_job –autoplay</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>object EngagementWeightedTfgBasedTopicEmbeddingsAdhocJob</dt><dd><blockquote>
<div><p>extends AdhocExecutionApp
with EngagementWeightedTfgBasedTopicEmbeddingsBaseJob {</p>
</div></blockquote>
<dl class="simple">
<dt>override val outputByFav =</dt><dd><p>“/user/cassowary/adhoc/manhattan_sequence_files/simclusters_v2_embedding/user_tfgembedding/by_fav”</p>
</dd>
<dt>override val parquetOutputByFav =</dt><dd><p>“/user/cassowary/adhoc/processed/simclusters_v2_embedding/user_tfgembedding/by_fav/snapshot”</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>./bazel bundle …</p></li>
<li><p>scalding workflow upload –jobs src/scala/com/twitter/simclusters_v2/scalding/embedding/tfg:fav_weighted_user_topic_tfg_embeddings_batch_job –autoplay</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>object EngagementWeightedTfgBasedTopicEmbeddingsScheduleJob</dt><dd><blockquote>
<div><p>extends ScheduledExecutionApp
with EngagementWeightedTfgBasedTopicEmbeddingsBaseJob {</p>
</div></blockquote>
<p>override val firstTime: RichDate = RichDate(“2021-10-03”)
override val batchIncrement: Duration = Days(1)
override val outputByFav =</p>
<blockquote>
<div><p>“/user/cassowary/manhattan_sequence_files/simclusters_v2_embedding/user_tfgembedding/by_fav”</p>
</div></blockquote>
<dl class="simple">
<dt>override val parquetOutputByFav =</dt><dd><p>“/user/cassowary/processed/simclusters_v2_embedding/user_tfgembedding/by_fav/snapshot”</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>trait EngagementWeightedTfgBasedTopicEmbeddingsBaseJob extends DateRangeExecutionApp {</p>
<blockquote>
<div><p>val outputByFav: String
val parquetOutputByFav: String</p>
<p>//root path to read aggregate data
private val aggregateFeatureRootPath =</p>
<blockquote>
<div><p>“/atla/proc2/user/timelines/processed/aggregates_v2”</p>
</div></blockquote>
<p>private val topKTopicsToKeep = 100</p>
<dl class="simple">
<dt>private val favContinuousFeature = new Continuous(</dt><dd><p>“user_topic_aggregate.pair.recap.engagement.is_favorited.any_feature.50.days.count”)</p>
</dd>
<dt>private val parquetDataSource: SnapshotDALDatasetBase[UserTopicWeightedEmbedding] =</dt><dd><p>UserTopicWeightedEmbeddingParquetScalaDataset</p>
</dd>
<dt>def sortedTake[K](m: Map[K, Double], keysToKeep: Int): Map[K, Double] = {</dt><dd><p>m.toSeq.sortBy { case (k, v) =&gt; -v }.take(keysToKeep).toMap</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>case class UserTopicEngagement(</dt><dd><p>userId: Long,
topicId: Long,
language: String,
country: String, //field is not used
favCount: Double) {
val userLanguageGroup: (Long, String) = (userId, language)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def prepareUserToTopicEmbedding(</dt><dd><p>favTfgTopicEmbeddings: TypedPipe[(Long, String, SimClustersEmbedding)],
userTopicEngagementCount: TypedPipe[UserTopicEngagement]</p>
</dd>
<dt>)(</dt><dd><p>implicit uniqueID: UniqueID</p>
</dd>
<dt>): TypedPipe[((Long, String), Map[Int, Double])] = {</dt><dd><p>val userTfgEmbeddingsStat = Stat(“User Tfg Embeddings Count”)
val userTopicTopKEngagementStat = Stat(“User Topic Top K engagement count”)
val userEngagementStat = Stat(“User engagement count”)
val tfgEmbeddingsStat = Stat(“TFG Embedding Map count”)</p>
<p>//get only top K topics
val userTopKTopicEngagementCount: TypedPipe[UserTopicEngagement] = userTopicEngagementCount</p>
<blockquote>
<div><p>.groupBy(_.userLanguageGroup)
.withReducers(499)
.withDescription(“select topK topics”)
.sortedReverseTake(topKTopicsToKeep)(Ordering.by(_.favCount))
.values
.flatten</p>
</div></blockquote>
<p>//(userId, language), totalCount
val userLanguageEngagementCount: UnsortedGrouped[(Long, String), Double] =</p>
<blockquote>
<div><dl>
<dt>userTopKTopicEngagementCount</dt><dd><dl class="simple">
<dt>.collect {</dt><dd><dl class="simple">
<dt>case UserTopicEngagement(userId, topicId, language, country, favCount) =&gt;</dt><dd><p>userTopicTopKEngagementStat.inc()
((userId, language), favCount)</p>
</dd>
</dl>
</dd>
</dl>
<p>}.sumByKey
.withReducers(499)
.withDescription(“fav count by user”)</p>
</dd>
</dl>
</div></blockquote>
<p>//(topicId, language), (userId, favWeight)
val topicUserWithNormalizedWeights: TypedPipe[((Long, String), (Long, Double))] =</p>
<blockquote>
<div><dl>
<dt>userTopKTopicEngagementCount</dt><dd><p>.groupBy(_.userLanguageGroup)
.join(userLanguageEngagementCount)
.withReducers(499)
.withDescription(“join userTopic and user EngagementCount”)
.collect {</p>
<blockquote>
<div><dl>
<dt>case ((userId, language), (engagementData, totalCount)) =&gt;</dt><dd><p>userEngagementStat.inc()
(</p>
<blockquote>
<div><p>(engagementData.topicId, engagementData.language),
(userId, engagementData.favCount / totalCount)</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>// (topicId, language), embeddingMap
val tfgEmbeddingsMap: TypedPipe[((Long, String), Map[Int, Double])] = favTfgTopicEmbeddings</p>
<blockquote>
<div><dl class="simple">
<dt>.map {</dt><dd><dl class="simple">
<dt>case (topicId, language, embedding) =&gt;</dt><dd><p>tfgEmbeddingsStat.inc()
((topicId, language), embedding.embedding.map(a =&gt; a.clusterId -&gt; a.score).toMap)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.withDescription(“covert sim cluster embedding to map”)</p>
</div></blockquote>
<p>// (userId, language), clusters
val newUserTfgEmbedding = topicUserWithNormalizedWeights</p>
<blockquote>
<div><p>.join(tfgEmbeddingsMap)
.withReducers(799)
.withDescription(“join user | topic | favWeight * embedding”)
.collect {</p>
<blockquote>
<div><dl class="simple">
<dt>case ((topicId, language), ((userId, favWeight), embeddingMap)) =&gt;</dt><dd><p>userTfgEmbeddingsStat.inc()
((userId, language), embeddingMap.mapValues(_ * favWeight))</p>
</dd>
</dl>
</div></blockquote>
<p>}
.sumByKey
.withReducers(799)
.withDescription(“aggregate embedding by user”)</p>
</div></blockquote>
<p>newUserTfgEmbedding.toTypedPipe</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def writeOutput(</dt><dd><p>newUserTfgEmbedding: TypedPipe[((Long, String), Map[Int, Double])],
outputPath: String,
parquetOutputPath: String,
modelVersion: String</p>
</dd>
<dt>)(</dt><dd><p>implicit uniqueID: UniqueID,
dateRange: DateRange</p>
</dd>
<dt>): Execution[Unit] = {</dt><dd><p>val outputRecordStat = Stat(“output record count”)
val output = newUserTfgEmbedding</p>
<blockquote>
<div><dl>
<dt>.map {</dt><dd><p>//language has been purposely ignored because the entire logic is based on the fact that
//user is mapped to a language. In future if a user is mapped to multiple languages then
//the final output needs to be keyed on (userId, language)
case ((userId, language), embeddingMap) =&gt;</p>
<blockquote>
<div><p>outputRecordStat.inc()
val clusterScores = embeddingMap.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (clusterId, score) =&gt;</dt><dd><p>clusterId -&gt; UserToInterestedInClusterScores(favScore = Some(score))</p>
</dd>
</dl>
</div></blockquote>
<p>}
KeyVal(userId, ClustersUserIsInterestedIn(modelVersion, clusterScores))</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>val keyValExec = output</dt><dd><p>.withDescription(“write output keyval dataset”)
.writeDALVersionedKeyValExecution(</p>
<blockquote>
<div><p>UserTopicWeightedEmbeddingScalaDataset,
D.Suffix(outputPath))</p>
</div></blockquote>
</dd>
<dt>val parquetExec = newUserTfgEmbedding</dt><dd><dl>
<dt>.map {</dt><dd><dl>
<dt>case ((userId, language), embeddingMap) =&gt;</dt><dd><dl class="simple">
<dt>val clusterScores = embeddingMap.map {</dt><dd><p>case (clusterId, score) =&gt; ClustersScore(clusterId, score)</p>
</dd>
</dl>
<p>}
UserTopicWeightedEmbedding(userId, clusterScores.toSeq)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.withDescription(“write output parquet dataset”)
.writeDALSnapshotExecution(</p>
<blockquote>
<div><p>parquetDataSource,
D.Daily,
D.Suffix(parquetOutputPath),
D.Parquet,
dateRange.end</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>Execution.zip(keyValExec, parquetExec).unit</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override def runOnDateRange(</dt><dd><p>args: Args</p>
</dd>
<dt>)(</dt><dd><p>implicit dateRange: DateRange,
timeZone: TimeZone,
uniqueID: UniqueID</p>
</dd>
</dl>
<p>): Execution[Unit] = {</p>
<blockquote>
<div><p>val end = dateRange.start
val start = end - Days(21)
val featureDateRange = DateRange(start, end - Millisecs(1))
val outputPath = args.getOrElse(“output_path”, outputByFav)
val parquetOutputPath = args.getOrElse(“parquet_output_path”, parquetOutputByFav)
val modelVersion = ModelVersions.Model20M145K2020</p>
<p>//define stats counter
val favTfgTopicEmbeddingsStat = Stat(“FavTfgTopicEmbeddings”)
val userTopicEngagementStat = Stat(“UserTopicEngagement”)
val userTopicsStat = Stat(“UserTopics”)
val userLangStat = Stat(“UserLanguage”)</p>
<p>//get fav based tfg embeddings
//topic can have different languages and the clusters will be different
//current logic is to filter based on user language
// topicId, lang, embedding
val favTfgTopicEmbeddings: TypedPipe[(Long, String, SimClustersEmbedding)] = DAL</p>
<blockquote>
<div><p>.readMostRecentSnapshot(FavTfgTopicEmbeddings2020ScalaDataset, featureDateRange)
.withRemoteReadPolicy(AllowCrossClusterSameDC)
.toTypedPipe
.collect {</p>
<blockquote>
<div><dl>
<dt>case KeyVal(</dt><dd><blockquote>
<div><dl class="simple">
<dt>SimClustersEmbeddingId(</dt><dd><p>embedType,
modelVersion,
InternalId.LocaleEntityId(LocaleEntityId(entityId, language))),</p>
</dd>
</dl>
<p>embedding) =&gt;</p>
</div></blockquote>
<p>favTfgTopicEmbeddingsStat.inc()
(entityId, language, embedding)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>/*
Ideally, if the timeline aggregate framework provided data with breakdown by language,
it could have been joined with (topic, language) embedding. Since, it is not possible
we fetch the language of the user from other sources.
This returns language for the user so that it could be joined with (topic, language) embedding.
<cite>userSource</cite> returns 1 language per user
<cite>inferredUserConsumedLanguageSource</cite> returns multiple languages with confidence values</p>
<blockquote>
<div><p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</div></blockquote>
<dl>
<dt>val userLangSource = ExternalDataSources.userSource</dt><dd><dl class="simple">
<dt>.map {</dt><dd><dl class="simple">
<dt>case (userId, (country, language)) =&gt;</dt><dd><p>userLangStat.inc()
(userId, (language, country))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>//get userid, topicid, favcount as aggregated dataset
//currently there is no way to get language breakdown from the timeline aggregate framework.
val userTopicEngagementPipe: DataSetPipe = AggregatesV2MostRecentFeatureSource(</p>
<blockquote>
<div><p>rootPath = aggregateFeatureRootPath,
storeName = “user_topic_aggregates”,
aggregates =</p>
<blockquote>
<div><p>Set(TimelinesAggregationConfig.userTopicAggregates).flatMap(_.buildTypedAggregateGroups()),</p>
</div></blockquote>
</div></blockquote>
<p>).read</p>
<dl>
<dt>val userTopicEngagementCount = userTopicEngagementPipe.records</dt><dd><dl>
<dt>.flatMap { record =&gt;</dt><dd><p>val sRichDataRecord = SRichDataRecord(record)
val userId: Long = sRichDataRecord.getFeatureValue(SharedFeatures.USER_ID)
val topicId: Long = sRichDataRecord.getFeatureValue(TimelinesSharedFeatures.TOPIC_ID)
val favCount: Double = sRichDataRecord</p>
<blockquote>
<div><p>.getFeatureValueOpt(favContinuousFeature).map(_.toDouble).getOrElse(0.0)</p>
</div></blockquote>
<p>userTopicEngagementStat.inc()
if (favCount &gt; 0) {</p>
<blockquote>
<div><p>List((userId, (topicId, favCount)))</p>
</div></blockquote>
<p>} else None</p>
</dd>
</dl>
<p>}.join(userLangSource)
.collect {</p>
<blockquote>
<div><dl class="simple">
<dt>case (userId, ((topicId, favCount), (language, country))) =&gt;</dt><dd><p>userTopicsStat.inc()
UserTopicEngagement(userId, topicId, language, country, favCount)</p>
</dd>
</dl>
</div></blockquote>
<p>}
.withDescription(“User Topic aggregated favcount”)</p>
</dd>
</dl>
<p>// combine user, topics, topic_embeddings
// and take weighted aggregate of the tfg embedding
val newUserTfgEmbedding =</p>
<blockquote>
<div><p>prepareUserToTopicEmbedding(favTfgTopicEmbeddings, userTopicEngagementCount)</p>
</div></blockquote>
<p>writeOutput(newUserTfgEmbedding, outputPath, parquetOutputPath, modelVersion)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../_sources/src/scala/com/twitter/simclusters_v2/scalding/embedding/tfg/EngagementWeightedTfgBasedTopicEmbeddingsJob.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>