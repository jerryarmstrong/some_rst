<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../" id="documentation_options" src="../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.simclusters_v2.scalding</p>
<p>import com.twitter.algebird.Aggregator
import com.twitter.algebird.Monoid
import com.twitter.scalding._
import com.twitter.scalding.commons.source.VersionedKeyValSource
import com.twitter.scalding.typed.TypedPipe
import com.twitter.scalding_internal.dalv2.DAL
import com.twitter.scalding_internal.dalv2.remote_access.ExplicitLocation
import com.twitter.scalding_internal.dalv2.remote_access.ProcAtla
import com.twitter.scalding_internal.job.TwitterExecutionApp
import com.twitter.scalding_internal.multiformat.format.keyval.KeyVal
import com.twitter.simclusters_v2.hdfs_sources.AdhocKeyValSources
import com.twitter.simclusters_v2.hdfs_sources.NormsAndCountsFixedPathSource
import com.twitter.simclusters_v2.hdfs_sources.ProducerNormsAndCountsScalaDataset
import com.twitter.simclusters_v2.hdfs_sources.SimclustersV2InterestedInScalaDataset
import com.twitter.simclusters_v2.hdfs_sources.UserAndNeighborsFixedPathSource
import com.twitter.simclusters_v2.hdfs_sources.UserUserNormalizedGraphScalaDataset
import com.twitter.simclusters_v2.scalding.BipartiteClusterEvaluationClasses._
import com.twitter.simclusters_v2.scalding.common.TypedRichPipe._
import com.twitter.simclusters_v2.scalding.common.Util
import com.twitter.simclusters_v2.thriftscala.BipartiteClusterQuality
import com.twitter.simclusters_v2.thriftscala.ClustersUserIsInterestedIn
import com.twitter.simclusters_v2.thriftscala.NeighborWithWeights
import com.twitter.simclusters_v2.thriftscala.NormsAndCounts
import com.twitter.simclusters_v2.thriftscala.UserAndNeighbors
import scala.collection.JavaConverters._</p>
<p>object BipartiteClusterEvaluation extends TwitterExecutionApp {</p>
<blockquote>
<div><p>implicit val tz: java.util.TimeZone = DateOps.UTC
implicit val dp = DateParser.default</p>
<dl>
<dt>private def getClusterL2Norms(</dt><dd><p>knownFor: TypedPipe[(Long, Array[(Int, Float)])]</p>
</dd>
<dt>): Execution[Map[Int, Float]] = {</dt><dd><dl>
<dt>knownFor</dt><dd><dl>
<dt>.flatMap {</dt><dd><dl>
<dt>case (_, clusterArray) =&gt;</dt><dd><dl class="simple">
<dt>clusterArray.map {</dt><dd><dl class="simple">
<dt>case (clusterId, score) =&gt;</dt><dd><p>Map(clusterId -&gt; score * score)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.sum
.getExecution
.map(_.mapValues { x =&gt; math.sqrt(x).toFloat })</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def l2NormalizeKnownFor(</dt><dd><p>knownFor: TypedPipe[(Long, Array[(Int, Float)])]</p>
</dd>
<dt>): Execution[TypedPipe[(Long, Array[(Int, Float)])]] = {</dt><dd><dl>
<dt>getClusterL2Norms(knownFor).map { clusterToNorms =&gt;</dt><dd><dl>
<dt>knownFor.mapValues { clusterScoresArray =&gt;</dt><dd><dl class="simple">
<dt>clusterScoresArray.map {</dt><dd><dl class="simple">
<dt>case (clusterId, score) =&gt;</dt><dd><p>(clusterId, score / clusterToNorms(clusterId))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>./bazel bundle src/scala/com/twitter/simclusters_v2/scalding:bp_cluster_evaluation &amp;&amp; </p></li>
<li><p>oscar hdfs –user frigate –host hadoopnest2.atla.twitter.com –bundle bp_cluster_evaluation </p></li>
<li><p>–tool com.twitter.simclusters_v2.scalding.BipartiteClusterEvaluation –screen –screen-detached </p></li>
<li><p>–tee logs/newBpQuality_updateUnnormalizedScores_interestedInUsing20190329Graph_evaluatedOn20190329Graph_run2 </p></li>
<li><p>– –normsAndCountsDir /user/frigate/your_ldap/producerNormsAndCounts_20190330 </p></li>
<li><p>–graphInputDir /user/frigate/your_ldap/user_user_normalized_graph_copiedFromAtlaProc_20190329 </p></li>
<li><p>–knownForDir /user/frigate/your_ldap/dirFor_updatedKnownFor20M_145K_dec11_usingSims20190127_unnormalizedInputScores/knownFor </p></li>
<li><p>–interestedInDir /user/frigate/your_ldap/dirFor_updatedKnownFor20M_145K_dec11_usingSims20190127_unnormalizedInputScores/interestedInUsing20190329Graph </p></li>
<li><p>–outgoingVolumesResultsDir /user/frigate/your_ldap/dirFor_updatedKnownFor20M_145K_dec11_usingSims20190127_unnormalizedInputScores/bpQualityForInterestedInUsing20190329On20190329Graph_outgoingVolumes </p></li>
<li><p>–incomingVolumesResultsDir /user/frigate/your_ldap/dirFor_updatedKnownFor20M_145K_dec11_usingSims20190127_unnormalizedInputScores/bpQualityForInterestedInUsing20190329On20190329Graph_incomingVolumes </p></li>
<li><p>–outputDir /user/frigate/your_ldap/dirFor_updatedKnownFor20M_145K_dec11_usingSims20190127_unnormalizedInputScores/bpQualityForInterestedInUsing20190329On20190329Graph_perCluster </p></li>
<li><p>–toEmailAddress <a class="reference external" href="mailto:your_ldap&#37;&#52;&#48;twitter&#46;com">your_ldap<span>&#64;</span>twitter<span>&#46;</span>com</a> –modelVersion 20M_145K_updated</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>override def job: Execution[Unit] = Execution.getConfigMode.flatMap {</dt><dd><dl>
<dt>case (config, mode) =&gt;</dt><dd><dl>
<dt>Execution.withId { implicit uniqueId =&gt;</dt><dd><p>val args = config.getArgs</p>
<dl>
<dt>val interestedIn = args.optional(“interestedInDir”) match {</dt><dd><dl>
<dt>case Some(dir) =&gt;</dt><dd><dl class="simple">
<dt>TypedPipe</dt><dd><p>.from(AdhocKeyValSources.interestedInSource(args(“interestedInDir”)))</p>
</dd>
</dl>
</dd>
<dt>case None =&gt;</dt><dd><dl>
<dt>DAL</dt><dd><dl class="simple">
<dt>.readMostRecentSnapshotNoOlderThan(</dt><dd><p>SimclustersV2InterestedInScalaDataset,
Days(20)</p>
</dd>
</dl>
<p>)
.withRemoteReadPolicy(ExplicitLocation(ProcAtla))
.toTypedPipe
.map {</p>
<blockquote>
<div><p>case KeyVal(key, value) =&gt; (key, value)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val inputKnownFor = args</dt><dd><p>.optional(“knownForDir”)
.map { location =&gt; KnownForSources.readKnownFor(location) }
.getOrElse(KnownForSources.knownFor_20M_Dec11_145K)</p>
</dd>
<dt>val modelVersion =</dt><dd><p>args.optional(“modelVersion”).getOrElse(“20M_145K_dec11”)</p>
</dd>
</dl>
<p>val useLogFavWeights = args.boolean(“useLogFavWeights”)</p>
<p>val shouldL2NormalizeKnownFor = args.boolean(“l2NormalizeKnownFor”)</p>
<p>val toEmailAddressOpt = args.optional(“toEmailAddress”)</p>
<dl class="simple">
<dt>val knownForExec = if (shouldL2NormalizeKnownFor) {</dt><dd><p>l2NormalizeKnownFor(inputKnownFor)</p>
</dd>
<dt>} else {</dt><dd><p>Execution.from(inputKnownFor)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val finalExec = knownForExec.flatMap { knownFor =&gt;</dt><dd><dl class="simple">
<dt>val graph = args.optional(“graphInputDir”) match {</dt><dd><dl class="simple">
<dt>case Some(dir) =&gt;</dt><dd><p>TypedPipe.from(UserAndNeighborsFixedPathSource(dir))</p>
</dd>
<dt>case None =&gt;</dt><dd><dl class="simple">
<dt>DAL</dt><dd><p>.readMostRecentSnapshotNoOlderThan(UserUserNormalizedGraphScalaDataset, Days(20))
.withRemoteReadPolicy(ExplicitLocation(ProcAtla))
.toTypedPipe</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val producerNormsAndCounts = args.optional(“normsAndCountsDir”) match {</dt><dd><dl class="simple">
<dt>case Some(dir) =&gt;</dt><dd><p>TypedPipe.from(NormsAndCountsFixedPathSource(args(dir)))</p>
</dd>
<dt>case None =&gt;</dt><dd><dl class="simple">
<dt>DAL</dt><dd><p>.readMostRecentSnapshotNoOlderThan(ProducerNormsAndCountsScalaDataset, Days(20))
.withRemoteReadPolicy(ExplicitLocation(ProcAtla))
.toTypedPipe</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val clusterIncomingVolumesExec = loadOrMake(</dt><dd><p>computeClusterIncomingVolumes(knownFor, producerNormsAndCounts, useLogFavWeights),
modelVersion,
args(“incomingVolumesResultsDir”)</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>val resultsWithOutgoingVolumesExec = loadOrMake(</dt><dd><p>getResultsWithOutgoingVolumes(graph, interestedIn, useLogFavWeights),
modelVersion,
args(“outgoingVolumesResultsDir”)</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>val finalPerClusterResultsExec =</dt><dd><dl class="simple">
<dt>finalPerClusterResults(</dt><dd><p>knownFor,
interestedIn,
resultsWithOutgoingVolumesExec,
clusterIncomingVolumesExec)
.flatMap { pipe =&gt; loadOrMake(pipe, modelVersion, args(“outputDir”)) }</p>
</dd>
</dl>
</dd>
<dt>finalPerClusterResultsExec.flatMap { finalPerClusterResults =&gt;</dt><dd><p>val perClusterResults = finalPerClusterResults.values
val distributionResultsExec = getClusterResultsSummary(perClusterResults).map {</p>
<blockquote>
<div><dl class="simple">
<dt>case Some(summary) =&gt;</dt><dd><dl class="simple">
<dt>“Summary of results across clusters: n” +</dt><dd><p>Util.prettyJsonMapper.writeValueAsString(summary)</p>
</dd>
</dl>
</dd>
<dt>case _ =&gt;</dt><dd><p>“No summary of results! The cluster level results pipe must be empty!”</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl>
<dt>val overallResultsExec = perClusterResults.sum.toOptionExecution.map {</dt><dd><dl>
<dt>case Some(overallQuality) =&gt;</dt><dd><dl>
<dt>“Overall Quality: n” +</dt><dd><dl class="simple">
<dt>Util.prettyJsonMapper.writeValueAsString(</dt><dd><p>printableBipartiteQuality(overallQuality)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
<dt>case _ =&gt;</dt><dd><p>“No overall quality! The cluster level results pipe must be empty!”</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>Execution.zip(distributionResultsExec, overallResultsExec).map {</dt><dd><dl>
<dt>case (distResults, overallResults) =&gt;</dt><dd><dl>
<dt>toEmailAddressOpt.foreach { address =&gt;</dt><dd><dl class="simple">
<dt>Util.sendEmail(</dt><dd><p>distResults + “n” + overallResults,
“Bipartite cluster quality for “ + modelVersion,
address</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}
println(distResults + “n” + overallResults)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
Util.printCounters(finalExec)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getResultsWithOutgoingVolumes(</dt><dd><p>graph: TypedPipe[UserAndNeighbors],
interestedIn: TypedPipe[(Long, ClustersUserIsInterestedIn)],
useLogFavWeights: Boolean</p>
</dd>
<dt>): TypedPipe[(Int, BipartiteClusterQuality)] = {</dt><dd><dl>
<dt>graph</dt><dd><p>.map { un =&gt; (un.userId, un.neighbors) }
// should this be a leftJoin? For now, leaving it as an inner join. If in the future,
// we want to compare two approaches with very different coverages on interestedIn, this
// could become a problem.
.join(interestedIn)
.withReducers(4000)
.flatMap {</p>
<blockquote>
<div><dl class="simple">
<dt>case (userId, (neighbors, clusters)) =&gt;</dt><dd><p>getBIResultsFromSingleUser(userId, neighbors, clusters, useLogFavWeights)</p>
</dd>
</dl>
</div></blockquote>
<p>}
.sumByKey
.withReducers(600)
.map {</p>
<blockquote>
<div><dl>
<dt>case (clusterId, bir) =&gt;</dt><dd><dl>
<dt>(</dt><dd><p>clusterId,
BipartiteClusterQuality(</p>
<blockquote>
<div><p>inClusterFollowEdges = Some(bir.inClusterWeights.isFollowEdge),
inClusterFavEdges = Some(bir.inClusterWeights.isFavEdge),
favWtSumOfInClusterFollowEdges = Some(bir.inClusterWeights.favWtIfFollowEdge),
favWtSumOfInClusterFavEdges = Some(bir.inClusterWeights.favWtIfFavEdge),
outgoingFollowEdges = Some(bir.totalOutgoingVolumes.isFollowEdge),
outgoingFavEdges = Some(bir.totalOutgoingVolumes.isFavEdge),
favWtSumOfOutgoingFollowEdges = Some(bir.totalOutgoingVolumes.favWtIfFollowEdge),
favWtSumOfOutgoingFavEdges = Some(bir.totalOutgoingVolumes.favWtIfFavEdge),
interestedInSize = Some(bir.interestedInSize),
sampledEdges = Some(</p>
<blockquote>
<div><dl>
<dt>bir.edgeSample</dt><dd><p>.iterator()
.asScala
.toSeq
.map {</p>
<blockquote>
<div><p>case (edge, data) =&gt; makeThriftSampledEdge(edge, data)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getBIResultsFromSingleUser(</dt><dd><p>userId: Long,
neighbors: Seq[NeighborWithWeights],
clusters: ClustersUserIsInterestedIn,
useLogFavScores: Boolean</p>
</dd>
<dt>): List[(Int, BipartiteIntermediateResults)] = {</dt><dd><dl>
<dt>val neighborsToWeights = neighbors.map { neighborAndWeights =&gt;</dt><dd><dl class="simple">
<dt>val isFollowEdge = neighborAndWeights.isFollowed match {</dt><dd><p>case Some(true) =&gt; 1.0
case _ =&gt; 0.0</p>
</dd>
</dl>
<p>}
val favScore = if (useLogFavScores) {</p>
<blockquote>
<div><p>neighborAndWeights.logFavScore.getOrElse(0.0)</p>
</div></blockquote>
<p>} else neighborAndWeights.favScoreHalfLife100Days.getOrElse(0.0)
val isFavEdge = math.min(1, math.ceil(favScore))
neighborAndWeights.neighborId -&gt; Weights(</p>
<blockquote>
<div><p>isFollowEdge,
isFavEdge,
favScore * isFollowEdge,
favScore</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}.toMap</p>
<p>val outgoingVolumes = Monoid.sum(neighborsToWeights.values)(WeightsMonoid)</p>
<dl>
<dt>clusters.clusterIdToScores.toList.map {</dt><dd><dl>
<dt>case (clusterId, scoresStruct) =&gt;</dt><dd><dl>
<dt>val inClusterNeighbors =</dt><dd><dl class="simple">
<dt>(scoresStruct.usersBeingFollowed.getOrElse(Nil) ++</dt><dd><p>scoresStruct.usersThatWereFaved.getOrElse(Nil)).toSet</p>
</dd>
</dl>
</dd>
<dt>val edgesForSampling = inClusterNeighbors.flatMap { neighborId =&gt;</dt><dd><dl>
<dt>if (neighborsToWeights.contains(neighborId)) {</dt><dd><dl>
<dt>Some(</dt><dd><p>(userId, neighborId),
SampledEdgeData(</p>
<blockquote>
<div><p>neighborsToWeights(neighborId).favWtIfFollowEdge,
neighborsToWeights(neighborId).favWtIfFavEdge,
scoresStruct.followScore.getOrElse(0.0),
scoresStruct.favScore.getOrElse(0.0)</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>} else {</dt><dd><p>None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val inClusterWeights =</dt><dd><p>Monoid.sum(neighborsToWeights.filterKeys(inClusterNeighbors).values)(WeightsMonoid)</p>
</dd>
</dl>
<dl>
<dt>(</dt><dd><p>clusterId,
BipartiteIntermediateResults(</p>
<blockquote>
<div><p>inClusterWeights,
outgoingVolumes,
1,
samplerMonoid.build(edgesForSampling)</p>
</div></blockquote>
<p>))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def computeClusterIncomingVolumes(</dt><dd><p>knownFor: TypedPipe[(Long, Array[(Int, Float)])],
producerNormsAndCounts: TypedPipe[NormsAndCounts],
useLogFavWeights: Boolean</p>
</dd>
<dt>): TypedPipe[(Int, BipartiteClusterQuality)] = {</dt><dd><dl>
<dt>producerNormsAndCounts</dt><dd><p>.map { x =&gt; (x.userId, x) }
.join(knownFor)
.withReducers(100)
.flatMap {</p>
<blockquote>
<div><dl>
<dt>case (userId, (normsAndCounts, clusters)) =&gt;</dt><dd><dl>
<dt>clusters.map {</dt><dd><dl>
<dt>case (clusterId, _) =&gt;</dt><dd><dl class="simple">
<dt>val followerCount =</dt><dd><p>normsAndCounts.followerCount.getOrElse(0L).toDouble</p>
</dd>
</dl>
<p>val faverCount = normsAndCounts.faverCount.getOrElse(0L).toDouble
val favWtSumOfIncomingFollows = if (useLogFavWeights) {</p>
<blockquote>
<div><p>normsAndCounts.logFavWeightsOnFollowEdgesSum.getOrElse(0.0)</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>normsAndCounts.favWeightsOnFollowEdgesSum.getOrElse(0.0)</p>
</dd>
</dl>
<p>}
val favWtSumOfIncomingFavs = if (useLogFavWeights) {</p>
<blockquote>
<div><p>normsAndCounts.logFavWeightsOnFavEdgesSum.getOrElse(0.0)</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>normsAndCounts.favWeightsOnFavEdgesSum.getOrElse(0.0)</p>
</dd>
</dl>
<blockquote>
<div><p>clusterId,
BipartiteClusterQuality(</p>
<blockquote>
<div><p>incomingFollowEdges = Some(followerCount),
incomingFavEdges = Some(faverCount),
favWtSumOfIncomingFollowEdges = Some(favWtSumOfIncomingFollows),
favWtSumOfIncomingFavEdges = Some(favWtSumOfIncomingFavs)</p>
</div></blockquote>
<p>))</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>}
.sumByKey
.toTypedPipe</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def loadOrMake(</dt><dd><p>pipe: TypedPipe[(Int, BipartiteClusterQuality)],
modelVersion: String,
path: String</p>
</dd>
<dt>): Execution[TypedPipe[(Int, BipartiteClusterQuality)]] = {</dt><dd><dl class="simple">
<dt>val mapped = pipe.map {</dt><dd><p>case (clusterId, struct) =&gt; ((modelVersion, clusterId), struct)</p>
</dd>
</dl>
<p>}
makeForKeyValSource(mapped, AdhocKeyValSources.bipartiteQualitySource(path), path).map { pipe =&gt;</p>
<blockquote>
<div><p>// discard model version
pipe.map { case ((_, clusterId), struct) =&gt; (clusterId, struct) }</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def makeForKeyValSource[K, V](</dt><dd><p>pipe: TypedPipe[(K, V)],
dest: VersionedKeyValSource[K, V],
path: String</p>
</dd>
<dt>): Execution[TypedPipe[(K, V)]] =</dt><dd><dl>
<dt>Execution.getMode.flatMap { mode =&gt;</dt><dd><dl class="simple">
<dt>if (dest.resourceExists(mode)) {</dt><dd><p>println(s”validated path $path”)
Execution.from(TypedPipe.from(dest))</p>
</dd>
<dt>} else {</dt><dd><p>println(s”Could not load from $path”)
pipe.writeThrough(dest)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>def precisionOfWholeGraph(</dt><dd><p>knownFor: TypedPipe[(Long, Array[(Int, Float)])],
interestedIn: TypedPipe[(Long, ClustersUserIsInterestedIn)],
clusterIncomingVolumesExec: Execution[TypedPipe[(Int, BipartiteClusterQuality)]]</p>
</dd>
<dt>): Execution[Option[Double]] = {</dt><dd><p>val knownForSizeExec = knownFor.aggregate(Aggregator.size).toOptionExecution
val interestedInSizeExec =</p>
<blockquote>
<div><p>interestedIn.aggregate(Aggregator.size).toOptionExecution</p>
</div></blockquote>
<dl class="simple">
<dt>val numExec = clusterIncomingVolumesExec.flatMap { volumes =&gt;</dt><dd><p>volumes.values.flatMap(_.favWtSumOfIncomingFavEdges).sum.toOptionExecution</p>
</dd>
</dl>
<p>}
Execution.zip(numExec, interestedInSizeExec, knownForSizeExec).map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (Some(num), Some(interestedInSize), Some(knownForSize)) =&gt;</dt><dd><p>Some(num / interestedInSize / knownForSize)</p>
</dd>
<dt>case x &#64; _ =&gt;</dt><dd><p>println(“Precision of whole graph zip: “ + x)
None</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def finalPerClusterResults(</dt><dd><p>knownFor: TypedPipe[(Long, Array[(Int, Float)])],
interestedIn: TypedPipe[(Long, ClustersUserIsInterestedIn)],
resultsWithOutgoingVolumesExec: Execution[TypedPipe[(Int, BipartiteClusterQuality)]],
incomingVolumesExec: Execution[TypedPipe[(Int, BipartiteClusterQuality)]]</p>
</dd>
<dt>): Execution[TypedPipe[(Int, BipartiteClusterQuality)]] = {</dt><dd><p>val knownForTranspose = KnownForSources.transpose(knownFor)</p>
<dl>
<dt>val precisionOfWholeGraphExec =</dt><dd><p>precisionOfWholeGraph(knownFor, interestedIn, incomingVolumesExec)</p>
</dd>
<dt>Execution</dt><dd><p>.zip(resultsWithOutgoingVolumesExec, incomingVolumesExec, precisionOfWholeGraphExec)
.map {</p>
<blockquote>
<div><dl>
<dt>case (resultsWithOutgoingVolumes, clusterIncomingVolumes, precisionOfWholeGraph) =&gt;</dt><dd><p>println(“Precision of whole graph “ + precisionOfWholeGraph)
resultsWithOutgoingVolumes</p>
<blockquote>
<div><p>.join(knownForTranspose)
.leftJoin(clusterIncomingVolumes)
.withReducers(500)
.map {</p>
<blockquote>
<div><dl>
<dt>case (clusterId, ((outgoingVolumeQuality, knownForList), incomingVolumesOpt)) =&gt;</dt><dd><dl class="simple">
<dt>val incomingVolumes =</dt><dd><p>incomingVolumesOpt.getOrElse(BipartiteClusterQuality())</p>
</dd>
</dl>
<p>val knownForMap = knownForList.toMap
(</p>
<blockquote>
<div><p>clusterId,
getFullQuality(</p>
<blockquote>
<div><p>outgoingVolumeQuality,
incomingVolumes,
knownForMap,
precisionOfWholeGraph))</p>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getFullQuality(</dt><dd><p>qualityWithOutgoingVolumes: BipartiteClusterQuality,
incomingVolumes: BipartiteClusterQuality,
knownFor: Map[Long, Float],
precisionOfWholeGraph: Option[Double]</p>
</dd>
<dt>): BipartiteClusterQuality = {</dt><dd><dl>
<dt>val newSampledEdges = qualityWithOutgoingVolumes.sampledEdges.map { sampledEdges =&gt;</dt><dd><dl>
<dt>sampledEdges.map { sampledEdge =&gt;</dt><dd><p>val knownForScore = knownFor.getOrElse(sampledEdge.followeeId, 0.0f)
sampledEdge.copy(</p>
<blockquote>
<div><p>predictedFollowScore = sampledEdge.followScoreToCluster.map { x =&gt; x * knownForScore },
predictedFavScore = sampledEdge.favScoreToCluster.map { x =&gt; x * knownForScore }</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
val correlationOfFavWtIfFollow = newSampledEdges.map { samples =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>val pairs = samples.map { s =&gt;</dt><dd><p>(s.predictedFollowScore.getOrElse(0.0), s.favWtIfFollowEdge.getOrElse(0.0))</p>
</dd>
</dl>
<p>}
Util.computeCorrelation(pairs.iterator)</p>
</div></blockquote>
<p>}
val correlationOfFavWtIfFav = newSampledEdges.map { samples =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>val pairs = samples.map { s =&gt;</dt><dd><p>(s.predictedFavScore.getOrElse(0.0), s.favWtIfFavEdge.getOrElse(0.0))</p>
</dd>
</dl>
<p>}
Util.computeCorrelation(pairs.iterator)</p>
</div></blockquote>
<p>}
val relativePrecisionNum = {</p>
<blockquote>
<div><dl class="simple">
<dt>if (qualityWithOutgoingVolumes.interestedInSize.exists(_ &gt; 0) &amp;&amp; knownFor.nonEmpty) {</dt><dd><dl class="simple">
<dt>qualityWithOutgoingVolumes.favWtSumOfInClusterFavEdges</dt><dd><p>.getOrElse(0.0) / qualityWithOutgoingVolumes.interestedInSize.get / knownFor.size</p>
</dd>
</dl>
</dd>
</dl>
<p>} else 0.0</p>
</div></blockquote>
<p>}
val relativePrecision = if (precisionOfWholeGraph.exists(_ &gt; 0.0)) {</p>
<blockquote>
<div><p>Some(relativePrecisionNum / precisionOfWholeGraph.get)</p>
</div></blockquote>
<p>} else None
qualityWithOutgoingVolumes.copy(</p>
<blockquote>
<div><p>incomingFollowEdges = incomingVolumes.incomingFollowEdges,
incomingFavEdges = incomingVolumes.incomingFavEdges,
favWtSumOfIncomingFollowEdges = incomingVolumes.favWtSumOfIncomingFollowEdges,
favWtSumOfIncomingFavEdges = incomingVolumes.favWtSumOfIncomingFavEdges,
knownForSize = Some(knownFor.size),
correlationOfFavWtIfFollowWithPredictedFollow = correlationOfFavWtIfFollow,
correlationOfFavWtIfFavWithPredictedFav = correlationOfFavWtIfFav,
sampledEdges = newSampledEdges,
relativePrecisionUsingFavWtIfFav = relativePrecision,
averagePrecisionOfWholeGraphUsingFavWtIfFav = precisionOfWholeGraph</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>object DumpBpQuality extends TwitterExecutionApp {</dt><dd><dl>
<dt>def job: Execution[Unit] = Execution.getConfigMode.flatMap {</dt><dd><dl>
<dt>case (config, mode) =&gt;</dt><dd><dl>
<dt>Execution.withId { implicit uniqueId =&gt;</dt><dd><p>val args = config.getArgs
val inputDir = args(“inputDir”)</p>
<p>val clusters = args.list(“clusters”).map(_.toInt).toSet
val input =</p>
<blockquote>
<div><dl>
<dt>TypedPipe</dt><dd><p>.from(AdhocKeyValSources.bipartiteQualitySource(inputDir))
.map {</p>
<blockquote>
<div><dl>
<dt>case ((modelVersion, clusterId), quality) =&gt;</dt><dd><dl>
<dt>(</dt><dd><p>(modelVersion, clusterId),
BipartiteClusterEvaluationClasses</p>
<blockquote>
<div><p>.printableBipartiteQuality(quality))</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>if (clusters.isEmpty) {</dt><dd><p>input.printSummary(“Bipartite quality”)</p>
</dd>
<dt>} else {</dt><dd><dl>
<dt>input</dt><dd><dl class="simple">
<dt>.collect {</dt><dd><dl class="simple">
<dt>case rec &#64; ((_, clusterId), quality) if clusters(clusterId) =&gt;</dt><dd><dl class="simple">
<dt>Util.prettyJsonMapper</dt><dd><p>.writeValueAsString(rec)
.replaceAll(”n”, “ “)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}
.toIterableExecution
.map { strings =&gt; println(strings.mkString(”n”)) }</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../_sources/src/scala/com/twitter/simclusters_v2/scalding/BipartiteClusterEvaluation.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>