<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../" id="documentation_options" src="../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.simclusters_v2.scalding</p>
<p>import com.twitter.algebird.Monoid
import com.twitter.logging.Logger
import com.twitter.scalding.{Execution, TypedPipe, TypedTsv}
import com.twitter.scalding_internal.job.TwitterExecutionApp
import com.twitter.simclusters_v2.hdfs_sources.AdhocKeyValSources
import java.util
import no.uib.cipr.matrix.Matrix
import no.uib.cipr.matrix.sparse.{ArpackSym, LinkedSparseMatrix}
import scala.collection.JavaConverters._</p>
<dl>
<dt>object EigenVectorsForSparseSymmetric {</dt><dd><p>val log: Logger = Logger()</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Construct matrix from the rows of the matrix, specified as a map. The outer map is indexed by rowId, and the inner maps are indexed by columnId.</p></li>
<li><p>Note that the input matrix is intended to be symmetric.</p></li>
<li></li>
<li><p>&#64;param map   A map specifying the rows of the matrix. The outer map is indexed by rowId, and the inner maps are indexed by columnId. Both rows and columns are zero-indexed.</p></li>
<li><p>&#64;param nRows number of rows in matrix</p></li>
<li><p>&#64;param nCols number of columns in matrix</p></li>
<li></li>
<li><p>&#64;return the constructed matrix</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>def getMatrix(map: Map[Int, Map[Int, Double]], nRows: Int, nCols: Int): Matrix = {</dt><dd><dl>
<dt>val nonzeros = map.toSeq.flatMap {</dt><dd><dl>
<dt>case (i, subMap) =&gt;</dt><dd><dl class="simple">
<dt>subMap.toSeq.map {</dt><dd><dl class="simple">
<dt>case (j, value) =&gt;</dt><dd><p>(i, j, value)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}
getMatrix(nonzeros, nRows, nCols)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Construct matrix from iterable of the non-zero entries. Note that the input matrix is intended to be symmetric.</p></li>
<li></li>
<li><p>&#64;param nonzeros non-zeros in (i, j, v) format, where i is row, j is column, and v is value. Both rows and columns are zero-indexed.</p></li>
<li><p>&#64;param nRows    number of rows in matrix</p></li>
<li><p>&#64;param nCols    number of columns in matrix</p></li>
<li></li>
<li><p>&#64;return the constructed matrix</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>def getMatrix(nonzeros: Iterable[(Int, Int, Double)], nRows: Int, nCols: Int): Matrix = {</dt><dd><p>val matrix = new LinkedSparseMatrix(nRows, nCols)
var numEntries = 0
var maxRow = 0
var maxCol = 0</p>
<dl>
<dt>nonzeros.foreach {</dt><dd><dl>
<dt>case (i, j, v) =&gt;</dt><dd><dl class="simple">
<dt>if (i &gt; maxRow) {</dt><dd><p>maxRow = i</p>
</dd>
</dl>
<p>}
if (j &gt; maxCol) {</p>
<blockquote>
<div><p>maxCol = j</p>
</div></blockquote>
<p>}
numEntries += 1
matrix.set(i, j, v)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
log.info(</p>
<blockquote>
<div><dl class="simple">
<dt>“Finished building matrix with %d entries and maxRow %d and maxCol %d”</dt><dd><p>.format(numEntries, maxRow, maxCol))</p>
</dd>
</dl>
</div></blockquote>
<p>matrix</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Prints out various diagnostics about how much the given matrix differs from a perfect</p></li>
<li><p>symmetric matrix. If (i,j) and (j,i) are different, it sets both of them to be the max of the two.</p></li>
<li><p>Call this function before invoking EVD.</p></li>
<li></li>
<li><p>&#64;param matrix Matrix which is modified (if need be) in place.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>def ensureMatrixIsSymmetric(matrix: Matrix): Unit = {</dt><dd><p>var numUnequalEntries = 0
var numEntriesDifferentBy1Percent = 0
var numEqualEntries = 0
var numUnequalDueToZero = 0
var maxUnequal = (0, 0, 0.0, 0.0)
matrix.iterator().asScala.foreach { entry =&gt;</p>
<blockquote>
<div><p>val curr = entry.get()
val opp = matrix.get(entry.column(), entry.row())
if (curr == opp) {</p>
<blockquote>
<div><p>numEqualEntries += 1</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>numUnequalEntries += 1
if (opp == 0) {</p>
<blockquote>
<div><p>numUnequalDueToZero += 1</p>
</div></blockquote>
<p>}
if (opp != 0 &amp;&amp; (math.abs(curr - opp) / math.min(curr, opp)) &gt; 0.01) {</p>
<blockquote>
<div><p>numEntriesDifferentBy1Percent += 1</p>
</div></blockquote>
<p>}
if (opp != 0 &amp;&amp; math.abs(curr - opp) &gt; maxUnequal._4) {</p>
<blockquote>
<div><p>maxUnequal = (entry.row(), entry.column(), curr, math.abs(curr - opp))</p>
</div></blockquote>
<p>}
val max = math.max(curr, opp)
matrix.set(entry.column(), entry.row(), max)
matrix.set(entry.row(), entry.column(), max)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>var numUnEqualPrinted = 0
matrix.iterator().asScala.foreach { entry =&gt;</p>
<blockquote>
<div><p>val opp = matrix.get(entry.column(), entry.row())
if (numUnEqualPrinted &lt; 10 &amp;&amp; entry.get() != opp) {</p>
<blockquote>
<div><p>numUnEqualPrinted += 1
log.info(</p>
<blockquote>
<div><dl class="simple">
<dt>“Entries for (%d, %d) are %s and %s”</dt><dd><p>.format(entry.row(), entry.column(), entry.get(), opp))</p>
</dd>
</dl>
</div></blockquote>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>log.info(</dt><dd><dl class="simple">
<dt>“Num unequal entries: %d, num unequal due to zero: %d, num unequal by 1percent or more: %d, num equal entries: %d, maxUnequal: %s”</dt><dd><dl class="simple">
<dt>.format(</dt><dd><p>numUnequalEntries,
numUnequalDueToZero,
numEntriesDifferentBy1Percent,
numEqualEntries,
maxUnequal))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Get the top-k eigenvalues (largest magnitude) and eigenvectors for an input matrix.</p></li>
<li><p>Top eigenvalues means they’re the largest in magnitude.</p></li>
<li><p>Input matrix needs to be perfectly symmetric; if it’s not, this function will fail.</p></li>
<li></li>
<li><p>Many of the eigenvectors will have very small values along most of the dimensions. This method also</p></li>
<li><p>only retains the bigger entries in an eigenvector.</p></li>
<li></li>
<li><p>&#64;param matrix               symmetric input matrix.</p></li>
<li><p>&#64;param k                    how many of the top eigenvectors to get.</p></li>
<li><p>&#64;param ratioToLargestCutoff An entry needs to be at least 1/ratioToLargestCutoff of the biggest entry in that vector to be retained.</p></li>
<li></li>
<li><p>&#64;return seq of (eigenvalue, eigenvector) pairs.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>def getTruncatedEVD(</dt><dd><p>matrix: Matrix,
k: Int,
ratioToLargestCutoff: Float</p>
</dd>
<dt>): Seq[(Double, Seq[(Int, Double)])] = {</dt><dd><p>val solver = new ArpackSym(matrix)
val resultsMap = solver.solve(k, ArpackSym.Ritz.LM).asScala.toMap
val results = resultsMap.toIndexedSeq.sortBy { case (eigValue, _) =&gt; -eigValue }
results.zipWithIndex.map {</p>
<blockquote>
<div><dl>
<dt>case ((eigValue, denseVectorJava), index) =&gt;</dt><dd><p>val denseVector = new Array[Double](denseVectorJava.size())
denseVector.indices.foreach { index =&gt; denseVector(index) = denseVectorJava.get(index) }
val denseVectorMax = denseVector.maxBy { entry =&gt; math.abs(entry) }
val cutOff = math.abs(denseVectorMax) / ratioToLargestCutoff
val significantEntries = denseVector.zipWithIndex</p>
<blockquote>
<div><p>.filter { case (vectorEntry, _) =&gt; math.abs(vectorEntry) &gt;= cutOff }
.sortBy { case (vectorEntry, _) =&gt; -1 * math.abs(vectorEntry) }</p>
</div></blockquote>
<p>(eigValue.toDouble, significantEntries.toSeq.map(_.swap))</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Compute U*Diag*Ut - where Diag is a diagonal matrix, and U is a sparse matrix.</p></li>
<li><p>This is primarily for testing - to make sure that the computed eigenvectors can be used to</p></li>
<li><p>reconstruct the original matrix up to some reasonable approximation.</p></li>
<li></li>
<li><p>&#64;param diagToUColumns seq of (diagonal entries, associated column in U)</p></li>
<li><p>&#64;param cutoff         cutoff for including a value in the result.</p></li>
<li></li>
<li><p>&#64;return result of multiplication, returned as a map of the rows in the results.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>def uTimesDiagTimesUT(</dt><dd><p>diagToUColumns: Seq[(Double, Seq[(Int, Double)])],
cutoff: Double</p>
</dd>
<dt>): Map[Int, Map[Int, Double]] = {</dt><dd><p>val result = new util.HashMap[Int, util.HashMap[Int, Double]]()
diagToUColumns.foreach {</p>
<blockquote>
<div><dl>
<dt>case (diag, uColumn) =&gt;</dt><dd><dl>
<dt>uColumn.foreach {</dt><dd><dl>
<dt>case (i, iVal) =&gt;</dt><dd><dl>
<dt>uColumn.foreach {</dt><dd><dl>
<dt>case (j, jVal) =&gt;</dt><dd><p>val prod = diag * iVal * jVal
if (result.containsKey(i)) {</p>
<blockquote>
<div><dl class="simple">
<dt>val newVal = if (result.get(i).containsKey(j)) {</dt><dd><p>result.get(i).get(j) + prod</p>
</dd>
</dl>
<p>} else prod
result.get(i).put(j, newVal)</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>result.put(i, new util.HashMap[Int, Double])
result.get(i).put(j, prod)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>}
val unfiltered = result.asScala.toMap.mapValues(_.asScala.toMap)
unfiltered</p>
<blockquote>
<div><p>.mapValues { m =&gt; m.filter { case (_, value) =&gt; math.abs(value) &gt;= cutoff } }
.filter { case (_, vector) =&gt; vector.nonEmpty }</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<p>/** Note: This requires a full EVD to correctly compute the inverse! :-( <a href="#id11"><span class="problematic" id="id12">*</span></a>/
def getInverseFromEVD(</p>
<blockquote>
<div><p>evd: Seq[(Double, Seq[(Int, Double)])],
cutoff: Double</p>
</div></blockquote>
<dl>
<dt>): Map[Int, Map[Int, Double]] = {</dt><dd><dl class="simple">
<dt>val evdInverse = evd.map {</dt><dd><dl class="simple">
<dt>case (eigValue, eigVector) =&gt;</dt><dd><p>(1.0 / eigValue, eigVector)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
uTimesDiagTimesUT(evdInverse, cutoff)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>object PCAProjectionMatrixAdhoc extends TwitterExecutionApp {</dt><dd><p>val log = Logger()</p>
<dl>
<dt>def job: Execution[Unit] =</dt><dd><dl>
<dt>Execution.getConfigMode.flatMap {</dt><dd><dl>
<dt>case (config, _) =&gt;</dt><dd><dl>
<dt>Execution.withId { _ =&gt;</dt><dd><p>val args = config.getArgs
val k = args.int(“k”, 100)
val ratioToLargestEntryInVectorCutoff = args.int(“ratioToLargestEntryInVectorCutoff”, 100)
val minClusterFavers = args.int(“minClusterFavers”, 1000)
val input = TypedPipe.from(AdhocKeyValSources.clusterDetailsSource(args(“inputDir”)))
val outputDir = args(“outputDir”)</p>
<dl>
<dt>val filteredClustersExec =</dt><dd><dl>
<dt>input</dt><dd><dl>
<dt>.collect {</dt><dd><dl>
<dt>case ((_, clusterId), details)</dt><dd><blockquote>
<div><p>if details.numUsersWithNonZeroFavScore &gt; minClusterFavers =&gt;</p>
</div></blockquote>
<p>clusterId</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.toIterableExecution
.map { fc =&gt;</p>
<blockquote>
<div><p>val fcSet = fc.toSet
log.info(“Number of clusters with favers more than %d is %d”</p>
<blockquote>
<div><p>.format(minClusterFavers, fcSet.size))</p>
</div></blockquote>
<p>fcSet</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
<dt>filteredClustersExec</dt><dd><dl>
<dt>.flatMap { filteredClusters =&gt;</dt><dd><dl>
<dt>input.flatMap {</dt><dd><dl>
<dt>case ((_, clusterId), details) =&gt;</dt><dd><dl>
<dt>if (filteredClusters(clusterId)) {</dt><dd><dl>
<dt>details.neighborClusters.getOrElse(Nil).collect {</dt><dd><dl>
<dt>case neighbor</dt><dd><blockquote>
<div><dl class="simple">
<dt>if filteredClusters(</dt><dd><p>neighbor.clusterId) &amp;&amp; neighbor.favCosineSimilarity.isDefined =&gt;</p>
</dd>
</dl>
</div></blockquote>
<p>(clusterId, neighbor.clusterId, neighbor.favCosineSimilarity.get)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>} else Nil</p>
</dd>
</dl>
</dd>
</dl>
<p>}.toIterableExecution</p>
</dd>
</dl>
<p>}
.flatMap { edgesIter =&gt;</p>
<blockquote>
<div><p>val edges = edgesIter.toSeq
val oldIdToNewId = edges</p>
<blockquote>
<div><p>.flatMap { case (i, j, _) =&gt; Seq(i, j) }
.distinct
.zipWithIndex
.toMap</p>
</div></blockquote>
<dl>
<dt>val mapString = oldIdToNewId.toList</dt><dd><dl class="simple">
<dt>.take(5).map {</dt><dd><dl class="simple">
<dt>case (old, nw) =&gt;</dt><dd><p>Seq(old, nw).mkString(” “)</p>
</dd>
</dl>
</dd>
</dl>
<p>}.mkString(”n”)</p>
</dd>
</dl>
<p>log.info(“A few entries of OldId to NewId map is”)
log.info(mapString)</p>
<p>val newIdToOldId = oldIdToNewId.map(_.swap)
log.info(</p>
<blockquote>
<div><dl class="simple">
<dt>“Num clusters after filtering out those with no neighbors with favers more than %d is %d”</dt><dd><p>.format(minClusterFavers, oldIdToNewId.size))</p>
</dd>
</dl>
</div></blockquote>
<dl class="simple">
<dt>val newEdges = edges.map {</dt><dd><dl class="simple">
<dt>case (oldI, oldJ, value) =&gt;</dt><dd><p>(oldIdToNewId(oldI), oldIdToNewId(oldJ), value)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
log.info(“Going to build matrix”)
val matrix = EigenVectorsForSparseSymmetric.getMatrix(</p>
<blockquote>
<div><p>newEdges,
oldIdToNewId.size,
oldIdToNewId.size)</p>
</div></blockquote>
<p>EigenVectorsForSparseSymmetric.ensureMatrixIsSymmetric(matrix)</p>
<p>log.info(“Going to solve now for %d eigenvalues”.format(k))
val tic = System.currentTimeMillis()
val results = EigenVectorsForSparseSymmetric.getTruncatedEVD(</p>
<blockquote>
<div><p>matrix,
k,
ratioToLargestEntryInVectorCutoff)</p>
</div></blockquote>
<p>val toc = System.currentTimeMillis()
log.info(“Finished solving in %.2f minutes”.format((toc - tic) / 1000 / 60.0))</p>
<p>val eigValues = results.map(_._1).map { x =&gt; “%.3g”.format(x) }.mkString(” “)
val eigValueNorm = math.sqrt(results.map(_._1).map(x =&gt; x * x).sum)
val matrixNorm = math.sqrt(matrix.iterator().asScala.map(_.get()).map(x =&gt; x * x).sum)</p>
<dl class="simple">
<dt>println(</dt><dd><dl class="simple">
<dt>“matrixNorm %s, eigValueNorm %s, explained fraction %s”</dt><dd><p>.format(matrixNorm, eigValueNorm, eigValueNorm / matrixNorm))</p>
</dd>
</dl>
</dd>
</dl>
<p>log.info(“The eigenvalues are:”)
log.info(eigValues)</p>
<p>val nnzInEigenVectors = results.map(_._2.size).sum
log.info(“Average nnz per eigenvector using ratioToLargestCutoff %d is %.2g”</p>
<blockquote>
<div><p>.format(ratioToLargestEntryInVectorCutoff, nnzInEigenVectors * 1.0 / results.size))</p>
</div></blockquote>
<dl>
<dt>val transposedRaw = results.zipWithIndex.flatMap {</dt><dd><dl>
<dt>case ((_, eigVector), eigIndex) =&gt;</dt><dd><dl class="simple">
<dt>eigVector.map {</dt><dd><dl class="simple">
<dt>case (index, vectorEntry) =&gt;</dt><dd><p>val clusterId = newIdToOldId(index)
Map(clusterId -&gt; List((eigIndex, vectorEntry)))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}
val transposed = Monoid.sum(transposedRaw).mapValues { rowForCluster =&gt;</p>
<blockquote>
<div><dl>
<dt>rowForCluster</dt><dd><dl class="simple">
<dt>.map {</dt><dd><dl class="simple">
<dt>case (dimId, weight) =&gt;</dt><dd><p>“%d:%.2g”.format(dimId, weight)</p>
</dd>
</dl>
</dd>
</dl>
<p>}.mkString(” “)</p>
</dd>
</dl>
</div></blockquote>
<p>}
TypedPipe.from(transposed.toSeq).writeExecution(TypedTsv(outputDir))</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../_sources/src/scala/com/twitter/simclusters_v2/scalding/EigenVectorsForSparseSymmetric.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>