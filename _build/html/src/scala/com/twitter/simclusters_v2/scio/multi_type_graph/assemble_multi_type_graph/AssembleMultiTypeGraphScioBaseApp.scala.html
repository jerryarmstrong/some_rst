<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../" id="documentation_options" src="../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.simclusters_v2.scio.multi_type_graph.assemble_multi_type_graph</p>
<p>import com.spotify.scio.ScioContext
import com.spotify.scio.coders.Coder
import com.spotify.scio.values.SCollection
import com.twitter.beam.io.dal.DAL
import com.twitter.beam.io.fs.multiformat.DiskFormat
import com.twitter.beam.io.fs.multiformat.PathLayout
import com.twitter.beam.job.DateRangeOptions
import com.twitter.dal.client.dataset.KeyValDALDataset
import com.twitter.dal.client.dataset.SnapshotDALDataset
import com.twitter.frigate.data_pipeline.magicrecs.magicrecs_notifications_lite.thriftscala.MagicRecsNotificationLite
import com.twitter.iesource.thriftscala.InteractionEvent
import com.twitter.iesource.thriftscala.InteractionType
import com.twitter.iesource.thriftscala.ReferenceTweet
import com.twitter.scalding_internal.multiformat.format.keyval.KeyVal
import com.twitter.scio_internal.coders.ThriftStructLazyBinaryScroogeCoder
import com.twitter.scio_internal.job.ScioBeamJob
import com.twitter.scrooge.ThriftStruct
import com.twitter.simclusters_v2.common.Country
import com.twitter.simclusters_v2.common.Language
import com.twitter.simclusters_v2.common.TopicId
import com.twitter.simclusters_v2.common.TweetId
import com.twitter.simclusters_v2.common.UserId
import com.twitter.simclusters_v2.hdfs_sources.MultiTypeGraphForTopKRightNodesThriftScioScalaDataset
import com.twitter.simclusters_v2.hdfs_sources.TopKRightNounsScioScalaDataset
import com.twitter.simclusters_v2.hdfs_sources.TruncatedMultiTypeGraphScioScalaDataset
import com.twitter.simclusters_v2.scio.common.ExternalDataSources
import com.twitter.simclusters_v2.scio.multi_type_graph.assemble_multi_type_graph.Config.GlobalDefaultMinFrequencyOfRightNodeType
import com.twitter.simclusters_v2.scio.multi_type_graph.assemble_multi_type_graph.Config.HalfLifeInDaysForFavScore
import com.twitter.simclusters_v2.scio.multi_type_graph.assemble_multi_type_graph.Config.NumTopNounsForUnknownRightNodeType
import com.twitter.simclusters_v2.scio.multi_type_graph.assemble_multi_type_graph.Config.SampledEmployeeIds
import com.twitter.simclusters_v2.scio.multi_type_graph.assemble_multi_type_graph.Config.TopKConfig
import com.twitter.simclusters_v2.scio.multi_type_graph.assemble_multi_type_graph.Config.TopKRightNounsForMHDump
import com.twitter.simclusters_v2.scio.multi_type_graph.common.MultiTypeGraphUtil
import com.twitter.simclusters_v2.thriftscala.EdgeWithDecayedWeights
import com.twitter.simclusters_v2.thriftscala.LeftNode
import com.twitter.simclusters_v2.thriftscala.MultiTypeGraphEdge
import com.twitter.simclusters_v2.thriftscala.Noun
import com.twitter.simclusters_v2.thriftscala.NounWithFrequency
import com.twitter.simclusters_v2.thriftscala.NounWithFrequencyList
import com.twitter.simclusters_v2.thriftscala.RightNode
import com.twitter.simclusters_v2.thriftscala.RightNodeType
import com.twitter.simclusters_v2.thriftscala.RightNodeTypeStruct
import com.twitter.simclusters_v2.thriftscala.RightNodeWithEdgeWeight
import com.twitter.simclusters_v2.thriftscala.RightNodeWithEdgeWeightList
import com.twitter.twadoop.user.gen.thriftscala.CombinedUser
import com.twitter.util.Duration
import java.time.Instant
import org.joda.time.Interval</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Scio version of</p></li>
<li><p>src/scala/com/twitter/simclusters_v2/scalding/multi_type_graph/assemble_multi_type_graph/AssembleMultiTypeGraph.scala</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>trait AssembleMultiTypeGraphScioBaseApp extends ScioBeamJob[DateRangeOptions] {</dt><dd><p>// Provides an implicit binary thrift scrooge coder by default.
override implicit def scroogeCoder[T &lt;: ThriftStruct: Manifest]: Coder[T] =</p>
<blockquote>
<div><p>ThriftStructLazyBinaryScroogeCoder.scroogeCoder</p>
</div></blockquote>
<p>val isAdhoc: Boolean
val rootMHPath: String
val rootThriftPath: String</p>
<dl class="simple">
<dt>val truncatedMultiTypeGraphMHOutputDir: String =</dt><dd><p>Config.truncatedMultiTypeGraphMHOutputDir</p>
</dd>
<dt>val truncatedMultiTypeGraphThriftOutputDir: String =</dt><dd><p>Config.truncatedMultiTypeGraphThriftOutputDir</p>
</dd>
</dl>
<p>val topKRightNounsMHOutputDir: String = Config.topKRightNounsMHOutputDir
val topKRightNounsOutputDir: String = Config.topKRightNounsOutputDir</p>
<dl class="simple">
<dt>val fullMultiTypeGraphThriftOutputDir: String =</dt><dd><p>Config.fullMultiTypeGraphThriftOutputDir</p>
</dd>
<dt>val truncatedMultiTypeGraphKeyValDataset: KeyValDALDataset[</dt><dd><p>KeyVal[LeftNode, RightNodeWithEdgeWeightList]</p>
</dd>
</dl>
<p>] = TruncatedMultiTypeGraphScioScalaDataset
val topKRightNounsKeyValDataset: KeyValDALDataset[</p>
<blockquote>
<div><p>KeyVal[RightNodeTypeStruct, NounWithFrequencyList]</p>
</div></blockquote>
<p>] = TopKRightNounsScioScalaDataset
val topKRightNounsMHKeyValDataset: KeyValDALDataset[</p>
<blockquote>
<div><p>KeyVal[RightNodeTypeStruct, NounWithFrequencyList]</p>
</div></blockquote>
<p>] = TopKRightNounsMhScioScalaDataset
val fullMultiTypeGraphSnapshotDataset: SnapshotDALDataset[MultiTypeGraphEdge] =</p>
<blockquote>
<div><p>FullMultiTypeGraphScioScalaDataset</p>
</div></blockquote>
<dl>
<dt>val multiTypeGraphTopKForRightNodesSnapshotDataset: SnapshotDALDataset[</dt><dd><p>MultiTypeGraphEdge</p>
</dd>
<dt>] =</dt><dd><p>MultiTypeGraphForTopKRightNodesThriftScioScalaDataset</p>
</dd>
<dt>def getValidUsers(</dt><dd><p>input: SCollection[CombinedUser]</p>
</dd>
<dt>): SCollection[UserId] = {</dt><dd><dl>
<dt>input</dt><dd><dl>
<dt>.flatMap { u =&gt;</dt><dd><dl class="simple">
<dt>for {</dt><dd><p>user &lt;- u.user
if user.id != 0
safety &lt;- user.safety
if !(safety.suspended || safety.deactivated)</p>
</dd>
<dt>} yield {</dt><dd><p>user.id</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def filterInvalidUsers(</dt><dd><p>flockEdges: SCollection[(UserId, UserId)],
validUsers: SCollection[UserId]</p>
</dd>
<dt>): SCollection[(UserId, UserId)] = {</dt><dd><p>val validUsersWithValues = validUsers.map(userId =&gt; (userId, ()))
flockEdges</p>
<blockquote>
<div><p>.join(validUsersWithValues)
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (srcId, (destId, _)) =&gt;</dt><dd><p>(destId, srcId)</p>
</dd>
</dl>
</div></blockquote>
<p>}
.join(validUsersWithValues)
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (destId, (srcId, _)) =&gt;</dt><dd><p>(srcId, destId)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getFavEdges(</dt><dd><p>input: SCollection[EdgeWithDecayedWeights],
halfLifeInDaysForFavScore: Int,</p>
</dd>
<dt>): SCollection[(Long, Long, Double)] = {</dt><dd><dl>
<dt>input</dt><dd><dl>
<dt>.flatMap { edge =&gt;</dt><dd><dl class="simple">
<dt>if (edge.weights.halfLifeInDaysToDecayedSums.contains(halfLifeInDaysForFavScore)) {</dt><dd><dl class="simple">
<dt>Some(</dt><dd><dl class="simple">
<dt>(</dt><dd><p>edge.sourceId,
edge.destinationId,
edge.weights.halfLifeInDaysToDecayedSums(halfLifeInDaysForFavScore)))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
<dt>} else {</dt><dd><p>None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def leftRightTuple(</dt><dd><p>leftNodeUserId: UserId,
rightNodeType: RightNodeType,
rightNoun: Noun,
weight: Double = 1.0</p>
</dd>
<dt>): (LeftNode, RightNodeWithEdgeWeight) = {</dt><dd><dl>
<dt>(</dt><dd><p>LeftNode.UserId(leftNodeUserId),
RightNodeWithEdgeWeight(</p>
<blockquote>
<div><p>rightNode = RightNode(rightNodeType = rightNodeType, noun = rightNoun),
weight = weight))</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getUserFavGraph(</dt><dd><p>userUserFavEdges: SCollection[(UserId, UserId, Double)]</p>
</dd>
<dt>): SCollection[(LeftNode, RightNodeWithEdgeWeight)] = {</dt><dd><dl class="simple">
<dt>userUserFavEdges.map {</dt><dd><dl class="simple">
<dt>case (srcId, destId, edgeWt) =&gt;</dt><dd><p>leftRightTuple(srcId, RightNodeType.FavUser, Noun.UserId(destId), edgeWt)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getUserFollowGraph(</dt><dd><p>userUserFollowEdges: SCollection[(UserId, UserId)]</p>
</dd>
<dt>): SCollection[(LeftNode, RightNodeWithEdgeWeight)] = {</dt><dd><dl class="simple">
<dt>userUserFollowEdges.map {</dt><dd><dl class="simple">
<dt>case (srcId, destId) =&gt;</dt><dd><p>leftRightTuple(srcId, RightNodeType.FollowUser, Noun.UserId(destId), 1.0)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getUserBlockGraph(</dt><dd><p>userUserBlockEdges: SCollection[(UserId, UserId)]</p>
</dd>
<dt>): SCollection[(LeftNode, RightNodeWithEdgeWeight)] = {</dt><dd><dl class="simple">
<dt>userUserBlockEdges.map {</dt><dd><dl class="simple">
<dt>case (srcId, destId) =&gt;</dt><dd><p>leftRightTuple(srcId, RightNodeType.BlockUser, Noun.UserId(destId), 1.0)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getUserAbuseReportGraph(</dt><dd><p>userUserAbuseReportEdges: SCollection[(UserId, UserId)]</p>
</dd>
<dt>): SCollection[(LeftNode, RightNodeWithEdgeWeight)] = {</dt><dd><dl class="simple">
<dt>userUserAbuseReportEdges.map {</dt><dd><dl class="simple">
<dt>case (srcId, destId) =&gt;</dt><dd><p>leftRightTuple(srcId, RightNodeType.AbuseReportUser, Noun.UserId(destId), 1.0)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getUserSpamReportGraph(</dt><dd><p>userUserSpamReportEdges: SCollection[(UserId, UserId)]</p>
</dd>
<dt>): SCollection[(LeftNode, RightNodeWithEdgeWeight)] = {</dt><dd><dl class="simple">
<dt>userUserSpamReportEdges.map {</dt><dd><dl class="simple">
<dt>case (srcId, destId) =&gt;</dt><dd><p>leftRightTuple(srcId, RightNodeType.SpamReportUser, Noun.UserId(destId), 1.0)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getUserTopicFollowGraph(</dt><dd><p>topicUserFollowedByEdges: SCollection[(TopicId, UserId)]</p>
</dd>
<dt>): SCollection[(LeftNode, RightNodeWithEdgeWeight)] = {</dt><dd><dl class="simple">
<dt>topicUserFollowedByEdges.map {</dt><dd><dl class="simple">
<dt>case (topicId, userId) =&gt;</dt><dd><p>leftRightTuple(userId, RightNodeType.FollowTopic, Noun.TopicId(topicId), 1.0)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getUserSignUpCountryGraph(</dt><dd><p>userSignUpCountryEdges: SCollection[(UserId, Country)]</p>
</dd>
<dt>): SCollection[(LeftNode, RightNodeWithEdgeWeight)] = {</dt><dd><dl class="simple">
<dt>userSignUpCountryEdges.map {</dt><dd><dl class="simple">
<dt>case (userId, country) =&gt;</dt><dd><p>leftRightTuple(userId, RightNodeType.SignUpCountry, Noun.Country(country), 1.0)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getMagicRecsNotifOpenOrClickTweetsGraph(</dt><dd><p>userMRNotifOpenOrClickEvents: SCollection[MagicRecsNotificationLite]</p>
</dd>
<dt>): SCollection[(LeftNode, RightNodeWithEdgeWeight)] = {</dt><dd><dl>
<dt>userMRNotifOpenOrClickEvents.flatMap { entry =&gt;</dt><dd><dl class="simple">
<dt>for {</dt><dd><p>userId &lt;- entry.targetUserId
tweetId &lt;- entry.tweetId</p>
</dd>
<dt>} yield {</dt><dd><p>leftRightTuple(userId, RightNodeType.NotifOpenOrClickTweet, Noun.TweetId(tweetId), 1.0)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getUserConsumedLanguagesGraph(</dt><dd><p>userConsumedLanguageEdges: SCollection[(UserId, Seq[(Language, Double)])]</p>
</dd>
<dt>): SCollection[(LeftNode, RightNodeWithEdgeWeight)] = {</dt><dd><dl>
<dt>userConsumedLanguageEdges.flatMap {</dt><dd><dl>
<dt>case (userId, langWithWeights) =&gt;</dt><dd><dl class="simple">
<dt>langWithWeights.map {</dt><dd><dl class="simple">
<dt>case (lang, weight) =&gt;</dt><dd><p>leftRightTuple(userId, RightNodeType.ConsumedLanguage, Noun.Language(lang), 1.0)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getSearchGraph(</dt><dd><p>userSearchQueryEdges: SCollection[(UserId, String)]</p>
</dd>
<dt>): SCollection[(LeftNode, RightNodeWithEdgeWeight)] = {</dt><dd><dl class="simple">
<dt>userSearchQueryEdges.map {</dt><dd><dl class="simple">
<dt>case (userId, query) =&gt;</dt><dd><p>leftRightTuple(userId, RightNodeType.SearchQuery, Noun.Query(query), 1.0)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getUserTweetInteractionGraph(</dt><dd><p>tweetInteractionEvents: SCollection[InteractionEvent],</p>
</dd>
<dt>): SCollection[(LeftNode, RightNodeWithEdgeWeight)] = {</dt><dd><dl>
<dt>val userTweetInteractionsByType: SCollection[((UserId, TweetId), RightNodeType)] =</dt><dd><dl>
<dt>tweetInteractionEvents</dt><dd><dl>
<dt>.flatMap { event =&gt;</dt><dd><p>val referenceTweet: Option[ReferenceTweet] = event.referenceTweet
val targetId: Long = event.targetId
val userId: Long = event.engagingUserId</p>
<p>//  To find the id of the tweet that was interacted with
//  For likes, this is the targetId; for retweet or reply, it is the referenceTweet’s id
//  One thing to note is that for likes, referenceTweet is empty
val (tweetIdOpt, rightNodeTypeOpt) = {</p>
<blockquote>
<div><dl>
<dt>event.interactionType match {</dt><dd><dl>
<dt>case Some(InteractionType.Favorite) =&gt;</dt><dd><p>// Only allow favorites on original tweets, not retweets, to avoid double-counting
// because we have retweet-type tweets in the data source as well
(</p>
<blockquote>
<div><dl class="simple">
<dt>if (referenceTweet.isEmpty) {</dt><dd><p>Some(targetId)</p>
</dd>
</dl>
<p>} else None,
Some(RightNodeType.FavTweet))</p>
</div></blockquote>
</dd>
<dt>case Some(InteractionType.Reply) =&gt;</dt><dd><p>(referenceTweet.map(_.tweetId), Some(RightNodeType.ReplyTweet))</p>
</dd>
<dt>case Some(InteractionType.Retweet) =&gt;</dt><dd><p>(referenceTweet.map(_.tweetId), Some(RightNodeType.RetweetTweet))</p>
</dd>
</dl>
<p>case _ =&gt; (None, None)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
for {</p>
<blockquote>
<div><p>tweetId &lt;- tweetIdOpt
rightNodeType &lt;- rightNodeTypeOpt</p>
</div></blockquote>
<dl class="simple">
<dt>} yield {</dt><dd><p>((userId, tweetId), rightNodeType)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
<dt>userTweetInteractionsByType</dt><dd><p>.mapValues(Set(_))
.sumByKey
.flatMap {</p>
<blockquote>
<div><dl>
<dt>case ((userId, tweetId), rightNodeTypeSet) =&gt;</dt><dd><dl class="simple">
<dt>rightNodeTypeSet.map { rightNodeType =&gt;</dt><dd><p>leftRightTuple(userId, rightNodeType, Noun.TweetId(tweetId), 1.0)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getTopKRightNounsWithFrequencies(</dt><dd><p>fullGraph: SCollection[(LeftNode, RightNodeWithEdgeWeight)],
topKConfig: Map[RightNodeType, Int],
minFrequency: Int,</p>
</dd>
<dt>): SCollection[(RightNodeType, Seq[(Noun, Double)])] = {</dt><dd><p>val maxAcrossRightNounType: Int = topKConfig.valuesIterator.max</p>
<dl>
<dt>fullGraph</dt><dd><dl class="simple">
<dt>.map {</dt><dd><dl class="simple">
<dt>case (leftNode, rightNodeWithWeight) =&gt;</dt><dd><p>(rightNodeWithWeight.rightNode, 1.0)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.sumByKey
.filter(_._2 &gt;= minFrequency)
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (rightNode, freq) =&gt;</dt><dd><p>(rightNode.rightNodeType, (rightNode.noun, freq))</p>
</dd>
</dl>
</div></blockquote>
<p>}
.topByKey(maxAcrossRightNounType)(Ordering.by(_._2))
.map {</p>
<blockquote>
<div><dl>
<dt>case (rightNodeType, nounsListWithFreq) =&gt;</dt><dd><dl class="simple">
<dt>val truncatedList = nounsListWithFreq.toSeq</dt><dd><p>.sortBy(-_._2)
.take(topKConfig.getOrElse(rightNodeType, NumTopNounsForUnknownRightNodeType))</p>
</dd>
</dl>
<p>(rightNodeType, truncatedList)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getTruncatedGraph(</dt><dd><p>fullGraph: SCollection[(LeftNode, RightNodeWithEdgeWeight)],
topKWithFrequency: SCollection[(RightNodeType, Seq[(Noun, Double)])]</p>
</dd>
<dt>): SCollection[(LeftNode, RightNodeWithEdgeWeight)] = {</dt><dd><dl>
<dt>val topNouns = topKWithFrequency</dt><dd><dl>
<dt>.flatMap {</dt><dd><dl>
<dt>case (rightNodeType, nounsList) =&gt;</dt><dd><dl>
<dt>nounsList</dt><dd><dl class="simple">
<dt>.map {</dt><dd><dl class="simple">
<dt>case (nounVal, aggregatedFrequency) =&gt;</dt><dd><p>RightNode(rightNodeType, nounVal)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}.map(nouns =&gt; (nouns, ()))</p>
</dd>
<dt>fullGraph</dt><dd><dl class="simple">
<dt>.map {</dt><dd><dl class="simple">
<dt>case (leftNode, rightNodeWithWeight) =&gt;</dt><dd><p>(rightNodeWithWeight.rightNode, (leftNode, rightNodeWithWeight))</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.hashJoin(topNouns)
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (rightNode, ((left, rightNodeWithWeight), _)) =&gt;</dt><dd><p>(left, rightNodeWithWeight)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def buildEmployeeGraph(</dt><dd><p>graph: SCollection[(LeftNode, RightNodeWithEdgeWeight)]</p>
</dd>
<dt>): SCollection[(LeftNode, RightNodeWithEdgeWeight)] = {</dt><dd><p>val employeeIds = SampledEmployeeIds
graph</p>
<blockquote>
<div><dl class="simple">
<dt>.collect {</dt><dd><dl class="simple">
<dt>case (LeftNode.UserId(userId), rightNodeWithWeight) if employeeIds.contains(userId) =&gt;</dt><dd><p>(LeftNode.UserId(userId), rightNodeWithWeight)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def configurePipeline(sc: ScioContext, opts: DateRangeOptions): Unit = {</dt><dd><p>// Define the implicit ScioContext to read datasets from ExternalDataSources
implicit def scioContext: ScioContext = sc</p>
<p>// DAL.Environment variable for WriteExecs
val dalEnv = if (isAdhoc) DAL.Environment.Dev else DAL.Environment.Prod</p>
<p>// Define date intervals
val interval_7days =</p>
<blockquote>
<div><p>new Interval(opts.interval.getEnd.minusWeeks(1), opts.interval.getEnd.minusMillis(1))</p>
</div></blockquote>
<dl>
<dt>val interval_14days =</dt><dd><p>new Interval(opts.interval.getEnd.minusWeeks(2), opts.interval.getEnd.minusMillis(1))</p>
</dd>
<dt>/*</dt><dd><ul class="simple">
<li><p>Dataset read operations</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
</dl>
<p>// Get list of valid UserIds - to filter out deactivated or suspended user accounts
val validUsers = getValidUsers(ExternalDataSources.userSource(Duration.fromDays(7)))</p>
<p>// ieSource tweet engagements data for tweet favs, replies, retweets - from last 14 days
val tweetSource = ExternalDataSources.ieSourceTweetEngagementsSource(interval_14days)</p>
<p>// Read TFlock datasets
val flockFollowSource = ExternalDataSources.flockFollowSource(Duration.fromDays(7))
val flockBlockSource = ExternalDataSources.flockBlockSource(Duration.fromDays(7))
val flockReportAsAbuseSource =</p>
<blockquote>
<div><p>ExternalDataSources.flockReportAsAbuseSource(Duration.fromDays(7))</p>
</div></blockquote>
<dl class="simple">
<dt>val flockReportAsSpamSource =</dt><dd><p>ExternalDataSources.flockReportAsSpamSource(Duration.fromDays(7))</p>
</dd>
</dl>
<p>// user-user fav edges
val userUserFavSource = ExternalDataSources.userUserFavSource(Duration.fromDays(14))
val userUserFavEdges = getFavEdges(userUserFavSource, HalfLifeInDaysForFavScore)</p>
<p>// user-user follow edges
val userUserFollowEdges = filterInvalidUsers(flockFollowSource, validUsers)</p>
<p>// user-user block edges
val userUserBlockEdges = filterInvalidUsers(flockBlockSource, validUsers)</p>
<p>// user-user abuse report edges
val userUserAbuseReportEdges = filterInvalidUsers(flockReportAsAbuseSource, validUsers)</p>
<p>// user-user spam report edges
val userUserSpamReportEdges = filterInvalidUsers(flockReportAsSpamSource, validUsers)</p>
<p>// user-signup country edges
val userSignUpCountryEdges = ExternalDataSources</p>
<blockquote>
<div><p>.userCountrySource(Duration.fromDays(7))</p>
</div></blockquote>
<p>// user-consumed language edges
val userConsumedLanguageEdges =</p>
<blockquote>
<div><p>ExternalDataSources.inferredUserConsumedLanguageSource(Duration.fromDays(7))</p>
</div></blockquote>
<p>// user-topic follow edges
val topicUserFollowedByEdges =</p>
<blockquote>
<div><p>ExternalDataSources.topicFollowGraphSource(Duration.fromDays(7))</p>
</div></blockquote>
<p>// user-MRNotifOpenOrClick events from last 7 days
val userMRNotifOpenOrClickEvents =</p>
<blockquote>
<div><p>ExternalDataSources.magicRecsNotficationOpenOrClickEventsSource(interval_7days)</p>
</div></blockquote>
<p>// user-searchQuery strings from last 7 days
val userSearchQueryEdges =</p>
<blockquote>
<div><p>ExternalDataSources.adaptiveSearchScribeLogsSource(interval_7days)</p>
</div></blockquote>
<dl>
<dt>/*</dt><dd><ul class="simple">
<li><p>Generate the full graph</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>val fullGraph =</dt><dd><dl class="simple">
<dt>getUserTweetInteractionGraph(tweetSource) ++</dt><dd><p>getUserFavGraph(userUserFavEdges) ++
getUserFollowGraph(userUserFollowEdges) ++
getUserBlockGraph(userUserBlockEdges) ++
getUserAbuseReportGraph(userUserAbuseReportEdges) ++
getUserSpamReportGraph(userUserSpamReportEdges) ++
getUserSignUpCountryGraph(userSignUpCountryEdges) ++
getUserConsumedLanguagesGraph(userConsumedLanguageEdges) ++
getUserTopicFollowGraph(topicUserFollowedByEdges) ++
getMagicRecsNotifOpenOrClickTweetsGraph(userMRNotifOpenOrClickEvents) ++
getSearchGraph(userSearchQueryEdges)</p>
</dd>
</dl>
</dd>
</dl>
<p>// Get Top K RightNodes
val topKRightNodes: SCollection[(RightNodeType, Seq[(Noun, Double)])] =</p>
<blockquote>
<div><dl class="simple">
<dt>getTopKRightNounsWithFrequencies(</dt><dd><p>fullGraph,
TopKConfig,
GlobalDefaultMinFrequencyOfRightNodeType)</p>
</dd>
</dl>
</div></blockquote>
<p>// key transformation - topK nouns, keyed by the RightNodeNounType
val topKNounsKeyedByType: SCollection[(RightNodeTypeStruct, NounWithFrequencyList)] =</p>
<blockquote>
<div><dl>
<dt>topKRightNodes</dt><dd><dl>
<dt>.map {</dt><dd><dl>
<dt>case (rightNodeType, rightNounsWithScoresList) =&gt;</dt><dd><dl>
<dt>val nounsListWithFrequency: Seq[NounWithFrequency] = rightNounsWithScoresList</dt><dd><dl class="simple">
<dt>.map {</dt><dd><dl class="simple">
<dt>case (noun, aggregatedFrequency) =&gt;</dt><dd><p>NounWithFrequency(noun, aggregatedFrequency)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>(RightNodeTypeStruct(rightNodeType), NounWithFrequencyList(nounsListWithFrequency))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>// Get Truncated graph based on the top K RightNodes
val truncatedGraph: SCollection[(LeftNode, RightNodeWithEdgeWeight)] =</p>
<blockquote>
<div><p>getTruncatedGraph(fullGraph, topKRightNodes)</p>
</div></blockquote>
<p>// key transformations - truncated graph, keyed by LeftNode
// Note: By wrapping and unwrapping with the LeftNode.UserId, we don’t have to deal
// with defining our own customer ordering for LeftNode type
val truncatedGraphKeyedBySrc: SCollection[(LeftNode, RightNodeWithEdgeWeightList)] =</p>
<blockquote>
<div><dl>
<dt>truncatedGraph</dt><dd><dl class="simple">
<dt>.collect {</dt><dd><dl class="simple">
<dt>case (LeftNode.UserId(userId), rightNodeWithWeight) =&gt;</dt><dd><p>userId -&gt; List(rightNodeWithWeight)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.sumByKey
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (userId, rightNodeWithWeightList) =&gt;</dt><dd><p>(LeftNode.UserId(userId), RightNodeWithEdgeWeightList(rightNodeWithWeightList))</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>// WriteExecs
// Write TopK RightNodes to DAL - save all the top K nodes for the clustering step
topKNounsKeyedByType</p>
<blockquote>
<div><dl class="simple">
<dt>.map {</dt><dd><dl class="simple">
<dt>case (engagementType, rightList) =&gt;</dt><dd><p>KeyVal(engagementType, rightList)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.saveAsCustomOutput(</p>
<blockquote>
<div><p>name = “WriteTopKNouns”,
DAL.writeVersionedKeyVal(</p>
<blockquote>
<div><p>topKRightNounsKeyValDataset,
PathLayout.VersionedPath(prefix =</p>
<blockquote>
<div><p>rootMHPath + topKRightNounsOutputDir),</p>
</div></blockquote>
<p>instant = Instant.ofEpochMilli(opts.interval.getEndMillis - 1L),
environmentOverride = dalEnv,</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>// Write TopK RightNodes to DAL - only take TopKRightNounsForMHDump RightNodes for MH dump
topKNounsKeyedByType</p>
<blockquote>
<div><dl>
<dt>.map {</dt><dd><dl>
<dt>case (engagementType, rightList) =&gt;</dt><dd><dl class="simple">
<dt>val rightListMH =</dt><dd><p>NounWithFrequencyList(rightList.nounWithFrequencyList.take(TopKRightNounsForMHDump))</p>
</dd>
</dl>
<p>KeyVal(engagementType, rightListMH)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.saveAsCustomOutput(</p>
<blockquote>
<div><p>name = “WriteTopKNounsToMHForDebugger”,
DAL.writeVersionedKeyVal(</p>
<blockquote>
<div><p>topKRightNounsMHKeyValDataset,
PathLayout.VersionedPath(prefix =</p>
<blockquote>
<div><p>rootMHPath + topKRightNounsMHOutputDir),</p>
</div></blockquote>
<p>instant = Instant.ofEpochMilli(opts.interval.getEndMillis - 1L),
environmentOverride = dalEnv,</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>// Write truncated graph (MultiTypeGraphTopKForRightNodes) to DAL in KeyVal format
truncatedGraphKeyedBySrc</p>
<blockquote>
<div><dl>
<dt>.map {</dt><dd><dl class="simple">
<dt>case (leftNode, rightNodeWithWeightList) =&gt;</dt><dd><p>KeyVal(leftNode, rightNodeWithWeightList)</p>
</dd>
</dl>
</dd>
<dt>}.saveAsCustomOutput(</dt><dd><p>name = “WriteTruncatedMultiTypeGraph”,
DAL.writeVersionedKeyVal(</p>
<blockquote>
<div><p>truncatedMultiTypeGraphKeyValDataset,
PathLayout.VersionedPath(prefix =</p>
<blockquote>
<div><p>rootMHPath + truncatedMultiTypeGraphMHOutputDir),</p>
</div></blockquote>
<p>instant = Instant.ofEpochMilli(opts.interval.getEndMillis - 1L),
environmentOverride = dalEnv,</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>// Write truncated graph (MultiTypeGraphTopKForRightNodes) to DAL in thrift format
truncatedGraph</p>
<blockquote>
<div><dl>
<dt>.map {</dt><dd><dl class="simple">
<dt>case (leftNode, rightNodeWithWeight) =&gt;</dt><dd><p>MultiTypeGraphEdge(leftNode, rightNodeWithWeight)</p>
</dd>
</dl>
</dd>
<dt>}.saveAsCustomOutput(</dt><dd><p>name = “WriteTruncatedMultiTypeGraphThrift”,
DAL.writeSnapshot(</p>
<blockquote>
<div><p>multiTypeGraphTopKForRightNodesSnapshotDataset,
PathLayout.FixedPath(rootThriftPath + truncatedMultiTypeGraphThriftOutputDir),
Instant.ofEpochMilli(opts.interval.getEndMillis - 1L),
DiskFormat.Thrift(),
environmentOverride = dalEnv</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>// Write full graph to DAL
fullGraph</p>
<blockquote>
<div><dl class="simple">
<dt>.map {</dt><dd><dl class="simple">
<dt>case (leftNode, rightNodeWithWeight) =&gt;</dt><dd><p>MultiTypeGraphEdge(leftNode, rightNodeWithWeight)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.saveAsCustomOutput(</p>
<blockquote>
<div><p>name = “WriteFullMultiTypeGraph”,
DAL.writeSnapshot(</p>
<blockquote>
<div><p>fullMultiTypeGraphSnapshotDataset,
PathLayout.FixedPath(rootThriftPath + fullMultiTypeGraphThriftOutputDir),
Instant.ofEpochMilli(opts.interval.getEndMillis - 1L),
DiskFormat.Thrift(),
environmentOverride = dalEnv</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../_sources/src/scala/com/twitter/simclusters_v2/scio/multi_type_graph/assemble_multi_type_graph/AssembleMultiTypeGraphScioBaseApp.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>