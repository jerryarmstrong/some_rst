<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../" id="documentation_options" src="../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.visibility.rules</p>
<p>import com.twitter.contenthealth.sensitivemediasettings.thriftscala.SensitiveMediaSettingsLevel
import com.twitter.contenthealth.toxicreplyfilter.thriftscala.FilterState
import com.twitter.conversions.DurationOps._
import com.twitter.gizmoduck.thriftscala.Label
import com.twitter.gizmoduck.thriftscala.MuteSurface
import com.twitter.health.platform_manipulation.stcm_tweet_holdback.StcmTweetHoldback
import com.twitter.search.common.constants.thriftscala.ThriftQuerySource
import com.twitter.snowflake.id.SnowflakeId
import com.twitter.takedown.util.TakedownReasons
import com.twitter.takedown.util.{TakedownReasons =&gt; TakedownReasonsUtil}
import com.twitter.timelines.configapi.EnumParam
import com.twitter.timelines.configapi.Param
import com.twitter.timelines.configapi.Params
import com.twitter.tseng.withholding.thriftscala.TakedownReason
import com.twitter.util.Duration
import com.twitter.util.Time
import com.twitter.visibility.configapi.params.RuleParam
import com.twitter.visibility.configapi.params.RuleParams
import com.twitter.visibility.features.AuthorIsSuspended
import com.twitter.visibility.features.CardIsPoll
import com.twitter.visibility.features.CardUriHost
import com.twitter.visibility.features.SearchQuerySource
import com.twitter.visibility.features._
import com.twitter.visibility.features.{AuthorBlocksOuterAuthor =&gt; AuthorBlocksOuterAuthorFeature}
import com.twitter.visibility.features.{AuthorBlocksViewer =&gt; AuthorBlocksViewerFeature}
import com.twitter.visibility.features.{</p>
<blockquote>
<div><p>CommunityTweetAuthorIsRemoved =&gt; CommunityTweetAuthorIsRemovedFeature</p>
</div></blockquote>
<p>}
import com.twitter.visibility.features.{</p>
<blockquote>
<div><p>CommunityTweetCommunityNotFound =&gt; CommunityTweetCommunityNotFoundFeature</p>
</div></blockquote>
<p>}
import com.twitter.visibility.features.{</p>
<blockquote>
<div><p>CommunityTweetCommunityDeleted =&gt; CommunityTweetCommunityDeletedFeature</p>
</div></blockquote>
<p>}
import com.twitter.visibility.features.{</p>
<blockquote>
<div><p>CommunityTweetCommunitySuspended =&gt; CommunityTweetCommunitySuspendedFeature</p>
</div></blockquote>
<p>}
import com.twitter.visibility.features.{</p>
<blockquote>
<div><p>CommunityTweetCommunityVisible =&gt; CommunityTweetCommunityVisibleFeature</p>
</div></blockquote>
<p>}
import com.twitter.visibility.features.{CommunityTweetIsHidden =&gt; CommunityTweetIsHiddenFeature}
import com.twitter.visibility.features.{</p>
<blockquote>
<div><p>NotificationIsOnCommunityTweet =&gt; NotificationIsOnCommunityTweetFeature</p>
</div></blockquote>
<p>}
import com.twitter.visibility.features.{OuterAuthorFollowsAuthor =&gt; OuterAuthorFollowsAuthorFeature}
import com.twitter.visibility.features.{OuterAuthorIsInnerAuthor =&gt; OuterAuthorIsInnerAuthorFeature}
import com.twitter.visibility.features.{TweetHasCard =&gt; TweetHasCardFeature}
import com.twitter.visibility.features.{TweetHasMedia =&gt; TweetHasMediaFeature}
import com.twitter.visibility.features.{TweetIsCommunityTweet =&gt; TweetIsCommunityTweetFeature}
import com.twitter.visibility.features.{TweetIsEditTweet =&gt; TweetIsEditTweetFeature}
import com.twitter.visibility.features.{TweetIsStaleTweet =&gt; TweetIsStaleTweetFeature}
import com.twitter.visibility.features.{ViewerBlocksAuthor =&gt; ViewerBlocksAuthorFeature}
import com.twitter.visibility.features.{ViewerIsCommunityAdmin =&gt; ViewerIsCommunityAdminFeature}
import com.twitter.visibility.features.{ViewerIsCommunityMember =&gt; ViewerIsCommunityMemberFeature}
import com.twitter.visibility.features.{</p>
<blockquote>
<div><p>ViewerIsCommunityModerator =&gt; ViewerIsCommunityModeratorFeature</p>
</div></blockquote>
<p>}
import com.twitter.visibility.features.{</p>
<blockquote>
<div><p>ViewerIsInternalCommunitiesAdmin =&gt; ViewerIsInternalCommunitiesAdminFeature</p>
</div></blockquote>
<p>}
import com.twitter.visibility.features.{ViewerMutesAuthor =&gt; ViewerMutesAuthorFeature}
import com.twitter.visibility.features.{</p>
<blockquote>
<div><p>ViewerMutesRetweetsFromAuthor =&gt; ViewerMutesRetweetsFromAuthorFeature</p>
</div></blockquote>
<p>}
import com.twitter.visibility.models.ViolationLevel
import com.twitter.visibility.models._
import com.twitter.visibility.rules.Result.FoundCardUriRootDomain
import com.twitter.visibility.rules.Result.FoundMediaLabel
import com.twitter.visibility.rules.Result.FoundSpaceLabel
import com.twitter.visibility.rules.Result.FoundSpaceLabelWithScoreAboveThreshold
import com.twitter.visibility.rules.Result.FoundTweetLabel
import com.twitter.visibility.rules.Result.FoundTweetLabelForPerspectivalUser
import com.twitter.visibility.rules.Result.FoundTweetLabelWithLanguageIn
import com.twitter.visibility.rules.Result.FoundTweetLabelWithLanguageScoreAboveThreshold
import com.twitter.visibility.rules.Result.FoundTweetLabelWithScoreAboveThreshold
import com.twitter.visibility.rules.Result.FoundTweetViolationOfLevel
import com.twitter.visibility.rules.Result.FoundTweetViolationOfSomeLevel
import com.twitter.visibility.rules.Result.FoundUserLabel
import com.twitter.visibility.rules.Result.FoundUserRole
import com.twitter.visibility.rules.Result.HasQuerySource
import com.twitter.visibility.rules.Result.HasTweetTimestampAfterCutoff
import com.twitter.visibility.rules.Result.HasTweetTimestampAfterOffset
import com.twitter.visibility.rules.Result.HasTweetTimestampBeforeCutoff
import com.twitter.visibility.rules.Result.ParamWasTrue
import com.twitter.visibility.rules.Result.Result
import com.twitter.visibility.rules.Result.Satisfied
import com.twitter.visibility.rules.Result.Unsatisfied
import com.twitter.visibility.util.NamingUtils
import com.twitter.visibility.{features =&gt; feats}</p>
<p>sealed trait PreFilterResult
case object Filtered extends PreFilterResult
case object NeedsFullEvaluation extends PreFilterResult
case object NotFiltered extends PreFilterResult</p>
<dl>
<dt>sealed trait Condition {</dt><dd><p>lazy val name: String = NamingUtils.getFriendlyName(this)
def features: Set[Feature[_]]
def optionalFeatures: Set[Feature[_]]</p>
<dl>
<dt>def preFilter(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): PreFilterResult = {</dt><dd><dl>
<dt>if (features.forall(featureMap.contains)) {</dt><dd><dl class="simple">
<dt>if (apply(evaluationContext, featureMap).asBoolean) {</dt><dd><p>NotFiltered</p>
</dd>
<dt>} else {</dt><dd><p>Filtered</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>NeedsFullEvaluation</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>def apply(evaluationContext: EvaluationContext, featureMap: Map[Feature[_], _]): Result</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>trait PreFilterOnOptionalFeatures extends Condition {</dt><dd><dl>
<dt>override def preFilter(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): PreFilterResult =</dt><dd><dl>
<dt>if ((features ++ optionalFeatures).forall(featureMap.contains)) {</dt><dd><dl class="simple">
<dt>if (apply(evaluationContext, featureMap).asBoolean) {</dt><dd><p>NotFiltered</p>
</dd>
<dt>} else {</dt><dd><p>Filtered</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>NeedsFullEvaluation</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>trait HasSafetyLabelType {</dt><dd><p>val labelTypes: Set[SafetyLabelType]
def hasLabelType(labelType: SafetyLabelType): Boolean = labelTypes.contains(labelType)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>sealed trait HasNestedConditions extends HasSafetyLabelType {</dt><dd><p>val conditions: Seq[Condition]
override lazy val labelTypes: Set[SafetyLabelType] = conditions</p>
<blockquote>
<div><dl class="simple">
<dt>.collect {</dt><dd><p>case lt: HasSafetyLabelType =&gt; lt.labelTypes</p>
</dd>
</dl>
<p>}.flatten.toSet</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>object Result {</dt><dd><p>sealed trait ConditionReason
case object FoundInnerQuotedTweet extends ConditionReason
case object FoundTweetViolationOfSomeLevel extends ConditionReason
case class FoundTweetViolationOfLevel(level: ViolationLevel) extends ConditionReason
case class FoundTweetLabel(label: TweetSafetyLabelType) extends ConditionReason
case class FoundSpaceLabel(label: SpaceSafetyLabelType) extends ConditionReason
case class FoundMediaLabel(label: MediaSafetyLabelType) extends ConditionReason
case class FoundTweetLabelForPerspectivalUser(label: TweetSafetyLabelType) extends ConditionReason
case class FoundTweetLabelWithLanguageScoreAboveThreshold(</p>
<blockquote>
<div><p>label: TweetSafetyLabelType,
languagesToScoreThresholds: Map[String, Double])</p>
<blockquote>
<div><p>extends ConditionReason</p>
</div></blockquote>
</div></blockquote>
<dl>
<dt>case class FoundTweetLabelWithScoreAboveThreshold(label: TweetSafetyLabelType, threshold: Double)</dt><dd><p>extends ConditionReason</p>
</dd>
<dt>case class FoundTweetLabelWithLanguageIn(</dt><dd><p>safetyLabelType: TweetSafetyLabelType,
languages: Set[String])</p>
<blockquote>
<div><p>extends ConditionReason</p>
</div></blockquote>
</dd>
<dt>case class FoundTweetSafetyLabelWithPredicate(safetyLabelType: TweetSafetyLabelType, name: String)</dt><dd><p>extends ConditionReason</p>
</dd>
</dl>
<p>case class FoundUserLabel(label: UserLabelValue) extends ConditionReason
case class FoundMutedKeyword(keyword: String) extends ConditionReason
case object HasTweetTimestampAfterCutoff extends ConditionReason
case object HasTweetTimestampAfterOffset extends ConditionReason
case object HasTweetTimestampBeforeCutoff extends ConditionReason
case class IsTweetReplyToParentTweetBeforeDuration(duration: Duration) extends ConditionReason
case class IsTweetReplyToRootTweetBeforeDuration(duration: Duration) extends ConditionReason
case class HasQuerySource(querySource: ThriftQuerySource) extends ConditionReason
case class FoundUserRole(role: String) extends ConditionReason
case class ViewerInHrcj(jurisdiction: String) extends ConditionReason
case class ViewerOrRequestInCountry(country: String) extends ConditionReason
case class ViewerAgeInYears(ageInYears: Int) extends ConditionReason
case object NoViewerAge extends ConditionReason
case class ParamWasTrue(param: Param[Boolean]) extends ConditionReason
case class FoundCardUriRootDomain(domain: String) extends ConditionReason
case object Unknown extends ConditionReason</p>
<dl class="simple">
<dt>sealed trait Result {</dt><dd><p>def asBoolean: Boolean</p>
</dd>
</dl>
<p>}</p>
<p>val SatisfiedResult: Result = Satisfied()</p>
<dl class="simple">
<dt>case class Satisfied(reason: ConditionReason = Unknown) extends Result {</dt><dd><p>override val asBoolean: Boolean = true</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>case class Unsatisfied(condition: Condition) extends Result {</dt><dd><p>override val asBoolean: Boolean = false</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def fromMutedKeyword(mutedKeyword: MutedKeyword, unsatisfied: Unsatisfied): Result = {</dt><dd><dl class="simple">
<dt>mutedKeyword match {</dt><dd><p>case MutedKeyword(Some(keyword)) =&gt; Satisfied(FoundMutedKeyword(keyword))
case _ =&gt; unsatisfied</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>case class FoundSpaceLabelWithScoreAboveThreshold(label: SpaceSafetyLabelType, threshold: Double)</dt><dd><p>extends ConditionReason</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>object Condition {</p>
<blockquote>
<div><dl>
<dt>abstract class BooleanFeatureCondition(feature: Feature[Boolean]) extends Condition {</dt><dd><p>override val features: Set[Feature[_]] = Set(feature)
override val optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result =</dt><dd><dl class="simple">
<dt>if (featureMap(feature).asInstanceOf[Boolean]) {</dt><dd><p>Result.SatisfiedResult</p>
</dd>
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class ParamIsTrue(param: Param[Boolean]) extends Condition with HasParams {</dt><dd><p>override lazy val name: String = s”ParamIsTrue(${NamingUtils.getFriendlyName(param)})”
override val features: Set[Feature[_]] = Set.empty
override val optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>private val UnsatisfiedResult = Unsatisfied(this)
private val SatisfiedResult = Satisfied(ParamWasTrue(param))</p>
<p>override val params: Set[Param[_]] = Set(param)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result =</dt><dd><dl class="simple">
<dt>if (evaluationContext.params(param)) {</dt><dd><p>SatisfiedResult</p>
</dd>
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case object Never extends Condition {</dt><dd><p>override lazy val name: String = s”””Never”””
override val features: Set[Feature[_]] = Set.empty
override val optionalFeatures: Set[Feature[_]] = Set.empty
private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl class="simple">
<dt>override def preFilter(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): PreFilterResult = {</dt><dd><p>NeedsFullEvaluation</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result =</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>class BooleanCondition(value: Boolean) extends Condition {</dt><dd><p>override lazy val name: String = s”””${if (value) “True” else “False”}”””
override val features: Set[Feature[_]] = Set.empty
override val optionalFeatures: Set[Feature[_]] = Set.empty
private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result =</dt><dd><dl class="simple">
<dt>value match {</dt><dd><p>case true =&gt; Result.SatisfiedResult
case false =&gt; UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>case object True extends BooleanCondition(true)
case object False extends BooleanCondition(false)</p>
<dl>
<dt>abstract class ContentTakendownInViewerCountry(takedownFeature: Feature[Seq[TakedownReason]])</dt><dd><blockquote>
<div><p>extends Condition {</p>
</div></blockquote>
<p>override val features: Set[Feature[_]] = Set(takedownFeature)
override val optionalFeatures: Set[Feature[_]] = Set(RequestCountryCode)</p>
<p>private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val requestCountryCode = featureMap.get(RequestCountryCode).asInstanceOf[Option[String]]
val takedownReasons = featureMap(takedownFeature).asInstanceOf[Seq[TakedownReason]]
if (TakedownReasonsUtil.isTakenDownIn(requestCountryCode, takedownReasons)) {</p>
<blockquote>
<div><p>Result.SatisfiedResult</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>case object TweetTakendownInViewerCountry</dt><dd><p>extends ContentTakendownInViewerCountry(TweetTakedownReasons)</p>
</dd>
<dt>case object AuthorTakendownInViewerCountry</dt><dd><p>extends ContentTakendownInViewerCountry(AuthorTakedownReasons)</p>
</dd>
</dl>
<p>case object SuspendedAuthor extends BooleanFeatureCondition(AuthorIsSuspended)</p>
<p>case object SuspendedViewer extends BooleanFeatureCondition(ViewerIsSuspended)</p>
<p>case object DeactivatedViewer extends BooleanFeatureCondition(ViewerIsDeactivated)</p>
<p>case object UnavailableAuthor extends BooleanFeatureCondition(AuthorIsUnavailable)</p>
<p>case object IsVerifiedCrawlerViewer extends BooleanFeatureCondition(RequestIsVerifiedCrawler)</p>
<dl>
<dt>case object LoggedOutViewer extends Condition {</dt><dd><p>override val features: Set[Feature[_]] = Set.empty
override val optionalFeatures: Set[Feature[_]] = Set(ViewerId)</p>
<p>private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl class="simple">
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result =</dt><dd><p>if (featureMap.contains(ViewerId)) UnsatisfiedResult else Result.SatisfiedResult</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case object IsSelfQuote extends Condition {</dt><dd><p>override val features: Set[Feature[_]] = Set(AuthorId, OuterAuthorId)
override val optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val authorIds = featureMap(AuthorId).asInstanceOf[Set[Long]]
val outerAuthorId = featureMap(OuterAuthorId).asInstanceOf[Long]
if (authorIds.contains(outerAuthorId)) {</p>
<blockquote>
<div><p>Result.SatisfiedResult</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case object ViewerIsAuthor extends Condition {</dt><dd><p>override val features: Set[Feature[_]] = Set(AuthorId)
override val optionalFeatures: Set[Feature[_]] = Set(ViewerId)</p>
<p>private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result =</dt><dd><dl>
<dt>if (featureMap.contains(ViewerId)) {</dt><dd><p>val authorIds = featureMap(AuthorId).asInstanceOf[Set[Long]]
val viewerId = featureMap(ViewerId).asInstanceOf[Long]
if (authorIds.contains(viewerId)) {</p>
<blockquote>
<div><p>Result.SatisfiedResult</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case object NonAuthorViewer extends Condition {</dt><dd><p>override val features: Set[Feature[_]] = Set(AuthorId)
override val optionalFeatures: Set[Feature[_]] = Set(ViewerId)</p>
<p>private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result =</dt><dd><dl>
<dt>if (featureMap.contains(ViewerId)) {</dt><dd><p>val authorIds = featureMap(AuthorId).asInstanceOf[Set[Long]]
val viewerId = featureMap(ViewerId).asInstanceOf[Long]
if (authorIds.contains(viewerId)) {</p>
<blockquote>
<div><p>UnsatisfiedResult</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>Result.SatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>Result.SatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>case object ViewerFollowsAuthorOfFosnrViolatingTweet</dt><dd><p>extends BooleanFeatureCondition(ViewerFollowsAuthorOfViolatingTweet)</p>
</dd>
<dt>case object ViewerDoesNotFollowAuthorOfFosnrViolatingTweet</dt><dd><p>extends BooleanFeatureCondition(ViewerDoesNotFollowAuthorOfViolatingTweet)</p>
</dd>
</dl>
<p>case object ViewerDoesFollowAuthor extends BooleanFeatureCondition(ViewerFollowsAuthor)</p>
<p>case object AuthorDoesFollowViewer extends BooleanFeatureCondition(AuthorFollowsViewer)</p>
<p>case object AuthorBlocksViewer extends BooleanFeatureCondition(AuthorBlocksViewerFeature)</p>
<p>case object ViewerBlocksAuthor extends BooleanFeatureCondition(ViewerBlocksAuthorFeature)</p>
<p>case object ViewerIsUnmentioned extends BooleanFeatureCondition(NotificationIsOnUnmentionedViewer)</p>
<dl class="simple">
<dt>case object AuthorBlocksOuterAuthor</dt><dd><p>extends BooleanFeatureCondition(AuthorBlocksOuterAuthorFeature)</p>
</dd>
<dt>case object OuterAuthorFollowsAuthor</dt><dd><p>extends BooleanFeatureCondition(OuterAuthorFollowsAuthorFeature)</p>
</dd>
<dt>case object OuterAuthorIsInnerAuthor</dt><dd><p>extends BooleanFeatureCondition(OuterAuthorIsInnerAuthorFeature)</p>
</dd>
</dl>
<p>case object ViewerMutesAuthor extends BooleanFeatureCondition(ViewerMutesAuthorFeature)</p>
<p>case object ViewerReportsAuthor extends BooleanFeatureCondition(ViewerReportsAuthorAsSpam)
case object ViewerReportsTweet extends BooleanFeatureCondition(ViewerReportedTweet)</p>
<p>case object IsQuotedInnerTweet extends BooleanFeatureCondition(TweetIsInnerQuotedTweet)</p>
<p>case object IsSourceTweet extends BooleanFeatureCondition(TweetIsSourceTweet)</p>
<dl class="simple">
<dt>case object ViewerMutesRetweetsFromAuthor</dt><dd><p>extends BooleanFeatureCondition(ViewerMutesRetweetsFromAuthorFeature)</p>
</dd>
<dt>case object ConversationRootAuthorDoesFollowViewer</dt><dd><p>extends BooleanFeatureCondition(ConversationRootAuthorFollowsViewer)</p>
</dd>
<dt>case object ViewerDoesFollowConversationRootAuthor</dt><dd><p>extends BooleanFeatureCondition(ViewerFollowsConversationRootAuthor)</p>
</dd>
</dl>
<p>case object TweetIsCommunityTweet extends BooleanFeatureCondition(TweetIsCommunityTweetFeature)</p>
<dl class="simple">
<dt>case object NotificationIsOnCommunityTweet</dt><dd><p>extends BooleanFeatureCondition(NotificationIsOnCommunityTweetFeature)</p>
</dd>
</dl>
<p>sealed trait CommunityTweetCommunityUnavailable extends Condition</p>
<dl class="simple">
<dt>case object CommunityTweetCommunityNotFound</dt><dd><p>extends BooleanFeatureCondition(CommunityTweetCommunityNotFoundFeature)
with CommunityTweetCommunityUnavailable</p>
</dd>
<dt>case object CommunityTweetCommunityDeleted</dt><dd><p>extends BooleanFeatureCondition(CommunityTweetCommunityDeletedFeature)
with CommunityTweetCommunityUnavailable</p>
</dd>
<dt>case object CommunityTweetCommunitySuspended</dt><dd><p>extends BooleanFeatureCondition(CommunityTweetCommunitySuspendedFeature)
with CommunityTweetCommunityUnavailable</p>
</dd>
<dt>case object CommunityTweetCommunityVisible</dt><dd><p>extends BooleanFeatureCondition(CommunityTweetCommunityVisibleFeature)</p>
</dd>
<dt>case object ViewerIsInternalCommunitiesAdmin</dt><dd><p>extends BooleanFeatureCondition(ViewerIsInternalCommunitiesAdminFeature)</p>
</dd>
</dl>
<p>case object ViewerIsCommunityAdmin extends BooleanFeatureCondition(ViewerIsCommunityAdminFeature)</p>
<dl class="simple">
<dt>case object ViewerIsCommunityModerator</dt><dd><p>extends BooleanFeatureCondition(ViewerIsCommunityModeratorFeature)</p>
</dd>
<dt>case object ViewerIsCommunityMember</dt><dd><p>extends BooleanFeatureCondition(ViewerIsCommunityMemberFeature)</p>
</dd>
</dl>
<p>sealed trait CommunityTweetIsModerated extends Condition</p>
<dl class="simple">
<dt>case object CommunityTweetIsHidden</dt><dd><p>extends BooleanFeatureCondition(CommunityTweetIsHiddenFeature)
with CommunityTweetIsModerated</p>
</dd>
<dt>case object CommunityTweetAuthorIsRemoved</dt><dd><p>extends BooleanFeatureCondition(CommunityTweetAuthorIsRemovedFeature)
with CommunityTweetIsModerated</p>
</dd>
<dt>case object DoesHaveInnerCircleOfFriendsRelationship</dt><dd><p>extends BooleanFeatureCondition(HasInnerCircleOfFriendsRelationship)</p>
</dd>
<dt>case object TweetIsCommunityConversation</dt><dd><p>extends BooleanFeatureCondition(TweetHasCommunityConversationControl)</p>
</dd>
<dt>case object TweetIsByInvitationConversation</dt><dd><p>extends BooleanFeatureCondition(TweetHasByInvitationConversationControl)</p>
</dd>
<dt>case object TweetIsFollowersConversation</dt><dd><p>extends BooleanFeatureCondition(TweetHasFollowersConversationControl)</p>
</dd>
<dt>case object ViewerIsTweetConversationRootAuthor</dt><dd><p>extends BooleanFeatureCondition(TweetConversationViewerIsRootAuthor)</p>
</dd>
<dt>private case object ViewerIsInvitedToTweetConversationByMention</dt><dd><p>extends BooleanFeatureCondition(TweetConversationViewerIsInvited)</p>
</dd>
<dt>private case object ViewerIsInvitedToTweetConversationByReplyMention</dt><dd><p>extends BooleanFeatureCondition(TweetConversationViewerIsInvitedViaReplyMention)</p>
</dd>
<dt>object ViewerIsInvitedToTweetConversation</dt><dd><dl class="simple">
<dt>extends Or(</dt><dd><p>ViewerIsInvitedToTweetConversationByMention,
ViewerIsInvitedToTweetConversationByReplyMention)</p>
</dd>
</dl>
</dd>
</dl>
<p>object TweetIsExclusiveContent extends BooleanFeatureCondition(TweetIsExclusiveTweet)
object ViewerIsExclusiveTweetAuthor</p>
<blockquote>
<div><p>extends BooleanFeatureCondition(ViewerIsExclusiveTweetRootAuthor)</p>
</div></blockquote>
<dl class="simple">
<dt>object ViewerSuperFollowsExclusiveTweetAuthor</dt><dd><p>extends BooleanFeatureCondition(ViewerSuperFollowsExclusiveTweetRootAuthor)</p>
</dd>
</dl>
<p>object TweetIsTrustedFriendsContent extends BooleanFeatureCondition(TweetIsTrustedFriendTweet)
object ViewerIsTrustedFriendsTweetAuthor</p>
<blockquote>
<div><p>extends BooleanFeatureCondition(ViewerIsTrustedFriendTweetAuthor)</p>
</div></blockquote>
<p>object ViewerIsTrustedFriend extends BooleanFeatureCondition(ViewerIsTrustedFriendOfTweetAuthor)</p>
<dl>
<dt>object TweetIsCollabInvitationContent</dt><dd><p>extends BooleanFeatureCondition(TweetIsCollabInvitationTweet)</p>
</dd>
<dt>case class TweetHasLabelForPerspectivalUser(safetyLabel: TweetSafetyLabelType)</dt><dd><blockquote>
<div><p>extends Condition
with HasSafetyLabelType {</p>
</div></blockquote>
<p>override lazy val name: String = s”TweetHasLabelForPerspectivalUser(${safetyLabel.name})”
override val features: Set[Feature[_]] = Set(TweetSafetyLabels)
override val optionalFeatures: Set[Feature[_]] = Set(ViewerId)
override val labelTypes: Set[SafetyLabelType] = Set(safetyLabel)</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)
private val SatisfiedResult: Satisfied = Satisfied(</p>
<blockquote>
<div><p>FoundTweetLabelForPerspectivalUser(safetyLabel)</p>
</div></blockquote>
<p>)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><dl>
<dt>if (!featureMap.contains(ViewerId)) {</dt><dd><p>UnsatisfiedResult</p>
</dd>
<dt>} else {</dt><dd><p>val viewerId = featureMap(ViewerId).asInstanceOf[Long]
val labels = featureMap(TweetSafetyLabels).asInstanceOf[Seq[TweetSafetyLabel]]
labels</p>
<blockquote>
<div><dl>
<dt>.collectFirst {</dt><dd><dl>
<dt>case label</dt><dd><blockquote>
<div><dl class="simple">
<dt>if label.labelType == safetyLabel &amp;&amp; label.applicableUsers.contains(viewerId)</dt><dd><p>&amp;&amp; ExperimentBase.shouldFilterForSource(evaluationContext.params, label.source) =&gt;</p>
</dd>
</dl>
</div></blockquote>
<p>SatisfiedResult</p>
</dd>
</dl>
</dd>
</dl>
<p>}.getOrElse(UnsatisfiedResult)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class TweetHasLabel(</dt><dd><p>safetyLabel: TweetSafetyLabelType,
labelSourceExperimentPredicate: Option[(Params, Option[LabelSource]) =&gt; Boolean] = None)</p>
<blockquote>
<div><p>extends Condition
with HasSafetyLabelType {</p>
</div></blockquote>
<p>override lazy val name: String = s”TweetHasLabel(${safetyLabel.name})”
override val features: Set[Feature[_]] = Set(TweetSafetyLabels)
override val optionalFeatures: Set[Feature[_]] = Set.empty
override val labelTypes: Set[SafetyLabelType] = Set(safetyLabel)</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)
private val SatisfiedResult: Satisfied = Satisfied(FoundTweetLabel(safetyLabel))</p>
<dl>
<dt>private val labelSourcePredicate: (Params, Option[LabelSource]) =&gt; Boolean =</dt><dd><dl class="simple">
<dt>labelSourceExperimentPredicate match {</dt><dd><p>case Some(predicate) =&gt; predicate
case _ =&gt; ExperimentBase.shouldFilterForSource</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val labels = featureMap(TweetSafetyLabels).asInstanceOf[Seq[TweetSafetyLabel]]
labels</p>
<blockquote>
<div><dl>
<dt>.collectFirst {</dt><dd><dl>
<dt>case label</dt><dd><blockquote>
<div><dl class="simple">
<dt>if label.labelType == safetyLabel</dt><dd><p>&amp;&amp; labelSourcePredicate(evaluationContext.params, label.source) =&gt;</p>
</dd>
</dl>
</div></blockquote>
<p>SatisfiedResult</p>
</dd>
</dl>
</dd>
</dl>
<p>}.getOrElse(UnsatisfiedResult)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class SpaceHasLabel(</dt><dd><dl class="simple">
<dt>safetyLabelType: SpaceSafetyLabelType)</dt><dd><p>extends Condition
with HasSafetyLabelType {</p>
</dd>
</dl>
<p>override lazy val name: String = s”SpaceHasLabel(${safetyLabelType.name})”
override val features: Set[Feature[_]] = Set(SpaceSafetyLabels)
override val optionalFeatures: Set[Feature[_]] = Set.empty
override val labelTypes: Set[SafetyLabelType] = Set(safetyLabelType)</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)
private val SatisfiedResult: Satisfied = Satisfied(FoundSpaceLabel(safetyLabelType))</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val labels = featureMap(SpaceSafetyLabels).asInstanceOf[Seq[SpaceSafetyLabel]]
labels</p>
<blockquote>
<div><dl class="simple">
<dt>.collectFirst {</dt><dd><dl class="simple">
<dt>case label if label.safetyLabelType == safetyLabelType =&gt;</dt><dd><p>SatisfiedResult</p>
</dd>
</dl>
</dd>
</dl>
<p>}.getOrElse(UnsatisfiedResult)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class MediaHasLabel(</dt><dd><dl class="simple">
<dt>safetyLabelType: MediaSafetyLabelType)</dt><dd><p>extends Condition
with HasSafetyLabelType {</p>
</dd>
</dl>
<p>override lazy val name: String = s”MediaHasLabel(${safetyLabelType.name})”
override val features: Set[Feature[_]] = Set(MediaSafetyLabels)
override val optionalFeatures: Set[Feature[_]] = Set.empty
override val labelTypes: Set[SafetyLabelType] = Set(safetyLabelType)</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)
private val SatisfiedResult: Satisfied = Satisfied(FoundMediaLabel(safetyLabelType))</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val labels = featureMap(MediaSafetyLabels).asInstanceOf[Seq[MediaSafetyLabel]]
labels</p>
<blockquote>
<div><dl class="simple">
<dt>.collectFirst {</dt><dd><dl class="simple">
<dt>case label if label.safetyLabelType == safetyLabelType =&gt;</dt><dd><p>SatisfiedResult</p>
</dd>
</dl>
</dd>
</dl>
<p>}.getOrElse(UnsatisfiedResult)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class TweetHasLabelWithLanguageScoreAboveThreshold(</dt><dd><p>safetyLabel: TweetSafetyLabelType,
languagesToScoreThresholds: Map[String, Double])</p>
<blockquote>
<div><p>extends Condition
with HasSafetyLabelType {</p>
</div></blockquote>
<dl class="simple">
<dt>override lazy val name: String =</dt><dd><p>s”TweetHasLabelWithLanguageScoreAboveThreshold(${safetyLabel.name}, ${languagesToScoreThresholds.toString})”</p>
</dd>
</dl>
<p>override val features: Set[Feature[_]] = Set(TweetSafetyLabels)
override val optionalFeatures: Set[Feature[_]] = Set.empty
override val labelTypes: Set[SafetyLabelType] = Set(safetyLabel)</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)
private val SatisfiedResult: Satisfied =</p>
<blockquote>
<div><dl class="simple">
<dt>Satisfied(</dt><dd><p>FoundTweetLabelWithLanguageScoreAboveThreshold(safetyLabel, languagesToScoreThresholds))</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>private[this] def isAboveThreshold(label: TweetSafetyLabel) = {</dt><dd><dl class="simple">
<dt>val isAboveThresholdOpt = for {</dt><dd><p>modelMetadata &lt;- label.modelMetadata
calibratedLanguage &lt;- modelMetadata.calibratedLanguage
threshold &lt;- languagesToScoreThresholds.get(calibratedLanguage)
score &lt;- label.score</p>
</dd>
</dl>
<p>} yield score &gt;= threshold</p>
<p>isAboveThresholdOpt.getOrElse(false)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val labels = featureMap(TweetSafetyLabels).asInstanceOf[Seq[TweetSafetyLabel]]
labels</p>
<blockquote>
<div><dl>
<dt>.collectFirst {</dt><dd><dl>
<dt>case label</dt><dd><blockquote>
<div><dl class="simple">
<dt>if label.labelType == safetyLabel</dt><dd><p>&amp;&amp; isAboveThreshold(label) =&gt;</p>
</dd>
</dl>
</div></blockquote>
<p>SatisfiedResult</p>
</dd>
</dl>
</dd>
</dl>
<p>}.getOrElse(UnsatisfiedResult)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class TweetHasLabelWithScoreAboveThreshold(</dt><dd><p>safetyLabel: TweetSafetyLabelType,
threshold: Double)</p>
<blockquote>
<div><p>extends Condition
with HasSafetyLabelType {</p>
</div></blockquote>
<dl class="simple">
<dt>override lazy val name: String =</dt><dd><p>s”TweetHasLabelWithScoreAboveThreshold(${safetyLabel.name}, $threshold)”</p>
</dd>
</dl>
<p>override val features: Set[Feature[_]] = Set(TweetSafetyLabels)
override val optionalFeatures: Set[Feature[_]] = Set.empty
override val labelTypes: Set[SafetyLabelType] = Set(safetyLabel)</p>
<p>private val UnsatisfiedResult = Unsatisfied(this)
private val SatisfiedResult =</p>
<blockquote>
<div><p>Satisfied(FoundTweetLabelWithScoreAboveThreshold(safetyLabel, threshold))</p>
</div></blockquote>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val labels = featureMap(TweetSafetyLabels).asInstanceOf[Seq[TweetSafetyLabel]]
labels</p>
<blockquote>
<div><dl>
<dt>.collectFirst {</dt><dd><dl>
<dt>case label</dt><dd><blockquote>
<div><dl class="simple">
<dt>if label.labelType == safetyLabel</dt><dd><p>&amp;&amp; label.score.exists(_ &gt;= threshold) =&gt;</p>
</dd>
</dl>
</div></blockquote>
<p>SatisfiedResult</p>
</dd>
</dl>
</dd>
</dl>
<p>}.getOrElse(UnsatisfiedResult)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class TweetHasLabelWithScoreAboveThresholdWithParam(</dt><dd><p>safetyLabel: TweetSafetyLabelType,
thresholdParam: Param[Double])</p>
<blockquote>
<div><p>extends Condition
with HasSafetyLabelType
with HasParams {</p>
</div></blockquote>
<dl class="simple">
<dt>override lazy val name: String =</dt><dd><p>s”TweetHasLabelWithScoreAboveThreshold(${safetyLabel.name}, ${NamingUtils.getFriendlyName(thresholdParam)})”</p>
</dd>
</dl>
<p>override val features: Set[Feature[_]] = Set(TweetSafetyLabels)
override val optionalFeatures: Set[Feature[_]] = Set.empty
override val labelTypes: Set[SafetyLabelType] = Set(safetyLabel)
private val UnsatisfiedResult = Unsatisfied(this)
override val params: Set[Param[_]] = Set(thresholdParam)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val labels = featureMap(TweetSafetyLabels).asInstanceOf[Seq[TweetSafetyLabel]]
val threshold = evaluationContext.params(thresholdParam)
val SatisfiedResult =</p>
<blockquote>
<div><p>Satisfied(FoundTweetLabelWithScoreAboveThreshold(safetyLabel, threshold))</p>
</div></blockquote>
<dl>
<dt>labels</dt><dd><dl>
<dt>.collectFirst {</dt><dd><dl>
<dt>case label</dt><dd><blockquote>
<div><dl class="simple">
<dt>if label.labelType == safetyLabel</dt><dd><p>&amp;&amp; label.score.exists(_ &gt;= threshold) =&gt;</p>
</dd>
</dl>
</div></blockquote>
<p>SatisfiedResult</p>
</dd>
</dl>
</dd>
</dl>
<p>}.getOrElse(UnsatisfiedResult)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class TweetHasLabelWithLanguageIn(</dt><dd><p>safetyLabelType: TweetSafetyLabelType,
languages: Set[String])</p>
<blockquote>
<div><p>extends Condition
with HasSafetyLabelType {</p>
</div></blockquote>
<dl class="simple">
<dt>override lazy val name: String =</dt><dd><p>s”TweetHasLabelWithLanguageIn($safetyLabelType, $languages)”</p>
</dd>
</dl>
<p>override val features: Set[Feature[_]] = Set(TweetSafetyLabels)
override val optionalFeatures: Set[Feature[_]] = Set.empty
override val labelTypes: Set[SafetyLabelType] = Set(safetyLabelType)</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)
private val SatisfiedResult: Satisfied =</p>
<blockquote>
<div><p>Satisfied(FoundTweetLabelWithLanguageIn(safetyLabelType, languages))</p>
</div></blockquote>
<dl>
<dt>private[this] def hasLanguageMatch(label: TweetSafetyLabel): Boolean = {</dt><dd><dl class="simple">
<dt>val isMatchingLanguageOpt = for {</dt><dd><p>metadata &lt;- label.modelMetadata
language &lt;- metadata.calibratedLanguage</p>
</dd>
</dl>
<p>} yield languages.contains(language)
isMatchingLanguageOpt.getOrElse(false)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><dl>
<dt>featureMap(TweetSafetyLabels)</dt><dd><p>.asInstanceOf[Seq[TweetSafetyLabel]]
.collectFirst {</p>
<blockquote>
<div><dl class="simple">
<dt>case label if label.labelType == safetyLabelType &amp;&amp; hasLanguageMatch(label) =&gt;</dt><dd><p>SatisfiedResult</p>
</dd>
</dl>
</div></blockquote>
<p>}.getOrElse(UnsatisfiedResult)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class TweetHasLabelWithLanguagesWithParam(</dt><dd><p>safetyLabelType: TweetSafetyLabelType,
languageParam: Param[Seq[String]])</p>
<blockquote>
<div><p>extends Condition
with HasSafetyLabelType
with HasParams {</p>
</div></blockquote>
<dl class="simple">
<dt>override lazy val name: String =</dt><dd><p>s”TweetHasLabelWithLanguageIn($safetyLabelType, ${NamingUtils.getFriendlyName(languageParam)})”</p>
</dd>
</dl>
<p>override val features: Set[Feature[_]] = Set(TweetSafetyLabels)
override val optionalFeatures: Set[Feature[_]] = Set.empty
override val labelTypes: Set[SafetyLabelType] = Set(safetyLabelType)
override val params: Set[Param[_]] = Set(languageParam)</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)</p>
<dl>
<dt>private[this] def hasLanguageMatch(label: TweetSafetyLabel, languages: Set[String]): Boolean = {</dt><dd><dl class="simple">
<dt>val isMatchingLanguageOpt = for {</dt><dd><p>metadata &lt;- label.modelMetadata
language &lt;- metadata.calibratedLanguage</p>
</dd>
</dl>
<p>} yield languages.contains(language)
isMatchingLanguageOpt.getOrElse(false)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val languages = evaluationContext.params(languageParam).toSet
val SatisfiedResult: Satisfied =</p>
<blockquote>
<div><p>Satisfied(FoundTweetLabelWithLanguageIn(safetyLabelType, languages))</p>
</div></blockquote>
<dl>
<dt>featureMap(TweetSafetyLabels)</dt><dd><p>.asInstanceOf[Seq[TweetSafetyLabel]]
.collectFirst {</p>
<blockquote>
<div><dl class="simple">
<dt>case label if label.labelType == safetyLabelType &amp;&amp; hasLanguageMatch(label, languages) =&gt;</dt><dd><p>SatisfiedResult</p>
</dd>
</dl>
</div></blockquote>
<p>}.getOrElse(UnsatisfiedResult)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>type TweetSafetyLabelPredicateFn = (TweetSafetyLabel) =&gt; Boolean
abstract class NamedTweetSafetyLabelPredicate(</p>
<blockquote>
<div><p>private[rules] val fn: TweetSafetyLabelPredicateFn,
private[rules] val name: String)</p>
</div></blockquote>
<dl>
<dt>abstract class TweetHasSafetyLabelWithPredicate(</dt><dd><p>private[rules] val safetyLabelType: TweetSafetyLabelType,
private[rules] val predicate: NamedTweetSafetyLabelPredicate)</p>
<blockquote>
<div><p>extends Condition
with HasSafetyLabelType {</p>
</div></blockquote>
<dl class="simple">
<dt>override lazy val name: String =</dt><dd><p>s”TweetHasSafetyLabelWithPredicate(${predicate.name}($safetyLabelType))”</p>
</dd>
</dl>
<p>override val features: Set[Feature[_]] = Set(TweetSafetyLabels)
override val optionalFeatures: Set[Feature[_]] = Set.empty
override val labelTypes: Set[SafetyLabelType] = Set(safetyLabelType)</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)
private val SatisfiedResult: Satisfied =</p>
<blockquote>
<div><p>Satisfied(Result.FoundTweetSafetyLabelWithPredicate(safetyLabelType, predicate.name))</p>
</div></blockquote>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><dl>
<dt>featureMap(TweetSafetyLabels)</dt><dd><p>.asInstanceOf[Seq[TweetSafetyLabel]]
.collectFirst {</p>
<blockquote>
<div><dl class="simple">
<dt>case label if label.labelType == safetyLabelType &amp;&amp; predicate.fn(label) =&gt;</dt><dd><p>SatisfiedResult</p>
</dd>
</dl>
</div></blockquote>
<p>}.getOrElse(UnsatisfiedResult)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>object TweetHasSafetyLabelWithPredicate {</dt><dd><dl class="simple">
<dt>def unapply(</dt><dd><p>condition: TweetHasSafetyLabelWithPredicate</p>
</dd>
<dt>): Option[(TweetSafetyLabelType, NamedTweetSafetyLabelPredicate)] =</dt><dd><p>Some((condition.safetyLabelType, condition.predicate))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class WithScoreEqInt(score: Int)</dt><dd><dl class="simple">
<dt>extends NamedTweetSafetyLabelPredicate(</dt><dd><p>fn = tweetSafetyLabel =&gt; tweetSafetyLabel.score.exists(s =&gt; s.intValue() == score),
name = “WithScoreEqInt”</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>case class TweetHasSafetyLabelWithScoreEqInt(</dt><dd><p>override val safetyLabelType: TweetSafetyLabelType,
score: Int)</p>
<blockquote>
<div><dl class="simple">
<dt>extends TweetHasSafetyLabelWithPredicate(</dt><dd><p>safetyLabelType,
predicate = WithScoreEqInt(score)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
</dd>
<dt>case class TweetReplyToParentTweetBeforeDuration(duration: Duration) extends Condition {</dt><dd><p>override val features: Set[Feature[_]] = Set(TweetParentId, TweetTimestamp)
override val optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)
private val SatisfiedResult: Satisfied = Satisfied(</p>
<blockquote>
<div><p>Result.IsTweetReplyToParentTweetBeforeDuration(duration))</p>
</div></blockquote>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><dl>
<dt>featureMap</dt><dd><dl>
<dt>.get(TweetParentId).collect {</dt><dd><dl>
<dt>case tweetParentId: Long =&gt;</dt><dd><dl>
<dt>featureMap</dt><dd><dl>
<dt>.get(TweetTimestamp).collect {</dt><dd><dl>
<dt>case tweetTimestamp: Time</dt><dd><blockquote>
<div><p>if tweetTimestamp.diff(SnowflakeId.timeFromId(tweetParentId)) &lt; duration =&gt;</p>
</div></blockquote>
<p>SatisfiedResult</p>
</dd>
</dl>
</dd>
</dl>
<p>}.getOrElse(UnsatisfiedResult)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}.getOrElse(UnsatisfiedResult)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class TweetReplyToRootTweetBeforeDuration(duration: Duration) extends Condition {</dt><dd><p>override val features: Set[Feature[_]] = Set(TweetConversationId, TweetTimestamp)
override val optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)
private val SatisfiedResult: Satisfied = Satisfied(</p>
<blockquote>
<div><p>Result.IsTweetReplyToRootTweetBeforeDuration(duration))</p>
</div></blockquote>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><dl>
<dt>featureMap</dt><dd><dl>
<dt>.get(TweetConversationId).collect {</dt><dd><dl>
<dt>case tweetConversationId: Long =&gt;</dt><dd><dl>
<dt>featureMap</dt><dd><dl>
<dt>.get(TweetTimestamp).collect {</dt><dd><dl>
<dt>case tweetTimestamp: Time</dt><dd><blockquote>
<div><dl class="simple">
<dt>if tweetTimestamp.diff(</dt><dd><p>SnowflakeId.timeFromId(tweetConversationId)) &lt; duration =&gt;</p>
</dd>
</dl>
</div></blockquote>
<p>SatisfiedResult</p>
</dd>
</dl>
</dd>
</dl>
<p>}.getOrElse(UnsatisfiedResult)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}.getOrElse(UnsatisfiedResult)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class TweetComposedBefore(cutoffTimestamp: Time) extends Condition {</dt><dd><p>assert(cutoffTimestamp.inMilliseconds &gt; SnowflakeId.FirstSnowflakeIdUnixTime)</p>
<p>override val features: Set[Feature[_]] = Set(TweetTimestamp)
override val optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)
private val SatisfiedResult: Satisfied = Satisfied(HasTweetTimestampBeforeCutoff)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><dl class="simple">
<dt>featureMap(TweetTimestamp) match {</dt><dd><p>case timestamp: Time if timestamp &gt; cutoffTimestamp =&gt; UnsatisfiedResult
case _ =&gt; SatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class TweetComposedAfter(cutoffTimestamp: Time) extends Condition {</dt><dd><p>assert(cutoffTimestamp.inMilliseconds &gt; SnowflakeId.FirstSnowflakeIdUnixTime)</p>
<p>override val features: Set[Feature[_]] = Set(TweetTimestamp)
override val optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)
private val SatisfiedResult: Satisfied = Satisfied(HasTweetTimestampAfterCutoff)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><dl class="simple">
<dt>featureMap(TweetTimestamp) match {</dt><dd><p>case timestamp: Time if timestamp &gt; cutoffTimestamp =&gt; SatisfiedResult
case _ =&gt; UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class TweetComposedAfterOffset(offset: Duration) extends Condition {</dt><dd><p>override val features: Set[Feature[_]] = Set(TweetTimestamp)
override val optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)
private val SatisfiedResult: Satisfied = Satisfied(HasTweetTimestampAfterOffset)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><dl class="simple">
<dt>featureMap(TweetTimestamp) match {</dt><dd><p>case timestamp: Time if timestamp &gt; Time.now.minus(offset) =&gt; SatisfiedResult
case _ =&gt; UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class TweetComposedAfterWithParam(cutoffTimeParam: Param[Time])</dt><dd><blockquote>
<div><p>extends Condition
with HasParams {</p>
</div></blockquote>
<p>override val features: Set[Feature[_]] = Set(TweetTimestamp)
override val optionalFeatures: Set[Feature[_]] = Set.empty
override val params: Set[Param[_]] = Set(cutoffTimeParam)
private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)
private val SatisfiedResult: Satisfied = Satisfied(HasTweetTimestampAfterCutoff)</p>
<dl>
<dt>override def preFilter(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): PreFilterResult = {</dt><dd><p>val cutoffTimestamp = evaluationContext.params(cutoffTimeParam)
if (cutoffTimestamp.inMilliseconds &lt; SnowflakeId.FirstSnowflakeIdUnixTime) {</p>
<blockquote>
<div><p>Filtered</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>super.preFilter(evaluationContext, featureMap)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val cutoffTimestamp = evaluationContext.params(cutoffTimeParam)
featureMap(TweetTimestamp) match {</p>
<blockquote>
<div><dl class="simple">
<dt>case _: Time if cutoffTimestamp.inMilliseconds &lt; SnowflakeId.FirstSnowflakeIdUnixTime =&gt;</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>case timestamp: Time if timestamp &gt; cutoffTimestamp =&gt; SatisfiedResult
case _ =&gt; UnsatisfiedResult</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class AuthorHasLabel(labelValue: UserLabelValue, shortCircuitable: Boolean = true)</dt><dd><blockquote>
<div><p>extends Condition
with HasSafetyLabelType {</p>
</div></blockquote>
<p>override lazy val name: String = s”AuthorHasLabel(${labelValue.name})”
override val features: Set[Feature[_]] = Set(AuthorUserLabels)
override val optionalFeatures: Set[Feature[_]] = Set.empty
override val labelTypes: Set[SafetyLabelType] = Set(labelValue)</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)
private val SatisfiedResult: Satisfied = Satisfied(FoundUserLabel(labelValue))</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val labels = featureMap(AuthorUserLabels).asInstanceOf[Seq[Label]].map(UserLabel.fromThrift)
labels</p>
<blockquote>
<div><dl>
<dt>.collectFirst {</dt><dd><dl>
<dt>case label</dt><dd><blockquote>
<div><dl class="simple">
<dt>if label.labelValue == labelValue</dt><dd><p>&amp;&amp; ExperimentBase.shouldFilterForSource(evaluationContext.params, label.source) =&gt;</p>
</dd>
</dl>
</div></blockquote>
<p>SatisfiedResult</p>
</dd>
</dl>
</dd>
</dl>
<p>}.getOrElse(UnsatisfiedResult)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>abstract class ViewerHasRole(role: String) extends Condition {</dt><dd><p>override lazy val name: String = s”ViewerHasRole(${role})”
override val features: Set[Feature[_]] = Set(ViewerRoles)
override val optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)
private val SatisfiedResult: Satisfied = Satisfied(FoundUserRole(role))</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val roles = featureMap(ViewerRoles).asInstanceOf[Seq[String]]
if (roles.contains(role)) {</p>
<blockquote>
<div><p>SatisfiedResult</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>case object ViewerIsEmployee extends ViewerHasRole(ViewerRoles.EmployeeRole)</p>
<dl>
<dt>case class ViewerHasLabel(labelValue: UserLabelValue) extends Condition with HasSafetyLabelType {</dt><dd><p>override lazy val name: String = s”ViewerHasLabel(${labelValue.name})”
override val features: Set[Feature[_]] = Set(ViewerUserLabels)
override val optionalFeatures: Set[Feature[_]] = Set.empty
override val labelTypes: Set[SafetyLabelType] = Set(labelValue)</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)
private val SatisfiedResult: Satisfied = Satisfied(FoundUserLabel(labelValue))</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val labels = featureMap(ViewerUserLabels).asInstanceOf[Seq[Label]].map(UserLabel.fromThrift)
labels</p>
<blockquote>
<div><dl>
<dt>.collectFirst {</dt><dd><dl>
<dt>case label</dt><dd><blockquote>
<div><dl class="simple">
<dt>if label.labelValue == labelValue</dt><dd><p>&amp;&amp; ExperimentBase.shouldFilterForSource(evaluationContext.params, label.source) =&gt;</p>
</dd>
</dl>
</div></blockquote>
<p>SatisfiedResult</p>
</dd>
</dl>
</dd>
</dl>
<p>}.getOrElse(UnsatisfiedResult)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>case object DeactivatedAuthor extends BooleanFeatureCondition(AuthorIsDeactivated)
case object ErasedAuthor extends BooleanFeatureCondition(AuthorIsErased)
case object OffboardedAuthor extends BooleanFeatureCondition(AuthorIsOffboarded)
case object ProtectedAuthor extends BooleanFeatureCondition(AuthorIsProtected)
case object VerifiedAuthor extends BooleanFeatureCondition(AuthorIsVerified)
case object NsfwUserAuthor extends BooleanFeatureCondition(AuthorIsNsfwUser)
case object NsfwAdminAuthor extends BooleanFeatureCondition(AuthorIsNsfwAdmin)
case object TweetHasNsfwUserAuthor extends BooleanFeatureCondition(TweetHasNsfwUser)
case object TweetHasNsfwAdminAuthor extends BooleanFeatureCondition(TweetHasNsfwAdmin)
case object TweetHasMedia extends BooleanFeatureCondition(TweetHasMediaFeature)
case object TweetHasDmcaMedia extends BooleanFeatureCondition(HasDmcaMediaFeature)
case object TweetHasCard extends BooleanFeatureCondition(TweetHasCardFeature)
case object IsPollCard extends BooleanFeatureCondition(CardIsPoll)</p>
<p>case object ProtectedViewer extends BooleanFeatureCondition(ViewerIsProtected)
case object SoftViewer extends BooleanFeatureCondition(ViewerIsSoftUser)</p>
<dl>
<dt>case object ViewerHasUqfEnabled</dt><dd><p>extends BooleanFeatureCondition(ViewerHasUniversalQualityFilterEnabled)</p>
</dd>
<dt>abstract class ViewerHasMatchingKeywordFor(muteSurface: MuteSurface) extends Condition {</dt><dd><p>override def features: Set[Feature[_]] = Set(feature)
override val optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>private val feature: Feature[MutedKeyword] = muteSurface match {</dt><dd><p>case MuteSurface.HomeTimeline =&gt; ViewerMutesKeywordInTweetForHomeTimeline
case MuteSurface.Notifications =&gt; ViewerMutesKeywordInTweetForNotifications
case MuteSurface.TweetReplies =&gt; ViewerMutesKeywordInTweetForTweetReplies</p>
<p>case _ =&gt; throw new NoSuchElementException(muteSurface.toString)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><dl class="simple">
<dt>val mutedKeyword = featureMap(feature)</dt><dd><p>.asInstanceOf[MutedKeyword]</p>
</dd>
</dl>
<p>Result.fromMutedKeyword(mutedKeyword, UnsatisfiedResult)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case object ViewerHasMatchingKeywordForHomeTimeline</dt><dd><p>extends ViewerHasMatchingKeywordFor(MuteSurface.HomeTimeline)</p>
</dd>
<dt>case object ViewerHasMatchingKeywordForNotifications</dt><dd><p>extends ViewerHasMatchingKeywordFor(MuteSurface.Notifications)</p>
</dd>
<dt>case object ViewerHasMatchingKeywordForTweetReplies</dt><dd><p>extends ViewerHasMatchingKeywordFor(MuteSurface.TweetReplies)</p>
</dd>
<dt>case object ViewerHasMatchingKeywordForAllSurfaces extends Condition {</dt><dd><p>override def features: Set[Feature[_]] = Set(ViewerMutesKeywordInTweetForAllSurfaces)
override val optionalFeatures: Set[Feature[_]] = Set.empty
private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><dl class="simple">
<dt>val mutedKeyword = featureMap(ViewerMutesKeywordInTweetForAllSurfaces)</dt><dd><p>.asInstanceOf[MutedKeyword]</p>
</dd>
</dl>
<p>Result.fromMutedKeyword(mutedKeyword, UnsatisfiedResult)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>abstract class ViewerHasMatchingKeywordInSpaceTitleFor(muteSurface: MuteSurface)</dt><dd><blockquote>
<div><p>extends Condition {</p>
</div></blockquote>
<p>override def features: Set[Feature[_]] = Set(feature)
override val optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl class="simple">
<dt>private val feature: Feature[MutedKeyword] = muteSurface match {</dt><dd><p>case MuteSurface.Notifications =&gt; ViewerMutesKeywordInSpaceTitleForNotifications
case _ =&gt; throw new NoSuchElementException(muteSurface.toString)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><dl class="simple">
<dt>val mutedKeyword = featureMap(feature)</dt><dd><p>.asInstanceOf[MutedKeyword]</p>
</dd>
</dl>
<p>Result.fromMutedKeyword(mutedKeyword, UnsatisfiedResult)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case object ViewerHasMatchingKeywordInSpaceTitleForNotifications</dt><dd><p>extends ViewerHasMatchingKeywordInSpaceTitleFor(MuteSurface.Notifications)</p>
</dd>
<dt>case object ViewerFiltersNoConfirmedEmail</dt><dd><dl class="simple">
<dt>extends BooleanFeatureCondition(</dt><dd><p>com.twitter.visibility.features.ViewerFiltersNoConfirmedEmail</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>case object ViewerFiltersNoConfirmedPhone</dt><dd><dl class="simple">
<dt>extends BooleanFeatureCondition(</dt><dd><p>com.twitter.visibility.features.ViewerFiltersNoConfirmedPhone</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>case object ViewerFiltersDefaultProfileImage</dt><dd><dl class="simple">
<dt>extends BooleanFeatureCondition(</dt><dd><p>com.twitter.visibility.features.ViewerFiltersDefaultProfileImage</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>case object ViewerFiltersNewUsers</dt><dd><dl class="simple">
<dt>extends BooleanFeatureCondition(</dt><dd><p>com.twitter.visibility.features.ViewerFiltersNewUsers</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>case object ViewerFiltersNotFollowedBy</dt><dd><dl class="simple">
<dt>extends BooleanFeatureCondition(</dt><dd><p>com.twitter.visibility.features.ViewerFiltersNotFollowedBy</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>case object AuthorHasConfirmedEmail</dt><dd><dl class="simple">
<dt>extends BooleanFeatureCondition(</dt><dd><p>com.twitter.visibility.features.AuthorHasConfirmedEmail</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>case object AuthorHasVerifiedPhone</dt><dd><dl class="simple">
<dt>extends BooleanFeatureCondition(</dt><dd><p>com.twitter.visibility.features.AuthorHasVerifiedPhone</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>case object AuthorHasDefaultProfileImage</dt><dd><dl class="simple">
<dt>extends BooleanFeatureCondition(</dt><dd><p>com.twitter.visibility.features.AuthorHasDefaultProfileImage</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>case object AuthorIsNewAccount extends Condition {</dt><dd><p>override val features: Set[Feature[_]] = Set(AuthorAccountAge)
override val optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val age = featureMap(AuthorAccountAge).asInstanceOf[Duration]</p>
<dl class="simple">
<dt>if (age &lt; 72.hours) {</dt><dd><p>Result.SatisfiedResult</p>
</dd>
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>abstract class ViewerInJurisdiction extends Condition {</dt><dd><p>override def features: Set[Feature[_]] = Set.empty
override val optionalFeatures: Set[Feature[_]] = Set(RequestCountryCode, ViewerCountryCode)</p>
<p>protected val unsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>protected case class CountryFeatures(</dt><dd><p>requestCountryCode: Option[String],
viewerCountryCode: Option[String])</p>
</dd>
<dt>def getCountryFeatures(featureMap: Map[Feature[_], _]): CountryFeatures = {</dt><dd><dl class="simple">
<dt>val requestCountryCodeOpt = featureMap</dt><dd><p>.get(RequestCountryCode)
.map(_.asInstanceOf[String])</p>
</dd>
<dt>val viewerCountryCodeOpt = featureMap</dt><dd><p>.get(ViewerCountryCode)
.map(_.asInstanceOf[String])</p>
</dd>
</dl>
<p>CountryFeatures(requestCountryCodeOpt, viewerCountryCodeOpt)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>case class ViewerInHrcj(jurisdictions: Set[String]) extends ViewerInJurisdiction {</p>
<blockquote>
<div><dl>
<dt>override def preFilter(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): PreFilterResult =</dt><dd><dl>
<dt>featureMap</dt><dd><p>.get(RequestCountryCode)
.map(_.asInstanceOf[String])
.collectFirst {</p>
<blockquote>
<div><p>case rcc if jurisdictions.contains(rcc) =&gt; NeedsFullEvaluation</p>
</div></blockquote>
<p>}
.getOrElse(Filtered)</p>
</dd>
</dl>
</dd>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val countryFeatures = getCountryFeatures(featureMap)</p>
<dl>
<dt>countryFeatures match {</dt><dd><dl>
<dt>case CountryFeatures(Some(rcc), Some(vcc))</dt><dd><blockquote>
<div><p>if jurisdictions.contains(rcc) &amp;&amp; vcc.equals(rcc) =&gt;</p>
</div></blockquote>
<p>Satisfied(Result.ViewerInHrcj(rcc))</p>
</dd>
</dl>
<p>case _ =&gt; unsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>case class ViewerOrRequestInJurisdiction(enabledCountriesParam: Param[Seq[String]])</dt><dd><blockquote>
<div><p>extends ViewerInJurisdiction
with HasParams
with PreFilterOnOptionalFeatures {</p>
</div></blockquote>
<p>override val params: Set[Param[_]] = Set(enabledCountriesParam)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><dl class="simple">
<dt>val countries: Seq[String] =</dt><dd><p>evaluationContext.params(enabledCountriesParam).map(c =&gt; c.toLowerCase)</p>
</dd>
</dl>
<p>val countryFeatures = getCountryFeatures(featureMap)</p>
<dl>
<dt>val countryCodeOpt =</dt><dd><p>countryFeatures.viewerCountryCode.orElse(countryFeatures.requestCountryCode)</p>
</dd>
<dt>countryCodeOpt match {</dt><dd><dl class="simple">
<dt>case Some(countryCode) if countries.contains(countryCode) =&gt;</dt><dd><p>Satisfied(Result.ViewerOrRequestInCountry(countryCode))</p>
</dd>
</dl>
<p>case _ =&gt; unsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class ViewerAgeInYearsGte(ageToCompare: Int, ignoreEmptyAge: Boolean = false)</dt><dd><blockquote>
<div><p>extends Condition
with PreFilterOnOptionalFeatures {</p>
</div></blockquote>
<p>override def features: Set[Feature[_]] = Set.empty
override def optionalFeatures: Set[Feature[_]] = Set(ViewerAge)</p>
<p>private val unsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result =</dt><dd><dl>
<dt>featureMap</dt><dd><p>.get(ViewerAge)
.map(_.asInstanceOf[UserAge])
.collectFirst {</p>
<blockquote>
<div><dl class="simple">
<dt>case UserAge(Some(age)) if age &gt;= ageToCompare =&gt;</dt><dd><p>Satisfied(Result.ViewerAgeInYears(age))</p>
</dd>
<dt>case UserAge(None) if ignoreEmptyAge =&gt;</dt><dd><p>Satisfied(Result.NoViewerAge)</p>
</dd>
</dl>
</div></blockquote>
<p>}
.getOrElse(unsatisfiedResult)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class UnderageViewer(ageToCompare: Int) extends Condition with PreFilterOnOptionalFeatures {</dt><dd><p>override def features: Set[Feature[_]] = Set.empty
override def optionalFeatures: Set[Feature[_]] = Set(ViewerAge)</p>
<p>private val unsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result =</dt><dd><dl>
<dt>featureMap</dt><dd><p>.get(ViewerAge)
.map(_.asInstanceOf[UserAge])
.collectFirst {</p>
<blockquote>
<div><p>case UserAge(Some(age)) if age &lt; ageToCompare =&gt; Satisfied(Result.ViewerAgeInYears(age))</p>
</div></blockquote>
<p>}
.getOrElse(unsatisfiedResult)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case object ViewerMissingAge extends Condition with PreFilterOnOptionalFeatures {</dt><dd><p>override def features: Set[Feature[_]] = Set.empty
override def optionalFeatures: Set[Feature[_]] = Set(ViewerAge)</p>
<p>private val unsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result =</dt><dd><dl>
<dt>featureMap</dt><dd><p>.get(ViewerAge)
.map(_.asInstanceOf[UserAge])
.collectFirst {</p>
<blockquote>
<div><p>case UserAge(None) =&gt; Satisfied(Result.NoViewerAge)</p>
</div></blockquote>
<p>}
.getOrElse(unsatisfiedResult)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>case object ViewerOptInBlockingOnSearch extends BooleanFeatureCondition(ViewerOptInBlocking)
case object ViewerOptInFilteringOnSearch extends BooleanFeatureCondition(ViewerOptInFiltering)
case object SelfReply extends BooleanFeatureCondition(TweetIsSelfReply)
case object Nullcast extends BooleanFeatureCondition(TweetIsNullcast)
case object Moderated extends BooleanFeatureCondition(TweetIsModerated)
case object Retweet extends BooleanFeatureCondition(TweetIsRetweet)</p>
<dl>
<dt>case object IsFirstPageSearchResult extends Condition {</dt><dd><p>override val features: Set[Feature[_]] = Set(SearchResultsPageNumber)
override val optionalFeatures: Set[Feature[_]] = Set.empty
private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val searchResultsPageNumber = featureMap(SearchResultsPageNumber).asInstanceOf[Int]
if (searchResultsPageNumber == 1) {</p>
<blockquote>
<div><p>Result.SatisfiedResult</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case object HasSearchCandidateCountGreaterThan45 extends Condition {</dt><dd><p>override val features: Set[Feature[_]] = Set(SearchCandidateCount)
override val optionalFeatures: Set[Feature[_]] = Set.empty
private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val searchCandidateCount = featureMap(SearchCandidateCount).asInstanceOf[Int]
if (searchCandidateCount &gt; 45) {</p>
<blockquote>
<div><p>Result.SatisfiedResult</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>abstract class HasSearchQuerySource(querySourceToMatch: ThriftQuerySource) extends Condition {</dt><dd><p>override lazy val name: String = s”HasSearchQuerySource(${querySourceToMatch})”
override val features: Set[Feature[_]] = Set(SearchQuerySource)
override val optionalFeatures: Set[Feature[_]] = Set.empty
private val UnsatisfiedResult = Unsatisfied(this)
private val SatisfiedResult: Satisfied = Satisfied(HasQuerySource(querySourceToMatch))</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val querySource = featureMap(SearchQuerySource).asInstanceOf[ThriftQuerySource]
if (querySourceToMatch.equals(querySource)) {</p>
<blockquote>
<div><p>SatisfiedResult</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case object IsTrendClickSourceSearchResult extends Condition {</dt><dd><p>override val features: Set[Feature[_]] = Set(SearchQuerySource)
override val optionalFeatures: Set[Feature[_]] = Set.empty
private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>private def checkQuerySource[T](</dt><dd><p>featureMap: Map[Feature[_], _],
nonTrendSourceResult: T,
trendSourceResult: T</p>
</dd>
<dt>): T = {</dt><dd><p>val searchResultsPageNumber = featureMap(SearchQuerySource).asInstanceOf[ThriftQuerySource]
if (searchResultsPageNumber == ThriftQuerySource.TrendClick) {</p>
<blockquote>
<div><p>trendSourceResult</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>nonTrendSourceResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>override def preFilter(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): PreFilterResult =</dt><dd><p>checkQuerySource(featureMap, Filtered, NotFiltered)</p>
</dd>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result =</dt><dd><p>checkQuerySource(featureMap, UnsatisfiedResult, Result.SatisfiedResult)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
case object IsSearchHashtagClick extends HasSearchQuerySource(ThriftQuerySource.HashtagClick)
case object IsSearchTrendClick extends HasSearchQuerySource(ThriftQuerySource.TrendClick)</p>
<dl class="simple">
<dt>case object SearchQueryHasUser</dt><dd><p>extends BooleanFeatureCondition(com.twitter.visibility.features.SearchQueryHasUser)</p>
</dd>
</dl>
<p>case class Equals[T](feature: Feature[T], value: T) extends Condition {</p>
<blockquote>
<div><p>override def features: Set[Feature[_]] = Set(feature)
override val optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>private val SatisfiedResult: Result = Satisfied()
private val UnsatisfiedResult: Result = Unsatisfied(this)</p>
<dl class="simple">
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val featureValue = featureMap(feature).asInstanceOf[T]
if (featureValue.equals(value)) SatisfiedResult else UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>case class FeatureEquals[T](left: Feature[T], right: Feature[T]) extends Condition {</p>
<blockquote>
<div><p>override def features: Set[Feature[_]] = Set.empty
override val optionalFeatures: Set[Feature[_]] = Set(left, right)</p>
<p>private val SatisfiedResult: Result = Satisfied()
private val UnsatisfiedResult: Result = Unsatisfied(this)</p>
<dl>
<dt>override def preFilter(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): PreFilterResult = {</dt><dd><dl>
<dt>if (featureMap.contains(left) &amp;&amp; featureMap.contains(right)) {</dt><dd><dl class="simple">
<dt>if (apply(evaluationContext, featureMap).asBoolean) {</dt><dd><p>NotFiltered</p>
</dd>
<dt>} else {</dt><dd><p>Filtered</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>NeedsFullEvaluation</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><dl class="simple">
<dt>if (featureMap.contains(left) &amp;&amp; featureMap.contains(right)) {</dt><dd><p>val leftValue = featureMap(left).asInstanceOf[T]
val rightValue = featureMap(right).asInstanceOf[T]
if (leftValue.equals(rightValue)) SatisfiedResult else UnsatisfiedResult</p>
</dd>
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>case class And(override val conditions: Condition*)</dt><dd><blockquote>
<div><p>extends Condition
with HasNestedConditions
with HasParams {</p>
</div></blockquote>
<p>override lazy val name: String = s”(${conditions.map(_.name).mkString(” And “)})”
override val features: Set[Feature[_]] = conditions.flatMap(_.features).toSet
override val optionalFeatures: Set[Feature[_]] = conditions.flatMap(_.optionalFeatures).toSet
override val params: Set[Param[_]] =</p>
<blockquote>
<div><p>conditions.collect { case p: HasParams =&gt; p.params }.flatten.toSet</p>
</div></blockquote>
<dl>
<dt>override def preFilter(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): PreFilterResult = {</dt><dd><dl>
<dt>conditions.foldLeft(NotFiltered: PreFilterResult) {</dt><dd><p>case (NotFiltered, condition) =&gt; condition.preFilter(evaluationContext, featureMap)
case (Filtered, _) =&gt; Filtered
case (NeedsFullEvaluation, condition) =&gt; {</p>
<blockquote>
<div><dl class="simple">
<dt>condition.preFilter(evaluationContext, featureMap) match {</dt><dd><p>case Filtered =&gt; Filtered
case _ =&gt; NeedsFullEvaluation</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><dl>
<dt>conditions.foldLeft(Result.SatisfiedResult) {</dt><dd><p>case (result &#64; Unsatisfied(_), _) =&gt; result
case (Result.SatisfiedResult, condition) =&gt; condition.apply(evaluationContext, featureMap)
case (result &#64; Satisfied(_), condition) =&gt; {</p>
<blockquote>
<div><dl class="simple">
<dt>condition.apply(evaluationContext, featureMap) match {</dt><dd><p>case r &#64; Unsatisfied(_) =&gt; r
case _ =&gt; result</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class Or(override val conditions: Condition*)</dt><dd><blockquote>
<div><p>extends Condition
with HasNestedConditions
with HasParams {</p>
</div></blockquote>
<p>override lazy val name: String = s”(${conditions.map(_.name).mkString(” Or “)})”
override val features: Set[Feature[_]] = conditions.flatMap(_.features).toSet
override val optionalFeatures: Set[Feature[_]] = conditions.flatMap(_.optionalFeatures).toSet
override val params: Set[Param[_]] =</p>
<blockquote>
<div><p>conditions.collect { case p: HasParams =&gt; p.params }.flatten.toSet</p>
</div></blockquote>
<p>private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def preFilter(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): PreFilterResult = {</dt><dd><dl>
<dt>conditions.foldLeft(Filtered: PreFilterResult) {</dt><dd><p>case (Filtered, c) =&gt; c.preFilter(evaluationContext, featureMap)
case (NotFiltered, _) =&gt; NotFiltered
case (NeedsFullEvaluation, c) =&gt; {</p>
<blockquote>
<div><dl class="simple">
<dt>c.preFilter(evaluationContext, featureMap) match {</dt><dd><p>case NotFiltered =&gt; NotFiltered
case _ =&gt; NeedsFullEvaluation</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><dl class="simple">
<dt>val foundSatisfiedCondition =</dt><dd><p>conditions.find(_.apply(evaluationContext, featureMap).asBoolean)</p>
</dd>
<dt>if (foundSatisfiedCondition.isDefined) {</dt><dd><p>Result.SatisfiedResult</p>
</dd>
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class Not(condition: Condition) extends Condition with HasNestedConditions with HasParams {</dt><dd><p>override lazy val name: String = s”Not(${condition.name})”
override val features: Set[Feature[_]] = condition.features
override val optionalFeatures: Set[Feature[_]] = condition.optionalFeatures
override val conditions: Seq[Condition] = Seq(condition)
override val params: Set[Param[_]] =</p>
<blockquote>
<div><p>conditions.collect { case p: HasParams =&gt; p.params }.flatten.toSet</p>
</div></blockquote>
<p>private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def preFilter(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): PreFilterResult =</dt><dd><dl class="simple">
<dt>condition.preFilter(evaluationContext, featureMap) match {</dt><dd><p>case Filtered =&gt; NotFiltered
case NotFiltered =&gt; Filtered
case _ =&gt; NeedsFullEvaluation</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result =</dt><dd><dl class="simple">
<dt>if (condition(evaluationContext, featureMap).asBoolean) {</dt><dd><p>UnsatisfiedResult</p>
</dd>
<dt>} else {</dt><dd><p>Result.SatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val LoggedOutOrViewerNotFollowingAuthor: And =</dt><dd><p>And(NonAuthorViewer, Or(LoggedOutViewer, Not(ViewerDoesFollowAuthor)))</p>
</dd>
<dt>val LoggedOutOrViewerOptInFiltering: Or =</dt><dd><p>Or(LoggedOutViewer, ViewerOptInFilteringOnSearch)</p>
</dd>
</dl>
<p>val LoggedInViewer: Not = Not(LoggedOutViewer)</p>
<dl class="simple">
<dt>val OuterAuthorNotFollowingAuthor: And =</dt><dd><p>And(Not(OuterAuthorIsInnerAuthor), Not(OuterAuthorFollowsAuthor))</p>
</dd>
</dl>
<p>val IsFocalTweet: FeatureEquals[Long] = FeatureEquals(TweetId, FocalTweetId)</p>
<dl class="simple">
<dt>val NonHydratingConditions: Set[Class[_]] = Set(</dt><dd><p>LoggedOutViewer,
NonAuthorViewer,
True,
TweetComposedAfter(Time.now),
TweetComposedBefore(Time.now)</p>
</dd>
</dl>
<p>).map(_.getClass)</p>
<dl class="simple">
<dt>trait HasParams {</dt><dd><p>val params: Set[Param[_]]</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def hasLabelCondition(condition: Condition, tweetSafetyLabelType: TweetSafetyLabelType): Boolean =</dt><dd><dl>
<dt>condition match {</dt><dd><dl class="simple">
<dt>case lt: HasSafetyLabelType =&gt;</dt><dd><p>lt.hasLabelType(tweetSafetyLabelType)</p>
</dd>
</dl>
<p>case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>def hasLabelCondition(condition: Condition, userLabelValue: UserLabelValue): Boolean =</dt><dd><dl>
<dt>condition match {</dt><dd><dl class="simple">
<dt>case lt: HasSafetyLabelType =&gt;</dt><dd><p>lt.hasLabelType(userLabelValue)</p>
</dd>
</dl>
<p>case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>def hasLabelCondition(condition: Condition, spaceSafetyLabelType: SpaceSafetyLabelType): Boolean =</dt><dd><dl>
<dt>condition match {</dt><dd><dl class="simple">
<dt>case lt: HasSafetyLabelType =&gt;</dt><dd><p>lt.hasLabelType(spaceSafetyLabelType)</p>
</dd>
</dl>
<p>case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>def hasLabelCondition(condition: Condition, mediaSafetyLabelType: MediaSafetyLabelType): Boolean =</dt><dd><dl>
<dt>condition match {</dt><dd><dl class="simple">
<dt>case lt: HasSafetyLabelType =&gt;</dt><dd><p>lt.hasLabelType(mediaSafetyLabelType)</p>
</dd>
</dl>
<p>case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>case class Choose[T](</dt><dd><p>conditionMap: Map[T, Condition],
defaultCondition: Condition,
choiceParam: Param[T])</p>
<blockquote>
<div><p>extends Condition
with HasNestedConditions
with HasParams {</p>
</div></blockquote>
<dl class="simple">
<dt>override lazy val name: String =</dt><dd><p>s”(Either ${conditionMap.values.map(_.name).mkString(”, “)} or ${defaultCondition.name})”</p>
</dd>
<dt>override val features: Set[Feature[_]] =</dt><dd><p>conditionMap.values.flatMap(_.features).toSet ++ defaultCondition.features</p>
</dd>
<dt>override val optionalFeatures: Set[Feature[_]] =</dt><dd><p>conditionMap.values.flatMap(_.optionalFeatures).toSet ++ defaultCondition.optionalFeatures</p>
</dd>
</dl>
<p>override val conditions: Seq[Condition] = conditionMap.values.toSeq :+ defaultCondition
override val params: Set[Param[_]] =</p>
<blockquote>
<div><p>conditions.collect { case p: HasParams =&gt; p.params }.flatten.toSet</p>
</div></blockquote>
<dl class="simple">
<dt>private[this] def getCondition(evaluationContext: EvaluationContext): Condition =</dt><dd><p>conditionMap.getOrElse(evaluationContext.params(choiceParam), defaultCondition)</p>
</dd>
<dt>override def preFilter(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): PreFilterResult =</dt><dd><p>getCondition(evaluationContext).preFilter(evaluationContext, featureMap)</p>
</dd>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result =</dt><dd><p>getCondition(evaluationContext)(evaluationContext, featureMap)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class IfElse(</dt><dd><p>branchingCondition: Condition,
ifTrueCondition: Condition,
ifFalseCondition: Condition)</p>
<blockquote>
<div><p>extends Condition
with HasNestedConditions
with HasParams {</p>
</div></blockquote>
<dl>
<dt>override lazy val name: String =</dt><dd><p>s”(If ${branchingCondition.name} Then ${ifTrueCondition.name} Else ${ifFalseCondition.name})”</p>
</dd>
<dt>override val features: Set[Feature[_]] =</dt><dd><p>branchingCondition.features ++ ifTrueCondition.features ++ ifFalseCondition.features</p>
</dd>
<dt>override val optionalFeatures: Set[Feature[_]] =</dt><dd><p>branchingCondition.optionalFeatures ++ ifTrueCondition.optionalFeatures ++ ifFalseCondition.optionalFeatures</p>
</dd>
<dt>override val conditions: Seq[Condition] =</dt><dd><p>Seq(branchingCondition, ifTrueCondition, ifFalseCondition)</p>
</dd>
<dt>override val params: Set[Param[_]] =</dt><dd><p>conditions.collect { case p: HasParams =&gt; p.params }.flatten.toSet</p>
</dd>
<dt>override def preFilter(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): PreFilterResult =</dt><dd><dl class="simple">
<dt>branchingCondition.preFilter(evaluationContext, featureMap) match {</dt><dd><dl class="simple">
<dt>case Filtered =&gt;</dt><dd><p>ifFalseCondition.preFilter(evaluationContext, featureMap)</p>
</dd>
<dt>case NotFiltered =&gt;</dt><dd><p>ifTrueCondition.preFilter(evaluationContext, featureMap)</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>NeedsFullEvaluation</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result =</dt><dd><dl class="simple">
<dt>if (branchingCondition(evaluationContext, featureMap).asBoolean) {</dt><dd><p>ifTrueCondition(evaluationContext, featureMap)</p>
</dd>
<dt>} else {</dt><dd><p>ifFalseCondition(evaluationContext, featureMap)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class GatedAlternate[T](</dt><dd><p>defaultCondition: Condition,
alternateConditions: Map[T, Condition],
bucketIdentifierToUseOnDisagreementParam: Param[Option[T]])</p>
<blockquote>
<div><p>extends Condition
with HasNestedConditions
with HasParams {</p>
</div></blockquote>
<dl class="simple">
<dt>override lazy val name: String =</dt><dd><p>s”(${defaultCondition.name} or sometimes ${alternateConditions.values.map(_.name).mkString(” or “)})”</p>
</dd>
<dt>override val features: Set[Feature[_]] =</dt><dd><p>defaultCondition.features ++ alternateConditions.values.flatMap(_.features)</p>
</dd>
<dt>override val optionalFeatures: Set[Feature[_]] =</dt><dd><p>defaultCondition.optionalFeatures ++ alternateConditions.values.flatMap(_.optionalFeatures)</p>
</dd>
</dl>
<p>override val conditions: Seq[Condition] = Seq(defaultCondition) ++ alternateConditions.values</p>
<dl>
<dt>override val params: Set[Param[_]] =</dt><dd><p>conditions.collect { case p: HasParams =&gt; p.params }.flatten.toSet</p>
</dd>
<dt>override def preFilter(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): PreFilterResult =</dt><dd><dl>
<dt>if (defaultCondition.preFilter(evaluationContext, featureMap) == Filtered &amp;&amp;</dt><dd><p>alternateConditions.values.forall(_.preFilter(evaluationContext, featureMap) == Filtered)) {
Filtered</p>
</dd>
<dt>} else if (defaultCondition.preFilter(evaluationContext, featureMap) == NotFiltered &amp;&amp;</dt><dd><dl class="simple">
<dt>alternateConditions.values.forall(</dt><dd><p>_.preFilter(evaluationContext, featureMap) == NotFiltered)) {</p>
</dd>
</dl>
<p>NotFiltered</p>
</dd>
<dt>} else {</dt><dd><p>NeedsFullEvaluation</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val defaultConditionResult: Result = defaultCondition(evaluationContext, featureMap)
val alternateConditionResult: Map[T, Result] =</p>
<blockquote>
<div><p>alternateConditions.mapValues(_(evaluationContext, featureMap))</p>
</div></blockquote>
<dl>
<dt>if (alternateConditionResult.values.exists(_.asBoolean != defaultConditionResult.asBoolean)) {</dt><dd><dl class="simple">
<dt>evaluationContext.params(bucketIdentifierToUseOnDisagreementParam) match {</dt><dd><dl class="simple">
<dt>case Some(bucket) if alternateConditionResult.contains(bucket) =&gt;</dt><dd><p>alternateConditionResult(bucket)</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>defaultConditionResult</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>defaultConditionResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class EnumGatedAlternate[E &lt;: Enumeration](</dt><dd><p>defaultCondition: Condition,
alternateConditions: Map[E#Value, Condition],
bucketIdentifierToUseOnDisagreementParam: EnumParam[E])</p>
<blockquote>
<div><p>extends Condition
with HasNestedConditions
with HasParams {</p>
</div></blockquote>
<dl class="simple">
<dt>override lazy val name: String =</dt><dd><p>s”(${defaultCondition.name} or sometimes ${alternateConditions.values.map(_.name).mkString(” or “)})”</p>
</dd>
<dt>override val features: Set[Feature[_]] =</dt><dd><p>defaultCondition.features ++ alternateConditions.values.flatMap(_.features)</p>
</dd>
<dt>override val optionalFeatures: Set[Feature[_]] =</dt><dd><p>defaultCondition.optionalFeatures ++ alternateConditions.values.flatMap(_.optionalFeatures)</p>
</dd>
</dl>
<p>override val conditions: Seq[Condition] = Seq(defaultCondition) ++ alternateConditions.values</p>
<dl>
<dt>override val params: Set[Param[_]] =</dt><dd><dl>
<dt>conditions</dt><dd><dl class="simple">
<dt>.collect {</dt><dd><p>case p: HasParams =&gt; p.params</p>
</dd>
</dl>
<p>}.flatten.toSet + bucketIdentifierToUseOnDisagreementParam</p>
</dd>
</dl>
</dd>
<dt>override def preFilter(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): PreFilterResult =</dt><dd><dl>
<dt>if (defaultCondition.preFilter(evaluationContext, featureMap) == Filtered &amp;&amp;</dt><dd><p>alternateConditions.values.forall(_.preFilter(evaluationContext, featureMap) == Filtered)) {
Filtered</p>
</dd>
<dt>} else if (defaultCondition.preFilter(evaluationContext, featureMap) == NotFiltered &amp;&amp;</dt><dd><dl class="simple">
<dt>alternateConditions.values.forall(</dt><dd><p>_.preFilter(evaluationContext, featureMap) == NotFiltered)) {</p>
</dd>
</dl>
<p>NotFiltered</p>
</dd>
<dt>} else {</dt><dd><p>NeedsFullEvaluation</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val defaultConditionResult: Result = defaultCondition(evaluationContext, featureMap)
val alternateConditionResult: Map[E#Value, Result] =</p>
<blockquote>
<div><p>alternateConditions.mapValues(_(evaluationContext, featureMap))</p>
</div></blockquote>
<dl>
<dt>if (alternateConditionResult.values.exists(_.asBoolean != defaultConditionResult.asBoolean)) {</dt><dd><dl class="simple">
<dt>evaluationContext.params(bucketIdentifierToUseOnDisagreementParam) match {</dt><dd><dl class="simple">
<dt>case bucket if alternateConditionResult.contains(bucket) =&gt;</dt><dd><p>alternateConditionResult(bucket)</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>defaultConditionResult</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>defaultConditionResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case object IsTestTweet extends Condition {</dt><dd><p>override val features: Set[Feature[_]] = Set(TweetId)
override val optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><dl class="simple">
<dt>if (!featureMap.contains(TweetId)) {</dt><dd><p>UnsatisfiedResult</p>
</dd>
<dt>} else {</dt><dd><p>Result.SatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case object IsTweetInTweetLevelStcmHoldback extends Condition {</dt><dd><p>override val features: Set[Feature[_]] = Set(TweetId)
override val optionalFeatures: Set[Feature[_]] = Set.empty
private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val tweetId: Long = featureMap(TweetId).asInstanceOf[Long]
if (StcmTweetHoldback.isTweetInHoldback(tweetId)) {</p>
<blockquote>
<div><p>Result.SatisfiedResult</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case object MediaRestrictedInViewerCountry extends Condition {</dt><dd><dl class="simple">
<dt>override val features: Set[Feature[_]] =</dt><dd><p>Set(MediaGeoRestrictionsAllowList, MediaGeoRestrictionsDenyList)</p>
</dd>
</dl>
<p>override val optionalFeatures: Set[Feature[_]] = Set(RequestCountryCode)</p>
<p>private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><dl class="simple">
<dt>val requestCountryCode = TakedownReasons.normalizeCountryCodeOption(</dt><dd><p>featureMap.get(RequestCountryCode).asInstanceOf[Option[String]])</p>
</dd>
<dt>val allowlistCountryCodes =</dt><dd><p>featureMap(MediaGeoRestrictionsAllowList).asInstanceOf[Seq[String]]</p>
</dd>
<dt>val denylistCountryCodes =</dt><dd><p>featureMap(MediaGeoRestrictionsDenyList).asInstanceOf[Seq[String]]</p>
</dd>
<dt>if ((allowlistCountryCodes.nonEmpty &amp;&amp; !allowlistCountryCodes.contains(requestCountryCode))</dt><dd><p>|| denylistCountryCodes.contains(requestCountryCode)) {
Result.SatisfiedResult</p>
</dd>
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>case object OneToOneDmConversation</dt><dd><p>extends BooleanFeatureCondition(DmConversationIsOneToOneConversation)</p>
</dd>
<dt>case object DmConversationTimelineIsEmpty</dt><dd><p>extends BooleanFeatureCondition(DmConversationHasEmptyTimeline)</p>
</dd>
<dt>case object DmConversationLastReadableEventIdIsValid</dt><dd><p>extends BooleanFeatureCondition(DmConversationHasValidLastReadableEventId)</p>
</dd>
<dt>case object ViewerIsDmConversationParticipant</dt><dd><p>extends BooleanFeatureCondition(feats.ViewerIsDmConversationParticipant)</p>
</dd>
<dt>case object DmConversationInfoExists</dt><dd><p>extends BooleanFeatureCondition(feats.DmConversationInfoExists)</p>
</dd>
<dt>case object DmConversationTimelineExists</dt><dd><p>extends BooleanFeatureCondition(feats.DmConversationTimelineExists)</p>
</dd>
<dt>case object DmEventIsBeforeLastClearedEvent</dt><dd><p>extends BooleanFeatureCondition(DmEventOccurredBeforeLastClearedEvent)</p>
</dd>
<dt>case object DmEventIsBeforeJoinConversationEvent</dt><dd><p>extends BooleanFeatureCondition(DmEventOccurredBeforeJoinConversationEvent)</p>
</dd>
</dl>
<p>case object DmEventIsDeleted extends BooleanFeatureCondition(feats.DmEventIsDeleted)</p>
<p>case object DmEventIsHidden extends BooleanFeatureCondition(feats.DmEventIsHidden)</p>
<dl class="simple">
<dt>case object ViewerIsDmEventInitiatingUser</dt><dd><p>extends BooleanFeatureCondition(feats.ViewerIsDmEventInitiatingUser)</p>
</dd>
<dt>case object DmEventInOneToOneConversationWithUnavailableUser</dt><dd><p>extends BooleanFeatureCondition(feats.DmEventInOneToOneConversationWithUnavailableUser)</p>
</dd>
<dt>case object DmEventInOneToOneConversation</dt><dd><p>extends BooleanFeatureCondition(feats.DmEventInOneToOneConversation)</p>
</dd>
</dl>
<p>case object MessageCreateDmEvent extends BooleanFeatureCondition(DmEventIsMessageCreateEvent)</p>
<dl>
<dt>case object WelcomeMessageCreateDmEvent</dt><dd><p>extends BooleanFeatureCondition(DmEventIsWelcomeMessageCreateEvent)</p>
</dd>
<dt>case object LastMessageReadUpdateDmEvent</dt><dd><p>extends BooleanFeatureCondition(DmEventIsLastMessageReadUpdateEvent)</p>
</dd>
<dt>case object JoinConversationDmEvent</dt><dd><p>extends BooleanFeatureCondition(DmEventIsJoinConversationEvent)</p>
</dd>
<dt>case object ConversationCreateDmEvent</dt><dd><p>extends BooleanFeatureCondition(DmEventIsConversationCreateEvent)</p>
</dd>
<dt>case object TrustConversationDmEvent</dt><dd><p>extends BooleanFeatureCondition(DmEventIsTrustConversationEvent)</p>
</dd>
<dt>case object CsFeedbackSubmittedDmEvent</dt><dd><p>extends BooleanFeatureCondition(DmEventIsCsFeedbackSubmitted)</p>
</dd>
<dt>case object CsFeedbackDismissedDmEvent</dt><dd><p>extends BooleanFeatureCondition(DmEventIsCsFeedbackDismissed)</p>
</dd>
<dt>case object PerspectivalJoinConversationDmEvent</dt><dd><p>extends BooleanFeatureCondition(feats.DmEventIsPerspectivalJoinConversationEvent)</p>
</dd>
<dt>case class SpaceHasLabelWithScoreAboveThresholdWithParam(</dt><dd><p>spaceSafetyLabelType: SpaceSafetyLabelType,
thresholdParam: Param[Double])</p>
<blockquote>
<div><p>extends Condition
with HasParams {</p>
</div></blockquote>
<dl class="simple">
<dt>override lazy val name: String =</dt><dd><p>s”SpaceHasLabelWithScoreAboveThreshold(${spaceSafetyLabelType.name}, ${NamingUtils.getFriendlyName(thresholdParam)})”</p>
</dd>
</dl>
<p>override val features: Set[Feature[_]] = Set(SpaceSafetyLabels)
override val optionalFeatures: Set[Feature[_]] = Set.empty
private val UnsatisfiedResult = Unsatisfied(this)
override val params: Set[Param[_]] = Set(thresholdParam)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val labels = featureMap(SpaceSafetyLabels).asInstanceOf[Seq[SpaceSafetyLabel]]
val threshold = evaluationContext.params(thresholdParam)
val SatisfiedResult =</p>
<blockquote>
<div><p>Satisfied(FoundSpaceLabelWithScoreAboveThreshold(spaceSafetyLabelType, threshold))</p>
</div></blockquote>
<dl>
<dt>labels</dt><dd><dl>
<dt>.collectFirst {</dt><dd><dl>
<dt>case label</dt><dd><blockquote>
<div><dl class="simple">
<dt>if label.safetyLabelType == spaceSafetyLabelType</dt><dd><p>&amp;&amp; label.safetyLabel.score.exists(_ &gt;= threshold) =&gt;</p>
</dd>
</dl>
</div></blockquote>
<p>SatisfiedResult</p>
</dd>
</dl>
</dd>
</dl>
<p>}.getOrElse(UnsatisfiedResult)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class CardUriHasRootDomain(rootDomainParam: Param[Seq[String]])</dt><dd><blockquote>
<div><p>extends Condition
with HasParams {</p>
</div></blockquote>
<dl class="simple">
<dt>override lazy val name: String =</dt><dd><p>s”CardUriHasRootDomain(${NamingUtils.getFriendlyName(rootDomainParam)})”</p>
</dd>
</dl>
<p>override val features: Set[Feature[_]] = Set(CardUriHost)
override val optionalFeatures: Set[Feature[_]] = Set.empty
private val UnsatisfiedResult = Unsatisfied(this)
override val params: Set[Param[_]] = Set(rootDomainParam)</p>
<dl>
<dt>private[this] def isHostDomainOrSubdomain(domain: String, host: String): Boolean =</dt><dd><p>host == domain || host.endsWith(“.” + domain)</p>
</dd>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val cardUriHost = featureMap(CardUriHost).asInstanceOf[String]
val rootDomains = evaluationContext.params(rootDomainParam)</p>
<dl class="simple">
<dt>if (rootDomains.exists(isHostDomainOrSubdomain(_, cardUriHost))) {</dt><dd><p>Satisfied(FoundCardUriRootDomain(cardUriHost))</p>
</dd>
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class TweetHasViolationOfLevel(level: ViolationLevel)</dt><dd><blockquote>
<div><p>extends Condition
with HasSafetyLabelType {</p>
</div></blockquote>
<p>override lazy val name: String = s”tweetHasViolationOfLevel(${level})”</p>
<p>override val features: Set[Feature[_]] = Set(TweetSafetyLabels)
override def optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)</p>
<p>private val SatisfiedResult: Satisfied = Satisfied(FoundTweetViolationOfLevel(level))</p>
<dl>
<dt>override val labelTypes: Set[SafetyLabelType] =</dt><dd><dl class="simple">
<dt>ViolationLevel.violationLevelToSafetyLabels</dt><dd><p>.getOrElse(level, Set.empty)
.map(_.asInstanceOf[SafetyLabelType])</p>
</dd>
</dl>
</dd>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val labels = featureMap(TweetSafetyLabels).asInstanceOf[Seq[TweetSafetyLabel]]
if (labels.map(ViolationLevel.fromTweetSafetyLabel).contains(level)) {</p>
<blockquote>
<div><p>SatisfiedResult</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>case object TweetHasViolationOfAnyLevel extends Condition with HasSafetyLabelType {</p>
<blockquote>
<div><p>override lazy val name: String = s”tweetHasViolationOfAnyLevel”</p>
<p>override val features: Set[Feature[_]] = Set(TweetSafetyLabels)</p>
<p>override def optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)</p>
<p>private val SatisfiedResult: Satisfied = Satisfied(FoundTweetViolationOfSomeLevel)</p>
<dl>
<dt>override val labelTypes: Set[SafetyLabelType] =</dt><dd><dl class="simple">
<dt>ViolationLevel.violationLevelToSafetyLabels.values</dt><dd><p>.reduceLeft(_ ++ _)
.map(_.asInstanceOf[SafetyLabelType])</p>
</dd>
</dl>
</dd>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val labels = featureMap(TweetSafetyLabels).asInstanceOf[Seq[TweetSafetyLabel]]
if (labels</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>.map(ViolationLevel.fromTweetSafetyLabelOpt).collect {</dt><dd><p>case Some(level) =&gt; level</p>
</dd>
</dl>
<p>}.nonEmpty) {</p>
</div></blockquote>
<p>SatisfiedResult</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>case object TweetIsEditTweet extends BooleanFeatureCondition(TweetIsEditTweetFeature)
case object TweetIsStaleTweet extends BooleanFeatureCondition(TweetIsStaleTweetFeature)</p>
<dl>
<dt>case class ViewerHasAdultMediaSettingLevel(settingLevelToCompare: SensitiveMediaSettingsLevel)</dt><dd><blockquote>
<div><p>extends Condition {</p>
</div></blockquote>
<p>override def features: Set[Feature[_]] = Set(ViewerSensitiveMediaSettings)</p>
<p>override def optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><dl>
<dt>featureMap</dt><dd><p>.get(ViewerSensitiveMediaSettings)
.map(_.asInstanceOf[UserSensitiveMediaSettings])
.collectFirst {</p>
<blockquote>
<div><dl>
<dt>case UserSensitiveMediaSettings(Some(setting))</dt><dd><blockquote>
<div><p>if (setting.viewAdultContent == settingLevelToCompare) =&gt;</p>
</div></blockquote>
<p>Result.SatisfiedResult</p>
</dd>
</dl>
<p>case UserSensitiveMediaSettings(None) =&gt; UnsatisfiedResult</p>
</div></blockquote>
<p>}.getOrElse(UnsatisfiedResult)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class ViewerHasViolentMediaSettingLevel(settingLevelToCompare: SensitiveMediaSettingsLevel)</dt><dd><blockquote>
<div><p>extends Condition {</p>
</div></blockquote>
<p>override def features: Set[Feature[_]] = Set(ViewerSensitiveMediaSettings)</p>
<p>override def optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl class="simple">
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
</dl>
<p>): Result = {</p>
<blockquote>
<div><dl>
<dt>featureMap</dt><dd><p>.get(ViewerSensitiveMediaSettings)
.map(_.asInstanceOf[UserSensitiveMediaSettings])
.collectFirst {</p>
<blockquote>
<div><dl>
<dt>case UserSensitiveMediaSettings(Some(setting))</dt><dd><blockquote>
<div><p>if (setting.viewViolentContent == settingLevelToCompare) =&gt;</p>
</div></blockquote>
<p>Result.SatisfiedResult</p>
</dd>
</dl>
<p>case UserSensitiveMediaSettings(None) =&gt; UnsatisfiedResult</p>
</div></blockquote>
<p>}.getOrElse(UnsatisfiedResult)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class ViewerHasOtherSensitiveMediaSettingLevel(</dt><dd><dl class="simple">
<dt>settingLevelToCompare: SensitiveMediaSettingsLevel)</dt><dd><p>extends Condition {</p>
</dd>
</dl>
<p>override def features: Set[Feature[_]] = Set(ViewerSensitiveMediaSettings)</p>
<p>override def optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl class="simple">
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
</dl>
<p>): Result = {</p>
<blockquote>
<div><dl>
<dt>featureMap</dt><dd><p>.get(ViewerSensitiveMediaSettings)
.map(_.asInstanceOf[UserSensitiveMediaSettings])
.collectFirst {</p>
<blockquote>
<div><dl>
<dt>case UserSensitiveMediaSettings(Some(setting))</dt><dd><blockquote>
<div><p>if (setting.viewOtherContent == settingLevelToCompare) =&gt;</p>
</div></blockquote>
<p>Result.SatisfiedResult</p>
</dd>
</dl>
<p>case UserSensitiveMediaSettings(None) =&gt; UnsatisfiedResult</p>
</div></blockquote>
<p>}.getOrElse(UnsatisfiedResult)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private[rules] val ToxrfTweetFilteredForAuthor =</dt><dd><p>Equals(ToxicReplyFilterState, FilterState.FilteredFromAuthor)</p>
</dd>
<dt>private[rules] case object ToxrfViewerIsConversationAuthor</dt><dd><p>extends BooleanFeatureCondition(ToxicReplyFilterConversationAuthorIsViewer)</p>
</dd>
<dt>val ToxrfFilteredFromAuthorViewer =</dt><dd><p>And(LoggedInViewer, ToxrfTweetFilteredForAuthor, ToxrfViewerIsConversationAuthor)</p>
</dd>
<dt>case object SearchQueryMatchesScreenName extends Condition {</dt><dd><p>override def features: Set[Feature[_]] = Set.empty</p>
<p>override def optionalFeatures: Set[Feature[_]] = Set(RawQuery, AuthorScreenName)</p>
<p>private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><dl>
<dt>if (featureMap.contains(RawQuery) &amp;&amp; featureMap.contains(AuthorScreenName)) {</dt><dd><p>val rawQuery = featureMap(RawQuery).asInstanceOf[String]
val authorScreenName = featureMap(AuthorScreenName).asInstanceOf[String]
if (rawQuery.equalsIgnoreCase(authorScreenName)) {</p>
<blockquote>
<div><p>Result.SatisfiedResult</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>UnsatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>object SearchQueryDoesNotMatchScreenNameConditionBuilder {</dt><dd><dl>
<dt>def apply(condition: Condition, ruleParam: RuleParam[Boolean]): Choose[Boolean] = {</dt><dd><dl>
<dt>Choose(</dt><dd><dl class="simple">
<dt>conditionMap =</dt><dd><p>Map(true -&gt; And(condition, Not(SearchQueryMatchesScreenName)), false -&gt; condition),</p>
</dd>
</dl>
<p>defaultCondition = condition,
choiceParam = ruleParam</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val SearchQueryDoesNotMatchScreenNameDefaultTrueCondition: Choose[Boolean] =</dt><dd><p>SearchQueryDoesNotMatchScreenNameConditionBuilder(Condition.True, RuleParams.False)</p>
</dd>
<dt>case object OptionalNonAuthorViewer extends Condition {</dt><dd><p>override val features: Set[Feature[_]] = Set()
override val optionalFeatures: Set[Feature[_]] = Set(AuthorId, ViewerId)</p>
<p>private val UnsatisfiedResult = Unsatisfied(this)</p>
<dl class="simple">
<dt>override def preFilter(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): PreFilterResult = {</dt><dd><p>NeedsFullEvaluation</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val authorIdsOpt = featureMap.get(AuthorId).asInstanceOf[Option[Set[Long]]]
val viewerIdOpt = featureMap.get(ViewerId).asInstanceOf[Option[Long]]</p>
<dl class="simple">
<dt>(for {</dt><dd><p>authorIds &lt;- authorIdsOpt
viewerId &lt;- viewerIdOpt</p>
</dd>
<dt>} yield {</dt><dd><p>if (authorIds.contains(viewerId)) UnsatisfiedResult
else Result.SatisfiedResult</p>
</dd>
<dt>}) getOrElse {</dt><dd><p>Result.SatisfiedResult</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class ViewerLocatedInApplicableCountriesOfMediaWithholdingLabel(</dt><dd><dl class="simple">
<dt>safetyLabelType: MediaSafetyLabelType)</dt><dd><p>extends ViewerInJurisdiction
with HasSafetyLabelType {</p>
</dd>
<dt>override lazy val name: String =</dt><dd><p>s”ViewerLocatedInApplicableCountriesOfMediaLabel(${safetyLabelType.name})”</p>
</dd>
</dl>
<p>override val features: Set[Feature[_]] = Set(MediaSafetyLabels)
override val optionalFeatures: Set[Feature[_]] = Set(ViewerCountryCode, RequestCountryCode)
override val labelTypes: Set[SafetyLabelType] = Set(safetyLabelType)</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)</p>
<dl>
<dt>private[this] def isInApplicableCountries(</dt><dd><p>countryCodeOpt: Option[String],
label: SafetyLabel</p>
</dd>
<dt>): Boolean = {</dt><dd><dl class="simple">
<dt>val inApplicableCountry = (for {</dt><dd><p>applicableCountries &lt;- label.applicableCountries
countryCode &lt;- countryCodeOpt</p>
</dd>
<dt>} yield {</dt><dd><p>applicableCountries.contains(countryCode)</p>
</dd>
</dl>
<p>}) getOrElse (false)
inApplicableCountry</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val labels = featureMap(MediaSafetyLabels).asInstanceOf[Seq[MediaSafetyLabel]]</p>
<p>val countryFeatures = getCountryFeatures(featureMap)
val countryCodeOpt = countryFeatures.requestCountryCode</p>
<blockquote>
<div><p>.orElse(countryFeatures.viewerCountryCode)</p>
</div></blockquote>
<dl>
<dt>labels</dt><dd><dl>
<dt>.collectFirst {</dt><dd><dl>
<dt>case label</dt><dd><blockquote>
<div><dl class="simple">
<dt>if label.safetyLabelType == safetyLabelType</dt><dd><dl class="simple">
<dt>&amp;&amp;</dt><dd><p>isInApplicableCountries(countryCodeOpt, label.safetyLabel) =&gt;</p>
</dd>
</dl>
</dd>
</dl>
</div></blockquote>
<p>Result.SatisfiedResult</p>
</dd>
</dl>
</dd>
</dl>
<p>}.getOrElse(UnsatisfiedResult)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class MediaHasLabelWithWorldwideWithholding(safetyLabelType: MediaSafetyLabelType)</dt><dd><blockquote>
<div><p>extends Condition
with HasSafetyLabelType {</p>
</div></blockquote>
<dl class="simple">
<dt>override lazy val name: String =</dt><dd><p>s”MediaHasLabelWithWorldwideWithholding(${safetyLabelType.name})”</p>
</dd>
</dl>
<p>override val features: Set[Feature[_]] = Set(MediaSafetyLabels)</p>
<p>override val optionalFeatures: Set[Feature[_]] = Set.empty</p>
<p>override val labelTypes: Set[SafetyLabelType] = Set(safetyLabelType)</p>
<p>private val UnsatisfiedResult: Unsatisfied = Unsatisfied(this)</p>
<dl class="simple">
<dt>private[this] def isWithheldWorldwide(label: SafetyLabel): Boolean = {</dt><dd><p>label.applicableCountries.map(_.contains(“xx”)).getOrElse(false)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def apply(</dt><dd><p>evaluationContext: EvaluationContext,
featureMap: Map[Feature[_], _]</p>
</dd>
<dt>): Result = {</dt><dd><p>val labels = featureMap(MediaSafetyLabels).asInstanceOf[Seq[MediaSafetyLabel]]</p>
<dl>
<dt>labels</dt><dd><dl>
<dt>.collectFirst {</dt><dd><dl>
<dt>case label</dt><dd><blockquote>
<div><dl class="simple">
<dt>if label.safetyLabelType == safetyLabelType</dt><dd><p>&amp;&amp; isWithheldWorldwide(label.safetyLabel) =&gt;</p>
</dd>
</dl>
</div></blockquote>
<p>Result.SatisfiedResult</p>
</dd>
</dl>
</dd>
</dl>
<p>}.getOrElse(UnsatisfiedResult)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../_sources/visibilitylib/src/main/scala/com/twitter/visibility/rules/Condition.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>