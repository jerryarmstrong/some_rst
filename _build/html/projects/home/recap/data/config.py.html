<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>import typing
from enum import Enum</p>
<p>from tml.core import config as base_config</p>
<p>import pydantic</p>
<dl>
<dt>class ExplicitDateInputs(base_config.BaseConfig):</dt><dd><p>“””Arguments to select train/validation data using end_date and days of data.”””</p>
<p>data_root: str = pydantic.Field(…, description=”Data path prefix.”)
end_date: str = pydantic.Field(…, description=”Data end date, inclusive.”)
days: int = pydantic.Field(…, description=”Number of days of data for dataset.”)
num_missing_days_tol: int = pydantic.Field(</p>
<blockquote>
<div><p>0, description=”We tolerate &lt;= num_missing_days_tol days of missing data.”</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>class ExplicitDatetimeInputs(base_config.BaseConfig):</dt><dd><p>“””Arguments to select train/validation data using end_datetime and hours of data.”””</p>
<p>data_root: str = pydantic.Field(…, description=”Data path prefix.”)
end_datetime: str = pydantic.Field(…, description=”Data end datetime, inclusive.”)
hours: int = pydantic.Field(…, description=”Number of hours of data for dataset.”)
num_missing_hours_tol: int = pydantic.Field(</p>
<blockquote>
<div><p>0, description=”We tolerate &lt;= num_missing_hours_tol hours of missing data.”</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>class DdsCompressionOption(str, Enum):</dt><dd><p>“””The only valid compression option is ‘AUTO’”””</p>
<p>AUTO = “AUTO”</p>
</dd>
<dt>class DatasetConfig(base_config.BaseConfig):</dt><dd><dl class="simple">
<dt>inputs: str = pydantic.Field(</dt><dd><p>None, description=”A glob for selecting data.”, one_of=”date_inputs_format”</p>
</dd>
</dl>
<p>)
explicit_datetime_inputs: ExplicitDatetimeInputs = pydantic.Field(</p>
<blockquote>
<div><p>None, one_of=”date_inputs_format”</p>
</div></blockquote>
<p>)
explicit_date_inputs: ExplicitDateInputs = pydantic.Field(None, one_of=”date_inputs_format”)</p>
<p>global_batch_size: pydantic.PositiveInt</p>
<dl class="simple">
<dt>num_files_to_keep: pydantic.PositiveInt = pydantic.Field(</dt><dd><p>None, description=”Number of shards to keep.”</p>
</dd>
</dl>
<p>)
repeat_files: bool = pydantic.Field(</p>
<blockquote>
<div><p>True, description=”DEPRICATED. Files are repeated no matter what this is set to.”</p>
</div></blockquote>
<p>)
file_batch_size: pydantic.PositiveInt = pydantic.Field(16, description=”File batch size”)</p>
<dl class="simple">
<dt>cache: bool = pydantic.Field(</dt><dd><p>False,
description=”Cache dataset in memory. Careful to only use this when you”
“ have enough memory to fit entire dataset.”,</p>
</dd>
</dl>
<p>)</p>
<p>data_service_dispatcher: str = pydantic.Field(None)
ignore_data_errors: bool = pydantic.Field(</p>
<blockquote>
<div><p>False, description=”Whether to ignore tf.data errors. DANGER DANGER, may wedge jobs.”</p>
</div></blockquote>
<p>)
dataset_service_compression: DdsCompressionOption = pydantic.Field(</p>
<blockquote>
<div><p>None,
description=”Compress the dataset for DDS worker -&gt; training host. Disabled by default and the only valid option is ‘AUTO’”,</p>
</div></blockquote>
<p>)</p>
<p># tf.data.Dataset options
examples_shuffle_buffer_size: int = pydantic.Field(1024, description=”Size of shuffle buffers.”)
map_num_parallel_calls: pydantic.PositiveInt = pydantic.Field(</p>
<blockquote>
<div><p>None, description=”Number of parallel calls.”</p>
</div></blockquote>
<p>)
interleave_num_parallel_calls: pydantic.PositiveInt = pydantic.Field(</p>
<blockquote>
<div><p>None, description=”Number of shards to interleave.”</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>class TruncateAndSlice(base_config.BaseConfig):</dt><dd><p># Apply truncation and then slice.
continuous_feature_truncation: pydantic.PositiveInt = pydantic.Field(</p>
<blockquote>
<div><p>None, description=”Experimental. Truncates continuous features to this amount for efficiency.”</p>
</div></blockquote>
<p>)
binary_feature_truncation: pydantic.PositiveInt = pydantic.Field(</p>
<blockquote>
<div><p>None, description=”Experimental. Truncates binary features to this amount for efficiency.”</p>
</div></blockquote>
<p>)</p>
<dl class="simple">
<dt>continuous_feature_mask_path: str = pydantic.Field(</dt><dd><p>None, description=”Path of mask used to slice input continuous features.”</p>
</dd>
</dl>
<p>)
binary_feature_mask_path: str = pydantic.Field(</p>
<blockquote>
<div><p>None, description=”Path of mask used to slice input binary features.”</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>class DataType(str, Enum):</dt><dd><p>BFLOAT16 = “bfloat16”
BOOL = “bool”</p>
<p>FLOAT32 = “float32”
FLOAT16 = “float16”</p>
<p>UINT8 = “uint8”</p>
</dd>
<dt>class DownCast(base_config.BaseConfig):</dt><dd><p># Apply down casting to selected features.
features: typing.Dict[str, DataType] = pydantic.Field(</p>
<blockquote>
<div><p>None, description=”Map features to down cast data types.”</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>class TaskData(base_config.BaseConfig):</dt><dd><dl class="simple">
<dt>pos_downsampling_rate: float = pydantic.Field(</dt><dd><p>1.0,
description=”Downsampling rate of positives used to generate dataset.”,</p>
</dd>
</dl>
<p>)
neg_downsampling_rate: float = pydantic.Field(</p>
<blockquote>
<div><p>1.0,
description=”Downsampling rate of negatives used to generate dataset.”,</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>class SegDenseSchema(base_config.BaseConfig):</dt><dd><p>schema_path: str = pydantic.Field(…, description=”Path to feature config json.”)
features: typing.List[str] = pydantic.Field(</p>
<blockquote>
<div><p>[],
description=”List of features (in addition to the renamed features) to read from schema path above.”,</p>
</div></blockquote>
<p>)
renamed_features: typing.Dict[str, str] = pydantic.Field(</p>
<blockquote>
<div><p>{}, description=”Dictionary of renamed features.”</p>
</div></blockquote>
<p>)
mask_mantissa_features: typing.Dict[str, int] = pydantic.Field(</p>
<blockquote>
<div><p>{},
description=”(experimental) Number of mantissa bits to mask to simulate lower precision data.”,</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>class RectifyLabels(base_config.BaseConfig):</dt><dd><dl class="simple">
<dt>label_rectification_window_in_hours: float = pydantic.Field(</dt><dd><p>3.0, description=”overlap time in hours for which to flip labels”</p>
</dd>
</dl>
<p>)
served_timestamp_field: str = pydantic.Field(</p>
<blockquote>
<div><p>…, description=”input field corresponding to served time”</p>
</div></blockquote>
<p>)
impressed_timestamp_field: str = pydantic.Field(</p>
<blockquote>
<div><p>…, description=”input field corresponding to impressed time”</p>
</div></blockquote>
<p>)
label_to_engaged_timestamp_field: typing.Dict[str, str] = pydantic.Field(</p>
<blockquote>
<div><p>…, description=”label to the input field corresponding to engagement time”</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>class ExtractFeaturesRow(base_config.BaseConfig):</dt><dd><dl class="simple">
<dt>name: str = pydantic.Field(</dt><dd><p>…,
description=”name of the new field name to be created”,</p>
</dd>
</dl>
<p>)
source_tensor: str = pydantic.Field(</p>
<blockquote>
<div><p>…,
description=”name of the dense tensor to look for the feature”,</p>
</div></blockquote>
<p>)
index: int = pydantic.Field(</p>
<blockquote>
<div><p>…,
description=”index of the feature in the dense tensor”,</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>class ExtractFeatures(base_config.BaseConfig):</dt><dd><dl class="simple">
<dt>extract_feature_table: typing.List[ExtractFeaturesRow] = pydantic.Field(</dt><dd><p>[],
description=”list of features to be extracted with their name, source tensor and index”,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>class DownsampleNegatives(base_config.BaseConfig):</dt><dd><dl class="simple">
<dt>batch_multiplier: int = pydantic.Field(</dt><dd><p>None,
description=”batch multiplier”,</p>
</dd>
</dl>
<p>)
engagements_list: typing.List[str] = pydantic.Field(</p>
<blockquote>
<div><p>[],
description=”engagements with kept positives”,</p>
</div></blockquote>
<p>)
num_engagements: int = pydantic.Field(</p>
<blockquote>
<div><p>…,
description=”number engagements used in the model, including ones excluded in engagements_list”,</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>class Preprocess(base_config.BaseConfig):</dt><dd><p>truncate_and_slice: TruncateAndSlice = pydantic.Field(None, description=”Truncation and slicing.”)
downcast: DownCast = pydantic.Field(None, description=”Down cast to features.”)
rectify_labels: RectifyLabels = pydantic.Field(</p>
<blockquote>
<div><p>None, description=”Rectify labels for a given overlap window”</p>
</div></blockquote>
<p>)
extract_features: ExtractFeatures = pydantic.Field(</p>
<blockquote>
<div><p>None, description=”Extract features from dense tensors.”</p>
</div></blockquote>
<p>)
downsample_negatives: DownsampleNegatives = pydantic.Field(</p>
<blockquote>
<div><p>None, description=”Downsample negatives.”</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>class Sampler(base_config.BaseConfig):</dt><dd><p>“””Assumes function is defined in data/samplers.py.</p>
<p>Only use this for quick experimentation.
If samplers are useful, we should sample from upstream data generation.</p>
<p>DEPRICATED, DO NOT USE.
“””</p>
<p>name: str
kwargs: typing.Dict</p>
</dd>
<dt>class RecapDataConfig(DatasetConfig):</dt><dd><p>seg_dense_schema: SegDenseSchema</p>
<dl class="simple">
<dt>tasks: typing.Dict[str, TaskData] = pydantic.Field(</dt><dd><p>description=”Description of individual tasks in this dataset.”</p>
</dd>
</dl>
<p>)
evaluation_tasks: typing.List[str] = pydantic.Field(</p>
<blockquote>
<div><p>[], description=”If specified, lists the tasks we’re generating metrics for.”</p>
</div></blockquote>
<p>)</p>
<dl class="simple">
<dt>preprocess: Preprocess = pydantic.Field(</dt><dd><p>None, description=”Function run in tf.data.Dataset at train/eval, in-graph at inference.”</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>sampler: Sampler = pydantic.Field(</dt><dd><p>None,
description=”””DEPRICATED, DO NOT USE. Sampling function for offline experiments.”””,</p>
</dd>
</dl>
<p>)</p>
<p>&#64;pydantic.root_validator()
def _validate_evaluation_tasks(cls, values):</p>
<blockquote>
<div><dl class="simple">
<dt>if values.get(“evaluation_tasks”) is not None:</dt><dd><dl class="simple">
<dt>for task in values[“evaluation_tasks”]:</dt><dd><dl class="simple">
<dt>if task not in values[“tasks”]:</dt><dd><p>raise KeyError(f”Evaluation task {task} must be in tasks. Received {values[‘tasks’]}”)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>return values</p>
</div></blockquote>
</dd>
</dl>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../_sources/projects/home/recap/data/config.py.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>