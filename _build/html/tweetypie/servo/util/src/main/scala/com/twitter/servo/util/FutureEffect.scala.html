<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../../" id="documentation_options" src="../../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.servo.util</p>
<p>import com.twitter.finagle.stats.{StatsReceiver, Stat}
import com.twitter.logging.{Logger, NullLogger}
import com.twitter.util._</p>
<dl>
<dt>object FutureEffect {</dt><dd><dl class="simple">
<dt>private[this] val _unit = FutureEffect[Any] { _ =&gt;</dt><dd><p>Future.Unit</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A FutureEffect that always succeeds.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>def unit[T]: FutureEffect[T] =</dt><dd><p>_unit.asInstanceOf[FutureEffect[T]]</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>A FutureEffect that always fails with the given exception.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>def fail[T](ex: Throwable): FutureEffect[T] =</dt><dd><dl class="simple">
<dt>FutureEffect[T] { _ =&gt;</dt><dd><p>Future.exception(ex)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Lift a function returning a Future to a FutureEffect.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>def apply[T](f: T =&gt; Future[Unit]) =</dt><dd><dl class="simple">
<dt>new FutureEffect[T] {</dt><dd><p>override def apply(x: T) = f(x)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Performs all of the effects in order. If any effect fails, the</p></li>
<li><p>whole operation fails, and the subsequent effects are not</p></li>
<li><p>attempted.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>def sequentially[T](effects: FutureEffect[T]*): FutureEffect[T] =</dt><dd><p>effects.foldLeft[FutureEffect[T]](unit[T])(_ andThen _)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Perform all of the effects concurrently. If any effect fails, the</p></li>
<li><p>whole operation fails, but any of the effects may or may not have</p></li>
<li><p>taken place.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>def inParallel[T](effects: FutureEffect[T]*): FutureEffect[T] =</dt><dd><dl class="simple">
<dt>FutureEffect[T] { t =&gt;</dt><dd><p>Future.join(effects map { _(t) })</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>def fromPartial[T](f: PartialFunction[T, Future[Unit]]) =</dt><dd><dl class="simple">
<dt>FutureEffect[T] { x =&gt;</dt><dd><p>if (f.isDefinedAt(x)) f(x) else Future.Unit</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Combines two FutureEffects into one that dispatches according to a gate.  If the gate is</p></li>
<li><p>true, use <cite>a</cite>, otherwise, use <cite>b</cite>.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>def selected[T](condition: Gate[Unit], a: FutureEffect[T], b: FutureEffect[T]): FutureEffect[T] =</dt><dd><p>selected(() =&gt; condition(), a, b)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Combines two FutureEffects into one that dispatches according to a nullary boolean function.</p></li>
<li><p>If the function returns true, use <cite>a</cite>, otherwise, use <cite>b</cite>.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>def selected[T](f: () =&gt; Boolean, a: FutureEffect[T], b: FutureEffect[T]): FutureEffect[T] =</dt><dd><dl class="simple">
<dt>FutureEffect[T] { t =&gt;</dt><dd><p>if (f()) a(t) else b(t)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A function whose only result is a future effect. This wrapper</p></li>
<li><p>provides convenient combinators.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
</dl>
<p>trait FutureEffect[T] extends (T =&gt; Future[Unit]) { self =&gt;</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Simplified version of <cite>apply</cite> when type is <cite>Unit</cite>.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
</dl>
<p>def apply()(implicit ev: Unit &lt;:&lt; T): Future[Unit] = self(())</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Combines two Future effects, performing this one first and</p></li>
<li><p>performing the next one if this one succeeds.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>def andThen(next: FutureEffect[T]): FutureEffect[T] =</dt><dd><dl>
<dt>FutureEffect[T] { x =&gt;</dt><dd><dl class="simple">
<dt>self(x) flatMap { _ =&gt;</dt><dd><p>next(x)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Wraps this FutureEffect with a failure handling function that will be chained to</p></li>
<li><p>the Future returned by this FutureEffect.</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
<dt>def rescue(</dt><dd><p>handler: PartialFunction[Throwable, FutureEffect[T]]</p>
</dd>
<dt>): FutureEffect[T] =</dt><dd><dl>
<dt>FutureEffect[T] { x =&gt;</dt><dd><dl class="simple">
<dt>self(x) rescue {</dt><dd><dl class="simple">
<dt>case t if handler.isDefinedAt(t) =&gt;</dt><dd><p>handler(t)(x)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Combines two future effects, performing them both simultaneously.</p></li>
<li><p>If either effect fails, the result will be failure, but the other</p></li>
<li><p>effects will have occurred.</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>def inParallel(other: FutureEffect[T]) =</dt><dd><dl class="simple">
<dt>FutureEffect[T] { x =&gt;</dt><dd><p>Future.join(Seq(self(x), other(x)))</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Perform this effect only if the provided gate returns true.</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
<dt>def enabledBy(enabled: Gate[Unit]): FutureEffect[T] =</dt><dd><p>enabledBy(() =&gt; enabled())</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Perform this effect only if the provided gate returns true.</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
<dt>def enabledBy(enabled: () =&gt; Boolean): FutureEffect[T] =</dt><dd><dl class="simple">
<dt>onlyIf { _ =&gt;</dt><dd><p>enabled()</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Perform this effect only if the provided predicate returns true</p></li>
<li><p>for the input.</p></li>
</ul>
<p><a href="#id29"><span class="problematic" id="id30">*</span></a>/</p>
</dd>
<dt>def onlyIf(predicate: T =&gt; Boolean) =</dt><dd><dl class="simple">
<dt>FutureEffect[T] { x =&gt;</dt><dd><p>if (predicate(x)) self(x) else Future.Unit</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Perform this effect with arg only if the condition is true. Otherwise just return Future Unit</p></li>
</ul>
<p><a href="#id31"><span class="problematic" id="id32">*</span></a>/</p>
</dd>
<dt>def when(condition: Boolean)(arg: =&gt; T): Future[Unit] =</dt><dd><p>if (condition) self(arg) else Future.Unit</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Adapt this effect to take a different input via the provided conversion.</p></li>
<li></li>
<li><p>(Contravariant map)</p></li>
</ul>
<p><a href="#id33"><span class="problematic" id="id34">*</span></a>/</p>
</dd>
<dt>def contramap[U](g: U =&gt; T) = FutureEffect[U] { u =&gt;</dt><dd><p>self(g(u))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Adapt this effect to take a different input via the provided conversion.</p></li>
<li></li>
<li><p>(Contravariant map)</p></li>
</ul>
<p><a href="#id35"><span class="problematic" id="id36">*</span></a>/</p>
</dd>
<dt>def contramapFuture[U](g: U =&gt; Future[T]) = FutureEffect[U] { u =&gt;</dt><dd><p>g(u) flatMap self</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Adapt this effect to take a different input via the provided conversion.</p></li>
<li><p>If the output value of the given function is None, the effect is a no-op.</p></li>
</ul>
<p><a href="#id37"><span class="problematic" id="id38">*</span></a>/</p>
</dd>
<dt>def contramapOption[U](g: U =&gt; Option[T]) =</dt><dd><dl>
<dt>FutureEffect[U] {</dt><dd><dl class="simple">
<dt>g andThen {</dt><dd><p>case None =&gt; Future.Unit
case Some(t) =&gt; self(t)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Adapt this effect to take a different input via the provided conversion.</p></li>
<li><p>If the output value of the given function is future-None, the effect is a no-op.</p></li>
<li><p>(Contravariant map)</p></li>
</ul>
<p><a href="#id39"><span class="problematic" id="id40">*</span></a>/</p>
</dd>
<dt>def contramapFutureOption[U](g: U =&gt; Future[Option[T]]) =</dt><dd><dl>
<dt>FutureEffect[U] { u =&gt;</dt><dd><dl class="simple">
<dt>g(u) flatMap {</dt><dd><p>case None =&gt; Future.Unit
case Some(x) =&gt; self(x)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Adapt this effect to take a sequence of input values.</p></li>
</ul>
<p><a href="#id41"><span class="problematic" id="id42">*</span></a>/</p>
</dd>
<dt>def liftSeq: FutureEffect[Seq[T]] =</dt><dd><dl class="simple">
<dt>FutureEffect[Seq[T]] { seqT =&gt;</dt><dd><p>Future.join(seqT.map(self))</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Allow the effect to fail, but immediately return success. The</p></li>
<li><p>effect is not guaranteed to have finished when its future is</p></li>
<li><p>available.</p></li>
</ul>
<p><a href="#id43"><span class="problematic" id="id44">*</span></a>/</p>
</dd>
<dt>def ignoreFailures: FutureEffect[T] =</dt><dd><dl class="simple">
<dt>FutureEffect[T] { x =&gt;</dt><dd><p>Try(self(x)); Future.Unit</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Allow the effect to fail but always return success.  Unlike ignoreFailures, the</p></li>
<li><p>effect is guaranteed to have finished when its future is available.</p></li>
</ul>
<p><a href="#id45"><span class="problematic" id="id46">*</span></a>/</p>
</dd>
<dt>def ignoreFailuresUponCompletion: FutureEffect[T] =</dt><dd><dl>
<dt>FutureEffect[T] { x =&gt;</dt><dd><dl class="simple">
<dt>Try(self(x)) match {</dt><dd><p>case Return(f) =&gt; f.handle { case _ =&gt; () }
case Throw(_) =&gt; Future.Unit</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns a chained FutureEffect in which the given function will be called for any</p></li>
<li><p>input that succeeds.</p></li>
</ul>
<p><a href="#id47"><span class="problematic" id="id48">*</span></a>/</p>
</dd>
<dt>def onSuccess(f: T =&gt; Unit): FutureEffect[T] =</dt><dd><dl class="simple">
<dt>FutureEffect[T] { x =&gt;</dt><dd><p>self(x).onSuccess(_ =&gt; f(x))</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns a chained FutureEffect in which the given function will be called for any</p></li>
<li><p>input that fails.</p></li>
</ul>
<p><a href="#id49"><span class="problematic" id="id50">*</span></a>/</p>
</dd>
<dt>def onFailure(f: (T, Throwable) =&gt; Unit): FutureEffect[T] =</dt><dd><dl class="simple">
<dt>FutureEffect[T] { x =&gt;</dt><dd><p>self(x).onFailure(t =&gt; f(x, t))</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Translate exception returned by a FutureEffect according to a</p></li>
<li><p>PartialFunction.</p></li>
</ul>
<p><a href="#id51"><span class="problematic" id="id52">*</span></a>/</p>
</dd>
<dt>def translateExceptions(</dt><dd><p>translateException: PartialFunction[Throwable, Throwable]</p>
</dd>
<dt>): FutureEffect[T] =</dt><dd><dl>
<dt>FutureEffect[T] { request =&gt;</dt><dd><dl class="simple">
<dt>self(request) rescue {</dt><dd><p>case t if translateException.isDefinedAt(t) =&gt; Future.exception(translateException(t))
case t =&gt; Future.exception(t)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Wraps an effect with retry logic.  Will retry against any failure.</p></li>
</ul>
<p><a href="#id53"><span class="problematic" id="id54">*</span></a>/</p>
</dd>
<dt>def retry(backoffs: Stream[Duration], timer: Timer, stats: StatsReceiver): FutureEffect[T] =</dt><dd><p>retry(RetryHandler.failuresOnly(backoffs, timer, stats))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns a new FutureEffect that executes the effect within the given RetryHandler, which</p></li>
<li><p>may retry the operation on failures.</p></li>
</ul>
<p><a href="#id55"><span class="problematic" id="id56">*</span></a>/</p>
</dd>
<dt>def retry(handler: RetryHandler[Unit]): FutureEffect[T] =</dt><dd><p>FutureEffect[T](handler.wrap(self))</p>
</dd>
</dl>
<p>&#64;deprecated(“use trackOutcome”, “2.11.1”)
def countExceptions(stats: StatsReceiver, getScope: T =&gt; String) = {</p>
<blockquote>
<div><p>val exceptionCounterFactory = new MemoizedExceptionCounterFactory(stats)
FutureEffect[T] { t =&gt;</p>
<blockquote>
<div><p>exceptionCounterFactory(getScope(t)) { self(t) }</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a FutureEffect that tracks the latency of the underlying operation.</p></li>
</ul>
<p><a href="#id57"><span class="problematic" id="id58">*</span></a>/</p>
</dd>
<dt>def trackLatency(stats: StatsReceiver, extractName: T =&gt; String): FutureEffect[T] =</dt><dd><dl class="simple">
<dt>FutureEffect[T] { t =&gt;</dt><dd><p>Stat.timeFuture(stats.stat(extractName(t), “latency_ms”)) { self(t) }</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>def trackOutcome(</dt><dd><p>stats: StatsReceiver,
extractName: T =&gt; String,
logger: Logger = NullLogger</p>
</dd>
</dl>
<p>): FutureEffect[T] = trackOutcome(stats, extractName, logger, _ =&gt; None)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a FutureEffect that tracks the outcome (i.e. success vs failure) of</p></li>
<li><p>requests, including counting exceptions by classname.</p></li>
</ul>
<p><a href="#id59"><span class="problematic" id="id60">*</span></a>/</p>
</dd>
<dt>def trackOutcome(</dt><dd><p>stats: StatsReceiver,
extractName: T =&gt; String,
logger: Logger,
exceptionCategorizer: Throwable =&gt; Option[String]</p>
</dd>
<dt>): FutureEffect[T] =</dt><dd><dl>
<dt>FutureEffect[T] { t =&gt;</dt><dd><p>val name = extractName(t)
val scope = stats.scope(name)</p>
<dl>
<dt>self(t) respond { r =&gt;</dt><dd><p>scope.counter(“requests”).incr()</p>
<dl class="simple">
<dt>r match {</dt><dd><dl class="simple">
<dt>case Return(_) =&gt;</dt><dd><p>scope.counter(“success”).incr()</p>
</dd>
<dt>case Throw(t) =&gt;</dt><dd><p>val category = exceptionCategorizer(t).getOrElse(“failures”)
scope.counter(category).incr()
scope.scope(category).counter(ThrowableHelper.sanitizeClassnameChain(t): _*).incr()
logger.warning(t, s”failure in $name”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Observe latency and success rate for any FutureEffect</p></li>
<li><p>&#64;param statsScope a function to produce a parent stats scope from the argument</p></li>
<li><p>to the FutureEffect</p></li>
<li><p>&#64;param exceptionCategorizer a function to assign different Throwables with custom stats scopes.</p></li>
</ul>
<p><a href="#id61"><span class="problematic" id="id62">*</span></a>/</p>
</dd>
<dt>def observed(</dt><dd><p>statsReceiver: StatsReceiver,
statsScope: T =&gt; String,
logger: Logger = NullLogger,
exceptionCategorizer: Throwable =&gt; Option[String] = _ =&gt; None</p>
</dd>
<dt>): FutureEffect[T] =</dt><dd><dl class="simple">
<dt>self</dt><dd><p>.trackLatency(statsReceiver, statsScope)
.trackOutcome(statsReceiver, statsScope, logger, exceptionCategorizer)</p>
</dd>
</dl>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a new FutureEffect where the given function is applied to the result of this</p></li>
<li><p>FutureEffect.</p></li>
</ul>
<p><a href="#id63"><span class="problematic" id="id64">*</span></a>/</p>
</dd>
<dt>def mapResult(f: Future[Unit] =&gt; Future[Unit]): FutureEffect[T] =</dt><dd><dl class="simple">
<dt>FutureEffect[T] { x =&gt;</dt><dd><p>f(self(x))</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a new FutureEffect where the returned Future must complete within the specified</p></li>
<li><p>timeout, otherwise the Future fails with a com.twitter.util.TimeoutException.</p></li>
<li></li>
<li><p>‘’Note’’: On timeout, the underlying future is NOT interrupted.</p></li>
</ul>
<p><a href="#id65"><span class="problematic" id="id66">*</span></a>/</p>
</dd>
<dt>def withTimeout(timer: Timer, timeout: Duration): FutureEffect[T] =</dt><dd><p>mapResult(_.within(timer, timeout))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a new FutureEffect where the returned Future must complete within the specified</p></li>
<li><p>timeout, otherwise the Future fails with the specified Throwable.</p></li>
<li></li>
<li><p>‘’Note’’: On timeout, the underlying future is NOT interrupted.</p></li>
</ul>
<p><a href="#id67"><span class="problematic" id="id68">*</span></a>/</p>
</dd>
<dt>def withTimeout(timer: Timer, timeout: Duration, exc: =&gt; Throwable): FutureEffect[T] =</dt><dd><p>mapResult(_.within(timer, timeout, exc))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a new FutureEffect where the returned Future must complete within the specified</p></li>
<li><p>timeout, otherwise the Future fails with a com.twitter.util.TimeoutException.</p></li>
<li></li>
<li><p>‘’Note’’: On timeout, the underlying future is interrupted.</p></li>
</ul>
<p><a href="#id69"><span class="problematic" id="id70">*</span></a>/</p>
</dd>
<dt>def raiseWithin(timer: Timer, timeout: Duration): FutureEffect[T] =</dt><dd><p>mapResult(_.raiseWithin(timeout)(timer))</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces a new FutureEffect where the returned Future must complete within the specified</p></li>
<li><p>timeout, otherwise the Future fails with the specified Throwable.</p></li>
<li></li>
<li><p>‘’Note’’: On timeout, the underlying future is interrupted.</p></li>
</ul>
<p><a href="#id71"><span class="problematic" id="id72">*</span></a>/</p>
</dd>
<dt>def raiseWithin(timer: Timer, timeout: Duration, exc: =&gt; Throwable): FutureEffect[T] =</dt><dd><p>mapResult(_.raiseWithin(timer, timeout, exc))</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../../_sources/tweetypie/servo/util/src/main/scala/com/twitter/servo/util/FutureEffect.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>