<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../../" id="documentation_options" src="../../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.servo.cache</p>
<p>import com.twitter.finagle.stats.{Stat, StatsReceiver}
import com.twitter.logging.{Level, Logger}
import com.twitter.servo.util.{ExceptionCounter, WindowedAverage}
import com.twitter.util._</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>track hits and misses in caches, time reads and writes</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
</dl>
<p>trait CacheObserver {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>register a hit</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
</dl>
<p>def hit(key: String): Unit</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>register a miss</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
</dl>
<p>def miss(key: String): Unit</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>time the read, and automatically handle hits and misses from the KeyValueResult</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>def read[K, T](</dt><dd><p>name: String,
keys: Seq[K]</p>
</dd>
<dt>)(</dt><dd><p>f: =&gt; Future[KeyValueResult[K, T]]</p>
</dd>
</dl>
<p>): Future[KeyValueResult[K, T]]</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>time the write</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
</dl>
<p>def write[K, T](name: String, key: K)(f: =&gt; Future[T]): Future[T]</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>time the incr, and record the success/failure</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
</dl>
<p>def incr[K](name: String, key: Seq[K])(f: =&gt; Future[Option[Long]]): Future[Option[Long]]</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>produce a new CacheObserver with a nested scope</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
</dl>
<p>def scope(s: String*): CacheObserver</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>increment a counter tracking the number of expirations.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
</dl>
<p>def expired(delta: Int = 1): Unit</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Increment a counter tracking the number of failures.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
</dl>
<p>def failure(delta: Int = 1): Unit</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Increment a counter tracking the number of tombstones.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
</dl>
<p>def tombstone(delta: Int = 1): Unit</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Increment a counter tracking the number of not cached.</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
</dl>
<p>def noCache(delta: Int = 1): Unit</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>object NullCacheObserver extends CacheObserver {</dt><dd><p>override def hit(key: String) = ()
override def miss(key: String) = ()
override def read[K, T](name: String, keys: Seq[K])(f: =&gt; Future[KeyValueResult[K, T]]) = f
override def write[K, T](name: String, key: K)(f: =&gt; Future[T]) = f
override def incr[K](name: String, key: Seq[K])(f: =&gt; Future[Option[Long]]) = f
override def scope(s: String*) = this
override def expired(delta: Int = 1) = ()
override def failure(delta: Int = 1): Unit = {}
override def tombstone(delta: Int = 1): Unit = {}
override def noCache(delta: Int = 1): Unit = {}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A CacheObserver that writes to a StatsReceiver</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>class StatsReceiverCacheObserver(</dt><dd><p>stats: StatsReceiver,
windowSize: Long,
log: Logger,
disableLogging: Boolean = false)</p>
<blockquote>
<div><p>extends CacheObserver {</p>
</div></blockquote>
<dl>
<dt>def this(</dt><dd><p>statsReceiver: StatsReceiver,
windowSize: Long,
scope: String</p>
</dd>
<dt>) =</dt><dd><dl class="simple">
<dt>this(</dt><dd><p>statsReceiver.scope(scope),
windowSize,
Logger.get(scope.replaceAll(“([a-z]+)([A-Z])”, “$1_$2”).toLowerCase)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>def this(</dt><dd><p>statsReceiver: StatsReceiver,
windowSize: Long,
scope: String,
disableLogging: Boolean</p>
</dd>
<dt>) =</dt><dd><dl class="simple">
<dt>this(</dt><dd><p>statsReceiver.scope(scope),
windowSize,
Logger.get(scope.replaceAll(“([a-z]+)([A-Z])”, “$1_$2”).toLowerCase),
disableLogging</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>protected[this] val expirationCounter = stats.counter(“expirations”)</p>
<p>// needed to make sure we hand out the same observer for each scope,
// so that the hit rates are properly calculated
protected[this] val children = Memoize {</p>
<blockquote>
<div><p>new StatsReceiverCacheObserver(stats, windowSize, _: String, disableLogging)</p>
</div></blockquote>
<p>}</p>
<p>protected[this] val exceptionCounter = new ExceptionCounter(stats)
private[this] val hitCounter = stats.counter(“hits”)
private[this] val missCounter = stats.counter(“misses”)
private[this] val failuresCounter = stats.counter(“failures”)
private[this] val tombstonesCounter = stats.counter(“tombstones”)
private[this] val noCacheCounter = stats.counter(“noCache”)</p>
<p>private[this] val windowedHitRate = new WindowedAverage(windowSize)
private[this] val windowedIncrHitRate = new WindowedAverage(windowSize)</p>
<dl class="simple">
<dt>private[this] val hitRateGauge = stats.addGauge(“hit_rate”) {</dt><dd><p>windowedHitRate.value.getOrElse(1.0).toFloat</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private[this] val incrHitRateGauge = stats.addGauge(“incr_hit_rate”) {</dt><dd><p>windowedIncrHitRate.value.getOrElse(1.0).toFloat</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>protected[this] def handleThrowable[K](name: String, t: Throwable, key: Option[K]): Unit = {</dt><dd><p>stats.counter(name + “_failures”).incr()
exceptionCounter(t)
if (!disableLogging) {</p>
<blockquote>
<div><dl>
<dt>lazy val suffix = key</dt><dd><dl class="simple">
<dt>.map { k =&gt;</dt><dd><p>“(” + k.toString + “)”</p>
</dd>
</dl>
<p>}
.getOrElse(“”)</p>
</dd>
</dl>
<p>log.warning(“%s%s caught: %s”, name, suffix, t.getClass.getName)
log.trace(t, “stack trace was: “)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def hit(key: String): Unit = {</dt><dd><p>hits(1)
if (!disableLogging)</p>
<blockquote>
<div><p>log.trace(“cache hit: %s”, key)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private[this] def hits(n: Int): Unit = {</dt><dd><p>windowedHitRate.record(n.toDouble, n.toDouble)
hitCounter.incr(n)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def miss(key: String): Unit = {</dt><dd><p>misses(1)
if (!disableLogging)</p>
<blockquote>
<div><p>log.trace(“cache miss: %s”, key)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private[this] def misses(n: Int): Unit = {</dt><dd><p>windowedHitRate.record(0.0F, n.toDouble)
missCounter.incr(n)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def read[K, T](</dt><dd><p>name: String,
keys: Seq[K]</p>
</dd>
<dt>)(</dt><dd><p>f: =&gt; Future[KeyValueResult[K, T]]</p>
</dd>
<dt>): Future[KeyValueResult[K, T]] =</dt><dd><dl>
<dt>Stat</dt><dd><dl class="simple">
<dt>.timeFuture(stats.stat(name)) {</dt><dd><p>stats.counter(name).incr()
f</p>
</dd>
</dl>
<p>}
.respond {</p>
<blockquote>
<div><dl>
<dt>case Return(lr) =&gt;</dt><dd><dl>
<dt>if (log.isLoggable(Level.TRACE)) {</dt><dd><dl class="simple">
<dt>lr.found.keys.foreach { k =&gt;</dt><dd><p>hit(k.toString)</p>
</dd>
</dl>
<p>}
lr.notFound.foreach { k =&gt;</p>
<blockquote>
<div><p>miss(k.toString)</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>hits(lr.found.keys.size)
misses(lr.notFound.size)</p>
</dd>
</dl>
<p>}
lr.failed foreach {</p>
<blockquote>
<div><dl class="simple">
<dt>case (k, t) =&gt;</dt><dd><p>handleThrowable(name, t, Some(k))
// count failures as misses
miss(k.toString)
failuresCounter.incr()</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
<dt>case Throw(t) =&gt;</dt><dd><p>handleThrowable(name, t, None)
// count failures as misses
keys.foreach { k =&gt;</p>
<blockquote>
<div><p>miss(k.toString)</p>
</div></blockquote>
<p>}
failuresCounter.incr()</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
<dt>override def write[K, T](name: String, key: K)(f: =&gt; Future[T]): Future[T] =</dt><dd><dl class="simple">
<dt>Stat.timeFuture(stats.stat(name)) {</dt><dd><p>stats.counter(name).incr()
f</p>
</dd>
<dt>} onFailure {</dt><dd><p>handleThrowable(name, _, Some(key))</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override def incr[K](name: String, key: Seq[K])(f: =&gt; Future[Option[Long]]) =</dt><dd><dl class="simple">
<dt>Stat.timeFuture(stats.stat(name)) {</dt><dd><p>stats.counter(name).incr()
f</p>
</dd>
<dt>} onSuccess { optVal =&gt;</dt><dd><p>val hit = optVal.isDefined
windowedIncrHitRate.record(if (hit) 1F else 0F)
stats.counter(name + (if (hit) “_hits” else “_misses”)).incr()</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override def scope(s: String*) =</dt><dd><dl class="simple">
<dt>s.toList match {</dt><dd><p>case Nil =&gt; this
case head :: tail =&gt; children(head).scope(tail: _*)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>override def expired(delta: Int = 1): Unit = { expirationCounter.incr(delta) }
override def failure(delta: Int = 1): Unit = { failuresCounter.incr(delta) }
override def tombstone(delta: Int = 1): Unit = { tombstonesCounter.incr(delta) }
override def noCache(delta: Int = 1): Unit = { noCacheCounter.incr(delta) }</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Wraps an underlying cache with calls to a CacheObserver</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
<dt>class ObservableReadCache[K, V](underlyingCache: ReadCache[K, V], observer: CacheObserver)</dt><dd><blockquote>
<div><p>extends ReadCache[K, V] {</p>
</div></blockquote>
<dl>
<dt>override def get(keys: Seq[K]): Future[KeyValueResult[K, V]] = {</dt><dd><dl class="simple">
<dt>observer.read(“get”, keys) {</dt><dd><p>underlyingCache.get(keys)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override def getWithChecksum(keys: Seq[K]): Future[CsKeyValueResult[K, V]] = {</dt><dd><dl class="simple">
<dt>observer.read[K, (Try[V], Checksum)](“get_with_checksum”, keys) {</dt><dd><p>underlyingCache.getWithChecksum(keys)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>override def release() = underlyingCache.release()</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>object ObservableCache {</dt><dd><dl>
<dt>def apply[K, V](</dt><dd><p>underlyingCache: Cache[K, V],
statsReceiver: StatsReceiver,
windowSize: Long,
name: String</p>
</dd>
<dt>): Cache[K, V] =</dt><dd><dl class="simple">
<dt>new ObservableCache(</dt><dd><p>underlyingCache,
new StatsReceiverCacheObserver(statsReceiver, windowSize, name)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>def apply[K, V](</dt><dd><p>underlyingCache: Cache[K, V],
statsReceiver: StatsReceiver,
windowSize: Long,
name: String,
disableLogging: Boolean</p>
</dd>
<dt>): Cache[K, V] =</dt><dd><dl>
<dt>new ObservableCache(</dt><dd><p>underlyingCache,
new StatsReceiverCacheObserver(</p>
<blockquote>
<div><p>statsReceiver = statsReceiver,
windowSize = windowSize,
scope = name,
disableLogging = disableLogging)</p>
</div></blockquote>
</dd>
</dl>
<p>)</p>
</dd>
<dt>def apply[K, V](</dt><dd><p>underlyingCache: Cache[K, V],
statsReceiver: StatsReceiver,
windowSize: Long,
log: Logger</p>
</dd>
<dt>): Cache[K, V] =</dt><dd><dl class="simple">
<dt>new ObservableCache(</dt><dd><p>underlyingCache,
new StatsReceiverCacheObserver(statsReceiver, windowSize, log)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Wraps an underlying Cache with calls to a CacheObserver</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
<dt>class ObservableCache[K, V](underlyingCache: Cache[K, V], observer: CacheObserver)</dt><dd><blockquote>
<div><p>extends ObservableReadCache(underlyingCache, observer)
with Cache[K, V] {</p>
</div></blockquote>
<dl>
<dt>override def add(key: K, value: V): Future[Boolean] =</dt><dd><dl class="simple">
<dt>observer.write(“add”, key) {</dt><dd><p>underlyingCache.add(key, value)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override def checkAndSet(key: K, value: V, checksum: Checksum): Future[Boolean] =</dt><dd><dl class="simple">
<dt>observer.write(“check_and_set”, key) {</dt><dd><p>underlyingCache.checkAndSet(key, value, checksum)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override def set(key: K, value: V): Future[Unit] =</dt><dd><dl class="simple">
<dt>observer.write(“set”, key) {</dt><dd><p>underlyingCache.set(key, value)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override def replace(key: K, value: V): Future[Boolean] =</dt><dd><dl class="simple">
<dt>observer.write(“replace”, key) {</dt><dd><p>underlyingCache.replace(key, value)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override def delete(key: K): Future[Boolean] =</dt><dd><dl class="simple">
<dt>observer.write(“delete”, key) {</dt><dd><p>underlyingCache.delete(key)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>object ObservableTtlCache {</dt><dd><dl>
<dt>def apply[K, V](</dt><dd><p>underlyingCache: TtlCache[K, V],
statsReceiver: StatsReceiver,
windowSize: Long,
name: String</p>
</dd>
<dt>): TtlCache[K, V] =</dt><dd><dl class="simple">
<dt>new ObservableTtlCache(</dt><dd><p>underlyingCache,
new StatsReceiverCacheObserver(statsReceiver, windowSize, name)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Wraps an underlying TtlCache with calls to a CacheObserver</p></li>
</ul>
<p><a href="#id29"><span class="problematic" id="id30">*</span></a>/</p>
</dd>
<dt>class ObservableTtlCache[K, V](underlyingCache: TtlCache[K, V], observer: CacheObserver)</dt><dd><blockquote>
<div><p>extends ObservableReadCache(underlyingCache, observer)
with TtlCache[K, V] {</p>
</div></blockquote>
<dl>
<dt>override def add(key: K, value: V, ttl: Duration): Future[Boolean] =</dt><dd><dl class="simple">
<dt>observer.write(“add”, key) {</dt><dd><p>underlyingCache.add(key, value, ttl)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override def checkAndSet(key: K, value: V, checksum: Checksum, ttl: Duration): Future[Boolean] =</dt><dd><dl class="simple">
<dt>observer.write(“check_and_set”, key) {</dt><dd><p>underlyingCache.checkAndSet(key, value, checksum, ttl)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override def set(key: K, value: V, ttl: Duration): Future[Unit] =</dt><dd><dl class="simple">
<dt>observer.write(“set”, key) {</dt><dd><p>underlyingCache.set(key, value, ttl)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override def replace(key: K, value: V, ttl: Duration): Future[Boolean] =</dt><dd><dl class="simple">
<dt>observer.write(“replace”, key) {</dt><dd><p>underlyingCache.replace(key, value, ttl)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override def delete(key: K): Future[Boolean] =</dt><dd><dl class="simple">
<dt>observer.write(“delete”, key) {</dt><dd><p>underlyingCache.delete(key)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>case class ObservableMemcacheFactory(memcacheFactory: MemcacheFactory, cacheObserver: CacheObserver)</dt><dd><blockquote>
<div><p>extends MemcacheFactory {</p>
</div></blockquote>
<dl class="simple">
<dt>override def apply() =</dt><dd><p>new ObservableMemcache(memcacheFactory(), cacheObserver)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>&#64;deprecated(“use ObservableMemcacheFactory or ObservableMemcache directly”, “0.1.2”)
object ObservableMemcache {</p>
<blockquote>
<div><dl>
<dt>def apply(</dt><dd><p>underlyingCache: Memcache,
statsReceiver: StatsReceiver,
windowSize: Long,
name: String</p>
</dd>
<dt>): Memcache =</dt><dd><dl class="simple">
<dt>new ObservableMemcache(</dt><dd><p>underlyingCache,
new StatsReceiverCacheObserver(statsReceiver, windowSize, name)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl>
<dt>class ObservableMemcache(underlyingCache: Memcache, observer: CacheObserver)</dt><dd><blockquote>
<div><p>extends ObservableTtlCache[String, Array[Byte]](underlyingCache, observer)
with Memcache {</p>
</div></blockquote>
<dl>
<dt>def incr(key: String, delta: Long = 1): Future[Option[Long]] =</dt><dd><dl class="simple">
<dt>observer.incr(“incr”, key) {</dt><dd><p>underlyingCache.incr(key, delta)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>def decr(key: String, delta: Long = 1): Future[Option[Long]] =</dt><dd><dl class="simple">
<dt>observer.incr(“decr”, key) {</dt><dd><p>underlyingCache.decr(key, delta)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../../_sources/tweetypie/servo/repo/src/main/scala/com/twitter/servo/cache/ObservableCache.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>