<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie
package handler</p>
<p>import com.twitter.stitch.Stitch
import com.twitter.timelineservice.{thriftscala =&gt; tls}
import com.twitter.tweetypie.backends.TimelineService
import com.twitter.tweetypie.repository.TweetQuery
import com.twitter.tweetypie.repository.TweetRepository
import com.twitter.tweetypie.thriftscala.CardReference
import com.twitter.tweetypie.thriftscala.ConversationControl
import com.twitter.tweetypie.thriftscala.ConversationControlByInvitation
import com.twitter.tweetypie.thriftscala.ConversationControlCommunity
import com.twitter.tweetypie.thriftscala.ConversationControlFollowers
import com.twitter.tweetypie.thriftscala.EditControl
import com.twitter.tweetypie.thriftscala.EditOptions
import com.twitter.tweetypie.thriftscala.NoteTweetOptions
import com.twitter.tweetypie.thriftscala.PostTweetRequest
import com.twitter.tweetypie.thriftscala.TweetCreateConversationControl
import com.twitter.tweetypie.util.ConversationControls
import com.twitter.tweetypie.util.EditControlUtil
import com.twitter.util.Time</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Used at tweet creation time to determine whether the tweet creation</p></li>
<li><p>request should be considered a duplicate of an existing tweet.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
</dl>
<p>object DuplicateTweetFinder {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Return the ids of any tweets that are found to be duplicates of</p></li>
<li><p>this request.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
</dl>
<p>type Type = RequestInfo =&gt; Future[Option[TweetId]]</p>
<dl class="simple">
<dt>final case class Settings(</dt><dd><p>// The number of tweets that are loaded from the user’s timeline
// for the heuristic duplicate check
numTweetsToCheck: Int,
// The oldest that a tweet can be to still be considered a
// duplicate by the heuristic duplicate check
maxDuplicateAge: Duration)</p>
</dd>
</dl>
<p>// Takes a ConversationControl from a Tweet and converts to the equivalent
// TweetCreateConversationControl. Note: this is a lossy conversion because the
// ConversationControl contains additional data from the Tweet.
def toTweetCreateConversationControl(</p>
<blockquote>
<div><p>conversationControl: ConversationControl</p>
</div></blockquote>
<dl>
<dt>): TweetCreateConversationControl =</dt><dd><dl>
<dt>conversationControl match {</dt><dd><dl>
<dt>case ConversationControl.ByInvitation(</dt><dd><blockquote>
<div><p>ConversationControlByInvitation(_, _, inviteViaMention)) =&gt;</p>
</div></blockquote>
<p>ConversationControls.Create.byInvitation(inviteViaMention)</p>
</dd>
<dt>case ConversationControl.Community(ConversationControlCommunity(_, _, inviteViaMention)) =&gt;</dt><dd><p>ConversationControls.Create.community(inviteViaMention)</p>
</dd>
<dt>case ConversationControl.Followers(ConversationControlFollowers(_, _, inviteViaMention)) =&gt;</dt><dd><p>ConversationControls.Create.followers(inviteViaMention)</p>
</dd>
</dl>
<p>case _ =&gt; throw new IllegalArgumentException</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>The parts of the request that we need in order to perform</p></li>
<li><p>duplicate detection.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>final case class RequestInfo(</dt><dd><p>userId: UserId,
isNarrowcast: Boolean,
isNullcast: Boolean,
text: String,
replyToTweetId: Option[TweetId],
mediaUploadIds: Seq[MediaId],
cardReference: Option[CardReference],
conversationControl: Option[TweetCreateConversationControl],
underlyingCreativesContainer: Option[CreativesContainerId],
editOptions: Option[EditOptions] = None,
noteTweetOptions: Option[NoteTweetOptions] = None) {</p>
<dl>
<dt>def isDuplicateOf(tweet: Tweet, oldestAcceptableTimestamp: Time): Boolean = {</dt><dd><p>val createdAt = getTimestamp(tweet)
val isDuplicateText = text == getText(tweet)
val isDuplicateReplyToTweetId = replyToTweetId == getReply(tweet).flatMap(_.inReplyToStatusId)
val isDuplicateMedia = getMedia(tweet).map(_.mediaId) == mediaUploadIds
val isDuplicateCardReference = getCardReference(tweet) == cardReference
val isDuplicateConversationControl =</p>
<blockquote>
<div><p>tweet.conversationControl.map(toTweetCreateConversationControl) == conversationControl</p>
</div></blockquote>
<dl class="simple">
<dt>val isDuplicateConversationContainerId = {</dt><dd><p>tweet.underlyingCreativesContainerId == underlyingCreativesContainer</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val isDuplicateIfEditRequest = if (editOptions.isDefined) {</dt><dd><p>// We do not count an incoming edit request as creating a duplicate tweet if:
// 1) The tweet that is considered a duplicate is a previous version of this tweet OR
// 2) The tweet that is considered a duplicate is otherwise stale.
val tweetEditChain = tweet.editControl match {</p>
<blockquote>
<div><dl class="simple">
<dt>case Some(EditControl.Initial(initial)) =&gt;</dt><dd><p>initial.editTweetIds</p>
</dd>
<dt>case Some(EditControl.Edit(edit)) =&gt;</dt><dd><p>edit.editControlInitial.map(_.editTweetIds).getOrElse(Nil)</p>
</dd>
</dl>
<p>case _ =&gt; Nil</p>
</div></blockquote>
<p>}
val tweetIsAPreviousVersion =</p>
<blockquote>
<div><p>editOptions.map(_.previousTweetId).exists(tweetEditChain.contains)</p>
</div></blockquote>
<dl class="simple">
<dt>val tweetIsStale = EditControlUtil.isLatestEdit(tweet.editControl, tweet.id) match {</dt><dd><p>case Return(false) =&gt; true
case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
<p>!(tweetIsStale || tweetIsAPreviousVersion)</p>
</dd>
<dt>} else {</dt><dd><p>// If not an edit request, this condition is true as duplication checking is not blocked
true</p>
</dd>
</dl>
<p>}</p>
<p>// Note that this does not prevent you from tweeting the same
// image twice with different text, or the same text twice with
// different images, because if you upload the same media twice,
// we will store two copies of it, each with a different media
// URL and thus different t.co URL, and since the text that
// we’re checking here has that t.co URL added to it already, it
// is necessarily different.
//
// We shouldn’t have to check the user id or whether it’s a
// retweet, because we loaded the tweets from the user’s
// (non-retweet) timelines, but it doesn’t hurt and protects
// against possible future changes.
(oldestAcceptableTimestamp &lt;= createdAt) &amp;&amp;
getShare(tweet).isEmpty &amp;&amp;
(getUserId(tweet) == userId) &amp;&amp;
isDuplicateText &amp;&amp;
isDuplicateReplyToTweetId &amp;&amp;
isDuplicateMedia &amp;&amp;
isDuplicateCardReference &amp;&amp;
isDuplicateConversationControl &amp;&amp;
isDuplicateConversationContainerId &amp;&amp;
isDuplicateIfEditRequest &amp;&amp;
noteTweetOptions.isEmpty // Skip duplicate checks for NoteTweets</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>object RequestInfo {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Extract the information relevant to the DuplicateTweetFinder</p></li>
<li><p>from the PostTweetRequest.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>def fromPostTweetRequest(req: PostTweetRequest, processedText: String): RequestInfo =</dt><dd><dl class="simple">
<dt>RequestInfo(</dt><dd><p>userId = req.userId,
isNarrowcast = req.narrowcast.nonEmpty,
isNullcast = req.nullcast,
text = processedText,
replyToTweetId = req.inReplyToTweetId,
mediaUploadIds = req.mediaUploadIds.getOrElse[Seq[MediaId]](Seq.empty),
cardReference = req.additionalFields.flatMap(_.cardReference),
conversationControl = req.conversationControl,
underlyingCreativesContainer = req.underlyingCreativesContainerId,
editOptions = req.editOptions,
noteTweetOptions = req.noteTweetOptions</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Encapsulates the external interactions that we need to do for</p></li>
<li><p>duplicate checking.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>trait TweetSource {</dt><dd><p>def loadTweets(tweetIds: Seq[TweetId]): Future[Seq[Tweet]]
def loadUserTimelineIds(userId: UserId, maxCount: Int): Future[Seq[TweetId]]
def loadNarrowcastTimelineIds(userId: UserId, maxCount: Int): Future[Seq[TweetId]]</p>
</dd>
</dl>
<p>}</p>
<p>object TweetSource {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Use the provided services to access tweets.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>def fromServices(</dt><dd><p>tweetRepo: TweetRepository.Optional,
getStatusTimeline: TimelineService.GetStatusTimeline</p>
</dd>
<dt>): TweetSource =</dt><dd><dl>
<dt>new TweetSource {</dt><dd><p>// only fields needed by RequestInfo.isDuplicateOf()
private[this] val tweetQueryOption =</p>
<blockquote>
<div><dl>
<dt>TweetQuery.Options(</dt><dd><dl>
<dt>TweetQuery.Include(</dt><dd><dl class="simple">
<dt>tweetFields = Set(</dt><dd><p>Tweet.CoreDataField.id,
Tweet.MediaField.id,
Tweet.ConversationControlField.id,
Tweet.EditControlField.id</p>
</dd>
</dl>
<p>),
pastedMedia = true</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>private[this] def loadTimeline(query: tls.TimelineQuery): Future[Seq[Long]] =</dt><dd><p>getStatusTimeline(Seq(query)).map(_.head.entries.map(_.statusId))</p>
</dd>
<dt>override def loadUserTimelineIds(userId: UserId, maxCount: Int): Future[Seq[Long]] =</dt><dd><dl>
<dt>loadTimeline(</dt><dd><dl class="simple">
<dt>tls.TimelineQuery(</dt><dd><p>timelineType = tls.TimelineType.User,
timelineId = userId,
maxCount = maxCount.toShort</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>override def loadNarrowcastTimelineIds(userId: UserId, maxCount: Int): Future[Seq[Long]] =</dt><dd><dl>
<dt>loadTimeline(</dt><dd><dl class="simple">
<dt>tls.TimelineQuery(</dt><dd><p>timelineType = tls.TimelineType.Narrowcasted,
timelineId = userId,
maxCount = maxCount.toShort</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>override def loadTweets(tweetIds: Seq[TweetId]): Future[Seq[Tweet]] =</dt><dd><dl>
<dt>if (tweetIds.isEmpty) {</dt><dd><p>Future.value(Seq[Tweet]())</p>
</dd>
<dt>} else {</dt><dd><dl>
<dt>Stitch</dt><dd><dl class="simple">
<dt>.run(</dt><dd><p>Stitch.traverse(tweetIds) { tweetId =&gt; tweetRepo(tweetId, tweetQueryOption) }</p>
</dd>
</dl>
<p>)
.map(_.flatten)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl>
<dt>def apply(settings: Settings, tweetSource: TweetSource): Type = { reqInfo =&gt;</dt><dd><dl>
<dt>if (reqInfo.isNullcast) {</dt><dd><p>// iff nullcast, we bypass duplication logic all together
Future.None</p>
</dd>
<dt>} else {</dt><dd><p>val oldestAcceptableTimestamp = Time.now - settings.maxDuplicateAge
val userTweetIdsFut =</p>
<blockquote>
<div><p>tweetSource.loadUserTimelineIds(reqInfo.userId, settings.numTweetsToCheck)</p>
</div></blockquote>
<p>// Check the narrowcast timeline iff this is a narrowcasted tweet
val narrowcastTweetIdsFut =</p>
<blockquote>
<div><dl class="simple">
<dt>if (reqInfo.isNarrowcast) {</dt><dd><p>tweetSource.loadNarrowcastTimelineIds(reqInfo.userId, settings.numTweetsToCheck)</p>
</dd>
<dt>} else {</dt><dd><p>Future.value(Seq.empty)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>for {</dt><dd><p>userTweetIds &lt;- userTweetIdsFut
narrowcastTweetIds &lt;- narrowcastTweetIdsFut
candidateTweets &lt;- tweetSource.loadTweets(userTweetIds ++ narrowcastTweetIds)</p>
</dd>
</dl>
<p>} yield candidateTweets.find(reqInfo.isDuplicateOf(_, oldestAcceptableTimestamp)).map(_.id)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/tweetypie/server/src/main/scala/com/twitter/tweetypie/handler/DuplicateTweetFinder.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>