<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie
package handler</p>
<p>import com.twitter.featureswitches.v2.FeatureSwitchResults
import com.twitter.featureswitches.v2.FeatureSwitches
import com.twitter.gizmoduck.thriftscala.AccessPolicy
import com.twitter.gizmoduck.thriftscala.LabelValue
import com.twitter.gizmoduck.thriftscala.UserType
import com.twitter.snowflake.id.SnowflakeId
import com.twitter.stitch.NotFound
import com.twitter.stitch.Stitch
import com.twitter.tweetypie.additionalfields.AdditionalFields._
import com.twitter.tweetypie.core._
import com.twitter.tweetypie.jiminy.tweetypie.NudgeBuilder
import com.twitter.tweetypie.jiminy.tweetypie.NudgeBuilderRequest
import com.twitter.tweetypie.media.Media
import com.twitter.tweetypie.repository.StratoCommunityAccessRepository.CommunityAccess
import com.twitter.tweetypie.repository._
import com.twitter.tweetypie.serverutil.DeviceSourceParser
import com.twitter.tweetypie.serverutil.ExtendedTweetMetadataBuilder
import com.twitter.tweetypie.store._
import com.twitter.tweetypie.thriftscala._
import com.twitter.tweetypie.thriftscala.entities.EntityExtractor
import com.twitter.tweetypie.tweettext._
import com.twitter.tweetypie.util.CommunityAnnotation
import com.twitter.tweetypie.util.CommunityUtil
import com.twitter.twittertext.Regex.{VALID_URL =&gt; UrlPattern}
import com.twitter.twittertext.TwitterTextParser</p>
<dl>
<dt>case class TweetBuilderResult(</dt><dd><p>tweet: Tweet,
user: User,
createdAt: Time,
sourceTweet: Option[Tweet] = None,
sourceUser: Option[User] = None,
parentUserId: Option[UserId] = None,
isSilentFail: Boolean = false,
geoSearchRequestId: Option[GeoSearchRequestId] = None,
initialTweetUpdateRequest: Option[InitialTweetUpdateRequest] = None)</p>
</dd>
<dt>object TweetBuilder {</dt><dd><p>import GizmoduckUserCountsUpdatingStore.isUserTweet
import PostTweet._
import Preprocessor._
import TweetCreateState.{Spam =&gt; CreateStateSpam, _}
import TweetText._
import UpstreamFailure._</p>
<p>type Type = FutureArrow[PostTweetRequest, TweetBuilderResult]</p>
<p>val log: Logger = Logger(getClass)</p>
<p>private[this] val _unitMutation = Future.value(Mutation.unit[Any])
def MutationUnitFuture[T]: Future[Mutation[T]] = _unitMutation.asInstanceOf[Future[Mutation[T]]]</p>
<p>case class MissingConversationId(inReplyToTweetId: TweetId) extends RuntimeException</p>
<dl>
<dt>case class TextVisibility(</dt><dd><p>visibleTextRange: Option[TextRange],
totalTextDisplayLength: Offset.DisplayUnit,
visibleText: String) {
val isExtendedTweet: Boolean = totalTextDisplayLength.toInt &gt; OriginalMaxDisplayLength</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Going forward we will be moving away from quoted-tweets urls in tweet text, but we</p></li>
<li><p>have a backwards-compat layer in Tweetypie which adds the QT url to text to provide</p></li>
<li><p>support for all clients to read in a backwards-compatible way until they upgrade.</p></li>
<li></li>
<li><p>Tweets can become extended as their display length can go beyond 140</p></li>
<li><p>after adding the QT short url. Therefore, we are adding below function</p></li>
<li><p>to account for legacy formatting during read-time and generate a self-permalink.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>def isExtendedWithExtraChars(extraChars: Int): Boolean =</dt><dd><p>totalTextDisplayLength.toInt &gt; (OriginalMaxDisplayLength - extraChars)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>/** Max number of users that can be tagged on a single tweet <a href="#id3"><span class="problematic" id="id4">*</span></a>/
val MaxMediaTagCount = 10</p>
<p>val MobileWebApp = “oauth:49152”
val M2App = “oauth:3033294”
val M5App = “oauth:3033300”</p>
<p>val TestRateLimitUserRole = “stresstest”</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>The fields to fetch for the user creating the tweet.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>val userFields: Set[UserField] =</dt><dd><dl class="simple">
<dt>Set(</dt><dd><p>UserField.Profile,
UserField.ProfileDesign,
UserField.Account,
UserField.Safety,
UserField.Counts,
UserField.Roles,
UserField.UrlEntities,
UserField.Labels</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>The fields to fetch for the user of the source tweet in a retweet.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>val sourceUserFields: Set[UserField] =</dt><dd><p>userFields + UserField.View</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Converts repository exceptions into an API-compatible exception type</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>def convertRepoExceptions[A](</dt><dd><p>notFoundState: TweetCreateState,
failureHandler: Throwable =&gt; Throwable</p>
</dd>
<dt>): PartialFunction[Throwable, Stitch[A]] = {</dt><dd><p>// stitch.NotFound is converted to the supplied TweetCreateState, wrapped in TweetCreateFailure
case NotFound =&gt; Stitch.exception(TweetCreateFailure.State(notFoundState))
// OverCapacity exceptions should not be translated and should bubble up to the top
case ex: OverCapacity =&gt; Stitch.exception(ex)
// Other exceptions are wrapped in the supplied failureHandler
case ex =&gt; Stitch.exception(failureHandler(ex))</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Adapts a UserRepository to a Repository for looking up a single user and that</p></li>
<li><p>fails with an appropriate TweetCreateFailure if the user is not found.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>def userLookup(userRepo: UserRepository.Type): UserId =&gt; Stitch[User] = {</dt><dd><p>val opts = UserQueryOptions(queryFields = userFields, visibility = UserVisibility.All)</p>
<dl class="simple">
<dt>userId =&gt;</dt><dd><dl class="simple">
<dt>userRepo(UserKey(userId), opts)</dt><dd><p>.rescue(convertRepoExceptions[User](UserNotFound, UserLookupFailure(_)))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Adapts a UserRepository to a Repository for looking up a single user and that</p></li>
<li><p>fails with an appropriate TweetCreateFailure if the user is not found.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>def sourceUserLookup(userRepo: UserRepository.Type): (UserId, UserId) =&gt; Stitch[User] = {</dt><dd><p>val opts = UserQueryOptions(queryFields = sourceUserFields, visibility = UserVisibility.All)</p>
<dl class="simple">
<dt>(userId, forUserId) =&gt;</dt><dd><dl class="simple">
<dt>userRepo(UserKey(userId), opts.copy(forUserId = Some(forUserId)))</dt><dd><p>.rescue(convertRepoExceptions[User](SourceUserNotFound, UserLookupFailure(_)))</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Any fields that are loaded on the user via TweetBuilder/RetweetBuilder, but which should not</p></li>
<li><p>be included on the user in the async-insert actions (such as hosebird) should be removed here.</p></li>
<li></li>
<li><p>This will include perspectival fields that were loaded relative to the user creating the tweet.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>def scrubUserInAsyncInserts: User =&gt; User =</dt><dd><p>user =&gt; user.copy(view = None)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Any fields that are loaded on the source user via TweetBuilder/RetweetBuilder, but which</p></li>
<li><p>should not be included on the user in the async-insert actions (such as hosebird) should</p></li>
<li><p>be removed here.</p></li>
<li></li>
<li><p>This will include perspectival fields that were loaded relative to the user creating the tweet.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>def scrubSourceUserInAsyncInserts: User =&gt; User =</dt><dd><p>// currently the same as scrubUserInAsyncInserts, could be different in the future
scrubUserInAsyncInserts</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Any fields that are loaded on the source tweet via RetweetBuilder, but which should not be</p></li>
<li><p>included on the source tweetypie in the async-insert actions (such as hosebird) should</p></li>
<li><p>be removed here.</p></li>
<li></li>
<li><p>This will include perspectival fields that were loaded relative to the user creating the tweet.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>def scrubSourceTweetInAsyncInserts: Tweet =&gt; Tweet =</dt><dd><p>tweet =&gt; tweet.copy(perspective = None, cards = None, card2 = None)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Adapts a DeviceSource to a Repository for looking up a single device-source and that</p></li>
<li><p>fails with an appropriate TweetCreateFailure if not found.</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
<dt>def deviceSourceLookup(devSrcRepo: DeviceSourceRepository.Type): DeviceSourceRepository.Type =</dt><dd><dl>
<dt>appIdStr =&gt; {</dt><dd><dl>
<dt>val result: Stitch[DeviceSource] =</dt><dd><dl class="simple">
<dt>if (DeviceSourceParser.isValid(appIdStr)) {</dt><dd><p>devSrcRepo(appIdStr)</p>
</dd>
<dt>} else {</dt><dd><p>Stitch.exception(NotFound)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>result.rescue(convertRepoExceptions(DeviceSourceNotFound, DeviceSourceLookupFailure(_)))</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Checks:</p></li>
<li><ul>
<li><p>that we have all the user fields we need</p></li>
</ul>
</li>
<li><ul>
<li><p>that the user is active</p></li>
</ul>
</li>
<li><ul>
<li><p>that they are not a frictionless follower account</p></li>
</ul>
</li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>def validateUser(user: User): Future[Unit] =</dt><dd><dl class="simple">
<dt>if (user.safety.isEmpty)</dt><dd><p>Future.exception(UserSafetyEmptyException)</p>
</dd>
<dt>else if (user.profile.isEmpty)</dt><dd><p>Future.exception(UserProfileEmptyException)</p>
</dd>
<dt>else if (user.safety.get.deactivated)</dt><dd><p>Future.exception(TweetCreateFailure.State(UserDeactivated))</p>
</dd>
<dt>else if (user.safety.get.suspended)</dt><dd><p>Future.exception(TweetCreateFailure.State(UserSuspended))</p>
</dd>
<dt>else if (user.labels.exists(_.labels.exists(_.labelValue == LabelValue.ReadOnly)))</dt><dd><p>Future.exception(TweetCreateFailure.State(CreateStateSpam))</p>
</dd>
<dt>else if (user.userType == UserType.Frictionless)</dt><dd><p>Future.exception(TweetCreateFailure.State(UserNotFound))</p>
</dd>
<dt>else if (user.userType == UserType.Soft)</dt><dd><p>Future.exception(TweetCreateFailure.State(UserNotFound))</p>
</dd>
<dt>else if (user.safety.get.accessPolicy == AccessPolicy.BounceAll ||</dt><dd><p>user.safety.get.accessPolicy == AccessPolicy.BounceAllPublicWrites)
Future.exception(TweetCreateFailure.State(UserReadonly))</p>
</dd>
<dt>else</dt><dd><p>Future.Unit</p>
</dd>
</dl>
</dd>
<dt>def validateCommunityReply(</dt><dd><p>communities: Option[Communities],
replyResult: Option[ReplyBuilder.Result]</p>
</dd>
</dl>
<p>): Future[Unit] = {</p>
<blockquote>
<div><dl>
<dt>if (replyResult.flatMap(_.reply.inReplyToStatusId).nonEmpty) {</dt><dd><p>val rootCommunities = replyResult.flatMap(_.community)
val rootCommunityIds = CommunityUtil.communityIds(rootCommunities)
val replyCommunityIds = CommunityUtil.communityIds(communities)</p>
<dl class="simple">
<dt>if (rootCommunityIds == replyCommunityIds) {</dt><dd><p>Future.Unit</p>
</dd>
<dt>} else {</dt><dd><p>Future.exception(TweetCreateFailure.State(CommunityReplyTweetNotAllowed))</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>Future.Unit</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// Project requirements do not allow exclusive tweets to be replies.
// All exclusive tweets must be root tweets.
def validateExclusiveTweetNotReplies(</p>
<blockquote>
<div><p>exclusiveTweetControls: Option[ExclusiveTweetControl],
replyResult: Option[ReplyBuilder.Result]</p>
</div></blockquote>
<dl>
<dt>): Future[Unit] = {</dt><dd><p>val isInReplyToTweet = replyResult.exists(_.reply.inReplyToStatusId.isDefined)
if (exclusiveTweetControls.isDefined &amp;&amp; isInReplyToTweet) {</p>
<blockquote>
<div><p>Future.exception(TweetCreateFailure.State(SuperFollowsInvalidParams))</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>Future.Unit</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// Invalid parameters for Exclusive Tweets:
// - Community field set # Tweets can not be both at the same time.
def validateExclusiveTweetParams(</p>
<blockquote>
<div><p>exclusiveTweetControls: Option[ExclusiveTweetControl],
communities: Option[Communities]</p>
</div></blockquote>
<dl>
<dt>): Future[Unit] = {</dt><dd><dl class="simple">
<dt>if (exclusiveTweetControls.isDefined &amp;&amp; CommunityUtil.hasCommunity(communities)) {</dt><dd><p>Future.exception(TweetCreateFailure.State(SuperFollowsInvalidParams))</p>
</dd>
<dt>} else {</dt><dd><p>Future.Unit</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def validateTrustedFriendsNotReplies(</dt><dd><p>trustedFriendsControl: Option[TrustedFriendsControl],
replyResult: Option[ReplyBuilder.Result]</p>
</dd>
<dt>): Future[Unit] = {</dt><dd><p>val isInReplyToTweet = replyResult.exists(_.reply.inReplyToStatusId.isDefined)
if (trustedFriendsControl.isDefined &amp;&amp; isInReplyToTweet) {</p>
<blockquote>
<div><p>Future.exception(TweetCreateFailure.State(TrustedFriendsInvalidParams))</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>Future.Unit</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def validateTrustedFriendsParams(</dt><dd><p>trustedFriendsControl: Option[TrustedFriendsControl],
conversationControl: Option[TweetCreateConversationControl],
communities: Option[Communities],
exclusiveTweetControl: Option[ExclusiveTweetControl]</p>
</dd>
<dt>): Future[Unit] = {</dt><dd><dl>
<dt>if (trustedFriendsControl.isDefined &amp;&amp;</dt><dd><dl class="simple">
<dt>(conversationControl.isDefined || CommunityUtil.hasCommunity(</dt><dd><p>communities) || exclusiveTweetControl.isDefined)) {</p>
</dd>
</dl>
<p>Future.exception(TweetCreateFailure.State(TrustedFriendsInvalidParams))</p>
</dd>
<dt>} else {</dt><dd><p>Future.Unit</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Checks the weighted tweet text length using twitter-text, as used by clients.</p></li>
<li><p>This should ensure that any tweet the client deems valid will also be deemed</p></li>
<li><p>valid by Tweetypie.</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
<dt>def prevalidateTextLength(text: String, stats: StatsReceiver): Future[Unit] = {</dt><dd><p>val twitterTextConfig = TwitterTextParser.TWITTER_TEXT_DEFAULT_CONFIG
val twitterTextResult = TwitterTextParser.parseTweet(text, twitterTextConfig)
val textTooLong = !twitterTextResult.isValid &amp;&amp; text.length &gt; 0</p>
<dl>
<dt>Future.when(textTooLong) {</dt><dd><p>val weightedLength = twitterTextResult.weightedLength
log.debug(</p>
<blockquote>
<div><dl class="simple">
<dt>s”Weighted length too long. weightedLength: $weightedLength” +</dt><dd><p>s”, Tweet text: ‘${diffshow.show(text)}’”</p>
</dd>
</dl>
</div></blockquote>
<p>)
stats.counter(“check_weighted_length/text_too_long”).incr()
Future.exception(TweetCreateFailure.State(TextTooLong))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Checks that the tweet text is neither blank nor too long.</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
<dt>def validateTextLength(</dt><dd><p>text: String,
visibleText: String,
replyResult: Option[ReplyBuilder.Result],
stats: StatsReceiver</p>
</dd>
<dt>): Future[Unit] = {</dt><dd><p>val utf8Length = Offset.Utf8.length(text)</p>
<dl>
<dt>def visibleTextTooLong =</dt><dd><p>Offset.DisplayUnit.length(visibleText) &gt; Offset.DisplayUnit(MaxVisibleWeightedEmojiLength)</p>
</dd>
<dt>def utf8LengthTooLong =</dt><dd><p>utf8Length &gt; Offset.Utf8(MaxUtf8Length)</p>
</dd>
<dt>if (isBlank(text)) {</dt><dd><p>stats.counter(“validate_text_length/text_cannot_be_blank”).incr()
Future.exception(TweetCreateFailure.State(TextCannotBeBlank))</p>
</dd>
<dt>} else if (replyResult.exists(_.replyTextIsEmpty(text))) {</dt><dd><p>stats.counter(“validate_text_length/reply_text_cannot_be_blank”).incr()
Future.exception(TweetCreateFailure.State(TextCannotBeBlank))</p>
</dd>
<dt>} else if (visibleTextTooLong) {</dt><dd><p>// Final check that visible text does not exceed MaxVisibleWeightedEmojiLength
// characters.
// prevalidateTextLength() does some portion of validation as well, most notably
// weighted length on raw, unescaped text.
stats.counter(“validate_text_length/text_too_long.visible_length_explicit”).incr()
log.debug(</p>
<blockquote>
<div><dl class="simple">
<dt>s”Explicit MaxVisibleWeightedLength visible length check failed. “ +</dt><dd><p>s”visibleText: ‘${diffshow.show(visibleText)}’ and “ +
s”total text: ‘${diffshow.show(text)}’”</p>
</dd>
</dl>
</div></blockquote>
<p>)
Future.exception(TweetCreateFailure.State(TextTooLong))</p>
</dd>
<dt>} else if (utf8LengthTooLong) {</dt><dd><p>stats.counter(“validate_text_length/text_too_long.utf8_length”).incr()
Future.exception(TweetCreateFailure.State(TextTooLong))</p>
</dd>
<dt>} else {</dt><dd><p>stats.stat(“validate_text_length/utf8_length”).add(utf8Length.toInt)
Future.Unit</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getTextVisibility(</dt><dd><p>text: String,
replyResult: Option[ReplyBuilder.Result],
urlEntities: Seq[UrlEntity],
mediaEntities: Seq[MediaEntity],
attachmentUrl: Option[String]</p>
</dd>
<dt>): TextVisibility = {</dt><dd><p>val totalTextLength = Offset.CodePoint.length(text)
val totalTextDisplayLength = Offset.DisplayUnit.length(text)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>visibleEnd for multiple scenarios:</p></li>
<li></li>
<li><p>normal tweet + media - fromIndex of mediaEntity (hydrated from last media permalink)</p></li>
<li><p>quote tweet + media - fromIndex of mediaEntity</p></li>
<li><p>replies + media - fromIndex of mediaEntity</p></li>
<li><p>normal quote tweet - total text length (visible text range will be None)</p></li>
<li><p>tweets with other attachments (DM deep links)</p></li>
<li><p>fromIndex of the last URL entity</p></li>
</ul>
<p><a href="#id29"><span class="problematic" id="id30">*</span></a>/</p>
</dd>
<dt>val visibleEnd = mediaEntities.headOption</dt><dd><p>.map(_.fromIndex)
.orElse(attachmentUrl.flatMap(_ =&gt; urlEntities.lastOption).map(_.fromIndex))
.map(from =&gt; (from - 1).max(0)) // for whitespace, unless there is none
.map(Offset.CodePoint(_))
.getOrElse(totalTextLength)</p>
</dd>
<dt>val visibleStart = replyResult match {</dt><dd><p>case Some(rr) =&gt; rr.visibleStart.min(visibleEnd)
case None =&gt; Offset.CodePoint(0)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>if (visibleStart.toInt == 0 &amp;&amp; visibleEnd == totalTextLength) {</dt><dd><dl class="simple">
<dt>TextVisibility(</dt><dd><p>visibleTextRange = None,
totalTextDisplayLength = totalTextDisplayLength,
visibleText = text</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>} else {</dt><dd><p>val charFrom = visibleStart.toCodeUnit(text)
val charTo = charFrom.offsetByCodePoints(text, visibleEnd - visibleStart)
val visibleText = text.substring(charFrom.toInt, charTo.toInt)</p>
<dl class="simple">
<dt>TextVisibility(</dt><dd><p>visibleTextRange = Some(TextRange(visibleStart.toInt, visibleEnd.toInt)),
totalTextDisplayLength = totalTextDisplayLength,
visibleText = visibleText</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def isValidHashtag(entity: HashtagEntity): Boolean =</dt><dd><p>TweetText.codePointLength(entity.text) &lt;= TweetText.MaxHashtagLength</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Validates that the number of various entities are within the limits, and the</p></li>
<li><p>length of hashtags are with the limit.</p></li>
</ul>
<p><a href="#id31"><span class="problematic" id="id32">*</span></a>/</p>
</dd>
<dt>def validateEntities(tweet: Tweet): Future[Unit] =</dt><dd><dl class="simple">
<dt>if (getMentions(tweet).length &gt; TweetText.MaxMentions)</dt><dd><p>Future.exception(TweetCreateFailure.State(MentionLimitExceeded))</p>
</dd>
<dt>else if (getUrls(tweet).length &gt; TweetText.MaxUrls)</dt><dd><p>Future.exception(TweetCreateFailure.State(UrlLimitExceeded))</p>
</dd>
<dt>else if (getHashtags(tweet).length &gt; TweetText.MaxHashtags)</dt><dd><p>Future.exception(TweetCreateFailure.State(HashtagLimitExceeded))</p>
</dd>
<dt>else if (getCashtags(tweet).length &gt; TweetText.MaxCashtags)</dt><dd><p>Future.exception(TweetCreateFailure.State(CashtagLimitExceeded))</p>
</dd>
<dt>else if (getHashtags(tweet).exists(e =&gt; !isValidHashtag(e)))</dt><dd><p>Future.exception(TweetCreateFailure.State(HashtagLengthLimitExceeded))</p>
</dd>
<dt>else</dt><dd><p>Future.Unit</p>
</dd>
</dl>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Update the user to what it should look like after the tweet is created</p></li>
</ul>
<p><a href="#id33"><span class="problematic" id="id34">*</span></a>/</p>
</dd>
<dt>def updateUserCounts(hasMedia: Tweet =&gt; Boolean): (User, Tweet) =&gt; Future[User] =</dt><dd><dl>
<dt>(user: User, tweet: Tweet) =&gt; {</dt><dd><p>val countAsUserTweet = isUserTweet(tweet)
val tweetsDelta = if (countAsUserTweet) 1 else 0
val mediaTweetsDelta = if (countAsUserTweet &amp;&amp; hasMedia(tweet)) 1 else 0</p>
<dl>
<dt>Future.value(</dt><dd><dl>
<dt>user.copy(</dt><dd><dl>
<dt>counts = user.counts.map { counts =&gt;</dt><dd><dl class="simple">
<dt>counts.copy(</dt><dd><p>tweets = counts.tweets + tweetsDelta,
mediaTweets = counts.mediaTweets.map(_ + mediaTweetsDelta)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>def validateAdditionalFields[R](implicit view: RequestView[R]): FutureEffect[R] =</dt><dd><dl>
<dt>FutureEffect[R] { req =&gt;</dt><dd><dl>
<dt>view</dt><dd><p>.additionalFields(req)
.map(tweet =&gt;</p>
<blockquote>
<div><p>unsettableAdditionalFieldIds(tweet) ++ rejectedAdditionalFieldIds(tweet)) match {</p>
</div></blockquote>
<dl>
<dt>case Some(unsettableFieldIds) if unsettableFieldIds.nonEmpty =&gt;</dt><dd><dl>
<dt>Future.exception(</dt><dd><dl class="simple">
<dt>TweetCreateFailure.State(</dt><dd><p>InvalidAdditionalField,
Some(unsettableAdditionalFieldIdsErrorMessage(unsettableFieldIds))</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>case _ =&gt; Future.Unit</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>def validateTweetMediaTags(</dt><dd><p>stats: StatsReceiver,
getUserMediaTagRateLimit: RateLimitChecker.GetRemaining,
userRepo: UserRepository.Optional</p>
</dd>
<dt>): (Tweet, Boolean) =&gt; Future[Mutation[Tweet]] = {</dt><dd><dl>
<dt>val userRepoWithStats: UserRepository.Optional =</dt><dd><dl>
<dt>(userKey, queryOptions) =&gt;</dt><dd><dl class="simple">
<dt>userRepo(userKey, queryOptions).liftToTry.map {</dt><dd><dl class="simple">
<dt>case Return(res &#64; Some(_)) =&gt;</dt><dd><p>stats.counter(“found”).incr()
res</p>
</dd>
<dt>case Return(None) =&gt;</dt><dd><p>stats.counter(“not_found”).incr()
None</p>
</dd>
<dt>case Throw(_) =&gt;</dt><dd><p>stats.counter(“failed”).incr()
None</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
<dt>(tweet: Tweet, dark: Boolean) =&gt; {</dt><dd><p>val mediaTags = getMediaTagMap(tweet)</p>
<dl>
<dt>if (mediaTags.isEmpty) {</dt><dd><p>MutationUnitFuture</p>
</dd>
<dt>} else {</dt><dd><dl>
<dt>getUserMediaTagRateLimit((getUserId(tweet), dark)).flatMap { remainingMediaTagCount =&gt;</dt><dd><p>val maxMediaTagCount = math.min(remainingMediaTagCount, MaxMediaTagCount)</p>
<dl>
<dt>val taggedUserIds =</dt><dd><dl class="simple">
<dt>mediaTags.values.flatten.toSeq.collect {</dt><dd><p>case MediaTag(MediaTagType.User, Some(userId), _, _) =&gt; userId</p>
</dd>
</dl>
<p>}.distinct</p>
</dd>
</dl>
<p>val droppedTagCount = taggedUserIds.size - maxMediaTagCount
if (droppedTagCount &gt; 0) stats.counter(“over_limit_tags”).incr(droppedTagCount)</p>
<dl>
<dt>val userQueryOpts =</dt><dd><dl class="simple">
<dt>UserQueryOptions(</dt><dd><p>queryFields = Set(UserField.MediaView),
visibility = UserVisibility.MediaTaggable,
forUserId = Some(getUserId(tweet))</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>val keys = taggedUserIds.take(maxMediaTagCount).map(UserKey.byId)
val keyOpts = keys.map((_, userQueryOpts))</p>
<dl>
<dt>Stitch.run {</dt><dd><dl>
<dt>Stitch</dt><dd><p>.traverse(keyOpts)(userRepoWithStats.tupled)
.map(_.flatten)
.map { users =&gt;</p>
<blockquote>
<div><p>val userMap = users.map(u =&gt; u.id -&gt; u).toMap
val mediaTagsMutation =</p>
<blockquote>
<div><dl>
<dt>Mutation[Seq[MediaTag]] { mediaTags =&gt;</dt><dd><dl>
<dt>val validMediaTags =</dt><dd><dl>
<dt>mediaTags.filter {</dt><dd><dl class="simple">
<dt>case MediaTag(MediaTagType.User, Some(userId), _, _) =&gt;</dt><dd><p>userMap.get(userId).exists(_.mediaView.exists(_.canMediaTag))</p>
</dd>
</dl>
<p>case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>val invalidCount = mediaTags.size - validMediaTags.size</p>
<dl class="simple">
<dt>if (invalidCount != 0) {</dt><dd><p>stats.counter(“invalid”).incr(invalidCount)
Some(validMediaTags)</p>
</dd>
<dt>} else {</dt><dd><p>None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>TweetLenses.mediaTagMap.mutation(mediaTagsMutation.liftMapValues)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def validateCommunityMembership(</dt><dd><p>communityMembershipRepository: StratoCommunityMembershipRepository.Type,
communityAccessRepository: StratoCommunityAccessRepository.Type,
communities: Option[Communities]</p>
</dd>
<dt>): Future[Unit] =</dt><dd><dl>
<dt>communities match {</dt><dd><dl>
<dt>case Some(Communities(Seq(communityId))) =&gt;</dt><dd><dl>
<dt>Stitch</dt><dd><dl>
<dt>.run {</dt><dd><dl>
<dt>communityMembershipRepository(communityId).flatMap {</dt><dd><p>case true =&gt; Stitch.value(None)
case false =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>communityAccessRepository(communityId).map {</dt><dd><dl class="simple">
<dt>case Some(CommunityAccess.Public) | Some(CommunityAccess.Closed) =&gt;</dt><dd><p>Some(TweetCreateState.CommunityUserNotAuthorized)</p>
</dd>
<dt>case Some(CommunityAccess.Private) | None =&gt;</dt><dd><p>Some(TweetCreateState.CommunityNotFound)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
<dt>}.flatMap {</dt><dd><dl class="simple">
<dt>case None =&gt;</dt><dd><p>Future.Done</p>
</dd>
<dt>case Some(tweetCreateState) =&gt;</dt><dd><p>Future.exception(TweetCreateFailure.State(tweetCreateState))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
<dt>case Some(Communities(communities)) if communities.length &gt; 1 =&gt;</dt><dd><p>// Not allowed to specify more than one community ID.
Future.exception(TweetCreateFailure.State(TweetCreateState.InvalidAdditionalField))</p>
</dd>
</dl>
<p>case _ =&gt; Future.Done</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>private[this] val CardUriSchemeRegex = “(?i)^(?:card|tombstone):”.r</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Is the given String a URI that is allowed as a card reference</p></li>
<li><p>without a matching URL in the text?</p></li>
</ul>
<p><a href="#id35"><span class="problematic" id="id36">*</span></a>/</p>
</dd>
<dt>def hasCardsUriScheme(uri: String): Boolean =</dt><dd><p>CardUriSchemeRegex.findPrefixMatchOf(uri).isDefined</p>
</dd>
<dt>val InvalidAdditionalFieldEmptyUrlEntities: TweetCreateFailure.State =</dt><dd><dl class="simple">
<dt>TweetCreateFailure.State(</dt><dd><p>TweetCreateState.InvalidAdditionalField,
Some(“url entities are empty”)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val InvalidAdditionalFieldNonMatchingUrlAndShortUrl: TweetCreateFailure.State =</dt><dd><dl class="simple">
<dt>TweetCreateFailure.State(</dt><dd><p>TweetCreateState.InvalidAdditionalField,
Some(“non-matching url and short url”)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val InvalidAdditionalFieldInvalidUri: TweetCreateFailure.State =</dt><dd><dl class="simple">
<dt>TweetCreateFailure.State(</dt><dd><p>TweetCreateState.InvalidAdditionalField,
Some(“invalid URI”)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val InvalidAdditionalFieldInvalidCardUri: TweetCreateFailure.State =</dt><dd><dl class="simple">
<dt>TweetCreateFailure.State(</dt><dd><p>TweetCreateState.InvalidAdditionalField,
Some(“invalid card URI”)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>type CardReferenceBuilder =</dt><dd><p>(Tweet, UrlShortener.Context) =&gt; Future[Mutation[Tweet]]</p>
</dd>
<dt>def cardReferenceBuilder(</dt><dd><p>cardReferenceValidator: CardReferenceValidationHandler.Type,
urlShortener: UrlShortener.Type</p>
</dd>
<dt>): CardReferenceBuilder =</dt><dd><dl>
<dt>(tweet, urlShortenerCtx) =&gt; {</dt><dd><dl>
<dt>getCardReference(tweet) match {</dt><dd><dl>
<dt>case Some(CardReference(uri)) =&gt;</dt><dd><dl>
<dt>for {</dt><dd><dl>
<dt>cardUri &lt;-</dt><dd><dl>
<dt>if (hasCardsUriScheme(uri)) {</dt><dd><p>// This is an explicit card references that does not
// need a corresponding URL in the text.
Future.value(uri)</p>
</dd>
<dt>} else if (UrlPattern.matcher(uri).matches) {</dt><dd><p>// The card reference is being used to specify which URL
// card to show. We need to verify that the URL is
// actually in the tweet text, or it can be effectively
// used to bypass the tweet length limit.
val urlEntities = getUrls(tweet)</p>
<dl>
<dt>if (urlEntities.isEmpty) {</dt><dd><p>// Fail fast if there can’t possibly be a matching URL entity
Future.exception(InvalidAdditionalFieldEmptyUrlEntities)</p>
</dd>
<dt>} else {</dt><dd><p>// Look for the URL in the expanded URL entities. If
// it is present, then map it to the t.co shortened
// version of the URL.
urlEntities</p>
<blockquote>
<div><dl class="simple">
<dt>.collectFirst {</dt><dd><dl class="simple">
<dt>case urlEntity if urlEntity.expanded.exists(_ == uri) =&gt;</dt><dd><p>Future.value(urlEntity.url)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.getOrElse {</p>
<blockquote>
<div><p>// The URL may have been altered when it was
// returned from Talon, such as expanding a pasted
// t.co link. In this case, we t.co-ize the link and
// make sure that the corresponding t.co is present
// as a URL entity.
urlShortener((uri, urlShortenerCtx)).flatMap { shortened =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>if (urlEntities.exists(_.url == shortened.shortUrl)) {</dt><dd><p>Future.value(shortened.shortUrl)</p>
</dd>
<dt>} else {</dt><dd><p>Future.exception(InvalidAdditionalFieldNonMatchingUrlAndShortUrl)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>Future.exception(InvalidAdditionalFieldInvalidUri)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>validatedCardUri &lt;- cardReferenceValidator((getUserId(tweet), cardUri)).rescue {</dt><dd><dl class="simple">
<dt>case CardReferenceValidationFailedException =&gt;</dt><dd><p>Future.exception(InvalidAdditionalFieldInvalidCardUri)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} yield {</dt><dd><dl>
<dt>TweetLenses.cardReference.mutation(</dt><dd><dl class="simple">
<dt>Mutation[CardReference] { cardReference =&gt;</dt><dd><p>Some(cardReference.copy(cardUri = validatedCardUri))</p>
</dd>
</dl>
<p>}.checkEq.liftOption</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>case None =&gt;</dt><dd><p>MutationUnitFuture</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>def filterInvalidData(</dt><dd><p>validateTweetMediaTags: (Tweet, Boolean) =&gt; Future[Mutation[Tweet]],
cardReferenceBuilder: CardReferenceBuilder</p>
</dd>
<dt>): (Tweet, PostTweetRequest, UrlShortener.Context) =&gt; Future[Tweet] =</dt><dd><dl>
<dt>(tweet: Tweet, request: PostTweetRequest, urlShortenerCtx: UrlShortener.Context) =&gt; {</dt><dd><dl>
<dt>Future</dt><dd><dl class="simple">
<dt>.join(</dt><dd><p>validateTweetMediaTags(tweet, request.dark),
cardReferenceBuilder(tweet, urlShortenerCtx)</p>
</dd>
</dl>
<p>)
.map {</p>
<blockquote>
<div><dl class="simple">
<dt>case (mediaMutation, cardRefMutation) =&gt;</dt><dd><p>mediaMutation.also(cardRefMutation).endo(tweet)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>def apply(</dt><dd><p>stats: StatsReceiver,
validateRequest: PostTweetRequest =&gt; Future[Unit],
validateEdit: EditValidator.Type,
validateUser: User =&gt; Future[Unit] = TweetBuilder.validateUser,
validateUpdateRateLimit: RateLimitChecker.Validate,
tweetIdGenerator: TweetIdGenerator,
userRepo: UserRepository.Type,
deviceSourceRepo: DeviceSourceRepository.Type,
communityMembershipRepo: StratoCommunityMembershipRepository.Type,
communityAccessRepo: StratoCommunityAccessRepository.Type,
urlShortener: UrlShortener.Type,
urlEntityBuilder: UrlEntityBuilder.Type,
geoBuilder: GeoBuilder.Type,
replyBuilder: ReplyBuilder.Type,
mediaBuilder: MediaBuilder.Type,
attachmentBuilder: AttachmentBuilder.Type,
duplicateTweetFinder: DuplicateTweetFinder.Type,
spamChecker: Spam.Checker[TweetSpamRequest],
filterInvalidData: (Tweet, PostTweetRequest, UrlShortener.Context) =&gt; Future[Tweet],
updateUserCounts: (User, Tweet) =&gt; Future[User],
validateConversationControl: ConversationControlBuilder.Validate.Type,
conversationControlBuilder: ConversationControlBuilder.Type,
validateTweetWrite: TweetWriteValidator.Type,
nudgeBuilder: NudgeBuilder.Type,
communitiesValidator: CommunitiesValidator.Type,
collabControlBuilder: CollabControlBuilder.Type,
editControlBuilder: EditControlBuilder.Type,
featureSwitches: FeatureSwitches</p>
</dd>
<dt>): TweetBuilder.Type = {</dt><dd><p>val entityExtractor = EntityExtractor.mutationWithoutUrls.endo
val getUser = userLookup(userRepo)
val getDeviceSource = deviceSourceLookup(deviceSourceRepo)</p>
<p>// create a tco of the permalink for given a tweetId
val permalinkShortener = (tweetId: TweetId, ctx: UrlShortener.Context) =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>urlShortener((s”<a class="reference external" href="https://twitter.com/i/web/status/$tweetId">https://twitter.com/i/web/status/$tweetId</a>”, ctx)).rescue {</dt><dd><p>// propagate OverCapacity
case e: OverCapacity =&gt; Future.exception(e)
// convert any other failure into UrlShorteningFailure
case e =&gt; Future.exception(UrlShorteningFailure(e))</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>def extractGeoSearchRequestId(tweetGeoOpt: Option[TweetCreateGeo]): Option[GeoSearchRequestId] =</dt><dd><dl class="simple">
<dt>for {</dt><dd><p>tweetGeo &lt;- tweetGeoOpt
geoSearchRequestId &lt;- tweetGeo.geoSearchRequestId</p>
</dd>
</dl>
<p>} yield GeoSearchRequestId(geoSearchRequestId.id)</p>
</dd>
<dt>def featureSwitchResults(user: User, stats: StatsReceiver): Option[FeatureSwitchResults] =</dt><dd><dl>
<dt>TwitterContext()</dt><dd><dl class="simple">
<dt>.flatMap { viewer =&gt;</dt><dd><p>UserViewerRecipient(user, viewer, stats)</p>
</dd>
<dt>}.map { recipient =&gt;</dt><dd><p>featureSwitches.matchRecipient(recipient)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
<dt>FutureArrow { request =&gt;</dt><dd><dl>
<dt>for {</dt><dd><p>() &lt;- validateRequest(request)</p>
<dl class="simple">
<dt>(tweetId, user, devsrc) &lt;- Future.join(</dt><dd><p>tweetIdGenerator().rescue { case t =&gt; Future.exception(SnowflakeFailure(t)) },
Stitch.run(getUser(request.userId)),
Stitch.run(getDeviceSource(request.createdVia))</p>
</dd>
</dl>
<p>)</p>
<p>() &lt;- validateUser(user)
() &lt;- validateUpdateRateLimit((user.id, request.dark))</p>
<p>// Feature Switch results are calculated once and shared between multiple builders
matchedResults = featureSwitchResults(user, stats)</p>
<dl>
<dt>() &lt;- validateConversationControl(</dt><dd><dl class="simple">
<dt>ConversationControlBuilder.Validate.Request(</dt><dd><p>matchedResults = matchedResults,
conversationControl = request.conversationControl,
inReplyToTweetId = request.inReplyToTweetId</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
<p>// strip illegal chars, normalize newlines, collapse blank lines, etc.
text = preprocessText(request.text)</p>
<p>() &lt;- prevalidateTextLength(text, stats)</p>
<dl>
<dt>attachmentResult &lt;- attachmentBuilder(</dt><dd><dl class="simple">
<dt>AttachmentBuilderRequest(</dt><dd><p>tweetId = tweetId,
user = user,
mediaUploadIds = request.mediaUploadIds,
cardReference = request.additionalFields.flatMap(_.cardReference),
attachmentUrl = request.attachmentUrl,
remoteHost = request.remoteHost,
darkTraffic = request.dark,
deviceSource = devsrc</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
<p>// updated text with appended attachment url, if any.
text &lt;- Future.value(</p>
<blockquote>
<div><dl class="simple">
<dt>attachmentResult.attachmentUrl match {</dt><dd><p>case None =&gt; text
case Some(url) =&gt; s”$text $url”</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>)</p>
<dl>
<dt>spamResult &lt;- spamChecker(</dt><dd><dl class="simple">
<dt>TweetSpamRequest(</dt><dd><p>tweetId = tweetId,
userId = request.userId,
text = text,
mediaTags = request.additionalFields.flatMap(_.mediaTags),
safetyMetaData = request.safetyMetaData,
inReplyToTweetId = request.inReplyToTweetId,
quotedTweetId = attachmentResult.quotedTweet.map(_.tweetId),
quotedTweetUserId = attachmentResult.quotedTweet.map(_.userId)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
<p>safety = user.safety.get
createdAt = SnowflakeId(tweetId).time</p>
<dl class="simple">
<dt>urlShortenerCtx = UrlShortener.Context(</dt><dd><p>tweetId = tweetId,
userId = user.id,
createdAt = createdAt,
userProtected = safety.isProtected,
clientAppId = devsrc.clientAppId,
remoteHost = request.remoteHost,
dark = request.dark</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>replyRequest = ReplyBuilder.Request(</dt><dd><p>authorId = request.userId,
authorScreenName = user.profile.map(_.screenName).get,
inReplyToTweetId = request.inReplyToTweetId,
tweetText = text,
prependImplicitMentions = request.autoPopulateReplyMetadata,
enableTweetToNarrowcasting = request.enableTweetToNarrowcasting,
excludeUserIds = request.excludeReplyUserIds.getOrElse(Nil),
spamResult = spamResult,
batchMode = request.transientContext.flatMap(_.batchCompose)</p>
</dd>
</dl>
<p>)</p>
<p>replyResult &lt;- replyBuilder(replyRequest)
replyOpt = replyResult.map(_.reply)</p>
<dl>
<dt>replyConversationId &lt;- replyResult match {</dt><dd><dl>
<dt>case Some(r) if r.reply.inReplyToStatusId.nonEmpty =&gt;</dt><dd><dl>
<dt>r.conversationId match {</dt><dd><dl class="simple">
<dt>case None =&gt;</dt><dd><p>// Throw this specific exception to make it easier to
// count how often we hit this corner case.
Future.exception(MissingConversationId(r.reply.inReplyToStatusId.get))</p>
</dd>
</dl>
<p>case conversationIdOpt =&gt; Future.value(conversationIdOpt)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>case _ =&gt; Future.value(None)</p>
</dd>
</dl>
<p>}</p>
<p>// Validate that the current user can reply to this conversation, based on
// the conversation’s ConversationControl.
// Note: currently we only validate conversation controls access on replies,
// therefore we use the conversationId from the inReplyToStatus.
// Validate that the exclusive tweet control option is only used by allowed users.
() &lt;- validateTweetWrite(</p>
<blockquote>
<div><dl class="simple">
<dt>TweetWriteValidator.Request(</dt><dd><p>replyConversationId,
request.userId,
request.exclusiveTweetControlOptions,
replyResult.flatMap(_.exclusiveTweetControl),
request.trustedFriendsControlOptions,
replyResult.flatMap(_.trustedFriendsControl),
attachmentResult.quotedTweet,
replyResult.flatMap(_.reply.inReplyToStatusId),
replyResult.flatMap(_.editControl),
request.editOptions</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>)</p>
<dl>
<dt>convoId = replyConversationId match {</dt><dd><p>case Some(replyConvoId) =&gt; replyConvoId
case None =&gt;</p>
<blockquote>
<div><p>// This is a root tweet, so the tweet id is the conversation id.
tweetId</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>() &lt;- nudgeBuilder(</dt><dd><dl class="simple">
<dt>NudgeBuilderRequest(</dt><dd><p>text = text,
inReplyToTweetId = replyOpt.flatMap(_.inReplyToStatusId),
conversationId = if (convoId == tweetId) None else Some(convoId),
hasQuotedTweet = attachmentResult.quotedTweet.nonEmpty,
nudgeOptions = request.nudgeOptions,
tweetId = Some(tweetId),</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
<p>// updated text with implicit reply mentions inserted, if any
text &lt;- Future.value(</p>
<blockquote>
<div><p>replyResult.map(_.tweetText).getOrElse(text)</p>
</div></blockquote>
<p>)</p>
<p>// updated text with urls replaced with t.cos
((text, urlEntities), (geoCoords, placeIdOpt)) &lt;- Future.join(</p>
<blockquote>
<div><dl>
<dt>urlEntityBuilder((text, urlShortenerCtx))</dt><dd><dl class="simple">
<dt>.map {</dt><dd><dl class="simple">
<dt>case (text, urlEntities) =&gt;</dt><dd><p>UrlEntityBuilder.updateTextAndUrls(text, urlEntities)(partialHtmlEncode)</p>
</dd>
</dl>
</dd>
</dl>
<p>},</p>
</dd>
<dt>if (request.geo.isEmpty)</dt><dd><p>Future.value((None, None))</p>
</dd>
<dt>else</dt><dd><dl>
<dt>geoBuilder(</dt><dd><dl class="simple">
<dt>GeoBuilder.Request(</dt><dd><p>request.geo.get,
user.account.map(_.geoEnabled).getOrElse(false),
user.account.map(_.language).getOrElse(“en”)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>).map(r =&gt; (r.geoCoordinates, r.placeId))</p>
</dd>
</dl>
</div></blockquote>
<p>)</p>
<p>// updated text with trailing media url
MediaBuilder.Result(text, mediaEntities, mediaKeys) &lt;-</p>
<blockquote>
<div><dl>
<dt>request.mediaUploadIds.getOrElse(Nil) match {</dt><dd><p>case Nil =&gt; Future.value(MediaBuilder.Result(text, Nil, Nil))
case ids =&gt;</p>
<blockquote>
<div><dl>
<dt>mediaBuilder(</dt><dd><dl class="simple">
<dt>MediaBuilder.Request(</dt><dd><p>mediaUploadIds = ids,
text = text,
tweetId = tweetId,
userId = user.id,
userScreenName = user.profile.get.screenName,
isProtected = user.safety.get.isProtected,
createdAt = createdAt,
dark = request.dark,
productMetadata = request.mediaMetadata.map(_.toMap)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>() &lt;- Future.when(!request.dark) {</dt><dd><dl>
<dt>val reqInfo =</dt><dd><p>DuplicateTweetFinder.RequestInfo.fromPostTweetRequest(request, text)</p>
</dd>
<dt>duplicateTweetFinder(reqInfo).flatMap {</dt><dd><p>case None =&gt; Future.Unit
case Some(duplicateId) =&gt;</p>
<blockquote>
<div><p>log.debug(s”timeline_duplicate_check_failed:$duplicateId”)
Future.exception(TweetCreateFailure.State(TweetCreateState.Duplicate))</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>textVisibility = getTextVisibility(</dt><dd><p>text = text,
replyResult = replyResult,
urlEntities = urlEntities,
mediaEntities = mediaEntities,
attachmentUrl = attachmentResult.attachmentUrl</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>() &lt;- validateTextLength(</dt><dd><p>text = text,
visibleText = textVisibility.visibleText,
replyResult = replyResult,
stats = stats</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>communities =</dt><dd><dl class="simple">
<dt>request.additionalFields</dt><dd><p>.flatMap(CommunityAnnotation.additionalFieldsToCommunityIDs)
.map(ids =&gt; Communities(communityIds = ids))</p>
</dd>
</dl>
</dd>
<dt>rootExclusiveControls = request.exclusiveTweetControlOptions.map { _ =&gt;</dt><dd><p>ExclusiveTweetControl(request.userId)</p>
</dd>
</dl>
<p>}</p>
<p>() &lt;- validateExclusiveTweetNotReplies(rootExclusiveControls, replyResult)
() &lt;- validateExclusiveTweetParams(rootExclusiveControls, communities)</p>
<p>replyExclusiveControls = replyResult.flatMap(_.exclusiveTweetControl)</p>
<p>// The userId is pulled off of the request rather than being supplied
// via the ExclusiveTweetControlOptions because additional fields
// can be set by clients to contain any value they want.
// This could include userIds that don’t match their actual userId.
// Only one of replyResult or request.exclusiveTweetControlOptions will be defined.
exclusiveTweetControl = replyExclusiveControls.orElse(rootExclusiveControls)</p>
<dl class="simple">
<dt>rootTrustedFriendsControl = request.trustedFriendsControlOptions.map { options =&gt;</dt><dd><p>TrustedFriendsControl(options.trustedFriendsListId)</p>
</dd>
</dl>
<p>}</p>
<p>() &lt;- validateTrustedFriendsNotReplies(rootTrustedFriendsControl, replyResult)
() &lt;- validateTrustedFriendsParams(</p>
<blockquote>
<div><p>rootTrustedFriendsControl,
request.conversationControl,
communities,
exclusiveTweetControl</p>
</div></blockquote>
<p>)</p>
<p>replyTrustedFriendsControl = replyResult.flatMap(_.trustedFriendsControl)</p>
<p>trustedFriendsControl = replyTrustedFriendsControl.orElse(rootTrustedFriendsControl)</p>
<dl>
<dt>collabControl &lt;- collabControlBuilder(</dt><dd><dl class="simple">
<dt>CollabControlBuilder.Request(</dt><dd><p>collabControlOptions = request.collabControlOptions,
replyResult = replyResult,
communities = communities,
trustedFriendsControl = trustedFriendsControl,
conversationControl = request.conversationControl,
exclusiveTweetControl = exclusiveTweetControl,
userId = request.userId</p>
</dd>
</dl>
<p>))</p>
</dd>
<dt>isCollabInvitation = collabControl.isDefined &amp;&amp; (collabControl.get match {</dt><dd><p>case CollabControl.CollabInvitation(_: CollabInvitation) =&gt; true
case _ =&gt; false</p>
</dd>
</dl>
<p>})</p>
<dl>
<dt>coreData = TweetCoreData(</dt><dd><p>userId = request.userId,
text = text,
createdAtSecs = createdAt.inSeconds,
createdVia = devsrc.internalName,
reply = replyOpt,
hasTakedown = safety.hasTakedown,
// We want to nullcast community tweets and CollabInvitations
// This will disable tweet fanout to followers’ home timelines,
// and filter the tweets from appearing from the tweeter’s profile
// or search results for the tweeter’s tweets.
nullcast =</p>
<blockquote>
<div><p>request.nullcast || CommunityUtil.hasCommunity(communities) || isCollabInvitation,</p>
</div></blockquote>
<p>narrowcast = request.narrowcast,
nsfwUser = request.possiblySensitive.getOrElse(safety.nsfwUser),
nsfwAdmin = safety.nsfwAdmin,
trackingId = request.trackingId,
placeId = placeIdOpt,
coordinates = geoCoords,
conversationId = Some(convoId),
// Set hasMedia to true if we know that there is media,
// and leave it unknown if not, so that it will be
// correctly set for pasted media.
hasMedia = if (mediaEntities.nonEmpty) Some(true) else None</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>tweet = Tweet(</dt><dd><p>id = tweetId,
coreData = Some(coreData),
urls = Some(urlEntities),
media = Some(mediaEntities),
mediaKeys = if (mediaKeys.nonEmpty) Some(mediaKeys) else None,
contributor = getContributor(request.userId),
visibleTextRange = textVisibility.visibleTextRange,
selfThreadMetadata = replyResult.flatMap(_.selfThreadMetadata),
directedAtUserMetadata = replyResult.map(_.directedAtMetadata),
composerSource = request.composerSource,
quotedTweet = attachmentResult.quotedTweet,
exclusiveTweetControl = exclusiveTweetControl,
trustedFriendsControl = trustedFriendsControl,
collabControl = collabControl,
noteTweet = request.noteTweetOptions.map(options =&gt;</p>
<blockquote>
<div><p>NoteTweet(options.noteTweetId, options.isExpandable))</p>
</div></blockquote>
</dd>
</dl>
<p>)</p>
<dl>
<dt>editControl &lt;- editControlBuilder(</dt><dd><dl class="simple">
<dt>EditControlBuilder.Request(</dt><dd><p>postTweetRequest = request,
tweet = tweet,
matchedResults = matchedResults</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
<p>tweet &lt;- Future.value(tweet.copy(editControl = editControl))</p>
<p>tweet &lt;- Future.value(entityExtractor(tweet))</p>
<p>() &lt;- validateEntities(tweet)</p>
<dl>
<dt>tweet &lt;- {</dt><dd><dl class="simple">
<dt>val cctlRequest =</dt><dd><dl class="simple">
<dt>ConversationControlBuilder.Request.fromTweet(</dt><dd><p>tweet,
request.conversationControl,
request.noteTweetOptions.flatMap(_.mentionedUserIds))</p>
</dd>
</dl>
</dd>
<dt>Stitch.run(conversationControlBuilder(cctlRequest)).map { conversationControl =&gt;</dt><dd><p>tweet.copy(conversationControl = conversationControl)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>tweet &lt;- Future.value(</dt><dd><p>setAdditionalFields(tweet, request.additionalFields)</p>
</dd>
</dl>
<p>)
() &lt;- validateCommunityMembership(communityMembershipRepo, communityAccessRepo, communities)
() &lt;- validateCommunityReply(communities, replyResult)
() &lt;- communitiesValidator(</p>
<blockquote>
<div><p>CommunitiesValidator.Request(matchedResults, safety.isProtected, communities))</p>
</div></blockquote>
<p>tweet &lt;- Future.value(tweet.copy(communities = communities))</p>
<dl class="simple">
<dt>tweet &lt;- Future.value(</dt><dd><p>tweet.copy(underlyingCreativesContainerId = request.underlyingCreativesContainerId)</p>
</dd>
</dl>
<p>)</p>
<p>// For certain tweets we want to write a self-permalink which is used to generate modified
// tweet text for legacy clients that contains a link. NOTE: this permalink is for
// the tweet being created - we also create permalinks for related tweets further down
// e.g. if this tweet is an edit, we might create a permalink for the initial tweet as well
tweet &lt;- {</p>
<blockquote>
<div><p>val isBeyond140 = textVisibility.isExtendedWithExtraChars(attachmentResult.extraChars)
val isEditTweet = request.editOptions.isDefined
val isMixedMedia = Media.isMixedMedia(mediaEntities)
val isNoteTweet = request.noteTweetOptions.isDefined</p>
<dl>
<dt>if (isBeyond140 || isEditTweet || isMixedMedia || isNoteTweet)</dt><dd><dl>
<dt>permalinkShortener(tweetId, urlShortenerCtx)</dt><dd><dl>
<dt>.map { selfPermalink =&gt;</dt><dd><dl class="simple">
<dt>tweet.copy(</dt><dd><p>selfPermalink = Some(selfPermalink),
extendedTweetMetadata = Some(ExtendedTweetMetadataBuilder(tweet, selfPermalink))</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
<dt>else {</dt><dd><p>Future.value(tweet)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<p>// When an edit tweet is created we have to update some information on the
// initial tweet, this object stores info about those updates for use
// in the tweet insert store.
// We update the editControl for each edit tweet and for the first edit tweet
// we update the self permalink.
initialTweetUpdateRequest: Option[InitialTweetUpdateRequest] &lt;- editControl match {</p>
<blockquote>
<div><dl>
<dt>case Some(EditControl.Edit(edit)) =&gt;</dt><dd><p>// Identifies the first edit of an initial tweet
val isFirstEdit =</p>
<blockquote>
<div><p>request.editOptions.map(_.previousTweetId).contains(edit.initialTweetId)</p>
</div></blockquote>
<p>// A potential permalink for this tweet being created’s initial tweet
val selfPermalinkForInitial: Future[Option[ShortenedUrl]] =</p>
<blockquote>
<div><dl class="simple">
<dt>if (isFirstEdit) {</dt><dd><p>// <cite>tweet</cite> is the first edit of an initial tweet, which means
// we need to write a self permalink. We create it here in
// TweetBuilder and pass it through to the tweet store to
// be written to the initial tweet.
permalinkShortener(edit.initialTweetId, urlShortenerCtx).map(Some(_))</p>
</dd>
<dt>} else {</dt><dd><p>Future.value(None)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>selfPermalinkForInitial.map { link =&gt;</dt><dd><dl>
<dt>Some(</dt><dd><dl class="simple">
<dt>InitialTweetUpdateRequest(</dt><dd><p>initialTweetId = edit.initialTweetId,
editTweetId = tweet.id,
selfPermalink = link</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>// This is not an edit this is the initial tweet - so there are no initial
// tweet updates
case _ =&gt; Future.value(None)</p>
</div></blockquote>
<p>}</p>
<p>tweet &lt;- filterInvalidData(tweet, request, urlShortenerCtx)</p>
<p>() &lt;- validateEdit(tweet, request.editOptions)</p>
<p>user &lt;- updateUserCounts(user, tweet)</p>
</dd>
<dt>} yield {</dt><dd><dl class="simple">
<dt>TweetBuilderResult(</dt><dd><p>tweet,
user,
createdAt,
isSilentFail = spamResult == Spam.SilentFail,
geoSearchRequestId = extractGeoSearchRequestId(request.geo),
initialTweetUpdateRequest = initialTweetUpdateRequest</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/tweetypie/server/src/main/scala/com/twitter/tweetypie/handler/TweetBuilder.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>