<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie
package config</p>
<p>import com.twitter.abdecider.ABDeciderFactory
import com.twitter.config.yaml.YamlConfig
import com.twitter.decider.Decider
import com.twitter.featureswitches.v2.FeatureSwitches
import com.twitter.finagle.memcached
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.servo.cache._
import com.twitter.servo.cache.{KeyValueResult =&gt; _}
import com.twitter.servo.repository._
import com.twitter.stitch.NotFound
import com.twitter.stitch.Stitch
import com.twitter.stitch.repo.Repo
import com.twitter.stitch.timelineservice.TimelineService
import com.twitter.strato.client.{Client =&gt; StratoClient}
import com.twitter.stringcenter.client.ExternalStringRegistry
import com.twitter.stringcenter.client.MultiProjectStringCenter
import com.twitter.translation.Languages
import com.twitter.translation.YamlConfigLanguages
import com.twitter.tweetypie.caching.CacheOperations
import com.twitter.tweetypie.caching.Expiry
import com.twitter.tweetypie.caching.ServoCachedValueSerializer
import com.twitter.tweetypie.caching.StitchCaching
import com.twitter.tweetypie.caching.ValueSerializer
import com.twitter.tweetypie.client_id.ClientIdHelper
import com.twitter.tweetypie.core.FilteredState
import com.twitter.tweetypie.core.TweetResult
import com.twitter.tweetypie.hydrator.TextRepairer
import com.twitter.tweetypie.hydrator.TweetHydration
import com.twitter.tweetypie.hydrator.TweetQueryOptionsExpander
import com.twitter.tweetypie.repository.TweetRepository
import com.twitter.tweetypie.repository.UserRepository
import com.twitter.tweetypie.repository._
import com.twitter.tweetypie.serverutil.BoringStackTrace
import com.twitter.tweetypie.serverutil.ExceptionCounter
import com.twitter.tweetypie.thriftscala.DeviceSource
import com.twitter.tweetypie.thriftscala.Place
import com.twitter.tweetypie.thriftscala.entities.EntityExtractor
import com.twitter.tweetypie.util.StitchUtils
import com.twitter.util.Duration
import com.twitter.util.FuturePool
import com.twitter.util.Timer
import com.twitter.visibility.VisibilityLibrary
import com.twitter.visibility.common.KeywordMatcher
import com.twitter.visibility.common.LocalizationSource
import com.twitter.visibility.common.TweetMediaMetadataSource
import com.twitter.visibility.common.TweetPerspectiveSource
import com.twitter.visibility.common.UserRelationshipSource
import com.twitter.visibility.common.UserSource
import com.twitter.visibility.common.tflock.UserIsInvitedToConversationRepository
import com.twitter.visibility.configapi.configs.VisibilityDeciderGates
import com.twitter.visibility.generators.CountryNameGenerator
import com.twitter.visibility.generators.LocalizedInterstitialGenerator
import com.twitter.visibility.generators.TombstoneGenerator
import com.twitter.visibility.interfaces.tweets.DeletedTweetVisibilityLibrary
import com.twitter.visibility.interfaces.tweets.QuotedTweetVisibilityLibrary
import com.twitter.visibility.interfaces.tweets.TweetVisibilityLibrary
import com.twitter.visibility.interfaces.tweets.UserUnavailableStateVisibilityLibrary
import com.twitter.visibility.util.DeciderUtil
import com.twitter.visibility.util.FeatureSwitchUtil
import java.util.concurrent.Executors</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>LogicalRepositories is a layer above ExternalRepositories.  These repos may have additional</p></li>
<li><p>logic layered in, such as memcache-caching, hot-key caching, etc.  There may</p></li>
<li><p>also be multiple logical repositories mapped to an single external repository.</p></li>
<li></li>
<li><p>These repositories are used in tweet hydration and tweet creation.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
</dl>
<p>trait LogicalRepositories {</p>
<blockquote>
<div><p>def card2Repo: Card2Repository.Type
def cardRepo: CardRepository.Type
def cardUsersRepo: CardUsersRepository.Type
def conversationIdRepo: ConversationIdRepository.Type
def conversationControlRepo: ConversationControlRepository.Type
def conversationMutedRepo: ConversationMutedRepository.Type
def containerAsGetTweetResultRepo: CreativesContainerMaterializationRepository.GetTweetType
def containerAsGetTweetFieldsResultRepo: CreativesContainerMaterializationRepository.GetTweetFieldsType
def deviceSourceRepo: DeviceSourceRepository.Type
def escherbirdAnnotationRepo: EscherbirdAnnotationRepository.Type
def geoScrubTimestampRepo: GeoScrubTimestampRepository.Type
def languageRepo: LanguageRepository.Type
def mediaMetadataRepo: MediaMetadataRepository.Type
def pastedMediaRepo: PastedMediaRepository.Type
def perspectiveRepo: PerspectiveRepository.Type
def placeRepo: PlaceRepository.Type
def profileGeoRepo: ProfileGeoRepository.Type
def quoterHasAlreadyQuotedRepo: QuoterHasAlreadyQuotedRepository.Type
def lastQuoteOfQuoterRepo: LastQuoteOfQuoterRepository.Type
def relationshipRepo: RelationshipRepository.Type
def stratoSafetyLabelsRepo: StratoSafetyLabelsRepository.Type
def stratoCommunityMembershipRepo: StratoCommunityMembershipRepository.Type
def stratoCommunityAccessRepo: StratoCommunityAccessRepository.Type
def stratoSuperFollowEligibleRepo: StratoSuperFollowEligibleRepository.Type
def stratoSuperFollowRelationsRepo: StratoSuperFollowRelationsRepository.Type
def stratoPromotedTweetRepo: StratoPromotedTweetRepository.Type
def stratoSubscriptionVerificationRepo: StratoSubscriptionVerificationRepository.Type
def takedownRepo: UserTakedownRepository.Type
def tweetSpamCheckRepo: TweetSpamCheckRepository.Type
def retweetSpamCheckRepo: RetweetSpamCheckRepository.Type
def tweetCountsRepo: TweetCountsRepository.Type
def tweetVisibilityRepo: TweetVisibilityRepository.Type
def quotedTweetVisibilityRepo: QuotedTweetVisibilityRepository.Type
def deletedTweetVisibilityRepo: DeletedTweetVisibilityRepository.Type
def unmentionedEntitiesRepo: UnmentionedEntitiesRepository.Type
def urlRepo: UrlRepository.Type
def userRepo: UserRepository.Type
def optionalUserRepo: UserRepository.Optional
def userIdentityRepo: UserIdentityRepository.Type
def userIsInvitedToConversationRepo: UserIsInvitedToConversationRepository.Type
def userProtectionRepo: UserProtectionRepository.Type
def userViewRepo: UserViewRepository.Type
def userVisibilityRepo: UserVisibilityRepository.Type</p>
<p>def tweetResultRepo: TweetResultRepository.Type
def tweetRepo: TweetRepository.Type
def optionalTweetRepo: TweetRepository.Optional</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Not actually repositories, but intimately intertwined.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
</dl>
<p>def tweetHydrators: TweetHydrators</p>
</div></blockquote>
<p>}</p>
<p>object LogicalRepositories {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Middleware is a function that takes a stitch repo and returns a new stitch repo.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
</dl>
<p>type Middleware[K, V] = (K =&gt; Stitch[V]) =&gt; K =&gt; Stitch[V]</p>
<p>// Middleware2 is a function that takes a two-arg stitch repo and returns a new two-arg stitch repo.
type Middleware2[K, C, V] = ((K, C) =&gt; Stitch[V]) =&gt; ((K, C) =&gt; Stitch[V])
val exceptionLog: Logger = Logger(getClass)</p>
<p>// Converts a Middleware2 to a Middleware for use with withMiddleware.
def tupledMiddleware[K, C, V](middleware2: Middleware2[K, C, V]): Middleware[(K, C), V] =</p>
<blockquote>
<div><p>repo =&gt; middleware2(Function.untupled(repo)).tupled</p>
</div></blockquote>
<dl>
<dt>object ObserveStitch {</dt><dd><dl>
<dt>def apply[K, V](</dt><dd><p>repo: K =&gt; Stitch[V],
repoName: String,
stats: StatsReceiver</p>
</dd>
<dt>): K =&gt; Stitch[V] = {</dt><dd><p>val successCounter = stats.counter(“success”)
val notFoundCounter = stats.counter(“not_found”)
val latencyStat = stats.stat(“latency_ms”)</p>
<dl>
<dt>val exceptionCounter =</dt><dd><dl class="simple">
<dt>ExceptionCounter(</dt><dd><p>stats,
// don’t count FilteredState exceptions
FilteredState.ignoringCategorizer(ExceptionCounter.defaultCategorizer)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>(key: K) =&gt;</dt><dd><dl>
<dt>StitchUtils.trackLatency(latencyStat, repo(key)).respond {</dt><dd><p>case Return(_) =&gt; successCounter.incr()
case Throw(NotFound) =&gt; notFoundCounter.incr()
case Throw(t) =&gt;</p>
<blockquote>
<div><p>val message = s”$repoName: $key”
if (BoringStackTrace.isBoring(t)) {</p>
<blockquote>
<div><p>exceptionLog.debug(message, t)</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>exceptionLog.warn(message, t)</p>
</dd>
</dl>
<p>}</p>
<p>exceptionCounter(t)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Add middleware to configure a repository. The stats receiver is</p></li>
<li><p>scoped for the currently-configured repository. The <cite>toRepo</cite> field</p></li>
<li><p>is the repository with some set of middleware applied. Each method</p></li>
<li><p>adds a new middleware to the current repo, and returns it as a</p></li>
<li><p><cite>RepoConfig</cite>, allowing method chaining.</p></li>
<li></li>
<li><p>Since each method call applies a new middleware, the final middleware is</p></li>
<li><p>the outermost middleware, and thus the one that sees the arguments</p></li>
<li><p>first.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>class RepoConfig[K, V](</dt><dd><p>val toRepo: K =&gt; Stitch[V],
stats: StatsReceiver,
name: String,
memcachedClientWithInProcessCaching: memcached.Client) {
def withMiddleware(middleware: Middleware[K, V]): RepoConfig[K, V] =</p>
<blockquote>
<div><p>new RepoConfig[K, V](middleware(toRepo), stats, name, memcachedClientWithInProcessCaching)</p>
</div></blockquote>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Wraps a repo with success/failure/latency stats tracking and logs</p></li>
<li><p>exceptions. This will be applied to every repository.</p></li>
<li></li>
<li><p>&#64;param repoName Used when logging exceptions thrown by the underlying repo.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>def observe(repoName: String = s”${name}_repo”): RepoConfig[K, V] = {</dt><dd><p>withMiddleware { repo =&gt; ObserveStitch[K, V](repo, repoName, stats) }</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Use the supplied cache to wrap the repository with a read-through</p></li>
<li><p>caching layer.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>def caching(</dt><dd><p>cache: LockingCache[K, Cached[V]],
partialHandler: CachedResult.PartialHandler[K, V],
maxCacheRequestSize: Int = Int.MaxValue</p>
</dd>
<dt>): RepoConfig[K, V] = {</dt><dd><dl class="simple">
<dt>val stitchLockingCache = StitchLockingCache(</dt><dd><p>underlying = cache,
picker = new PreferNewestCached[V],
maxRequestSize = maxCacheRequestSize</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>val handler: CachedResult.Handler[K, V] =</dt><dd><dl>
<dt>CachedResult.Handler(</dt><dd><dl class="simple">
<dt>CachedResult.PartialHandler.orElse(</dt><dd><p>partialHandler,
CachedResult.failuresAreDoNotCache</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>withMiddleware { repo =&gt;</dt><dd><dl class="simple">
<dt>CacheStitch[K, K, V](</dt><dd><p>repo = repo,
cache = stitchLockingCache,
identity,
handler = handler,
cacheable = CacheStitch.cacheFoundAndNotFound</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def newCaching(</dt><dd><p>keySerializer: K =&gt; String,
valueSerializer: ValueSerializer[Try[V]]</p>
</dd>
<dt>): RepoConfig[K, V] =</dt><dd><dl>
<dt>withMiddleware { repo =&gt;</dt><dd><p>val logger = Logger(s”com.twitter.tweetypie.config.LogicalRepositories.$name”)</p>
<dl>
<dt>val cacheOperations: CacheOperations[K, Try[V]] =</dt><dd><dl class="simple">
<dt>new CacheOperations(</dt><dd><p>keySerializer = keySerializer,
valueSerializer = valueSerializer,
memcachedClient = memcachedClientWithInProcessCaching,
statsReceiver = stats.scope(“caching”),
logger = logger</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>val tryRepo: K =&gt; Stitch[Try[V]] = repo.andThen(_.liftToTry)
val cachingTryRepo: K =&gt; Stitch[Try[V]] = new StitchCaching(cacheOperations, tryRepo)
cachingTryRepo.andThen(_.lowerFromTry)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>def toRepo2[K1, C](implicit tupleToK: ((K1, C)) &lt;:&lt; K): (K1, C) =&gt; Stitch[V] =</dt><dd><p>(k1, c) =&gt; toRepo(tupleToK((k1, c)))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def softTtlPartialHandler[K, V](</dt><dd><p>softTtl: Option[V] =&gt; Duration,
softTtlPerturbationFactor: Float = 0.05f</p>
</dd>
<dt>): CachedResult.PartialHandler[K, V] =</dt><dd><dl class="simple">
<dt>CachedResult</dt><dd><p>.softTtlExpiration[K, V](softTtl, CachedResult.randomExpiry(softTtlPerturbationFactor))</p>
</dd>
</dl>
</dd>
<dt>def apply(</dt><dd><p>settings: TweetServiceSettings,
stats: StatsReceiver,
timer: Timer,
deciderGates: TweetypieDeciderGates,
external: ExternalRepositories,
caches: Caches,
stratoClient: StratoClient,
hasMedia: Tweet =&gt; Boolean,
clientIdHelper: ClientIdHelper,
featureSwitchesWithoutExperiments: FeatureSwitches,</p>
</dd>
<dt>): LogicalRepositories = {</dt><dd><p>val repoStats = stats.scope(“repositories”)</p>
<dl>
<dt>def repoConfig[K, V](name: String, repo: K =&gt; Stitch[V]): RepoConfig[K, V] =</dt><dd><dl class="simple">
<dt>new RepoConfig[K, V](</dt><dd><p>name = name,
toRepo = repo,
stats = repoStats.scope(name),
memcachedClientWithInProcessCaching = caches.memcachedClientWithInProcessCaching)</p>
</dd>
</dl>
</dd>
<dt>def repo2Config[K, C, V](name: String, repo: (K, C) =&gt; Stitch[V]): RepoConfig[(K, C), V] =</dt><dd><p>repoConfig[(K, C), V](name, repo.tupled)</p>
</dd>
<dt>new LogicalRepositories {</dt><dd><p>// the final tweetResultRepo has a circular dependency, where it depends on hydrators
// that in turn depend on the tweetResultRepo, so we create a <cite>tweetResultRepo</cite> function
// that proxies to <cite>var finalTweetResultRepo</cite>, which gets set at the end of this block.
var finalTweetResultRepo: TweetResultRepository.Type = null
val tweetResultRepo: TweetResultRepository.Type =</p>
<blockquote>
<div><p>(tweetId, opts) =&gt; finalTweetResultRepo(tweetId, opts)</p>
</div></blockquote>
<p>val tweetRepo: TweetRepository.Type = TweetRepository.fromTweetResult(tweetResultRepo)</p>
<p>val optionalTweetRepo: TweetRepository.Optional = TweetRepository.optional(tweetRepo)</p>
<dl class="simple">
<dt>val userRepo: UserRepository.Type =</dt><dd><dl class="simple">
<dt>repo2Config(repo = external.userRepo, name = “user”)</dt><dd><p>.observe()
.toRepo2</p>
</dd>
</dl>
</dd>
</dl>
<p>val optionalUserRepo: UserRepository.Optional = UserRepository.optional(userRepo)</p>
<dl class="simple">
<dt>private[this] val tweetVisibilityStatsReceiver: StatsReceiver =</dt><dd><p>repoStats.scope(“tweet_visibility_library”)</p>
</dd>
<dt>private[this] val userUnavailableVisibilityStatsReceiver: StatsReceiver =</dt><dd><p>repoStats.scope(“user_unavailable_visibility_library”)</p>
</dd>
<dt>private[this] val quotedTweetVisibilityStatsReceiver: StatsReceiver =</dt><dd><p>repoStats.scope(“quoted_tweet_visibility_library”)</p>
</dd>
<dt>private[this] val deletedTweetVisibilityStatsReceiver: StatsReceiver =</dt><dd><p>repoStats.scope(“deleted_tweet_visibility_library”)</p>
</dd>
</dl>
<p>// TweetVisibilityLibrary still uses the old c.t.logging.Logger
private[this] val tweetVisibilityLogger =</p>
<blockquote>
<div><p>com.twitter.logging.Logger(“com.twitter.tweetypie.TweetVisibility”)</p>
</div></blockquote>
<dl class="simple">
<dt>private[this] val visibilityDecider: Decider = DeciderUtil.mkDecider(</dt><dd><p>deciderOverlayPath = settings.vfDeciderOverlayFilename,
useLocalDeciderOverrides = true)</p>
</dd>
</dl>
<p>private[this] val visibilityDeciderGates = VisibilityDeciderGates(visibilityDecider)</p>
<dl>
<dt>private[this] def visibilityLibrary(statsReceiver: StatsReceiver) = VisibilityLibrary</dt><dd><dl class="simple">
<dt>.Builder(</dt><dd><p>log = tweetVisibilityLogger,
statsReceiver = statsReceiver,
memoizeSafetyLevelParams = visibilityDeciderGates.enableMemoizeSafetyLevelParams</p>
</dd>
</dl>
<p>)
.withDecider(visibilityDecider)
.withDefaultABDecider(isLocal = false)
.withCaptureDebugStats(Gate.True)
.withEnableComposableActions(Gate.True)
.withEnableFailClosed(Gate.True)
.withEnableShortCircuiting(visibilityDeciderGates.enableShortCircuitingTVL)
.withSpecialLogging(visibilityDeciderGates.enableSpecialLogging)
.build()</p>
</dd>
<dt>def countryNameGenerator(statsReceiver: StatsReceiver) = {</dt><dd><p>// TweetVisibilityLibrary, DeletedTweetVisibilityLibrary, and
// UserUnavailableVisibilityLibrary do not evaluate any Rules
// that require the display of country names in copy
CountryNameGenerator.providesWithCustomMap(Map.empty, statsReceiver)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def tombstoneGenerator(</dt><dd><p>countryNameGenerator: CountryNameGenerator,
statsReceiver: StatsReceiver</p>
</dd>
<dt>) =</dt><dd><dl class="simple">
<dt>TombstoneGenerator(</dt><dd><p>visibilityLibrary(statsReceiver).visParams,
countryNameGenerator,
statsReceiver)</p>
</dd>
</dl>
</dd>
<dt>private[this] val userUnavailableVisibilityLibrary =</dt><dd><dl>
<dt>UserUnavailableStateVisibilityLibrary(</dt><dd><p>visibilityLibrary(userUnavailableVisibilityStatsReceiver),
visibilityDecider,
tombstoneGenerator(</p>
<blockquote>
<div><p>countryNameGenerator(userUnavailableVisibilityStatsReceiver),
userUnavailableVisibilityStatsReceiver</p>
</div></blockquote>
<p>),
LocalizedInterstitialGenerator(visibilityDecider, userUnavailableVisibilityStatsReceiver)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val userIdentityRepo: UserIdentityRepository.Type =</dt><dd><dl class="simple">
<dt>repoConfig(repo = UserIdentityRepository(userRepo), name = “user_identity”)</dt><dd><p>.observe()
.toRepo</p>
</dd>
</dl>
</dd>
<dt>val userProtectionRepo: UserProtectionRepository.Type =</dt><dd><dl class="simple">
<dt>repoConfig(repo = UserProtectionRepository(userRepo), name = “user_protection”)</dt><dd><p>.observe()
.toRepo</p>
</dd>
</dl>
</dd>
<dt>val userViewRepo: UserViewRepository.Type =</dt><dd><dl class="simple">
<dt>repoConfig(repo = UserViewRepository(userRepo), name = “user_view”)</dt><dd><p>.observe()
.toRepo</p>
</dd>
</dl>
</dd>
<dt>val userVisibilityRepo: UserVisibilityRepository.Type =</dt><dd><dl class="simple">
<dt>repoConfig(</dt><dd><p>repo = UserVisibilityRepository(userRepo, userUnavailableVisibilityLibrary),
name = “user_visibility”</p>
</dd>
</dl>
<p>).observe().toRepo</p>
</dd>
<dt>val urlRepo: UrlRepository.Type =</dt><dd><dl class="simple">
<dt>repoConfig(repo = external.urlRepo, name = “url”)</dt><dd><p>.observe()
.toRepo</p>
</dd>
</dl>
</dd>
<dt>val profileGeoRepo: ProfileGeoRepository.Type =</dt><dd><dl class="simple">
<dt>repoConfig(repo = external.profileGeoRepo, name = “profile_geo”)</dt><dd><p>.observe()
.toRepo</p>
</dd>
</dl>
</dd>
<dt>val quoterHasAlreadyQuotedRepo: QuoterHasAlreadyQuotedRepository.Type =</dt><dd><dl class="simple">
<dt>repo2Config(repo = external.quoterHasAlreadyQuotedRepo, name = “quoter_has_already_quoted”)</dt><dd><p>.observe()
.toRepo2</p>
</dd>
</dl>
</dd>
<dt>val lastQuoteOfQuoterRepo: LastQuoteOfQuoterRepository.Type =</dt><dd><dl class="simple">
<dt>repo2Config(repo = external.lastQuoteOfQuoterRepo, name = “last_quote_of_quoter”)</dt><dd><p>.observe()
.toRepo2</p>
</dd>
</dl>
</dd>
<dt>val mediaMetadataRepo: MediaMetadataRepository.Type =</dt><dd><dl class="simple">
<dt>repoConfig(repo = external.mediaMetadataRepo, name = “media_metadata”)</dt><dd><p>.observe()
.toRepo</p>
</dd>
</dl>
</dd>
<dt>val perspectiveRepo: PerspectiveRepository.Type =</dt><dd><dl class="simple">
<dt>repoConfig(repo = external.perspectiveRepo, name = “perspective”)</dt><dd><p>.observe()
.toRepo</p>
</dd>
</dl>
</dd>
<dt>val conversationMutedRepo: ConversationMutedRepository.Type =</dt><dd><p>TimelineService.GetPerspectives.getConversationMuted(perspectiveRepo)</p>
</dd>
</dl>
<p>// Because observe is applied before caching, only cache misses
// (i.e. calls to the underlying repo) are observed.
// Note that <cite>newCaching</cite> has stats around cache hit/miss but <cite>caching</cite> does not.
val deviceSourceRepo: DeviceSourceRepository.Type =</p>
<blockquote>
<div><dl>
<dt>repoConfig(repo = external.deviceSourceRepo, name = “device_source”)</dt><dd><p>.observe()
.newCaching(</p>
<blockquote>
<div><p>keySerializer = appIdStr =&gt; DeviceSourceKey(appIdStr).toString,
valueSerializer = ServoCachedValueSerializer(</p>
<blockquote>
<div><p>codec = DeviceSource,
expiry = Expiry.byAge(settings.deviceSourceMemcacheTtl),
softTtl = settings.deviceSourceMemcacheSoftTtl</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>)
.caching(</p>
<blockquote>
<div><p>cache = caches.deviceSourceInProcessCache,
partialHandler = softTtlPartialHandler(_ =&gt; settings.deviceSourceInProcessSoftTtl)</p>
</div></blockquote>
<p>)
.toRepo</p>
</dd>
</dl>
</div></blockquote>
<p>// Because observe is applied before caching, only cache misses
// (i.e. calls to the underlying repo) are observed
// Note that <cite>newCaching</cite> has stats around cache hit/miss but <cite>caching</cite> does not.
val placeRepo: PlaceRepository.Type =</p>
<blockquote>
<div><dl>
<dt>repoConfig(repo = external.placeRepo, name = “place”)</dt><dd><p>.observe()
.newCaching(</p>
<blockquote>
<div><p>keySerializer = placeKey =&gt; placeKey.toString,
valueSerializer = ServoCachedValueSerializer(</p>
<blockquote>
<div><p>codec = Place,
expiry = Expiry.byAge(settings.placeMemcacheTtl),
softTtl = settings.placeMemcacheSoftTtl</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>)
.toRepo</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>val cardRepo: CardRepository.Type =</dt><dd><dl class="simple">
<dt>repoConfig(repo = external.cardRepo, name = “cards”)</dt><dd><p>.observe()
.toRepo</p>
</dd>
</dl>
</dd>
<dt>val card2Repo: Card2Repository.Type =</dt><dd><dl class="simple">
<dt>repo2Config(repo = external.card2Repo, name = “card2”)</dt><dd><p>.observe()
.toRepo2</p>
</dd>
</dl>
</dd>
<dt>val cardUsersRepo: CardUsersRepository.Type =</dt><dd><dl class="simple">
<dt>repo2Config(repo = external.cardUsersRepo, name = “card_users”)</dt><dd><p>.observe()
.toRepo2</p>
</dd>
</dl>
</dd>
<dt>val relationshipRepo: RelationshipRepository.Type =</dt><dd><dl class="simple">
<dt>repoConfig(repo = external.relationshipRepo, name = “relationship”)</dt><dd><p>.observe()
.toRepo</p>
</dd>
</dl>
</dd>
<dt>val conversationIdRepo: ConversationIdRepository.Type =</dt><dd><dl class="simple">
<dt>repoConfig(repo = external.conversationIdRepo, name = “conversation_id”)</dt><dd><p>.observe()
.toRepo</p>
</dd>
</dl>
</dd>
<dt>val conversationControlRepo: ConversationControlRepository.Type =</dt><dd><dl class="simple">
<dt>repo2Config(</dt><dd><p>repo = ConversationControlRepository(tweetRepo, stats.scope(“conversation_control”)),
name = “conversation_control”</p>
</dd>
</dl>
<p>).observe().toRepo2</p>
</dd>
<dt>val containerAsGetTweetResultRepo: CreativesContainerMaterializationRepository.GetTweetType =</dt><dd><dl class="simple">
<dt>repo2Config(</dt><dd><p>repo = external.containerAsTweetRepo,
name = “container_as_tweet”</p>
</dd>
</dl>
<p>).observe().toRepo2</p>
</dd>
<dt>val containerAsGetTweetFieldsResultRepo: CreativesContainerMaterializationRepository.GetTweetFieldsType =</dt><dd><dl class="simple">
<dt>repo2Config(</dt><dd><p>repo = external.containerAsTweetFieldsRepo,
name = “container_as_tweet_fields”</p>
</dd>
</dl>
<p>).observe().toRepo2</p>
</dd>
<dt>val languageRepo: LanguageRepository.Type = {</dt><dd><p>val pool = FuturePool(Executors.newFixedThreadPool(settings.numPenguinThreads))
repoConfig(repo = PenguinLanguageRepository(pool), name = “language”)</p>
<blockquote>
<div><p>.observe()
.toRepo</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<p>// Because observe is applied before caching, only cache misses
// (i.e. calls to the underlying repo) are observed
// Note that <cite>newCaching</cite> has stats around cache hit/miss but <cite>caching</cite> does not.
val tweetCountsRepo: TweetCountsRepository.Type =</p>
<blockquote>
<div><dl>
<dt>repoConfig(repo = external.tweetCountsRepo, name = “counts”)</dt><dd><p>.observe()
.caching(</p>
<blockquote>
<div><p>cache = caches.tweetCountsCache,
partialHandler = softTtlPartialHandler {</p>
<blockquote>
<div><p>case Some(0) =&gt; settings.tweetCountsMemcacheZeroSoftTtl
case _ =&gt; settings.tweetCountsMemcacheNonZeroSoftTtl</p>
</div></blockquote>
<p>},
maxCacheRequestSize = settings.tweetCountsCacheChunkSize</p>
</div></blockquote>
<p>)
.toRepo</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>val pastedMediaRepo: PastedMediaRepository.Type =</dt><dd><dl class="simple">
<dt>repo2Config(repo = PastedMediaRepository(tweetRepo), name = “pasted_media”)</dt><dd><p>.observe()
.toRepo2</p>
</dd>
</dl>
</dd>
<dt>val escherbirdAnnotationRepo: EscherbirdAnnotationRepository.Type =</dt><dd><dl class="simple">
<dt>repoConfig(repo = external.escherbirdAnnotationRepo, name = “escherbird_annotations”)</dt><dd><p>.observe()
.toRepo</p>
</dd>
</dl>
</dd>
<dt>val stratoSafetyLabelsRepo: StratoSafetyLabelsRepository.Type =</dt><dd><dl class="simple">
<dt>repo2Config(repo = external.stratoSafetyLabelsRepo, name = “strato_safety_labels”)</dt><dd><p>.observe()
.toRepo2</p>
</dd>
</dl>
</dd>
<dt>val stratoCommunityMembershipRepo: StratoCommunityMembershipRepository.Type =</dt><dd><dl class="simple">
<dt>repoConfig(</dt><dd><p>repo = external.stratoCommunityMembershipRepo,
name = “strato_community_memberships”)
.observe()
.toRepo</p>
</dd>
</dl>
</dd>
<dt>val stratoCommunityAccessRepo: StratoCommunityAccessRepository.Type =</dt><dd><dl class="simple">
<dt>repoConfig(repo = external.stratoCommunityAccessRepo, name = “strato_community_access”)</dt><dd><p>.observe()
.toRepo</p>
</dd>
</dl>
</dd>
<dt>val stratoSuperFollowEligibleRepo: StratoSuperFollowEligibleRepository.Type =</dt><dd><dl class="simple">
<dt>repoConfig(</dt><dd><p>repo = external.stratoSuperFollowEligibleRepo,
name = “strato_super_follow_eligible”)
.observe()
.toRepo</p>
</dd>
</dl>
</dd>
<dt>val stratoSuperFollowRelationsRepo: StratoSuperFollowRelationsRepository.Type =</dt><dd><dl class="simple">
<dt>repo2Config(</dt><dd><p>repo = external.stratoSuperFollowRelationsRepo,
name = “strato_super_follow_relations”)
.observe()
.toRepo2</p>
</dd>
</dl>
</dd>
<dt>val stratoPromotedTweetRepo: StratoPromotedTweetRepository.Type =</dt><dd><dl class="simple">
<dt>repoConfig(repo = external.stratoPromotedTweetRepo, name = “strato_promoted_tweet”)</dt><dd><p>.observe()
.toRepo</p>
</dd>
</dl>
</dd>
<dt>val stratoSubscriptionVerificationRepo: StratoSubscriptionVerificationRepository.Type =</dt><dd><dl class="simple">
<dt>repo2Config(</dt><dd><p>repo = external.stratoSubscriptionVerificationRepo,
name = “strato_subscription_verification”)
.observe()
.toRepo2</p>
</dd>
</dl>
</dd>
<dt>val unmentionedEntitiesRepo: UnmentionedEntitiesRepository.Type =</dt><dd><dl class="simple">
<dt>repo2Config(repo = external.unmentionedEntitiesRepo, name = “unmentioned_entities”)</dt><dd><p>.observe()
.toRepo2</p>
</dd>
</dl>
</dd>
<dt>private[this] val userSource =</dt><dd><dl>
<dt>UserSource.fromRepo(</dt><dd><dl class="simple">
<dt>Repo { (k, _) =&gt;</dt><dd><p>val opts = UserQueryOptions(k.fields, UserVisibility.All)
userRepo(UserKey(k.id), opts)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>private[this] val userRelationshipSource =</dt><dd><dl>
<dt>UserRelationshipSource.fromRepo(</dt><dd><dl>
<dt>Repo[UserRelationshipSource.Key, Unit, Boolean] { (key, _) =&gt;</dt><dd><dl class="simple">
<dt>relationshipRepo(</dt><dd><p>RelationshipKey(key.subjectId, key.objectId, key.relationship)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>private[this] val tweetPerspectiveSource =</dt><dd><p>TweetPerspectiveSource.fromGetPerspectives(perspectiveRepo)</p>
</dd>
<dt>private[this] val tweetMediaMetadataSource =</dt><dd><p>TweetMediaMetadataSource.fromFunction(mediaMetadataRepo)</p>
</dd>
<dt>val userIsInvitedToConversationRepo: UserIsInvitedToConversationRepository.Type =</dt><dd><dl class="simple">
<dt>repo2Config(</dt><dd><p>repo = external.userIsInvitedToConversationRepo,
name = “user_is_invited_to_conversation”)
.observe()
.toRepo2</p>
</dd>
</dl>
</dd>
<dt>private[this] val stringCenterClient: MultiProjectStringCenter = {</dt><dd><p>val stringCenterProjects = settings.flags.stringCenterProjects().toList</p>
<dl class="simple">
<dt>val languages: Languages = new YamlConfigLanguages(</dt><dd><p>new YamlConfig(settings.flags.languagesConfig()))</p>
</dd>
<dt>val loggingAbDecider = ABDeciderFactory(“/usr/local/config/abdecider/abdecider.yml”)</dt><dd><p>.withEnvironment(“production”)
.buildWithLogging()</p>
</dd>
<dt>MultiProjectStringCenter(</dt><dd><p>projects = stringCenterProjects,
defaultBundlePath = MultiProjectStringCenter.StandardDefaultBundlePath,
refreshingBundlePath = MultiProjectStringCenter.StandardRefreshingBundlePath,
refreshingInterval = MultiProjectStringCenter.StandardRefreshingInterval,
requireDefaultBundleExists = true,
languages = languages,
statsReceiver = tweetVisibilityStatsReceiver,
loggingABDecider = loggingAbDecider</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}
private[this] val stringRegistry: ExternalStringRegistry = new ExternalStringRegistry()
private[this] val localizationSource: LocalizationSource =</p>
<blockquote>
<div><p>LocalizationSource.fromMultiProjectStringCenterClient(stringCenterClient, stringRegistry)</p>
</div></blockquote>
<dl>
<dt>val tweetVisibilityRepo: TweetVisibilityRepository.Type = {</dt><dd><dl>
<dt>val tweetVisibilityLibrary: TweetVisibilityLibrary.Type =</dt><dd><dl>
<dt>TweetVisibilityLibrary(</dt><dd><p>visibilityLibrary(tweetVisibilityStatsReceiver),
userSource = userSource,
userRelationshipSource = userRelationshipSource,
keywordMatcher = KeywordMatcher.defaultMatcher(stats),
stratoClient = stratoClient,
localizationSource = localizationSource,
decider = visibilityDecider,
invitedToConversationRepo = userIsInvitedToConversationRepo,
tweetPerspectiveSource = tweetPerspectiveSource,
tweetMediaMetadataSource = tweetMediaMetadataSource,
tombstoneGenerator = tombstoneGenerator(</p>
<blockquote>
<div><p>countryNameGenerator(tweetVisibilityStatsReceiver),
tweetVisibilityStatsReceiver</p>
</div></blockquote>
<p>),
interstitialGenerator =</p>
<blockquote>
<div><p>LocalizedInterstitialGenerator(visibilityDecider, tweetVisibilityStatsReceiver),</p>
</div></blockquote>
<dl class="simple">
<dt>limitedActionsFeatureSwitches =</dt><dd><p>FeatureSwitchUtil.mkLimitedActionsFeatureSwitches(tweetVisibilityStatsReceiver),</p>
</dd>
</dl>
<p>enableParityTest = deciderGates.tweetVisibilityLibraryEnableParityTest</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val underlying =</dt><dd><dl class="simple">
<dt>TweetVisibilityRepository(</dt><dd><p>tweetVisibilityLibrary,
visibilityDeciderGates,
tweetVisibilityLogger,
repoStats.scope(“tweet_visibility_repo”)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>repoConfig(repo = underlying, name = “tweet_visibility”)</dt><dd><p>.observe()
.toRepo</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val quotedTweetVisibilityRepo: QuotedTweetVisibilityRepository.Type = {</dt><dd><dl>
<dt>val quotedTweetVisibilityLibrary: QuotedTweetVisibilityLibrary.Type =</dt><dd><dl class="simple">
<dt>QuotedTweetVisibilityLibrary(</dt><dd><p>visibilityLibrary(quotedTweetVisibilityStatsReceiver),
userSource = userSource,
userRelationshipSource = userRelationshipSource,
visibilityDecider,
userStateVisibilityLibrary = userUnavailableVisibilityLibrary,
enableVfFeatureHydration = deciderGates.enableVfFeatureHydrationInQuotedTweetVLShim</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val underlying =</dt><dd><p>QuotedTweetVisibilityRepository(quotedTweetVisibilityLibrary, visibilityDeciderGates)</p>
</dd>
<dt>repoConfig(repo = underlying, name = “quoted_tweet_visibility”)</dt><dd><p>.observe()
.toRepo</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val deletedTweetVisibilityRepo: DeletedTweetVisibilityRepository.Type = {</dt><dd><dl>
<dt>val deletedTweetVisibilityLibrary: DeletedTweetVisibilityLibrary.Type =</dt><dd><dl>
<dt>DeletedTweetVisibilityLibrary(</dt><dd><p>visibilityLibrary(deletedTweetVisibilityStatsReceiver),
visibilityDecider,
tombstoneGenerator(</p>
<blockquote>
<div><p>countryNameGenerator(deletedTweetVisibilityStatsReceiver),
deletedTweetVisibilityStatsReceiver</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val underlying = DeletedTweetVisibilityRepository.apply(</dt><dd><p>deletedTweetVisibilityLibrary</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>repoConfig(repo = underlying, name = “deleted_tweet_visibility”)</dt><dd><p>.observe()
.toRepo</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>val takedownRepo: UserTakedownRepository.Type =</dt><dd><dl class="simple">
<dt>repoConfig(repo = UserTakedownRepository(userRepo), name = “takedowns”)</dt><dd><p>.observe()
.toRepo</p>
</dd>
</dl>
</dd>
<dt>val tweetSpamCheckRepo: TweetSpamCheckRepository.Type =</dt><dd><dl class="simple">
<dt>repo2Config(repo = external.tweetSpamCheckRepo, name = “tweet_spam_check”)</dt><dd><p>.observe()
.toRepo2</p>
</dd>
</dl>
</dd>
<dt>val retweetSpamCheckRepo: RetweetSpamCheckRepository.Type =</dt><dd><dl class="simple">
<dt>repoConfig(repo = external.retweetSpamCheckRepo, name = “retweet_spam_check”)</dt><dd><p>.observe()
.toRepo</p>
</dd>
</dl>
</dd>
</dl>
<p>// Because observe is applied before caching, only cache misses
// (i.e. calls to the underlying repo) are observed
// Note that <cite>newCaching</cite> has stats around cache hit/miss but <cite>caching</cite> does not.
val geoScrubTimestampRepo: GeoScrubTimestampRepository.Type =</p>
<blockquote>
<div><dl>
<dt>repoConfig(repo = external.geoScrubTimestampRepo, name = “geo_scrub”)</dt><dd><p>.observe()
.caching(</p>
<blockquote>
<div><p>cache = caches.geoScrubCache,
partialHandler = (_ =&gt; None)</p>
</div></blockquote>
<p>)
.toRepo</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>val tweetHydrators: TweetHydrators =</dt><dd><dl class="simple">
<dt>TweetHydrators(</dt><dd><p>stats = stats,
deciderGates = deciderGates,
repos = this,
tweetDataCache = caches.tweetDataCache,
hasMedia = hasMedia,
featureSwitchesWithoutExperiments = featureSwitchesWithoutExperiments,
clientIdHelper = clientIdHelper,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val queryOptionsExpander: TweetQueryOptionsExpander.Type =</dt><dd><dl class="simple">
<dt>TweetQueryOptionsExpander.threadLocalMemoize(</dt><dd><p>TweetQueryOptionsExpander.expandDependencies</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>// mutations to tweets that we only need to apply when reading from the external
// repository, and not when reading from cache
val tweetMutation: Mutation[Tweet] =</p>
<blockquote>
<div><dl>
<dt>Mutation</dt><dd><dl>
<dt>.all(</dt><dd><dl class="simple">
<dt>Seq(</dt><dd><p>EntityExtractor.mutationAll,
TextRepairer.BlankLineCollapser,
TextRepairer.CoreTextBugPatcher</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>).onlyIf(_.coreData.isDefined)</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>val cachingTweetRepo: TweetResultRepository.Type =</dt><dd><dl>
<dt>repo2Config(repo = external.tweetResultRepo, name = “saved_tweet”)</dt><dd><p>.observe()
.withMiddleware { repo =&gt;</p>
<blockquote>
<div><p>// applies tweetMutation to the results of TweetResultRepository
val mutateResult = TweetResult.mutate(tweetMutation)
repo.andThen(stitchResult =&gt; stitchResult.map(mutateResult))</p>
</div></blockquote>
<p>}
.withMiddleware(</p>
<blockquote>
<div><dl>
<dt>tupledMiddleware(</dt><dd><dl class="simple">
<dt>CachingTweetRepository(</dt><dd><p>caches.tweetResultCache,
settings.tweetTombstoneTtl,
stats.scope(“saved_tweet”, “cache”),
clientIdHelper,
deciderGates.logCacheExceptions,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>)
.toRepo2</p>
</dd>
</dl>
</dd>
<dt>finalTweetResultRepo = repo2Config(repo = cachingTweetRepo, name = “tweet”)</dt><dd><dl>
<dt>.withMiddleware(</dt><dd><dl>
<dt>tupledMiddleware(</dt><dd><dl class="simple">
<dt>TweetHydration.hydrateRepo(</dt><dd><p>tweetHydrators.hydrator,
tweetHydrators.cacheChangesEffect,
queryOptionsExpander</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)
.observe()
.withMiddleware(tupledMiddleware(TweetResultRepository.shortCircuitInvalidIds))
.toRepo2</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/tweetypie/server/src/main/scala/com/twitter/tweetypie/config/LogicalRepositories.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>