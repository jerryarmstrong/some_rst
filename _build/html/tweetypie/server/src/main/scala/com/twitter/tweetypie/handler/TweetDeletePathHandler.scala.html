<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie
package handler</p>
<p>import com.twitter.conversions.DurationOps.RichDuration
import com.twitter.servo.exception.thriftscala.ClientError
import com.twitter.servo.exception.thriftscala.ClientErrorCause
import com.twitter.servo.util.FutureArrow
import com.twitter.snowflake.id.SnowflakeId
import com.twitter.stitch.Stitch
import com.twitter.stitch.NotFound
import com.twitter.timelineservice.thriftscala.PerspectiveResult
import com.twitter.timelineservice.{thriftscala =&gt; tls}
import com.twitter.tweetypie.core._
import com.twitter.tweetypie.repository._
import com.twitter.tweetypie.store._
import com.twitter.tweetypie.thriftscala._
import com.twitter.util.Time
import com.twitter.util.Try
import Try._
import com.twitter.spam.rtf.thriftscala.SafetyLabelType
import com.twitter.tweetypie.backends.TimelineService.GetPerspectives
import com.twitter.tweetypie.util.EditControlUtil
import scala.util.control.NoStackTrace</p>
<dl class="simple">
<dt>case class CascadedDeleteNotAvailable(retweetId: TweetId) extends Exception with NoStackTrace {</dt><dd><dl class="simple">
<dt>override def getMessage: String =</dt><dd><dl class="simple">
<dt>s”””<a href="#id1"><span class="problematic" id="id2">|</span></a>Cascaded delete tweet failed because tweet $retweetId</dt><dd><p><a href="#id3"><span class="problematic" id="id4">|</span></a>is not present in cache or manhattan.”””.stripMargin</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>object TweetDeletePathHandler {</p>
<blockquote>
<div><dl class="simple">
<dt>type DeleteTweets =</dt><dd><p>(DeleteTweetsRequest, Boolean) =&gt; Future[Seq[DeleteTweetResult]]</p>
</dd>
</dl>
<p>type UnretweetEdits = (Option[EditControl], TweetId, UserId) =&gt; Future[Unit]</p>
<p>/** The information from a deleteTweet request that can be inspected by a deleteTweets validator <a href="#id5"><span class="problematic" id="id6">*</span></a>/
case class DeleteTweetsContext(</p>
<blockquote>
<div><p>byUserId: Option[UserId],
authenticatedUserId: Option[UserId],
tweetAuthorId: UserId,
users: Map[UserId, User],
isUserErasure: Boolean,
expectedErasureUserId: Option[UserId],
tweetIsBounced: Boolean,
isBounceDelete: Boolean)</p>
</div></blockquote>
<p>/** Provides reason a tweet deletion was allowed <a href="#id7"><span class="problematic" id="id8">*</span></a>/
sealed trait DeleteAuthorization { def byUserId: Option[UserId] }</p>
<dl class="simple">
<dt>case class AuthorizedByTweetOwner(userId: UserId) extends DeleteAuthorization {</dt><dd><p>def byUserId: Option[UserId] = Some(userId)</p>
</dd>
</dl>
<p>}
case class AuthorizedByTweetContributor(contributorUserId: UserId) extends DeleteAuthorization {</p>
<blockquote>
<div><p>def byUserId: Option[UserId] = Some(contributorUserId)</p>
</div></blockquote>
<p>}
case class AuthorizedByAdmin(adminUserId: UserId) extends DeleteAuthorization {</p>
<blockquote>
<div><p>def byUserId: Option[UserId] = Some(adminUserId)</p>
</div></blockquote>
<p>}
case object AuthorizedByErasure extends DeleteAuthorization {</p>
<blockquote>
<div><p>def byUserId: None.type = None</p>
</div></blockquote>
<p>}</p>
<p>// Type for a method that receives all the relevant information about a proposed internal tweet
// deletion and can return Future.exception to cancel the delete due to a validation error or
// return a [[DeleteAuthorization]] specifying the reason the deletion is allowed.
type ValidateDeleteTweets = FutureArrow[DeleteTweetsContext, DeleteAuthorization]</p>
<dl>
<dt>val userFieldsForDelete: Set[UserField] =</dt><dd><p>Set(UserField.Account, UserField.Profile, UserField.Roles, UserField.Safety)</p>
</dd>
<dt>val userQueryOptions: UserQueryOptions =</dt><dd><dl class="simple">
<dt>UserQueryOptions(</dt><dd><p>userFieldsForDelete,
UserVisibility.All</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>// user_agent property originates from the client so truncate to a reasonable length
val MaxUserAgentLength = 1000</p>
<p>// Age under which we treat not found tweets in
// cascaded_delete_tweet as a temporary condition (the most likely
// explanation being that the tweet has not yet been
// replicated). Tweets older than this we assume are due to
// <em>permanently</em> inconsistent data, either spurious edges in tflock or
// tweets that are not loadable from Manhattan.
val MaxCascadedDeleteTweetTemporaryInconsistencyAge: Duration =</p>
<blockquote>
<div><p>10.minutes</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
<dl>
<dt>trait TweetDeletePathHandler {</dt><dd><p>import TweetDeletePathHandler.ValidateDeleteTweets</p>
<p>def cascadedDeleteTweet(request: CascadedDeleteTweetRequest): Future[Unit]</p>
<dl class="simple">
<dt>def deleteTweets(</dt><dd><p>request: DeleteTweetsRequest,
isUnretweetEdits: Boolean = false,</p>
</dd>
</dl>
<p>): Future[Seq[DeleteTweetResult]]</p>
<dl class="simple">
<dt>def internalDeleteTweets(</dt><dd><p>request: DeleteTweetsRequest,
byUserId: Option[UserId],
authenticatedUserId: Option[UserId],
validate: ValidateDeleteTweets,
isUnretweetEdits: Boolean = false</p>
</dd>
</dl>
<p>): Future[Seq[DeleteTweetResult]]</p>
<dl class="simple">
<dt>def unretweetEdits(</dt><dd><p>optEditControl: Option[EditControl],
excludedTweetId: TweetId,
byUserId: UserId</p>
</dd>
</dl>
<p>): Future[Unit]</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Implementation of TweetDeletePathHandler</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>class DefaultTweetDeletePathHandler(</dt><dd><p>stats: StatsReceiver,
tweetResultRepo: TweetResultRepository.Type,
userRepo: UserRepository.Optional,
stratoSafetyLabelsRepo: StratoSafetyLabelsRepository.Type,
lastQuoteOfQuoterRepo: LastQuoteOfQuoterRepository.Type,
tweetStore: TotalTweetStore,
getPerspectives: GetPerspectives)</p>
<blockquote>
<div><p>extends TweetDeletePathHandler {</p>
</div></blockquote>
<p>import TweetDeletePathHandler._</p>
<p>val tweetRepo: TweetRepository.Type = TweetRepository.fromTweetResult(tweetResultRepo)</p>
<p>// attempt to delete tweets was made by someone other than the tweet owner or an admin user
object DeleteTweetsPermissionException extends Exception with NoStackTrace
object ExpectedUserIdMismatchException extends Exception with NoStackTrace</p>
<p>private[this] val log = Logger(“com.twitter.tweetypie.store.TweetDeletions”)</p>
<p>private[this] val cascadeEditDelete = stats.scope(“cascade_edit_delete”)
private[this] val cascadeEditDeletesEnqueued = cascadeEditDelete.counter(“enqueued”)
private[this] val cascadeEditDeleteTweets = cascadeEditDelete.counter(“tweets”)
private[this] val cascadeEditDeleteFailures = cascadeEditDelete.counter(“failures”)</p>
<p>private[this] val cascadedDeleteTweet = stats.scope(“cascaded_delete_tweet”)
private[this] val cascadedDeleteTweetFailures = cascadedDeleteTweet.counter(“failures”)
private[this] val cascadedDeleteTweetSourceMatch = cascadedDeleteTweet.counter(“source_match”)
private[this] val cascadedDeleteTweetSourceMismatch =</p>
<blockquote>
<div><p>cascadedDeleteTweet.counter(“source_mismatch”)</p>
</div></blockquote>
<dl class="simple">
<dt>private[this] val cascadedDeleteTweetTweetNotFound =</dt><dd><p>cascadedDeleteTweet.counter(“tweet_not_found”)</p>
</dd>
<dt>private[this] val cascadedDeleteTweetTweetNotFoundAge =</dt><dd><p>cascadedDeleteTweet.stat(“tweet_not_found_age”)</p>
</dd>
</dl>
<p>private[this] val cascadedDeleteTweetUserNotFound = cascadedDeleteTweet.counter(“user_not_found”)</p>
<p>private[this] val deleteTweets = stats.scope(“delete_tweets”)
private[this] val deleteTweetsAuth = deleteTweets.scope(“per_tweet_auth”)
private[this] val deleteTweetsAuthAttempts = deleteTweetsAuth.counter(“attempts”)
private[this] val deleteTweetsAuthFailures = deleteTweetsAuth.counter(“failures”)
private[this] val deleteTweetsAuthSuccessAdmin = deleteTweetsAuth.counter(“success_admin”)
private[this] val deleteTweetsAuthSuccessByUser = deleteTweetsAuth.counter(“success_by_user”)
private[this] val deleteTweetsTweets = deleteTweets.counter(“tweets”)
private[this] val deleteTweetsFailures = deleteTweets.counter(“failures”)
private[this] val deleteTweetsTweetNotFound = deleteTweets.counter(“tweet_not_found”)
private[this] val deleteTweetsUserNotFound = deleteTweets.counter(“user_not_found”)
private[this] val userIdMismatchInTweetDelete =</p>
<blockquote>
<div><p>deleteTweets.counter(“expected_actual_user_id_mismatch”)</p>
</div></blockquote>
<dl>
<dt>private[this] val bounceDeleteFlagNotSet =</dt><dd><p>deleteTweets.counter(“bounce_delete_flag_not_set”)</p>
</dd>
<dt>private[this] def getUser(userId: UserId): Future[Option[User]] =</dt><dd><p>Stitch.run(userRepo(UserKey(userId), userQueryOptions))</p>
</dd>
<dt>private[this] def getUsersForDeleteTweets(userIds: Seq[UserId]): Future[Map[UserId, User]] =</dt><dd><dl>
<dt>Stitch.run(</dt><dd><dl>
<dt>Stitch</dt><dd><dl>
<dt>.traverse(userIds) { userId =&gt;</dt><dd><dl class="simple">
<dt>userRepo(UserKey(userId), userQueryOptions).map {</dt><dd><p>case Some(u) =&gt; Some(userId -&gt; u)
case None =&gt; deleteTweetsUserNotFound.incr(); None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.map(_.flatten.toMap)</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
<dt>private[this] def getTweet(tweetId: TweetId): Future[Tweet] =</dt><dd><p>Stitch.run(tweetRepo(tweetId, WritePathQueryOptions.deleteTweetsWithoutEditControl))</p>
</dd>
<dt>private[this] def getSingleDeletedTweet(</dt><dd><p>id: TweetId,
isCascadedEditTweetDeletion: Boolean = false</p>
</dd>
<dt>): Stitch[Option[TweetData]] = {</dt><dd><dl class="simple">
<dt>val opts = if (isCascadedEditTweetDeletion) {</dt><dd><p>// Disable edit control hydration if this is cascade delete of edits.
// When edit control is hydrated, the tweet will actually be considered already deleted.
WritePathQueryOptions.deleteTweetsWithoutEditControl</p>
</dd>
<dt>} else {</dt><dd><p>WritePathQueryOptions.deleteTweets</p>
</dd>
</dl>
<p>}
tweetResultRepo(id, opts)</p>
<blockquote>
<div><p>.map(_.value)
.liftToOption {</p>
<blockquote>
<div><p>// We treat the request the same whether the tweet never
// existed or is in one of the already-deleted states by
// just filtering out those tweets. Any tweets that we
// return should be deleted. If the tweet has been
// bounce-deleted, we never want to soft-delete it, and
// vice versa.
case NotFound | FilteredState.Unavailable.TweetDeleted |</p>
<blockquote>
<div><blockquote>
<div><p>FilteredState.Unavailable.BounceDeleted =&gt;</p>
</div></blockquote>
<p>true</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private[this] def getTweetsForDeleteTweets(</dt><dd><p>ids: Seq[TweetId],
isCascadedEditTweetDeletion: Boolean</p>
</dd>
<dt>): Future[Map[TweetId, TweetData]] =</dt><dd><dl>
<dt>Stitch</dt><dd><dl>
<dt>.run {</dt><dd><dl>
<dt>Stitch.traverse(ids) { id =&gt;</dt><dd><dl>
<dt>getSingleDeletedTweet(id, isCascadedEditTweetDeletion)</dt><dd><dl>
<dt>.map {</dt><dd><p>// When deleting a tweet that has been edited, we want to instead delete the initial version.
// Because the initial tweet will be hydrated in every request, if it is deleted, later
// revisions will be hidden, and cleaned up asynchronously by TP Daemons</p>
<p>// However, we don’t need to do a second lookup if it’s already the original tweet
// or if we’re doing a cascading edit tweet delete (deleting the entire tweet history)
case Some(tweetData)</p>
<blockquote>
<div><blockquote>
<div><dl class="simple">
<dt>if EditControlUtil.isInitialTweet(tweetData.tweet) ||</dt><dd><p>isCascadedEditTweetDeletion =&gt;</p>
</dd>
</dl>
</div></blockquote>
<p>Stitch.value(Some(tweetData))</p>
</div></blockquote>
<dl class="simple">
<dt>case Some(tweetData) =&gt;</dt><dd><p>getSingleDeletedTweet(EditControlUtil.getInitialTweetId(tweetData.tweet))</p>
</dd>
<dt>case None =&gt;</dt><dd><p>Stitch.value(None)</p>
</dd>
</dl>
<p>// We need to preserve the input tweetId, and the initial TweetData</p>
</dd>
</dl>
<p>}.flatten.map(tweetData =&gt; (id, tweetData))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.map(_.collect { case (tweetId, Some(tweetData)) =&gt; (tweetId, tweetData) }.toMap)</p>
</dd>
</dl>
</dd>
<dt>private[this] def getStratoBounceStatuses(</dt><dd><p>ids: Seq[Long],
isUserErasure: Boolean,
isCascadedEditedTweetDeletion: Boolean</p>
</dd>
<dt>): Future[Map[TweetId, Boolean]] = {</dt><dd><p>// Don’t load bounce label for user erasure tweet deletion.
// User Erasure deletions cause unnecessary spikes of traffic
// to Strato when we read the bounce label that we don’t use.</p>
<p>// We also want to always delete a bounced tweet if the rest of the
// edit chain is being deleted in a cascaded edit tweet delete
if (isUserErasure || isCascadedEditedTweetDeletion) {</p>
<blockquote>
<div><p>Future.value(ids.map(id =&gt; id -&gt; false).toMap)</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><dl>
<dt>Stitch.run(</dt><dd><dl>
<dt>Stitch</dt><dd><dl>
<dt>.traverse(ids) { id =&gt;</dt><dd><dl class="simple">
<dt>stratoSafetyLabelsRepo(id, SafetyLabelType.Bounce).map { label =&gt;</dt><dd><p>id -&gt; label.isDefined</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.map(_.toMap)</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>/** A suspended/deactivated user can’t delete tweets <a href="#id11"><span class="problematic" id="id12">*</span></a>/
private[this] def userNotSuspendedOrDeactivated(user: User): Try[User] =</p>
<blockquote>
<div><dl>
<dt>user.safety match {</dt><dd><p>case None =&gt; Throw(UpstreamFailure.UserSafetyEmptyException)
case Some(safety) if safety.deactivated =&gt;</p>
<blockquote>
<div><dl>
<dt>Throw(</dt><dd><dl class="simple">
<dt>AccessDenied(</dt><dd><p>s”User deactivated userId: ${user.id}”,
errorCause = Some(AccessDeniedCause.UserDeactivated)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>case Some(safety) if safety.suspended =&gt;</dt><dd><dl>
<dt>Throw(</dt><dd><dl class="simple">
<dt>AccessDenied(</dt><dd><p>s”User suspended userId: ${user.id}”,
errorCause = Some(AccessDeniedCause.UserSuspended)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>case _ =&gt; Return(user)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Ensure that byUser has permission to delete tweet either by virtue of owning the tweet or being</p></li>
<li><p>an admin user.  Returns the reason as a DeleteAuthorization or else throws an Exception if not</p></li>
<li><p>authorized.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>private[this] def userAuthorizedToDeleteTweet(</dt><dd><p>byUser: User,
optAuthenticatedUserId: Option[UserId],
tweetAuthorId: UserId</p>
</dd>
</dl>
<p>): Try[DeleteAuthorization] = {</p>
<blockquote>
<div><dl class="simple">
<dt>def hasAdminPrivilege =</dt><dd><p>byUser.roles.exists(_.rights.contains(“delete_user_tweets”))</p>
</dd>
</dl>
<p>deleteTweetsAuthAttempts.incr()
if (byUser.id == tweetAuthorId) {</p>
<blockquote>
<div><p>deleteTweetsAuthSuccessByUser.incr()
optAuthenticatedUserId match {</p>
<blockquote>
<div><dl class="simple">
<dt>case Some(uid) =&gt;</dt><dd><p>Return(AuthorizedByTweetContributor(uid))</p>
</dd>
<dt>case None =&gt;</dt><dd><p>Return(AuthorizedByTweetOwner(byUser.id))</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</div></blockquote>
<dl class="simple">
<dt>} else if (optAuthenticatedUserId.isEmpty &amp;&amp; hasAdminPrivilege) { // contributor may not assume admin role</dt><dd><p>deleteTweetsAuthSuccessAdmin.incr()
Return(AuthorizedByAdmin(byUser.id))</p>
</dd>
<dt>} else {</dt><dd><p>deleteTweetsAuthFailures.incr()
Throw(DeleteTweetsPermissionException)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>expected user id is the id provided on the DeleteTweetsRequest that the indicates which user</p></li>
<li><p>owns the tweets they want to delete. The actualUserId is the actual userId on the tweet we are about to delete.</p></li>
<li><p>we check to ensure they are the same as a safety check against accidental deletion of tweets either from user mistakes</p></li>
<li><p>or from corrupted data (e.g bad tflock edges)</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>private[this] def expectedUserIdMatchesActualUserId(</dt><dd><p>expectedUserId: UserId,
actualUserId: UserId</p>
</dd>
<dt>): Try[Unit] =</dt><dd><dl class="simple">
<dt>if (expectedUserId == actualUserId) {</dt><dd><p>Return.Unit</p>
</dd>
<dt>} else {</dt><dd><p>userIdMismatchInTweetDelete.incr()
Throw(ExpectedUserIdMismatchException)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Validation for the normal public tweet delete case, the user must be found and must</p></li>
<li><p>not be suspended or deactivated.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>val validateTweetsForPublicDelete: ValidateDeleteTweets = FutureArrow {</dt><dd><dl>
<dt>ctx: DeleteTweetsContext =&gt;</dt><dd><dl>
<dt>Future.const(</dt><dd><p>for {</p>
<blockquote>
<div><p>// byUserId must be present
byUserId &lt;- ctx.byUserId.orThrow(</p>
<blockquote>
<div><p>ClientError(ClientErrorCause.BadRequest, “Missing byUserId”)</p>
</div></blockquote>
<p>)</p>
<p>// the byUser must be found
byUserOpt = ctx.users.get(byUserId)
byUser &lt;- byUserOpt.orThrow(</p>
<blockquote>
<div><p>ClientError(ClientErrorCause.BadRequest, s”User $byUserId not found”)</p>
</div></blockquote>
<p>)</p>
<p>_ &lt;- userNotSuspendedOrDeactivated(byUser)</p>
<dl class="simple">
<dt>_ &lt;- validateBounceConditions(</dt><dd><p>ctx.tweetIsBounced,
ctx.isBounceDelete</p>
</dd>
</dl>
<p>)</p>
<p>// if there’s a contributor, make sure the user is found and not suspended or deactivated
_ &lt;-</p>
<blockquote>
<div><dl>
<dt>ctx.authenticatedUserId</dt><dd><dl>
<dt>.map { uid =&gt;</dt><dd><dl class="simple">
<dt>ctx.users.get(uid) match {</dt><dd><dl class="simple">
<dt>case None =&gt;</dt><dd><p>Throw(ClientError(ClientErrorCause.BadRequest, s”Contributor $uid not found”))</p>
</dd>
<dt>case Some(authUser) =&gt;</dt><dd><p>userNotSuspendedOrDeactivated(authUser)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.getOrElse(Return.Unit)</p>
</dd>
</dl>
</div></blockquote>
<p>// if the expected user id is present, make sure it matches the user id on the tweet
_ &lt;-</p>
<blockquote>
<div><dl>
<dt>ctx.expectedErasureUserId</dt><dd><dl class="simple">
<dt>.map { expectedUserId =&gt;</dt><dd><p>expectedUserIdMatchesActualUserId(expectedUserId, ctx.tweetAuthorId)</p>
</dd>
</dl>
<p>}
.getOrElse(Return.Unit)</p>
</dd>
</dl>
</div></blockquote>
<p>// User must own the tweet or be an admin
deleteAuth &lt;- userAuthorizedToDeleteTweet(</p>
<blockquote>
<div><p>byUser,
ctx.authenticatedUserId,
ctx.tweetAuthorId</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>} yield deleteAuth</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def validateBounceConditions(</dt><dd><p>tweetIsBounced: Boolean,
isBounceDelete: Boolean</p>
</dd>
<dt>): Try[Unit] = {</dt><dd><dl class="simple">
<dt>if (tweetIsBounced &amp;&amp; !isBounceDelete) {</dt><dd><p>bounceDeleteFlagNotSet.incr()
Throw(ClientError(ClientErrorCause.BadRequest, “Cannot normal delete a Bounced Tweet”))</p>
</dd>
<dt>} else {</dt><dd><p>Return.Unit</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Validation for the user erasure case. User may be missing.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>val validateTweetsForUserErasureDaemon: ValidateDeleteTweets = FutureArrow {</dt><dd><dl>
<dt>ctx: DeleteTweetsContext =&gt;</dt><dd><dl>
<dt>Future</dt><dd><dl>
<dt>.const(</dt><dd><dl>
<dt>for {</dt><dd><dl>
<dt>expectedUserId &lt;- ctx.expectedErasureUserId.orThrow(</dt><dd><dl class="simple">
<dt>ClientError(</dt><dd><p>ClientErrorCause.BadRequest,
“expectedUserId is required for DeleteTweetRequests”</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
<p>// It’s critical to always check that the userId on the tweet we want to delete matches the
// userId on the erasure request. This prevents us from accidentally deleting tweets not owned by the
// erased user, even if tflock serves us bad data.
validationResult &lt;- expectedUserIdMatchesActualUserId(expectedUserId, ctx.tweetAuthorId)</p>
</dd>
</dl>
<p>} yield validationResult</p>
</dd>
</dl>
<p>)
.map(_ =&gt; AuthorizedByErasure)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Fill in missing values of AuditDeleteTweet with values from TwitterContext.</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
<dt>def enrichMissingFromTwitterContext(orig: AuditDeleteTweet): AuditDeleteTweet = {</dt><dd><p>val viewer = TwitterContext()
orig.copy(</p>
<blockquote>
<div><p>host = orig.host.orElse(viewer.flatMap(_.auditIp)),
clientApplicationId = orig.clientApplicationId.orElse(viewer.flatMap(_.clientApplicationId)),
userAgent = orig.userAgent.orElse(viewer.flatMap(_.userAgent)).map(_.take(MaxUserAgentLength))</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>core delete tweets implementation.</p></li>
<li></li>
<li><p>The [[deleteTweets]] method wraps this method and provides validation required</p></li>
<li><p>for a public endpoint.</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>override def internalDeleteTweets(</dt><dd><p>request: DeleteTweetsRequest,
byUserId: Option[UserId],
authenticatedUserId: Option[UserId],
validate: ValidateDeleteTweets,
isUnretweetEdits: Boolean = false</p>
</dd>
</dl>
<p>): Future[Seq[DeleteTweetResult]] = {</p>
<blockquote>
<div><dl class="simple">
<dt>val auditDeleteTweet =</dt><dd><p>enrichMissingFromTwitterContext(request.auditPassthrough.getOrElse(AuditDeleteTweet()))</p>
</dd>
</dl>
<p>deleteTweetsTweets.incr(request.tweetIds.size)
for {</p>
<blockquote>
<div><dl class="simple">
<dt>tweetDataMap &lt;- getTweetsForDeleteTweets(</dt><dd><p>request.tweetIds,
request.cascadedEditedTweetDeletion.getOrElse(false)</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>userIds: Seq[UserId] = (tweetDataMap.values.map { td =&gt;</dt><dd><blockquote>
<div><p>getUserId(td.tweet)</p>
</div></blockquote>
<p>} ++ byUserId ++ authenticatedUserId).toSeq.distinct</p>
</dd>
</dl>
<p>users &lt;- getUsersForDeleteTweets(userIds)</p>
<dl>
<dt>stratoBounceStatuses &lt;- getStratoBounceStatuses(</dt><dd><p>tweetDataMap.keys.toSeq,
request.isUserErasure,
request.cascadedEditedTweetDeletion.getOrElse(false))</p>
</dd>
<dt>results &lt;- Future.collect {</dt><dd><dl>
<dt>request.tweetIds.map { tweetId =&gt;</dt><dd><dl>
<dt>tweetDataMap.get(tweetId) match {</dt><dd><p>// already deleted, so nothing to do
case None =&gt;</p>
<blockquote>
<div><p>deleteTweetsTweetNotFound.incr()
Future.value(DeleteTweetResult(tweetId, TweetDeleteState.Ok))</p>
</div></blockquote>
<dl>
<dt>case Some(tweetData) =&gt;</dt><dd><p>val tweet: Tweet = tweetData.tweet
val tweetIsBounced = stratoBounceStatuses(tweetId)
val optSourceTweet: Option[Tweet] = tweetData.sourceTweetResult.map(_.value.tweet)</p>
<dl>
<dt>val validation: Future[(Boolean, DeleteAuthorization)] = for {</dt><dd><p>isLastQuoteOfQuoter &lt;- isFinalQuoteOfQuoter(tweet)
deleteAuth &lt;- validate(</p>
<blockquote>
<div><dl class="simple">
<dt>DeleteTweetsContext(</dt><dd><p>byUserId = byUserId,
authenticatedUserId = authenticatedUserId,
tweetAuthorId = getUserId(tweet),
users = users,
isUserErasure = request.isUserErasure,
expectedErasureUserId = request.expectedUserId,
tweetIsBounced = tweetIsBounced,
isBounceDelete = request.isBounceDelete</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>)
_ &lt;- optSourceTweet match {</p>
<blockquote>
<div><dl>
<dt>case Some(sourceTweet) if !isUnretweetEdits =&gt;</dt><dd><p>// If this is a retweet and this deletion was not triggered by
// unretweetEdits, unretweet edits of the source Tweet
// before deleting the retweet.
//
// deleteAuth will always contain a byUserId except for erasure deletion,
// in which case the retweets will be deleted individually.
deleteAuth.byUserId match {</p>
<blockquote>
<div><dl class="simple">
<dt>case Some(userId) =&gt;</dt><dd><p>unretweetEdits(sourceTweet.editControl, sourceTweet.id, userId)</p>
</dd>
</dl>
<p>case None =&gt; Future.Unit</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>case _ =&gt; Future.Unit</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>} yield {</dt><dd><p>(isLastQuoteOfQuoter, deleteAuth)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>validation</dt><dd><dl>
<dt>.flatMap {</dt><dd><dl>
<dt>case (isLastQuoteOfQuoter: Boolean, deleteAuth: DeleteAuthorization) =&gt;</dt><dd><dl class="simple">
<dt>val isAdminDelete = deleteAuth match {</dt><dd><p>case AuthorizedByAdmin(_) =&gt; true
case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val event =</dt><dd><dl class="simple">
<dt>DeleteTweet.Event(</dt><dd><p>tweet = tweet,
timestamp = Time.now,
user = users.get(getUserId(tweet)),
byUserId = deleteAuth.byUserId,
auditPassthrough = Some(auditDeleteTweet),
isUserErasure = request.isUserErasure,
isBounceDelete = request.isBounceDelete &amp;&amp; tweetIsBounced,
isLastQuoteOfQuoter = isLastQuoteOfQuoter,
isAdminDelete = isAdminDelete</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val numberOfEdits: Int = tweet.editControl</dt><dd><dl class="simple">
<dt>.collect {</dt><dd><dl class="simple">
<dt>case EditControl.Initial(initial) =&gt;</dt><dd><p>initial.editTweetIds.count(_ != tweet.id)</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.getOrElse(0)</p>
</dd>
</dl>
<p>cascadeEditDeletesEnqueued.incr(numberOfEdits)
tweetStore</p>
<blockquote>
<div><p>.deleteTweet(event)
.map(_ =&gt; DeleteTweetResult(tweetId, TweetDeleteState.Ok))</p>
</div></blockquote>
</dd>
</dl>
</dd>
</dl>
<p>}
.onFailure { _ =&gt;</p>
<blockquote>
<div><p>deleteTweetsFailures.incr()</p>
</div></blockquote>
<p>}
.handle {</p>
<blockquote>
<div><dl class="simple">
<dt>case ExpectedUserIdMismatchException =&gt;</dt><dd><p>DeleteTweetResult(tweetId, TweetDeleteState.ExpectedUserIdMismatch)</p>
</dd>
<dt>case DeleteTweetsPermissionException =&gt;</dt><dd><p>DeleteTweetResult(tweetId, TweetDeleteState.PermissionError)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>} yield results</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private def isFinalQuoteOfQuoter(tweet: Tweet): Future[Boolean] = {</dt><dd><dl>
<dt>tweet.quotedTweet match {</dt><dd><dl>
<dt>case Some(qt) =&gt;</dt><dd><dl class="simple">
<dt>Stitch.run {</dt><dd><dl class="simple">
<dt>lastQuoteOfQuoterRepo</dt><dd><p>.apply(qt.tweetId, getUserId(tweet))
.liftToTry
.map(_.getOrElse(false))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>case None =&gt; Future(false)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Validations for the public deleteTweets endpoint.</p></li>
<li><ul>
<li><p>ensures that the byUserId user can be found and is in the correct user state</p></li>
</ul>
</li>
<li><ul>
<li><p>ensures that the tweet is being deleted by the tweet’s owner, or by an admin</p></li>
</ul>
</li>
<li><p>If there is a validation error, a future.exception is returned</p></li>
<li></li>
<li><p>If the delete request is part of a user erasure, validations are relaxed (the User is allowed to be missing).</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
<dt>val deleteTweetsValidator: ValidateDeleteTweets =</dt><dd><dl>
<dt>FutureArrow { context =&gt;</dt><dd><dl class="simple">
<dt>if (context.isUserErasure) {</dt><dd><p>validateTweetsForUserErasureDaemon(context)</p>
</dd>
<dt>} else {</dt><dd><p>validateTweetsForPublicDelete(context)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>override def deleteTweets(</dt><dd><p>request: DeleteTweetsRequest,
isUnretweetEdits: Boolean = false,</p>
</dd>
</dl>
<p>): Future[Seq[DeleteTweetResult]] = {</p>
<blockquote>
<div><p>// For comparison testing we only want to compare the DeleteTweetsRequests that are generated
// in DeleteTweets path and not the call that comes from the Unretweet path
val context = TwitterContext()
internalDeleteTweets(</p>
<blockquote>
<div><p>request,
byUserId = request.byUserId.orElse(context.flatMap(_.userId)),
context.flatMap(_.authenticatedUserId),
deleteTweetsValidator,
isUnretweetEdits</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<p>}</p>
<p>// Cascade delete tweet is the logic for removing tweets that are detached
// from their dependency which has been deleted. They are already filtered
// out from serving, so this operation reconciles storage with the view
// presented by Tweetypie.
// This RPC call is delegated from daemons or batch jobs. Currently there
// are two use-cases when this call is issued:
// *   Deleting detached retweets after the source tweet was deleted.
//     This is done through RetweetsDeletion daemon and the
//     CleanupDetachedRetweets job.
// *   Deleting edits of an initial tweet that has been deleted.
//     This is done by CascadedEditedTweetDelete daemon.
//     Note that, when serving the original delete request for an edit,
//     the initial tweet is only deleted, which makes all edits hidden.
override def cascadedDeleteTweet(request: CascadedDeleteTweetRequest): Future[Unit] = {</p>
<blockquote>
<div><p>val contextViewer = TwitterContext()
getTweet(request.tweetId)</p>
<blockquote>
<div><dl>
<dt>.transform {</dt><dd><dl>
<dt>case Throw(</dt><dd><blockquote>
<div><p>FilteredState.Unavailable.TweetDeleted | FilteredState.Unavailable.BounceDeleted) =&gt;</p>
</div></blockquote>
<p>// The retweet or edit was already deleted via some other mechanism
Future.Unit</p>
</dd>
<dt>case Throw(NotFound) =&gt;</dt><dd><p>cascadedDeleteTweetTweetNotFound.incr()
val recentlyCreated =</p>
<blockquote>
<div><dl class="simple">
<dt>if (SnowflakeId.isSnowflakeId(request.tweetId)) {</dt><dd><p>val age = Time.now - SnowflakeId(request.tweetId).time
cascadedDeleteTweetTweetNotFoundAge.add(age.inMilliseconds)
age &lt; MaxCascadedDeleteTweetTemporaryInconsistencyAge</p>
</dd>
<dt>} else {</dt><dd><p>false</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>if (recentlyCreated) {</dt><dd><p>// Treat the NotFound as a temporary condition, most
// likely due to replication lag.
Future.exception(CascadedDeleteNotAvailable(request.tweetId))</p>
</dd>
<dt>} else {</dt><dd><p>// Treat the NotFound as a permanent inconsistenty, either
// spurious edges in tflock or invalid data in Manhattan. This
// was happening a few times an hour during the time that we
// were not treating it specially. For now, we will just log that
// it happened, but in the longer term, it would be good
// to collect this data and repair the corruption.
log.warn(</p>
<blockquote>
<div><dl class="simple">
<dt>Seq(</dt><dd><p>“cascaded_delete_tweet_old_not_found”,
request.tweetId,
request.cascadedFromTweetId</p>
</dd>
</dl>
<p>).mkString(”t”)</p>
</div></blockquote>
<p>)
Future.Done</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>// Any other FilteredStates should not be thrown because of
// the options that we used to load the tweet, so we will just
// let them bubble up as an internal server error
case Throw(other) =&gt;</p>
<blockquote>
<div><p>Future.exception(other)</p>
</div></blockquote>
<dl>
<dt>case Return(tweet) =&gt;</dt><dd><dl>
<dt>Future</dt><dd><dl class="simple">
<dt>.join(</dt><dd><p>isFinalQuoteOfQuoter(tweet),
getUser(getUserId(tweet))</p>
</dd>
</dl>
<p>)
.flatMap {</p>
<blockquote>
<div><dl>
<dt>case (isLastQuoteOfQuoter, user) =&gt;</dt><dd><dl class="simple">
<dt>if (user.isEmpty) {</dt><dd><p>cascadedDeleteTweetUserNotFound.incr()</p>
</dd>
</dl>
<p>}
val tweetSourceId = getShare(tweet).map(_.sourceStatusId)
val initialEditId = tweet.editControl.collect {</p>
<blockquote>
<div><p>case EditControl.Edit(edit) =&gt; edit.initialTweetId</p>
</div></blockquote>
<p>}
if (initialEditId.contains(request.cascadedFromTweetId)) {</p>
<blockquote>
<div><p>cascadeEditDeleteTweets.incr()</p>
</div></blockquote>
<p>}
if (tweetSourceId.contains(request.cascadedFromTweetId)</p>
<blockquote>
<div><p>|| initialEditId.contains(request.cascadedFromTweetId)) {
cascadedDeleteTweetSourceMatch.incr()
val deleteEvent =</p>
<blockquote>
<div><dl class="simple">
<dt>DeleteTweet.Event(</dt><dd><p>tweet = tweet,
timestamp = Time.now,
user = user,
byUserId = contextViewer.flatMap(_.userId),
cascadedFromTweetId = Some(request.cascadedFromTweetId),
auditPassthrough = request.auditPassthrough,
isUserErasure = false,
// cascaded deletes of retweets or edits have not been through a bouncer flow,
// so are not considered to be “bounce deleted”.
isBounceDelete = false,
isLastQuoteOfQuoter = isLastQuoteOfQuoter,
isAdminDelete = false</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>tweetStore</dt><dd><p>.deleteTweet(deleteEvent)
.onFailure { _ =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>if (initialEditId.contains(request.cascadedFromTweetId)) {</dt><dd><p>cascadeEditDeleteFailures.incr()</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>cascadedDeleteTweetSourceMismatch.incr()
log.warn(</p>
<blockquote>
<div><dl class="simple">
<dt>Seq(</dt><dd><p>“cascaded_from_tweet_id_source_mismatch”,
request.tweetId,
request.cascadedFromTweetId,
tweetSourceId.orElse(initialEditId).getOrElse(“-“)</p>
</dd>
</dl>
<p>).mkString(”t”)</p>
</div></blockquote>
<p>)
Future.Done</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}
.onFailure(_ =&gt; cascadedDeleteTweetFailures.incr())</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
<p>// Given a list of edit Tweet ids and a user id, find the retweet ids of those edit ids from the given user
private def editTweetIdRetweetsFromUser(</p>
<blockquote>
<div><p>editTweetIds: Seq[TweetId],
byUserId: UserId</p>
</div></blockquote>
<dl>
<dt>): Future[Seq[TweetId]] = {</dt><dd><dl>
<dt>if (editTweetIds.isEmpty) {</dt><dd><p>Future.value(Seq())</p>
</dd>
<dt>} else {</dt><dd><dl class="simple">
<dt>getPerspectives(</dt><dd><p>Seq(tls.PerspectiveQuery(byUserId, editTweetIds))</p>
</dd>
<dt>).map { res: Seq[PerspectiveResult] =&gt;</dt><dd><dl class="simple">
<dt>res.headOption.toSeq</dt><dd><p>.flatMap(_.perspectives.flatMap(_.retweetId))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>/* This function is called from three places -</dt><dd><ul class="simple">
<li><ol class="arabic simple">
<li><p>When Tweetypie gets a request to retweet the latest version of an edit chain, all the</p></li>
</ol>
</li>
<li><p>previous revisons should be unretweeted.</p></li>
<li><p>i.e. On Retweet of the latest tweet - unretweets all the previous revisions for this user.</p></li>
<li><ul>
<li><p>create A</p></li>
</ul>
</li>
<li><ul>
<li><p>retweet A’(retweet of A)</p></li>
</ul>
</li>
<li><ul>
<li><p>create edit B(edit of A)</p></li>
</ul>
</li>
<li><ul>
<li><p>retweet B’ =&gt; Deletes A’</p></li>
</ul>
</li>
<li></li>
<li><ol class="arabic simple" start="2">
<li><p>When Tweetypie gets an unretweet request for a source tweet that is an edit tweet, all</p></li>
</ol>
</li>
<li><p>the versions of the edit chain is retweeted.</p></li>
<li><p>i.e. On unretweet of any version in the edit chain - unretweets all the revisions for this user</p></li>
<li><ul>
<li><p>create A</p></li>
</ul>
</li>
<li><ul>
<li><p>retweet A’</p></li>
</ul>
</li>
<li><ul>
<li><p>create B</p></li>
</ul>
</li>
<li><ul>
<li><p>unretweet B =&gt; Deletes A’ (&amp; also any B’ if it existed)</p></li>
</ul>
</li>
<li></li>
<li><ol class="arabic simple" start="3">
<li><p>When Tweetypie gets a delete request for a retweet, say A1. &amp; if A happens to the source</p></li>
</ol>
</li>
<li><p>tweet for A1 &amp; if A is an edit tweet, then the entire edit chain should be unretweeted &amp; not</p></li>
<li><ol class="upperalpha simple">
<li><p>i.e. On delete of a retweet - unretweet all the revisions for this user.</p></li>
</ol>
</li>
<li><ul>
<li><p>create A</p></li>
</ul>
</li>
<li><ul>
<li><p>retweet A’</p></li>
</ul>
</li>
<li><ul>
<li><p>create B</p></li>
</ul>
</li>
<li><ul>
<li><p>delete A’ =&gt; Deletes A’ (&amp; also any B’ if it existed)</p></li>
</ul>
</li>
<li></li>
<li><p>The following function has two failure scenarios -</p></li>
<li><ol class="lowerroman simple">
<li><p>when it fails to get perspectives of any of the edit tweets.</p></li>
</ol>
</li>
<li><ol class="lowerroman simple" start="2">
<li><p>the deletion of any of the retweets of these edits fail.</p></li>
</ol>
</li>
<li></li>
<li><p>In either of this scenario, we fail the entire request &amp; the error bubbles up to the top.</p></li>
<li><p>Note: The above unretweet of edits only happens for the current user.</p></li>
<li><p>In normal circumstances, a maximum of one Tweet in the edit chain will have been retweeted,</p></li>
<li><p>but we don’t know which one it was. Additionally, there may be circumstances where</p></li>
<li><p>unretweet failed, and we end up with multiple versions retweeted. For these reasons,</p></li>
<li><p>we always unretweet all the revisions (except for <cite>excludedTweetId</cite>).</p></li>
<li><p>This is a no-op if none of these versions have been retweeted.</p></li>
<li><p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p></li>
</ul>
</dd>
<dt>override def unretweetEdits(</dt><dd><p>optEditControl: Option[EditControl],
excludedTweetId: TweetId,
byUserId: UserId</p>
</dd>
</dl>
<p>): Future[Unit] = {</p>
<blockquote>
<div><dl>
<dt>val editTweetIds: Seq[TweetId] =</dt><dd><p>EditControlUtil.getEditTweetIds(optEditControl).get().filter(_ != excludedTweetId)</p>
</dd>
<dt>(editTweetIdRetweetsFromUser(editTweetIds, byUserId).flatMap { tweetIds =&gt;</dt><dd><dl>
<dt>if (tweetIds.nonEmpty) {</dt><dd><dl class="simple">
<dt>deleteTweets(</dt><dd><p>DeleteTweetsRequest(tweetIds = tweetIds, byUserId = Some(byUserId)),
isUnretweetEdits = true</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>} else {</dt><dd><p>Future.Nil</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}).unit</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/tweetypie/server/src/main/scala/com/twitter/tweetypie/handler/TweetDeletePathHandler.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>