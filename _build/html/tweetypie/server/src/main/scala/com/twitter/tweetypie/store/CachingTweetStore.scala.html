<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie
package store</p>
<p>import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.module.scala.DefaultScalaModule
import com.twitter.scrooge.TFieldBlob
import com.twitter.servo.cache.LockingCache._
import com.twitter.servo.cache._
import com.twitter.tweetypie.additionalfields.AdditionalFields
import com.twitter.tweetypie.repository.CachedBounceDeleted.isBounceDeleted
import com.twitter.tweetypie.repository.CachedBounceDeleted.toBounceDeletedCachedTweet
import com.twitter.tweetypie.repository._
import com.twitter.tweetypie.store.TweetUpdate._
import com.twitter.tweetypie.thriftscala._
import com.twitter.util.Time
import diffshow.DiffShow</p>
<dl>
<dt>trait CachingTweetStore</dt><dd><blockquote>
<div><p>extends TweetStoreBase[CachingTweetStore]
with InsertTweet.Store
with ReplicatedInsertTweet.Store
with DeleteTweet.Store
with AsyncDeleteTweet.Store
with ReplicatedDeleteTweet.Store
with UndeleteTweet.Store
with AsyncUndeleteTweet.Store
with ReplicatedUndeleteTweet.Store
with SetAdditionalFields.Store
with ReplicatedSetAdditionalFields.Store
with DeleteAdditionalFields.Store
with AsyncDeleteAdditionalFields.Store
with ReplicatedDeleteAdditionalFields.Store
with ScrubGeo.Store
with ReplicatedScrubGeo.Store
with Takedown.Store
with ReplicatedTakedown.Store
with Flush.Store
with UpdatePossiblySensitiveTweet.Store
with AsyncUpdatePossiblySensitiveTweet.Store
with ReplicatedUpdatePossiblySensitiveTweet.Store {</p>
</div></blockquote>
<dl class="simple">
<dt>def wrap(w: TweetStore.Wrap): CachingTweetStore =</dt><dd><dl class="simple">
<dt>new TweetStoreWrapper(w, this)</dt><dd><p>with CachingTweetStore
with InsertTweet.StoreWrapper
with ReplicatedInsertTweet.StoreWrapper
with DeleteTweet.StoreWrapper
with AsyncDeleteTweet.StoreWrapper
with ReplicatedDeleteTweet.StoreWrapper
with UndeleteTweet.StoreWrapper
with AsyncUndeleteTweet.StoreWrapper
with ReplicatedUndeleteTweet.StoreWrapper
with SetAdditionalFields.StoreWrapper
with ReplicatedSetAdditionalFields.StoreWrapper
with DeleteAdditionalFields.StoreWrapper
with AsyncDeleteAdditionalFields.StoreWrapper
with ReplicatedDeleteAdditionalFields.StoreWrapper
with ScrubGeo.StoreWrapper
with ReplicatedScrubGeo.StoreWrapper
with Takedown.StoreWrapper
with ReplicatedTakedown.StoreWrapper
with Flush.StoreWrapper
with UpdatePossiblySensitiveTweet.StoreWrapper
with AsyncUpdatePossiblySensitiveTweet.StoreWrapper
with ReplicatedUpdatePossiblySensitiveTweet.StoreWrapper</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>object CachingTweetStore {</dt><dd><p>val Action: AsyncWriteAction.CacheUpdate.type = AsyncWriteAction.CacheUpdate</p>
<dl>
<dt>def apply(</dt><dd><p>tweetCache: LockingCache[TweetKey, Cached[CachedTweet]],
tweetKeyFactory: TweetKeyFactory,
stats: StatsReceiver</p>
</dd>
<dt>): CachingTweetStore = {</dt><dd><dl>
<dt>val ops =</dt><dd><dl class="simple">
<dt>new CachingTweetStoreOps(</dt><dd><p>tweetCache,
tweetKeyFactory,
stats</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>new CachingTweetStore {</dt><dd><dl class="simple">
<dt>override val insertTweet: FutureEffect[InsertTweet.Event] = {</dt><dd><dl class="simple">
<dt>FutureEffect[InsertTweet.Event](e =&gt;</dt><dd><p>ops.insertTweet(e.internalTweet, e.initialTweetUpdateRequest))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>override val replicatedInsertTweet: FutureEffect[ReplicatedInsertTweet.Event] =</dt><dd><dl class="simple">
<dt>FutureEffect[ReplicatedInsertTweet.Event](e =&gt;</dt><dd><p>ops.insertTweet(e.cachedTweet, e.initialTweetUpdateRequest))</p>
</dd>
</dl>
</dd>
<dt>override val deleteTweet: FutureEffect[DeleteTweet.Event] =</dt><dd><dl class="simple">
<dt>FutureEffect[DeleteTweet.Event](e =&gt;</dt><dd><p>ops.deleteTweet(e.tweet.id, updateOnly = true, isBounceDelete = e.isBounceDelete))</p>
</dd>
</dl>
</dd>
<dt>override val asyncDeleteTweet: FutureEffect[AsyncDeleteTweet.Event] =</dt><dd><dl class="simple">
<dt>FutureEffect[AsyncDeleteTweet.Event](e =&gt;</dt><dd><p>ops.deleteTweet(e.tweet.id, updateOnly = true, isBounceDelete = e.isBounceDelete))</p>
</dd>
</dl>
</dd>
<dt>override val retryAsyncDeleteTweet: FutureEffect[</dt><dd><p>TweetStoreRetryEvent[AsyncDeleteTweet.Event]</p>
</dd>
<dt>] =</dt><dd><p>TweetStore.retry(Action, asyncDeleteTweet)</p>
</dd>
<dt>override val replicatedDeleteTweet: FutureEffect[ReplicatedDeleteTweet.Event] =</dt><dd><dl>
<dt>FutureEffect[ReplicatedDeleteTweet.Event](e =&gt;</dt><dd><dl class="simple">
<dt>ops.deleteTweet(</dt><dd><p>tweetId = e.tweet.id,
updateOnly = e.isErasure,
isBounceDelete = e.isBounceDelete</p>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</dd>
<dt>override val undeleteTweet: FutureEffect[UndeleteTweet.Event] =</dt><dd><p>FutureEffect[UndeleteTweet.Event](e =&gt; ops.undeleteTweet(e.internalTweet))</p>
</dd>
<dt>override val asyncUndeleteTweet: FutureEffect[AsyncUndeleteTweet.Event] =</dt><dd><p>FutureEffect[AsyncUndeleteTweet.Event](e =&gt; ops.undeleteTweet(e.cachedTweet))</p>
</dd>
<dt>override val retryAsyncUndeleteTweet: FutureEffect[</dt><dd><p>TweetStoreRetryEvent[AsyncUndeleteTweet.Event]</p>
</dd>
<dt>] =</dt><dd><p>TweetStore.retry(Action, asyncUndeleteTweet)</p>
</dd>
<dt>override val replicatedUndeleteTweet: FutureEffect[ReplicatedUndeleteTweet.Event] =</dt><dd><p>FutureEffect[ReplicatedUndeleteTweet.Event](e =&gt; ops.undeleteTweet(e.cachedTweet))</p>
</dd>
<dt>override val setAdditionalFields: FutureEffect[SetAdditionalFields.Event] =</dt><dd><p>FutureEffect[SetAdditionalFields.Event](e =&gt; ops.setAdditionalFields(e.additionalFields))</p>
</dd>
<dt>override val replicatedSetAdditionalFields: FutureEffect[</dt><dd><p>ReplicatedSetAdditionalFields.Event</p>
</dd>
<dt>] =</dt><dd><dl class="simple">
<dt>FutureEffect[ReplicatedSetAdditionalFields.Event](e =&gt;</dt><dd><p>ops.setAdditionalFields(e.additionalFields))</p>
</dd>
</dl>
</dd>
<dt>override val deleteAdditionalFields: FutureEffect[DeleteAdditionalFields.Event] =</dt><dd><dl class="simple">
<dt>FutureEffect[DeleteAdditionalFields.Event](e =&gt;</dt><dd><p>ops.deleteAdditionalFields(e.tweetId, e.fieldIds))</p>
</dd>
</dl>
</dd>
<dt>override val asyncDeleteAdditionalFields: FutureEffect[AsyncDeleteAdditionalFields.Event] =</dt><dd><dl class="simple">
<dt>FutureEffect[AsyncDeleteAdditionalFields.Event](e =&gt;</dt><dd><p>ops.deleteAdditionalFields(e.tweetId, e.fieldIds))</p>
</dd>
</dl>
</dd>
<dt>override val retryAsyncDeleteAdditionalFields: FutureEffect[</dt><dd><p>TweetStoreRetryEvent[AsyncDeleteAdditionalFields.Event]</p>
</dd>
<dt>] =</dt><dd><p>TweetStore.retry(Action, asyncDeleteAdditionalFields)</p>
</dd>
<dt>override val replicatedDeleteAdditionalFields: FutureEffect[</dt><dd><p>ReplicatedDeleteAdditionalFields.Event</p>
</dd>
<dt>] =</dt><dd><dl class="simple">
<dt>FutureEffect[ReplicatedDeleteAdditionalFields.Event](e =&gt;</dt><dd><p>ops.deleteAdditionalFields(e.tweetId, e.fieldIds))</p>
</dd>
</dl>
</dd>
<dt>override val scrubGeo: FutureEffect[ScrubGeo.Event] =</dt><dd><p>FutureEffect[ScrubGeo.Event](e =&gt; ops.scrubGeo(e.tweetIds))</p>
</dd>
<dt>override val replicatedScrubGeo: FutureEffect[ReplicatedScrubGeo.Event] =</dt><dd><p>FutureEffect[ReplicatedScrubGeo.Event](e =&gt; ops.scrubGeo(e.tweetIds))</p>
</dd>
<dt>override val takedown: FutureEffect[Takedown.Event] =</dt><dd><p>FutureEffect[Takedown.Event](e =&gt; ops.takedown(e.tweet))</p>
</dd>
<dt>override val replicatedTakedown: FutureEffect[ReplicatedTakedown.Event] =</dt><dd><p>FutureEffect[ReplicatedTakedown.Event](e =&gt; ops.takedown(e.tweet))</p>
</dd>
<dt>override val flush: FutureEffect[Flush.Event] =</dt><dd><dl class="simple">
<dt>FutureEffect[Flush.Event](e =&gt; ops.flushTweets(e.tweetIds, logExisting = e.logExisting))</dt><dd><p>.onlyIf(_.flushTweets)</p>
</dd>
</dl>
</dd>
<dt>override val updatePossiblySensitiveTweet: FutureEffect[UpdatePossiblySensitiveTweet.Event] =</dt><dd><p>FutureEffect[UpdatePossiblySensitiveTweet.Event](e =&gt; ops.updatePossiblySensitive(e.tweet))</p>
</dd>
<dt>override val replicatedUpdatePossiblySensitiveTweet: FutureEffect[</dt><dd><p>ReplicatedUpdatePossiblySensitiveTweet.Event</p>
</dd>
<dt>] =</dt><dd><dl class="simple">
<dt>FutureEffect[ReplicatedUpdatePossiblySensitiveTweet.Event](e =&gt;</dt><dd><p>ops.updatePossiblySensitive(e.tweet))</p>
</dd>
</dl>
</dd>
<dt>override val asyncUpdatePossiblySensitiveTweet: FutureEffect[</dt><dd><p>AsyncUpdatePossiblySensitiveTweet.Event</p>
</dd>
<dt>] =</dt><dd><dl class="simple">
<dt>FutureEffect[AsyncUpdatePossiblySensitiveTweet.Event](e =&gt;</dt><dd><p>ops.updatePossiblySensitive(e.tweet))</p>
</dd>
</dl>
</dd>
<dt>override val retryAsyncUpdatePossiblySensitiveTweet: FutureEffect[</dt><dd><p>TweetStoreRetryEvent[AsyncUpdatePossiblySensitiveTweet.Event]</p>
</dd>
<dt>] =</dt><dd><p>TweetStore.retry(Action, asyncUpdatePossiblySensitiveTweet)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private class CachingTweetStoreOps(</dt><dd><p>tweetCache: LockingCache[TweetKey, Cached[CachedTweet]],
tweetKeyFactory: TweetKeyFactory,
stats: StatsReceiver,
evictionRetries: Int = 3) {
type CachedTweetHandler = Handler[Cached[CachedTweet]]</p>
<p>private val preferNewestPicker = new PreferNewestCached[CachedTweet]</p>
<p>private val evictionFailedCounter = stats.counter(“eviction_failures”)</p>
<p>private val cacheFlushesLog = Logger(“com.twitter.tweetypie.store.CacheFlushesLog”)</p>
<p>private[this] val mapper = new ObjectMapper().registerModule(DefaultScalaModule)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Inserts a tweet into cache, recording all compiled additional fields and all</p></li>
<li><p>included passthrough fields. Additionally if the insertion event contains</p></li>
<li><p>a ‘InitialTweetUpdateRequest` we will update the cache entry for this tweet’s</p></li>
<li><p>initialTweet.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>def insertTweet(</dt><dd><p>ct: CachedTweet,
initialTweetUpdateRequest: Option[InitialTweetUpdateRequest]</p>
</dd>
<dt>): Future[Unit] =</dt><dd><dl>
<dt>lockAndSet(</dt><dd><p>ct.tweet.id,
insertTweetHandler(ct)</p>
</dd>
<dt>).flatMap { _ =&gt;</dt><dd><dl>
<dt>initialTweetUpdateRequest match {</dt><dd><dl>
<dt>case Some(request) =&gt;</dt><dd><dl class="simple">
<dt>lockAndSet(</dt><dd><p>request.initialTweetId,
updateTweetHandler(tweet =&gt; InitialTweetUpdate.updateTweet(tweet, request))</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>case None =&gt;</dt><dd><p>Future.Unit</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Writes a <cite>deleted</cite> tombstone to cache.  If <cite>updateOnly</cite> is true, then we only</p></li>
<li><p>write the tombstone if the tweet is already in cache. If <cite>isBounceDelete</cite> we</p></li>
<li><p>write a special bounce-deleted CachedTweet record to cache.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>def deleteTweet(tweetId: TweetId, updateOnly: Boolean, isBounceDelete: Boolean): Future[Unit] = {</dt><dd><p>// We only need to store a CachedTweet value the tweet is bounce-deleted to support rendering
// timeline tombstones for tweets that violated the Twitter Rules. see go/bounced-tweet
val cachedValue = if (isBounceDelete) {</p>
<blockquote>
<div><p>found(toBounceDeletedCachedTweet(tweetId))</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>writeThroughCached[CachedTweet](None, CachedValueStatus.Deleted)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val pickerHandler =</dt><dd><dl class="simple">
<dt>if (updateOnly) {</dt><dd><p>deleteTweetUpdateOnlyHandler(cachedValue)</p>
</dd>
<dt>} else {</dt><dd><p>deleteTweetHandler(cachedValue)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>lockAndSet(tweetId, pickerHandler)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def undeleteTweet(ct: CachedTweet): Future[Unit] =</dt><dd><dl class="simple">
<dt>lockAndSet(</dt><dd><p>ct.tweet.id,
insertTweetHandler(ct)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>def setAdditionalFields(tweet: Tweet): Future[Unit] =</dt><dd><p>lockAndSet(tweet.id, setFieldsHandler(AdditionalFields.additionalFields(tweet)))</p>
</dd>
<dt>def deleteAdditionalFields(tweetId: TweetId, fieldIds: Seq[FieldId]): Future[Unit] =</dt><dd><p>lockAndSet(tweetId, deleteFieldsHandler(fieldIds))</p>
</dd>
<dt>def scrubGeo(tweetIds: Seq[TweetId]): Future[Unit] =</dt><dd><dl>
<dt>Future.join {</dt><dd><dl>
<dt>tweetIds.map { id =&gt;</dt><dd><p>// First, attempt to modify any tweets that are in cache to
// avoid having to reload the cached tweet from storage.
lockAndSet(id, scrubGeoHandler).unit.rescue {</p>
<blockquote>
<div><dl class="simple">
<dt>case _: OptimisticLockingCache.LockAndSetFailure =&gt;</dt><dd><p>// If the modification fails, then remove whatever is in
// cache. This is much more likely to succeed because it
// does not require multiple successful requests to cache.
// This will force the tweet to be loaded from storage the
// next time it is requested, and the stored tweet will have
// the geo information removed.
//
// This eviction path was added due to frequent failures of
// the in-place modification code path, causing geoscrub
// daemon tasks to fail.
evictOne(tweetKeyFactory.fromId(id), evictionRetries)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>def takedown(tweet: Tweet): Future[Unit] =</dt><dd><p>lockAndSet(tweet.id, updateCachedTweetHandler(copyTakedownFieldsForUpdate(tweet)))</p>
</dd>
<dt>def updatePossiblySensitive(tweet: Tweet): Future[Unit] =</dt><dd><p>lockAndSet(tweet.id, updateTweetHandler(copyNsfwFieldsForUpdate(tweet)))</p>
</dd>
<dt>def flushTweets(tweetIds: Seq[TweetId], logExisting: Boolean = false): Future[Unit] = {</dt><dd><p>val tweetKeys = tweetIds.map(tweetKeyFactory.fromId)</p>
<dl class="simple">
<dt>Future.when(logExisting) { logExistingValues(tweetKeys) }.ensure {</dt><dd><p>evictAll(tweetKeys)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A LockingCache.Handler that inserts a tweet into cache.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>private def insertTweetHandler(newValue: CachedTweet): Handler[Cached[CachedTweet]] =</dt><dd><p>AlwaysSetHandler(Some(writeThroughCached(Some(newValue), CachedValueStatus.Found)))</p>
</dd>
<dt>private def foundAndNotBounced(c: Cached[CachedTweet]) =</dt><dd><p>c.status == CachedValueStatus.Found &amp;&amp; !isBounceDeleted(c)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>A LockingCache.Handler that updates an existing CachedTweet in cache.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>private def updateTweetHandler(update: Tweet =&gt; Tweet): CachedTweetHandler =</dt><dd><dl>
<dt>inCache =&gt;</dt><dd><dl class="simple">
<dt>for {</dt><dd><p>cached &lt;- inCache.filter(foundAndNotBounced)
cachedTweet &lt;- cached.value
updatedTweet = update(cachedTweet.tweet)</p>
</dd>
</dl>
<p>} yield found(cachedTweet.copy(tweet = updatedTweet))</p>
</dd>
</dl>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>A LockingCache.Handler that updates an existing CachedTweet in cache.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>private def updateCachedTweetHandler(update: CachedTweet =&gt; CachedTweet): CachedTweetHandler =</dt><dd><dl>
<dt>inCache =&gt;</dt><dd><dl class="simple">
<dt>for {</dt><dd><p>cached &lt;- inCache.filter(foundAndNotBounced)
cachedTweet &lt;- cached.value
updatedCachedTweet = update(cachedTweet)</p>
</dd>
</dl>
<p>} yield found(updatedCachedTweet)</p>
</dd>
</dl>
</dd>
<dt>private def deleteTweetHandler(value: Cached[CachedTweet]): CachedTweetHandler =</dt><dd><p>PickingHandler(value, preferNewestPicker)</p>
</dd>
<dt>private def deleteTweetUpdateOnlyHandler(value: Cached[CachedTweet]): CachedTweetHandler =</dt><dd><p>UpdateOnlyPickingHandler(value, preferNewestPicker)</p>
</dd>
<dt>private def setFieldsHandler(additional: Seq[TFieldBlob]): CachedTweetHandler =</dt><dd><dl>
<dt>inCache =&gt;</dt><dd><dl class="simple">
<dt>for {</dt><dd><p>cached &lt;- inCache.filter(foundAndNotBounced)
cachedTweet &lt;- cached.value
updatedTweet = AdditionalFields.setAdditionalFields(cachedTweet.tweet, additional)
updatedCachedTweet = CachedTweet(updatedTweet)</p>
</dd>
</dl>
<p>} yield found(updatedCachedTweet)</p>
</dd>
</dl>
</dd>
<dt>private def deleteFieldsHandler(fieldIds: Seq[FieldId]): CachedTweetHandler =</dt><dd><dl>
<dt>inCache =&gt;</dt><dd><dl class="simple">
<dt>for {</dt><dd><p>cached &lt;- inCache.filter(foundAndNotBounced)
cachedTweet &lt;- cached.value
updatedTweet = AdditionalFields.unsetFields(cachedTweet.tweet, fieldIds)
scrubbedCachedTweet = cachedTweet.copy(tweet = updatedTweet)</p>
</dd>
</dl>
<p>} yield found(scrubbedCachedTweet)</p>
</dd>
</dl>
</dd>
<dt>private val scrubGeoHandler: CachedTweetHandler =</dt><dd><dl>
<dt>inCache =&gt;</dt><dd><dl class="simple">
<dt>for {</dt><dd><p>cached &lt;- inCache.filter(foundAndNotBounced)
cachedTweet &lt;- cached.value
tweet = cachedTweet.tweet
coreData &lt;- tweet.coreData if hasGeo(tweet)
scrubbedCoreData = coreData.copy(coordinates = None, placeId = None)
scrubbedTweet = tweet.copy(coreData = Some(scrubbedCoreData), place = None)
scrubbedCachedTweet = cachedTweet.copy(tweet = scrubbedTweet)</p>
</dd>
</dl>
<p>} yield found(scrubbedCachedTweet)</p>
</dd>
</dl>
</dd>
<dt>private def evictOne(key: TweetKey, tries: Int): Future[Int] =</dt><dd><dl class="simple">
<dt>tweetCache.delete(key).transform {</dt><dd><p>case Throw(_) if tries &gt; 1 =&gt; evictOne(key, tries - 1)
case Throw(_) =&gt; Future.value(1)
case Return(_) =&gt; Future.value(0)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>private def evictAll(keys: Seq[TweetKey]): Future[Unit] =</dt><dd><dl>
<dt>Future</dt><dd><dl class="simple">
<dt>.collect {</dt><dd><p>keys.map(evictOne(_, evictionRetries))</p>
</dd>
</dl>
<p>}
.onSuccess { (failures: Seq[Int]) =&gt; evictionFailedCounter.incr(failures.sum) }
.unit</p>
</dd>
</dl>
</dd>
<dt>private def logExistingValues(keys: Seq[TweetKey]): Future[Unit] =</dt><dd><dl>
<dt>tweetCache</dt><dd><p>.get(keys)
.map { existing =&gt;</p>
<blockquote>
<div><dl>
<dt>for {</dt><dd><p>(key, cached) &lt;- existing.found
cachedTweet &lt;- cached.value
tweet = cachedTweet.tweet</p>
</dd>
<dt>} yield {</dt><dd><dl>
<dt>cacheFlushesLog.info(</dt><dd><dl>
<dt>mapper.writeValueAsString(</dt><dd><dl class="simple">
<dt>Map(</dt><dd><p>“key” -&gt; key,
“tweet_id” -&gt; tweet.id,
“tweet” -&gt; DiffShow.show(tweet)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}
.unit</p>
</dd>
</dl>
</dd>
<dt>private def found(value: CachedTweet): Cached[CachedTweet] =</dt><dd><p>writeThroughCached(Some(value), CachedValueStatus.Found)</p>
</dd>
<dt>private def writeThroughCached[V](value: Option[V], status: CachedValueStatus): Cached[V] = {</dt><dd><p>val now = Time.now
Cached(value, status, now, None, Some(now))</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>private def lockAndSet(tweetId: TweetId, handler: LockingCache.Handler[Cached[CachedTweet]]) =</dt><dd><p>tweetCache.lockAndSet(tweetKeyFactory.fromId(tweetId), handler).unit</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/tweetypie/server/src/main/scala/com/twitter/tweetypie/store/CachingTweetStore.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>