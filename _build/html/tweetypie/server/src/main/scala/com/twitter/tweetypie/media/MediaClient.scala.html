<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie
package media</p>
<p>import com.twitter.mediainfo.server.{thriftscala =&gt; mis}
import com.twitter.mediaservices.commons.mediainformation.thriftscala.UserDefinedProductMetadata
import com.twitter.mediaservices.commons.photurkey.thriftscala.PrivacyType
import com.twitter.mediaservices.commons.servercommon.thriftscala.{ServerError =&gt; CommonServerError}
import com.twitter.mediaservices.commons.thriftscala.ProductKey
import com.twitter.mediaservices.commons.thriftscala.MediaKey
import com.twitter.servo.util.FutureArrow
import com.twitter.thumbingbird.{thriftscala =&gt; ifs}
import com.twitter.tweetypie.backends.MediaInfoService
import com.twitter.tweetypie.backends.UserImageService
import com.twitter.tweetypie.core.UpstreamFailure
import com.twitter.user_image_service.{thriftscala =&gt; uis}
import com.twitter.user_image_service.thriftscala.MediaUpdateAction
import com.twitter.user_image_service.thriftscala.MediaUpdateAction.Delete
import com.twitter.user_image_service.thriftscala.MediaUpdateAction.Undelete
import java.nio.ByteBuffer
import scala.util.control.NoStackTrace</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>The MediaClient trait encapsulates the various operations we make to the different media services</p></li>
<li><p>backends.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>trait MediaClient {</dt><dd><p>import MediaClient._</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>On tweet creation, if the tweet contains media upload ids, we call this operation to process</p></li>
<li><p>that media and get back metadata about the media.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
</dl>
<p>def processMedia: ProcessMedia</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>On the read path, when hydrating a MediaEntity, we call this operation to get metadata</p></li>
<li><p>about existing media.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
</dl>
<p>def getMediaMetadata: GetMediaMetadata</p>
<p>def deleteMedia: DeleteMedia</p>
<p>def undeleteMedia: UndeleteMedia</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Request type for the MediaClient.updateMedia operation.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>private case class UpdateMediaRequest(</dt><dd><p>mediaKey: MediaKey,
action: MediaUpdateAction,
tweetId: TweetId)</p>
</dd>
<dt>case class DeleteMediaRequest(mediaKey: MediaKey, tweetId: TweetId) {</dt><dd><p>private[media] def toUpdateMediaRequest = UpdateMediaRequest(mediaKey, Delete, tweetId)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>case class UndeleteMediaRequest(mediaKey: MediaKey, tweetId: TweetId) {</dt><dd><p>private[media] def toUpdateMediaRequest = UpdateMediaRequest(mediaKey, Undelete, tweetId)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Request type for the MediaClient.processMedia operation.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>case class ProcessMediaRequest(</dt><dd><p>mediaIds: Seq[MediaId],
userId: UserId,
tweetId: TweetId,
isProtected: Boolean,
productMetadata: Option[Map[MediaId, UserDefinedProductMetadata]]) {
private[media] def toProcessTweetMediaRequest =</p>
<blockquote>
<div><p>uis.ProcessTweetMediaRequest(mediaIds, userId, tweetId)</p>
</div></blockquote>
<dl>
<dt>private[media] def toUpdateProductMetadataRequests(mediaKeys: Seq[MediaKey]) =</dt><dd><dl>
<dt>productMetadata match {</dt><dd><p>case None =&gt; Seq()
case Some(map) =&gt;</p>
<blockquote>
<div><dl>
<dt>mediaKeys.flatMap { mediaKey =&gt;</dt><dd><dl class="simple">
<dt>map.get(mediaKey.mediaId).map { metadata =&gt;</dt><dd><p>uis.UpdateProductMetadataRequest(ProductKey(tweetId.toString, mediaKey), metadata)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Request type for the MediaClient.getMediaMetdata operation.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>case class MediaMetadataRequest(</dt><dd><p>mediaKey: MediaKey,
tweetId: TweetId,
isProtected: Boolean,
extensionsArgs: Option[ByteBuffer]) {
private[media] def privacyType = MediaClient.toPrivacyType(isProtected)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>For debugging purposes, make a copy of the byte buffer at object</p></li>
<li><p>creation time, so that we can inspect the original buffer if there</p></li>
<li><p>is an error.</p></li>
<li></li>
<li><p>Once we have found the problem, this method should be removed.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>val savedExtensionArgs: Option[ByteBuffer] =</dt><dd><dl class="simple">
<dt>extensionsArgs.map { buf =&gt;</dt><dd><p>val b = buf.asReadOnlyBuffer()
val ary = new Array[Byte](b.remaining)
b.get(ary)
ByteBuffer.wrap(ary)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>private[media] def toGetTweetMediaInfoRequest =</dt><dd><dl class="simple">
<dt>mis.GetTweetMediaInfoRequest(</dt><dd><p>mediaKey = mediaKey,
tweetId = Some(tweetId),
privacyType = privacyType,
stratoExtensionsArgs = extensionsArgs</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>object MediaClient {</dt><dd><p>import MediaExceptions._</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Operation type for processing uploaded media during tweet creation.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
</dl>
<p>type ProcessMedia = FutureArrow[ProcessMediaRequest, Seq[MediaKey]]</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Operation type for deleting and undeleting tweets.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
</dl>
<p>private[media] type UpdateMedia = FutureArrow[UpdateMediaRequest, Unit]</p>
<p>type UndeleteMedia = FutureArrow[UndeleteMediaRequest, Unit]</p>
<p>type DeleteMedia = FutureArrow[DeleteMediaRequest, Unit]</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Operation type for getting media metadata for existing media during tweet reads.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
</dl>
<p>type GetMediaMetadata = FutureArrow[MediaMetadataRequest, MediaMetadata]</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Builds a UpdateMedia FutureArrow using UserImageService endpoints.</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
<dt>private[media] object UpdateMedia {</dt><dd><dl>
<dt>def apply(updateTweetMedia: UserImageService.UpdateTweetMedia): UpdateMedia =</dt><dd><dl class="simple">
<dt>FutureArrow[UpdateMediaRequest, Unit] { r =&gt;</dt><dd><p>updateTweetMedia(uis.UpdateTweetMediaRequest(r.mediaKey, r.action, Some(r.tweetId))).unit</p>
</dd>
</dl>
<p>}.translateExceptions(handleMediaExceptions)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Builds a ProcessMedia FutureArrow using UserImageService endpoints.</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
</dl>
<p>object ProcessMedia {</p>
<blockquote>
<div><dl class="simple">
<dt>def apply(</dt><dd><p>updateProductMetadata: UserImageService.UpdateProductMetadata,
processTweetMedia: UserImageService.ProcessTweetMedia</p>
</dd>
</dl>
<p>): ProcessMedia = {</p>
<blockquote>
<div><p>val updateProductMetadataSeq = updateProductMetadata.liftSeq</p>
<dl>
<dt>FutureArrow[ProcessMediaRequest, Seq[MediaKey]] { req =&gt;</dt><dd><dl class="simple">
<dt>for {</dt><dd><p>mediaKeys &lt;- processTweetMedia(req.toProcessTweetMediaRequest).map(_.mediaKeys)
_ &lt;- updateProductMetadataSeq(req.toUpdateProductMetadataRequests(mediaKeys))</p>
</dd>
<dt>} yield {</dt><dd><p>sortKeysByIds(req.mediaIds, mediaKeys)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}.translateExceptions(handleMediaExceptions)</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Sort the mediaKeys Seq based on the media id ordering specified by the</p></li>
<li><p>caller’s request mediaIds Seq.</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
<dt>private def sortKeysByIds(mediaIds: Seq[MediaId], mediaKeys: Seq[MediaKey]): Seq[MediaKey] = {</dt><dd><p>val idToKeyMap = mediaKeys.map(key =&gt; (key.mediaId, key)).toMap
mediaIds.flatMap(idToKeyMap.get)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Builds a GetMediaMetadata FutureArrow using MediaInfoService endpoints.</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
</dl>
<p>object GetMediaMetadata {</p>
<blockquote>
<div><p>private[this] val log = Logger(getClass)</p>
<dl>
<dt>def apply(getTweetMediaInfo: MediaInfoService.GetTweetMediaInfo): GetMediaMetadata =</dt><dd><dl>
<dt>FutureArrow[MediaMetadataRequest, MediaMetadata] { req =&gt;</dt><dd><dl>
<dt>getTweetMediaInfo(req.toGetTweetMediaInfoRequest).map { res =&gt;</dt><dd><dl class="simple">
<dt>MediaMetadata(</dt><dd><p>res.mediaKey,
res.assetUrlHttps,
res.sizes.toSet,
res.mediaInfo,
res.additionalMetadata.flatMap(_.productMetadata),
res.stratoExtensionsReply,
res.additionalMetadata</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}.translateExceptions(handleMediaExceptions)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
<dl>
<dt>private[media] def toPrivacyType(isProtected: Boolean): PrivacyType =</dt><dd><p>if (isProtected) PrivacyType.Protected else PrivacyType.Public</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Constructs an implementation of the MediaClient interface using backend instances.</p></li>
</ul>
<p><a href="#id29"><span class="problematic" id="id30">*</span></a>/</p>
</dd>
<dt>def fromBackends(</dt><dd><p>userImageService: UserImageService,
mediaInfoService: MediaInfoService</p>
</dd>
<dt>): MediaClient =</dt><dd><p>new MediaClient {</p>
<blockquote>
<div><dl>
<dt>val getMediaMetadata =</dt><dd><dl class="simple">
<dt>GetMediaMetadata(</dt><dd><p>getTweetMediaInfo = mediaInfoService.getTweetMediaInfo</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val processMedia =</dt><dd><dl class="simple">
<dt>ProcessMedia(</dt><dd><p>userImageService.updateProductMetadata,
userImageService.processTweetMedia</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>private val updateMedia =</dt><dd><dl class="simple">
<dt>UpdateMedia(</dt><dd><p>userImageService.updateTweetMedia</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val deleteMedia: FutureArrow[DeleteMediaRequest, Unit] =</dt><dd><p>FutureArrow[DeleteMediaRequest, Unit](r =&gt; updateMedia(r.toUpdateMediaRequest))</p>
</dd>
<dt>val undeleteMedia: FutureArrow[UndeleteMediaRequest, Unit] =</dt><dd><p>FutureArrow[UndeleteMediaRequest, Unit](r =&gt; updateMedia(r.toUpdateMediaRequest))</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Exceptions from the various media services backends that indicate bad requests (validation</p></li>
<li><p>failures) are converted to a MediaClientException.  Exceptions that indicate a server</p></li>
<li><p>error are converted to a UpstreamFailure.MediaServiceServerError.</p></li>
<li></li>
<li><p>MediaNotFound: Given media id does not exist. It could have been expired</p></li>
<li><p>BadMedia:      Given media is corrupted and can not be processed.</p></li>
<li><p>InvalidMedia:  Given media has failed to pass one or more validations (size, dimensions, type etc.)</p></li>
<li><p>BadRequest     Request is bad, but reason not available</p></li>
</ul>
<p><a href="#id31"><span class="problematic" id="id32">*</span></a>/</p>
</dd>
<dt>object MediaExceptions {</dt><dd><p>import UpstreamFailure.MediaServiceServerError</p>
<p>// Extends NoStackTrace because the circumstances in which the
// exceptions are generated don’t yield useful stack traces
// (e.g. you can’t tell from the stack trace anything about what
// backend call was being made.)
abstract class MediaClientException(message: String) extends Exception(message) with NoStackTrace</p>
<p>class MediaNotFound(message: String) extends MediaClientException(message)
class BadMedia(message: String) extends MediaClientException(message)
class InvalidMedia(message: String) extends MediaClientException(message)
class BadRequest(message: String) extends MediaClientException(message)</p>
<p>// translations from various media service errors into MediaExceptions
val handleMediaExceptions: PartialFunction[Any, Exception] = {</p>
<blockquote>
<div><dl>
<dt>case uis.BadRequest(msg, reason) =&gt;</dt><dd><dl class="simple">
<dt>reason match {</dt><dd><p>case Some(uis.BadRequestReason.MediaNotFound) =&gt; new MediaNotFound(msg)
case Some(uis.BadRequestReason.BadMedia) =&gt; new BadMedia(msg)
case Some(uis.BadRequestReason.InvalidMedia) =&gt; new InvalidMedia(msg)
case _ =&gt; new BadRequest(msg)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>case ifs.BadRequest(msg, reason) =&gt;</dt><dd><dl class="simple">
<dt>reason match {</dt><dd><p>case Some(ifs.BadRequestReason.NotFound) =&gt; new MediaNotFound(msg)
case _ =&gt; new BadRequest(msg)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>case mis.BadRequest(msg, reason) =&gt;</dt><dd><dl class="simple">
<dt>reason match {</dt><dd><p>case Some(mis.BadRequestReason.MediaNotFound) =&gt; new MediaNotFound(msg)
case _ =&gt; new BadRequest(msg)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>case ex: CommonServerError =&gt; MediaServiceServerError(ex)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/tweetypie/server/src/main/scala/com/twitter/tweetypie/media/MediaClient.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>