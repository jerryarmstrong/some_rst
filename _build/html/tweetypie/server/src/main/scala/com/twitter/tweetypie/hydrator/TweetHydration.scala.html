<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie
package hydrator</p>
<p>import com.twitter.expandodo.thriftscala.Card
import com.twitter.expandodo.thriftscala.Card2
import com.twitter.servo.cache.Cached
import com.twitter.servo.cache.CachedValueStatus
import com.twitter.servo.cache.LockingCache
import com.twitter.stitch.Stitch
import com.twitter.tweetypie.core._
import com.twitter.tweetypie.media.thriftscala.MediaRef
import com.twitter.tweetypie.repository.PastedMedia
import com.twitter.tweetypie.repository.TweetQuery
import com.twitter.tweetypie.repository.TweetRepoCachePicker
import com.twitter.tweetypie.repository.TweetResultRepository
import com.twitter.tweetypie.thriftscala._
import com.twitter.tweetypie.util.Takedowns
import com.twitter.util.Return
import com.twitter.util.Throw</p>
<p>object TweetHydration {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Wires up a set of hydrators that include those whose results are cached on the tweet,</p></li>
<li><p>and some whose results are not cached but depend upon the results of the former.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>def apply(</dt><dd><p>hydratorStats: StatsReceiver,
hydrateFeatureSwitchResults: TweetDataValueHydrator,
hydrateMentions: MentionEntitiesHydrator.Type,
hydrateLanguage: LanguageHydrator.Type,
hydrateUrls: UrlEntitiesHydrator.Type,
hydrateQuotedTweetRef: QuotedTweetRefHydrator.Type,
hydrateQuotedTweetRefUrls: QuotedTweetRefUrlsHydrator.Type,
hydrateMediaCacheable: MediaEntitiesHydrator.Cacheable.Type,
hydrateReplyScreenName: ReplyScreenNameHydrator.Type,
hydrateConvoId: ConversationIdHydrator.Type,
hydratePerspective: PerspectiveHydrator.Type,
hydrateEditPerspective: EditPerspectiveHydrator.Type,
hydrateConversationMuted: ConversationMutedHydrator.Type,
hydrateContributor: ContributorHydrator.Type,
hydrateTakedowns: TakedownHydrator.Type,
hydrateDirectedAt: DirectedAtHydrator.Type,
hydrateGeoScrub: GeoScrubHydrator.Type,
hydrateCacheableRepairs: TweetDataValueHydrator,
hydrateMediaUncacheable: MediaEntitiesHydrator.Uncacheable.Type,
hydratePostCacheRepairs: TweetDataValueHydrator,
hydrateTweetLegacyFormat: TweetDataValueHydrator,
hydrateQuoteTweetVisibility: QuoteTweetVisibilityHydrator.Type,
hydrateQuotedTweet: QuotedTweetHydrator.Type,
hydratePastedMedia: PastedMediaHydrator.Type,
hydrateMediaRefs: MediaRefsHydrator.Type,
hydrateMediaTags: MediaTagsHydrator.Type,
hydrateClassicCards: CardHydrator.Type,
hydrateCard2: Card2Hydrator.Type,
hydrateContributorVisibility: ContributorVisibilityFilter.Type,
hydrateHasMedia: HasMediaHydrator.Type,
hydrateTweetCounts: TweetCountsHydrator.Type,
hydratePreviousTweetCounts: PreviousTweetCountsHydrator.Type,
hydratePlace: PlaceHydrator.Type,
hydrateDeviceSource: DeviceSourceHydrator.Type,
hydrateProfileGeo: ProfileGeoHydrator.Type,
hydrateSourceTweet: SourceTweetHydrator.Type,
hydrateIM1837State: IM1837FilterHydrator.Type,
hydrateIM2884State: IM2884FilterHydrator.Type,
hydrateIM3433State: IM3433FilterHydrator.Type,
hydrateTweetAuthorVisibility: TweetAuthorVisibilityHydrator.Type,
hydrateReportedTweetVisibility: ReportedTweetFilter.Type,
scrubSuperfluousUrlEntities: TweetDataValueHydrator,
copyFromSourceTweet: TweetDataValueHydrator,
hydrateTweetVisibility: TweetVisibilityHydrator.Type,
hydrateEscherbirdAnnotations: EscherbirdAnnotationHydrator.Type,
hydrateScrubEngagements: ScrubEngagementHydrator.Type,
hydrateConversationControl: ConversationControlHydrator.Type,
hydrateEditControl: EditControlHydrator.Type,
hydrateUnmentionData: UnmentionDataHydrator.Type,
hydrateNoteTweetSuffix: TweetDataValueHydrator</p>
</dd>
<dt>): TweetDataValueHydrator = {</dt><dd><dl>
<dt>val scrubCachedTweet: TweetDataValueHydrator =</dt><dd><dl>
<dt>ValueHydrator</dt><dd><dl class="simple">
<dt>.fromMutation[Tweet, TweetQuery.Options](</dt><dd><p>ScrubUncacheable.tweetMutation.countMutations(hydratorStats.counter(“scrub_cached_tweet”))</p>
</dd>
</dl>
<p>)
.lensed(TweetData.Lenses.tweet)
.onlyIf((td, opts) =&gt; opts.cause.reading(td.tweet.id))</p>
</dd>
</dl>
</dd>
</dl>
<p>// We perform independent hydrations of individual bits of
// data and pack the results into tuples instead of updating
// the tweet for each one in order to avoid making lots of
// copies of the tweet.</p>
<dl>
<dt>val hydratePrimaryCacheableFields: TweetDataValueHydrator =</dt><dd><dl>
<dt>ValueHydrator[TweetData, TweetQuery.Options] { (td, opts) =&gt;</dt><dd><p>val ctx = TweetCtx.from(td, opts)
val tweet = td.tweet</p>
<dl>
<dt>val urlsMediaQuoteTweet: Stitch[</dt><dd><p>ValueState[(Seq[UrlEntity], Seq[MediaEntity], Option[QuotedTweet])]</p>
</dd>
<dt>] =</dt><dd><dl>
<dt>for {</dt><dd><p>urls &lt;- hydrateUrls(getUrls(tweet), ctx)
(media, quotedTweet) &lt;- Stitch.join(</p>
<blockquote>
<div><dl class="simple">
<dt>hydrateMediaCacheable(</dt><dd><p>getMedia(tweet),
MediaEntityHydrator.Cacheable.Ctx(urls.value, ctx)</p>
</dd>
</dl>
<p>),
for {</p>
<blockquote>
<div><dl class="simple">
<dt>qtRef &lt;- hydrateQuotedTweetRef(</dt><dd><p>tweet.quotedTweet,
QuotedTweetRefHydrator.Ctx(urls.value, ctx)</p>
</dd>
</dl>
<p>)
qtRefWithUrls &lt;- hydrateQuotedTweetRefUrls(qtRef.value, ctx)</p>
</div></blockquote>
<dl class="simple">
<dt>} yield {</dt><dd><p>ValueState(qtRefWithUrls.value, qtRef.state ++ qtRefWithUrls.state)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>} yield {</dt><dd><p>ValueState.join(urls, media, quotedTweet)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>val conversationId: Stitch[ValueState[Option[ConversationId]]] =</dt><dd><p>hydrateConvoId(getConversationId(tweet), ctx)</p>
</dd>
<dt>val mentions: Stitch[ValueState[Seq[MentionEntity]]] =</dt><dd><p>hydrateMentions(getMentions(tweet), ctx)</p>
</dd>
<dt>val replyScreenName: Stitch[ValueState[Option[Reply]]] =</dt><dd><p>hydrateReplyScreenName(getReply(tweet), ctx)</p>
</dd>
<dt>val directedAt: Stitch[ValueState[Option[DirectedAtUser]]] =</dt><dd><dl>
<dt>hydrateDirectedAt(</dt><dd><p>getDirectedAtUser(tweet),
DirectedAtHydrator.Ctx(</p>
<blockquote>
<div><p>mentions = getMentions(tweet),
metadata = tweet.directedAtUserMetadata,
underlyingTweetCtx = ctx</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val language: Stitch[ValueState[Option[Language]]] =</dt><dd><p>hydrateLanguage(tweet.language, ctx)</p>
</dd>
<dt>val contributor: Stitch[ValueState[Option[Contributor]]] =</dt><dd><p>hydrateContributor(tweet.contributor, ctx)</p>
</dd>
<dt>val geoScrub: Stitch[ValueState[(Option[GeoCoordinates], Option[PlaceId])]] =</dt><dd><dl class="simple">
<dt>hydrateGeoScrub(</dt><dd><p>(TweetLenses.geoCoordinates(tweet), TweetLenses.placeId(tweet)),
ctx</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>Stitch</dt><dd><dl class="simple">
<dt>.joinMap(</dt><dd><p>urlsMediaQuoteTweet,
conversationId,
mentions,
replyScreenName,
directedAt,
language,
contributor,
geoScrub</p>
</dd>
</dl>
<p>)(ValueState.join(_, _, _, _, _, _, _, _))
.map { values =&gt;</p>
<blockquote>
<div><dl>
<dt>if (values.state.isEmpty) {</dt><dd><p>ValueState.unmodified(td)</p>
</dd>
<dt>} else {</dt><dd><dl>
<dt>values.map {</dt><dd><dl>
<dt>case (</dt><dd><blockquote>
<div><blockquote>
<div><p>(urls, media, quotedTweet),
conversationId,
mentions,
reply,
directedAt,
language,
contributor,
coreGeo</p>
</div></blockquote>
<p>) =&gt;</p>
</div></blockquote>
<p>val (coordinates, placeId) = coreGeo
td.copy(</p>
<blockquote>
<div><dl>
<dt>tweet = tweet.copy(</dt><dd><dl>
<dt>coreData = tweet.coreData.map(</dt><dd><dl class="simple">
<dt>_.copy(</dt><dd><p>reply = reply,
conversationId = conversationId,
directedAtUser = directedAt,
coordinates = coordinates,
placeId = placeId</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>),
urls = Some(urls),
media = Some(media),
mentions = Some(mentions),
language = language,
quotedTweet = quotedTweet,
contributor = contributor</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>val assertNotScrubbed: TweetDataValueHydrator =</dt><dd><dl>
<dt>ValueHydrator.fromMutation[TweetData, TweetQuery.Options](</dt><dd><dl>
<dt>ScrubUncacheable</dt><dd><dl class="simple">
<dt>.assertNotScrubbed(</dt><dd><p>“output of the cacheable tweet hydrator should not require scrubbing”</p>
</dd>
</dl>
<p>)
.lensed(TweetData.Lenses.tweet)</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val hydrateDependentUncacheableFields: TweetDataValueHydrator =</dt><dd><dl>
<dt>ValueHydrator[TweetData, TweetQuery.Options] { (td, opts) =&gt;</dt><dd><p>val ctx = TweetCtx.from(td, opts)
val tweet = td.tweet</p>
<dl>
<dt>val quotedTweetResult: Stitch[ValueState[Option[QuotedTweetResult]]] =</dt><dd><dl>
<dt>for {</dt><dd><p>qtFilterState &lt;- hydrateQuoteTweetVisibility(None, ctx)
quotedTweet &lt;- hydrateQuotedTweet(</p>
<blockquote>
<div><p>td.quotedTweetResult,
QuotedTweetHydrator.Ctx(qtFilterState.value, ctx)</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>} yield {</dt><dd><p>ValueState.join(qtFilterState, quotedTweet).map(_._2)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>val pastedMedia: Stitch[ValueState[PastedMedia]] =</dt><dd><dl class="simple">
<dt>hydratePastedMedia(</dt><dd><p>PastedMediaHydrator.getPastedMedia(tweet),
PastedMediaHydrator.Ctx(getUrls(tweet), ctx)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val mediaTags: Stitch[ValueState[Option[TweetMediaTags]]] =</dt><dd><p>hydrateMediaTags(tweet.mediaTags, ctx)</p>
</dd>
<dt>val classicCards: Stitch[ValueState[Option[Seq[Card]]]] =</dt><dd><dl class="simple">
<dt>hydrateClassicCards(</dt><dd><p>tweet.cards,
CardHydrator.Ctx(getUrls(tweet), getMedia(tweet), ctx)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val card2: Stitch[ValueState[Option[Card2]]] =</dt><dd><dl>
<dt>hydrateCard2(</dt><dd><p>tweet.card2,
Card2Hydrator.Ctx(</p>
<blockquote>
<div><p>getUrls(tweet),
getMedia(tweet),
getCardReference(tweet),
ctx,
td.featureSwitchResults</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val contributorVisibility: Stitch[ValueState[Option[Contributor]]] =</dt><dd><p>hydrateContributorVisibility(tweet.contributor, ctx)</p>
</dd>
<dt>val takedowns: Stitch[ValueState[Option[Takedowns]]] =</dt><dd><dl class="simple">
<dt>hydrateTakedowns(</dt><dd><p>None, // None because uncacheable hydrator doesn’t depend on previous value
TakedownHydrator.Ctx(Takedowns.fromTweet(tweet), ctx)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val conversationControl: Stitch[ValueState[Option[ConversationControl]]] =</dt><dd><dl class="simple">
<dt>hydrateConversationControl(</dt><dd><p>tweet.conversationControl,
ConversationControlHydrator.Ctx(getConversationId(tweet), ctx)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>// PreviousTweetCounts and Perspective hydration depends on tweet.editControl.edit_control_initial
// having been hydrated in EditControlHydrator; thus we are chaining them together.
val editControlWithDependencies: Stitch[</p>
<blockquote>
<div><dl>
<dt>ValueState[</dt><dd><dl class="simple">
<dt>(</dt><dd><p>Option[EditControl],
Option[StatusPerspective],
Option[StatusCounts],
Option[TweetPerspective]</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>]</p>
</div></blockquote>
<dl>
<dt>] =</dt><dd><dl>
<dt>for {</dt><dd><dl>
<dt>(edit, perspective) &lt;- Stitch.join(</dt><dd><p>hydrateEditControl(tweet.editControl, ctx),
hydratePerspective(</p>
<blockquote>
<div><p>tweet.perspective,
PerspectiveHydrator.Ctx(td.featureSwitchResults, ctx))</p>
</div></blockquote>
</dd>
</dl>
<p>)
(counts, editPerspective) &lt;- Stitch.join(</p>
<blockquote>
<div><dl>
<dt>hydratePreviousTweetCounts(</dt><dd><p>tweet.previousCounts,
PreviousTweetCountsHydrator.Ctx(edit.value, td.featureSwitchResults, ctx)),</p>
</dd>
<dt>hydrateEditPerspective(</dt><dd><p>tweet.editPerspective,
EditPerspectiveHydrator</p>
<blockquote>
<div><p>.Ctx(perspective.value, edit.value, td.featureSwitchResults, ctx))</p>
</div></blockquote>
</dd>
</dl>
</div></blockquote>
<p>)</p>
</dd>
<dt>} yield {</dt><dd><p>ValueState.join(edit, perspective, counts, editPerspective)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>Stitch</dt><dd><dl class="simple">
<dt>.joinMap(</dt><dd><p>quotedTweetResult,
pastedMedia,
mediaTags,
classicCards,
card2,
contributorVisibility,
takedowns,
conversationControl,
editControlWithDependencies</p>
</dd>
</dl>
<p>)(ValueState.join(_, _, _, _, _, _, _, _, _))
.map { values =&gt;</p>
<blockquote>
<div><dl>
<dt>if (values.state.isEmpty) {</dt><dd><p>ValueState.unmodified(td)</p>
</dd>
<dt>} else {</dt><dd><dl>
<dt>values.map {</dt><dd><dl>
<dt>case (</dt><dd><blockquote>
<div><blockquote>
<div><p>quotedTweetResult,
pastedMedia,
ownedMediaTags,
cards,
card2,
contributor,
takedowns,
conversationControl,
(editControl, perspective, previousCounts, editPerspective)</p>
</div></blockquote>
<p>) =&gt;</p>
</div></blockquote>
<dl>
<dt>td.copy(</dt><dd><dl class="simple">
<dt>tweet = tweet.copy(</dt><dd><p>media = Some(pastedMedia.mediaEntities),
mediaTags = pastedMedia.mergeTweetMediaTags(ownedMediaTags),
cards = cards,
card2 = card2,
contributor = contributor,
takedownCountryCodes = takedowns.map(_.countryCodes.toSeq),
takedownReasons = takedowns.map(_.reasons.toSeq),
conversationControl = conversationControl,
editControl = editControl,
previousCounts = previousCounts,
perspective = perspective,
editPerspective = editPerspective,</p>
</dd>
</dl>
<p>),
quotedTweetResult = quotedTweetResult</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>val hydrateIndependentUncacheableFields: TweetDataEditHydrator =</dt><dd><dl>
<dt>EditHydrator[TweetData, TweetQuery.Options] { (td, opts) =&gt;</dt><dd><p>val ctx = TweetCtx.from(td, opts)
val tweet = td.tweet</p>
<p>// Group together the results of hydrators that don’t perform
// filtering, because we don’t care about the precedence of
// exceptions from these hydrators, because the exceptions all
// indicate failures, and picking any failure will be
// fine. (All of the other hydrators might throw filtering
// exceptions, so we need to make sure that we give precedence
// to their failures.)
val hydratorsWithoutFiltering =</p>
<blockquote>
<div><dl class="simple">
<dt>Stitch.joinMap(</dt><dd><p>hydrateTweetCounts(tweet.counts, TweetCountsHydrator.Ctx(td.featureSwitchResults, ctx)),
// Note: Place is cached in memcache, it is just not cached on the Tweet.
hydratePlace(tweet.place, ctx),
hydrateDeviceSource(tweet.deviceSource, ctx),
hydrateProfileGeo(tweet.profileGeoEnrichment, ctx)</p>
</dd>
</dl>
<p>)(ValueState.join(_, _, _, _))</p>
</div></blockquote>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Multiple hydrators throw visibility filtering exceptions so specify an order to achieve</p></li>
<li><p>a deterministic hydration result while ensuring that any retweet has a source tweet:</p></li>
<li><ol class="arabic simple">
<li><p>hydrateSourceTweet throws SourceTweetNotFound, this is a detached-retweet so treat</p></li>
</ol>
</li>
<li><p>the retweet hydration as if it were not found</p></li>
<li><ol class="arabic simple" start="2">
<li><p>hydrateTweetAuthorVisibility</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="3">
<li><p>hydrateSourceTweet (other than SourceTweetNotFound already handled above)</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="4">
<li><p>hydrateIM1837State</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="5">
<li><p>hydrateIM2884State</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="6">
<li><p>hydrateIM3433State</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="7">
<li><p>hydratorsWithoutFiltering miscellaneous exceptions (any visibility filtering</p></li>
</ol>
</li>
<li><p>exceptions should win over failure of a hydrator)</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>val sourceTweetAndTweetAuthorResult =</dt><dd><dl>
<dt>Stitch</dt><dd><dl>
<dt>.joinMap(</dt><dd><p>hydrateSourceTweet(td.sourceTweetResult, ctx).liftToTry,
hydrateTweetAuthorVisibility((), ctx).liftToTry,
hydrateIM1837State((), ctx).liftToTry,
hydrateIM2884State((), ctx).liftToTry,
hydrateIM3433State((), ctx).liftToTry</p>
</dd>
<dt>) {</dt><dd><dl class="simple">
<dt>case (Throw(t &#64; FilteredState.Unavailable.SourceTweetNotFound(_)), _, _, _, _) =&gt;</dt><dd><p>Throw(t)</p>
</dd>
</dl>
<p>case (_, Throw(t), _, _, _) =&gt; Throw(t) // TweetAuthorVisibility
case (Throw(t), _, _, _, _) =&gt; Throw(t) // SourceTweet
case (_, _, Throw(t), _, _) =&gt; Throw(t) // IM1837State
case (_, _, _, Throw(t), _) =&gt; Throw(t) // IM2884State
case (_, _, _, _, Throw(t)) =&gt; Throw(t) // IM3433State
case (</p>
<blockquote>
<div><blockquote>
<div><blockquote>
<div><p>Return(sourceTweetResultValue),
Return(authorVisibilityValue),
Return(im1837Value),
Return(im2884Value),
Return(im3433Value)</p>
</div></blockquote>
<p>) =&gt;</p>
</div></blockquote>
<dl>
<dt>Return(</dt><dd><dl>
<dt>ValueState</dt><dd><dl class="simple">
<dt>.join(</dt><dd><p>sourceTweetResultValue,
authorVisibilityValue,
im1837Value,
im2884Value,
im3433Value</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</div></blockquote>
</dd>
</dl>
<p>}.lowerFromTry</p>
</dd>
</dl>
</dd>
<dt>StitchExceptionPrecedence(sourceTweetAndTweetAuthorResult)</dt><dd><p>.joinWith(hydratorsWithoutFiltering)(ValueState.join(_, _))
.toStitch
.map { values =&gt;</p>
<blockquote>
<div><dl>
<dt>if (values.state.isEmpty) {</dt><dd><p>EditState.unit[TweetData]</p>
</dd>
<dt>} else {</dt><dd><dl>
<dt>EditState[TweetData] { tweetData =&gt;</dt><dd><p>val tweet = tweetData.tweet
values.map {</p>
<blockquote>
<div><dl>
<dt>case (</dt><dd><blockquote>
<div><blockquote>
<div><p>(sourceTweetResult, _, _, _, _),
(counts, place, deviceSource, profileGeo)</p>
</div></blockquote>
<p>) =&gt;</p>
</div></blockquote>
<dl>
<dt>tweetData.copy(</dt><dd><dl class="simple">
<dt>tweet = tweet.copy(</dt><dd><p>counts = counts,
place = place,
deviceSource = deviceSource,
profileGeoEnrichment = profileGeo</p>
</dd>
</dl>
<p>),
sourceTweetResult = sourceTweetResult</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
<dt>val hydrateUnmentionDataToTweetData: TweetDataValueHydrator =</dt><dd><dl>
<dt>TweetHydration.setOnTweetData(</dt><dd><p>TweetData.Lenses.tweet.andThen(TweetLenses.unmentionData),
(td: TweetData, opts: TweetQuery.Options) =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>UnmentionDataHydrator</dt><dd><p>.Ctx(getConversationId(td.tweet), getMentions(td.tweet), TweetCtx.from(td, opts)),</p>
</dd>
</dl>
</div></blockquote>
<p>hydrateUnmentionData</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val hydrateCacheableFields: TweetDataValueHydrator =</dt><dd><dl class="simple">
<dt>ValueHydrator.inSequence(</dt><dd><p>scrubCachedTweet,
hydratePrimaryCacheableFields,
// Relies on mentions being hydrated in hydratePrimaryCacheableFields
hydrateUnmentionDataToTweetData,
assertNotScrubbed,
hydrateCacheableRepairs</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>// The conversation muted hydrator needs the conversation id,
// which comes from the primary cacheable fields, and the media hydrator
// needs the cacheable media entities.
val hydrateUncacheableMedia: TweetDataValueHydrator =</p>
<blockquote>
<div><dl>
<dt>ValueHydrator[TweetData, TweetQuery.Options] { (td, opts) =&gt;</dt><dd><p>val ctx = TweetCtx.from(td, opts)
val tweet = td.tweet</p>
<dl>
<dt>val mediaCtx =</dt><dd><p>MediaEntityHydrator.Uncacheable.Ctx(td.tweet.mediaKeys, ctx)</p>
</dd>
<dt>val media: Stitch[ValueState[Option[Seq[MediaEntity]]]] =</dt><dd><p>hydrateMediaUncacheable.liftOption.apply(td.tweet.media, mediaCtx)</p>
</dd>
<dt>val conversationMuted: Stitch[ValueState[Option[Boolean]]] =</dt><dd><dl class="simple">
<dt>hydrateConversationMuted(</dt><dd><p>tweet.conversationMuted,
ConversationMutedHydrator.Ctx(getConversationId(tweet), ctx)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>// MediaRefs need to be hydrated at this phase because they rely on the media field
// on the Tweet, which can get unset by later hydrators.
val mediaRefs: Stitch[ValueState[Option[Seq[MediaRef]]]] =</p>
<blockquote>
<div><dl class="simple">
<dt>hydrateMediaRefs(</dt><dd><p>tweet.mediaRefs,
MediaRefsHydrator.Ctx(getMedia(tweet), getMediaKeys(tweet), getUrls(tweet), ctx)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>Stitch</dt><dd><dl class="simple">
<dt>.joinMap(</dt><dd><p>media,
conversationMuted,
mediaRefs</p>
</dd>
</dl>
<p>)(ValueState.join(_, _, _))
.map { values =&gt;</p>
<blockquote>
<div><dl>
<dt>if (values.state.isEmpty) {</dt><dd><p>ValueState.unmodified(td)</p>
</dd>
<dt>} else {</dt><dd><p>val tweet = td.tweet
values.map {</p>
<blockquote>
<div><dl>
<dt>case (media, conversationMuted, mediaRefs) =&gt;</dt><dd><dl>
<dt>td.copy(</dt><dd><dl class="simple">
<dt>tweet = tweet.copy(</dt><dd><p>media = media,
conversationMuted = conversationMuted,
mediaRefs = mediaRefs</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>val hydrateHasMediaToTweetData: TweetDataValueHydrator =</dt><dd><dl class="simple">
<dt>TweetHydration.setOnTweetData(</dt><dd><p>TweetData.Lenses.tweet.andThen(TweetLenses.hasMedia),
(td: TweetData, opts: TweetQuery.Options) =&gt; td.tweet,
hydrateHasMedia</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val hydrateReportedTweetVisibilityToTweetData: TweetDataValueHydrator = {</dt><dd><p>// Create a TweetDataValueHydrator that calls hydrateReportedTweetVisibility, which
// either throws a FilteredState.Unavailable or returns Unit.
ValueHydrator[TweetData, TweetQuery.Options] { (td, opts) =&gt;</p>
<blockquote>
<div><p>val ctx = ReportedTweetFilter.Ctx(td.tweet.perspective, TweetCtx.from(td, opts))
hydrateReportedTweetVisibility((), ctx).map { _ =&gt;</p>
<blockquote>
<div><p>ValueState.unmodified(td)</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val hydrateTweetVisibilityToTweetData: TweetDataValueHydrator =</dt><dd><dl>
<dt>TweetHydration.setOnTweetData(</dt><dd><p>TweetData.Lenses.suppress,
(td: TweetData, opts: TweetQuery.Options) =&gt;</p>
<blockquote>
<div><p>TweetVisibilityHydrator.Ctx(td.tweet, TweetCtx.from(td, opts)),</p>
</div></blockquote>
<p>hydrateTweetVisibility</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val hydrateEscherbirdAnnotationsToTweetAndCachedTweet: TweetDataValueHydrator =</dt><dd><dl class="simple">
<dt>TweetHydration.setOnTweetAndCachedTweet(</dt><dd><p>TweetLenses.escherbirdEntityAnnotations,
(td: TweetData, _: TweetQuery.Options) =&gt; td.tweet,
hydrateEscherbirdAnnotations</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val scrubEngagements: TweetDataValueHydrator =</dt><dd><dl class="simple">
<dt>TweetHydration.setOnTweetData(</dt><dd><p>TweetData.Lenses.tweetCounts,
(td: TweetData, _: TweetQuery.Options) =&gt; ScrubEngagementHydrator.Ctx(td.suppress),
hydrateScrubEngagements</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>This is where we wire up all the separate hydrators into a single [[TweetDataValueHydrator]].</p></li>
<li></li>
<li><p>Each hydrator here is either a [[TweetDataValueHydrator]] or a [[TweetDataEditHydrator]].</p></li>
<li><p>We use [[EditHydrator]]s for anything that needs to run in parallel ([[ValueHydrator]]s can</p></li>
<li><p>only be run in sequence).</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>ValueHydrator.inSequence(</dt><dd><p>// Hydrate FeatureSwitchResults first, so they can be used by other hydrators if needed
hydrateFeatureSwitchResults,
EditHydrator</p>
<blockquote>
<div><dl>
<dt>.inParallel(</dt><dd><dl>
<dt>ValueHydrator</dt><dd><dl>
<dt>.inSequence(</dt><dd><p>// The result of running these hydrators is saved as <cite>cacheableTweetResult</cite> and
// written back to cache via <cite>cacheChangesEffect</cite> in <cite>hydrateRepo</cite>
TweetHydration.captureCacheableTweetResult(</p>
<blockquote>
<div><p>hydrateCacheableFields</p>
</div></blockquote>
<p>),
// Uncacheable hydrators that depend only on the cacheable fields
hydrateUncacheableMedia,
// clean-up partially hydrated entities before any of the hydrators that look at
// url and media entities run, so that they never see bad entities.
hydratePostCacheRepairs,
// These hydrators are all dependent on each other and/or the previous hydrators
hydrateDependentUncacheableFields,
// Sets <cite>hasMedia</cite>. Comes after PastedMediaHydrator in order to include pasted
// pics as well as other media &amp; urls.
hydrateHasMediaToTweetData</p>
</dd>
</dl>
<p>)
.toEditHydrator,</p>
</dd>
</dl>
<p>// These hydrators do not rely on any other hydrators and so can be run in parallel
// with the above hydrators (and with each other)
hydrateIndependentUncacheableFields</p>
</dd>
</dl>
<p>)
.toValueHydrator,</p>
</div></blockquote>
<p>// Depends on reported perspectival having been hydrated in PerspectiveHydrator
hydrateReportedTweetVisibilityToTweetData,
// Remove superfluous urls entities when there is a corresponding MediaEntity for the same url
scrubSuperfluousUrlEntities,
// The copyFromSourceTweet hydrator needs to be located after the hydrators that produce the
// fields to copy. It must be located after PartialEntityCleaner (part of postCacheRepairs),
// which removes failed MediaEntities. It also depends on takedownCountryCodes having been
// hydrated in TakedownHydrator.
copyFromSourceTweet,
// depends on AdditionalFieldsHydrator and CopyFromSourceTweet to copy safety labels
hydrateTweetVisibilityToTweetData,
// for IPI’d tweets, we want to disable tweet engagement counts from being returned
// StatusCounts for replyCount, retweetCount.
// scrubEngagements hydrator must come after tweet visibility hydrator.
// tweet visibility hydrator emits the suppressed FilteredState needed for scrubbing.
scrubEngagements,
// this hydrator runs when writing the current tweet
// Escherbird comes last in order to consume a tweet that’s as close as possible
// to the tweet written to tweet_events
hydrateEscherbirdAnnotationsToTweetAndCachedTweet</p>
<blockquote>
<div><p>.onlyIf((td, opts) =&gt; opts.cause.writing(td.tweet.id)),</p>
</div></blockquote>
<p>// Add an ellipsis to the end of the text for a Tweet that has a NoteTweet associated.
// This is so that the Tweet is displayed on the home timeline with an ellipsis, letting
// the User know that there’s more to see.
hydrateNoteTweetSuffix,
/**</p>
<blockquote>
<div><ul class="simple">
<li><p>Post-cache repair of QT text and entities to support rendering on all clients</p></li>
<li><p>Moving this to end of the pipeline to avoid/minimize chance of following hydrators</p></li>
<li><p>depending on modified tweet text or entities.</p></li>
<li><p>When we start persisting shortUrl in MH - permalink won’t be empty. therefore,</p></li>
<li><p>we won’t run QuotedTweetRefHydrator and just hydrate expanded and display</p></li>
<li><p>using QuotedTweetRefUrlsHydrator. We will use hydrated permalink to repair</p></li>
<li><p>QT text and entities for non-upgraded clients in this step.</p></li>
<li><p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p></li>
</ul>
</div></blockquote>
<p>hydrateTweetLegacyFormat</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Returns a new hydrator that takes the produced result, and captures the result value</p></li>
<li><p>in the <cite>cacheableTweetResult</cite> field of the enclosed <cite>TweetData</cite>.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>def captureCacheableTweetResult(h: TweetDataValueHydrator): TweetDataValueHydrator =</dt><dd><dl>
<dt>ValueHydrator[TweetData, TweetQuery.Options] { (td, opts) =&gt;</dt><dd><dl>
<dt>h(td, opts).map { v =&gt;</dt><dd><p>// In addition to saving off a copy of ValueState, make sure that the TweetData inside
// the ValueState has its “completedHydrations” set to the ValueState.HydrationStates’s
// completedHydrations.  This is used when converting to a CachedTweet.
v.map { td =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>td.copy(</dt><dd><p>cacheableTweetResult = Some(v.map(_.addHydrated(v.state.completedHydrations)))</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Takes a ValueHydrator and a Lens and returns a <cite>TweetDataValueHydrator</cite> that does three things:</p></li>
<li></li>
<li><ol class="arabic simple">
<li><p>Runs the ValueHydrator on the lensed value</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="2">
<li><p>Saves the result back to the main tweet using the lens</p></li>
</ol>
</li>
<li><ol class="arabic simple" start="3">
<li><p>Saves the result back to the tweet in cacheableTweetResult using the lens</p></li>
</ol>
</li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>def setOnTweetAndCachedTweet[A, C](</dt><dd><p>l: Lens[Tweet, A],
mkCtx: (TweetData, TweetQuery.Options) =&gt; C,
h: ValueHydrator[A, C]</p>
</dd>
<dt>): TweetDataValueHydrator = {</dt><dd><p>// A lens that goes from TweetData -&gt; tweet -&gt; l
val tweetDataLens = TweetData.Lenses.tweet.andThen(l)</p>
<p>// A lens that goes from TweetData -&gt; cacheableTweetResult -&gt; tweet -&gt; l
val cachedTweetLens =</p>
<blockquote>
<div><dl class="simple">
<dt>TweetLenses</dt><dd><p>.requireSome(TweetData.Lenses.cacheableTweetResult)
.andThen(TweetResult.Lenses.tweet)
.andThen(l)</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>ValueHydrator[TweetData, TweetQuery.Options] { (td, opts) =&gt;</dt><dd><dl>
<dt>h.run(tweetDataLens.get(td), mkCtx(td, opts)).map { r =&gt;</dt><dd><dl class="simple">
<dt>if (r.state.isEmpty) {</dt><dd><p>ValueState.unmodified(td)</p>
</dd>
<dt>} else {</dt><dd><p>r.map { v =&gt; Lens.setAll(td, tweetDataLens -&gt; v, cachedTweetLens -&gt; v) }</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Creates a <cite>TweetDataValueHydrator</cite> that hydrates a lensed value, overwriting</p></li>
<li><p>the existing value.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>def setOnTweetData[A, C](</dt><dd><p>lens: Lens[TweetData, A],
mkCtx: (TweetData, TweetQuery.Options) =&gt; C,
h: ValueHydrator[A, C]</p>
</dd>
<dt>): TweetDataValueHydrator =</dt><dd><dl>
<dt>ValueHydrator[TweetData, TweetQuery.Options] { (td, opts) =&gt;</dt><dd><dl class="simple">
<dt>h.run(lens.get(td), mkCtx(td, opts)).map { r =&gt;</dt><dd><p>if (r.state.isEmpty) ValueState.unmodified(td) else r.map(lens.set(td, _))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Produces an [[Effect]] that can be applied to a [[TweetDataValueHydrator]] to write updated</p></li>
<li><p>values back to cache.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>def cacheChanges(</dt><dd><p>cache: LockingCache[TweetId, Cached[TweetData]],
stats: StatsReceiver</p>
</dd>
<dt>): Effect[ValueState[TweetData]] = {</dt><dd><p>val updatedCounter = stats.counter(“updated”)
val unchangedCounter = stats.counter(“unchanged”)
val picker = new TweetRepoCachePicker[TweetData](_.cachedAt)
val cacheErrorCounter = stats.counter(“cache_error”)
val missingCacheableResultCounter = stats.counter(“missing_cacheable_result”)</p>
<dl>
<dt>Effect[TweetResult] { result =&gt;</dt><dd><p>// cacheErrorEncountered will never be set on <cite>cacheableTweetResult</cite>, so we need to
// look at the outer tweet state.
val cacheErrorEncountered = result.state.cacheErrorEncountered</p>
<dl>
<dt>result.value.cacheableTweetResult match {</dt><dd><dl>
<dt>case Some(ValueState(td, state)) if state.modified &amp;&amp; !cacheErrorEncountered =&gt;</dt><dd><p>val tweetData = td.addHydrated(state.completedHydrations)
val now = Time.now
val cached = Cached(Some(tweetData), CachedValueStatus.Found, now, Some(now))
val handler = LockingCache.PickingHandler(cached, picker)</p>
<p>updatedCounter.incr()
cache.lockAndSet(tweetData.tweet.id, handler)</p>
</dd>
<dt>case Some(ValueState(_, _)) if cacheErrorEncountered =&gt;</dt><dd><p>cacheErrorCounter.incr()</p>
</dd>
<dt>case None =&gt;</dt><dd><p>missingCacheableResultCounter.incr()</p>
</dd>
<dt>case _ =&gt;</dt><dd><p>unchangedCounter.incr()</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Wraps a hydrator with a check such that it only executes the hydrator if <cite>queryFilter</cite></p></li>
<li><p>returns true for the <cite>TweetQuery.Option</cite> in the <cite>Ctx</cite> value, and the specified</p></li>
<li><p><cite>HydrationType</cite> is not already marked as having been completed in</p></li>
<li><p><cite>ctx.tweetData.completedHydrations</cite>.  If these conditions pass, and the underlying</p></li>
<li><p>hydrator is executed, and the result does not contain a field-level or total failure,</p></li>
<li><p>then the resulting <cite>HydrationState</cite> is updated to indicate that the specified</p></li>
<li><p><cite>HydrationType</cite> has been completed.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>def completeOnlyOnce[A, C &lt;: TweetCtx](</dt><dd><p>queryFilter: TweetQuery.Options =&gt; Boolean = _ =&gt; true,
hydrationType: HydrationType,
dependsOn: Set[HydrationType] = Set.empty,
hydrator: ValueHydrator[A, C]</p>
</dd>
<dt>): ValueHydrator[A, C] = {</dt><dd><p>val completedState = HydrationState.modified(hydrationType)</p>
<dl>
<dt>ValueHydrator[A, C] { (a, ctx) =&gt;</dt><dd><dl>
<dt>hydrator(a, ctx).map { res =&gt;</dt><dd><dl>
<dt>if (res.state.failedFields.isEmpty &amp;&amp;</dt><dd><p>dependsOn.forall(ctx.completedHydrations.contains)) {
// successful result!
if (!ctx.completedHydrations.contains(hydrationType)) {</p>
<blockquote>
<div><p>res.copy(state = res.state ++ completedState)</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>// forced rehydration - don’t add hydrationType or change modified flag
res</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>// hydration failed or not all dependencies satisfied so don’t mark as complete
res</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>}.onlyIf { (a, ctx) =&gt;</dt><dd><p>queryFilter(ctx.opts) &amp;&amp;
(!ctx.completedHydrations.contains(hydrationType))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Applies a <cite>TweetDataValueHydrator</cite> to a <cite>TweetRepository.Type</cite>-typed repository.</p></li>
<li><p>The incoming <cite>TweetQuery.Options</cite> are first expanded using <cite>optionsExpander</cite>, and the</p></li>
<li><p>resulting options passed to <cite>repo</cite> and <cite>hydrator</cite>.  The resulting tweet result</p></li>
<li><p>objects are passed to <cite>cacheChangesEffect</cite> for possible write-back to cache.  Finally,</p></li>
<li><p>the tweets are scrubbed according to the original input <cite>TweetQuery.Options</cite>.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>def hydrateRepo(</dt><dd><p>hydrator: TweetDataValueHydrator,
cacheChangesEffect: Effect[TweetResult],
optionsExpander: TweetQueryOptionsExpander.Type</p>
</dd>
<dt>)(</dt><dd><p>repo: TweetResultRepository.Type</p>
</dd>
<dt>): TweetResultRepository.Type =</dt><dd><dl>
<dt>(tweetId: TweetId, originalOpts: TweetQuery.Options) =&gt; {</dt><dd><p>val expandedOpts = optionsExpander(originalOpts)</p>
<dl>
<dt>for {</dt><dd><p>repoResult &lt;- repo(tweetId, expandedOpts)
hydratorResult &lt;- hydrator(repoResult.value, expandedOpts)</p>
</dd>
<dt>} yield {</dt><dd><dl class="simple">
<dt>val hydratingRepoResult =</dt><dd><p>TweetResult(hydratorResult.value, repoResult.state ++ hydratorResult.state)</p>
</dd>
<dt>if (originalOpts.cacheControl.writeToCache) {</dt><dd><p>cacheChangesEffect(hydratingRepoResult)</p>
</dd>
</dl>
<p>}</p>
<p>UnrequestedFieldScrubber(originalOpts).scrub(hydratingRepoResult)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>A trivial wrapper around a Stitch[_] to provide a <cite>joinWith</cite></p></li>
<li><p>method that lets us choose the precedence of exceptions.</p></li>
<li></li>
<li><p>This wrapper is useful for the case in which it’s important that</p></li>
<li><p>we specify which of the two exceptions wins (such as visibility</p></li>
<li><p>filtering).</p></li>
<li></li>
<li><p>Since this is an [[AnyVal]], using this is no more expensive than</p></li>
<li><p>inlining the joinWith method.</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
</dl>
<p>// exposed for testing
case class StitchExceptionPrecedence[A](toStitch: Stitch[A]) extends AnyVal {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Concurrently evaluate two Stitch[_] values. This is different</p></li>
<li><p>from Stitch.join in that any exception from the expression on</p></li>
<li><p>the left hand side will take precedence over an exception on</p></li>
<li><p>the right hand side. This means that an exception from the</p></li>
<li><p>right-hand side will not short-circuit evaluation, but an</p></li>
<li><p>exception on the left-hand side <em>will</em> short-circuit. This is</p></li>
<li><p>desirable because it allows us to return the failure with as</p></li>
<li><p>little latency as possible. (Compare to lifting <em>both</em> to Try,</p></li>
<li><p>which would force us to wait for both computations to complete</p></li>
<li><p>before returning, even if the one with the higher precedence is</p></li>
<li><p>already known to be an exception.)</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>def joinWith[B, C](rhs: Stitch[B])(f: (A, B) =&gt; C): StitchExceptionPrecedence[C] =</dt><dd><dl class="simple">
<dt>StitchExceptionPrecedence {</dt><dd><dl class="simple">
<dt>Stitch</dt><dd><p>.joinMap(toStitch, rhs.liftToTry) { (a, tryB) =&gt; tryB.map(b =&gt; f(a, b)) }
.lowerFromTry</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/tweetypie/server/src/main/scala/com/twitter/tweetypie/hydrator/TweetHydration.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>