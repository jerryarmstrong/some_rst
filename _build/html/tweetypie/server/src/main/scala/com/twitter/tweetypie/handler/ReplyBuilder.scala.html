<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie
package handler</p>
<p>import com.twitter.stitch.Stitch
import com.twitter.tweetypie.core.TweetCreateFailure
import com.twitter.tweetypie.repository._
import com.twitter.tweetypie.serverutil.ExceptionCounter
import com.twitter.tweetypie.thriftscala._
import com.twitter.tweetypie.tweettext.Offset
import com.twitter.twittertext.Extractor
import scala.annotation.tailrec
import scala.collection.JavaConverters._
import scala.collection.mutable
import scala.util.control.NoStackTrace</p>
<dl>
<dt>object ReplyBuilder {</dt><dd><p>private val extractor = new Extractor
private val InReplyToTweetNotFound =</p>
<blockquote>
<div><p>TweetCreateFailure.State(TweetCreateState.InReplyToTweetNotFound)</p>
</div></blockquote>
<dl>
<dt>case class Request(</dt><dd><p>authorId: UserId,
authorScreenName: String,
inReplyToTweetId: Option[TweetId],
tweetText: String,
prependImplicitMentions: Boolean,
enableTweetToNarrowcasting: Boolean,
excludeUserIds: Seq[UserId],
spamResult: Spam.Result,
batchMode: Option[BatchComposeMode])</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>This case class contains the fields that are shared between legacy and simplified replies.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>case class BaseResult(</dt><dd><p>reply: Reply,
conversationId: Option[ConversationId],
selfThreadMetadata: Option[SelfThreadMetadata],
community: Option[Communities] = None,
exclusiveTweetControl: Option[ExclusiveTweetControl] = None,
trustedFriendsControl: Option[TrustedFriendsControl] = None,
editControl: Option[EditControl] = None) {
// Creates a Result by providing the fields that differ between legacy and simplified replies.
def toResult(</p>
<blockquote>
<div><p>tweetText: String,
directedAtMetadata: DirectedAtUserMetadata,
visibleStart: Offset.CodePoint = Offset.CodePoint(0),</p>
</div></blockquote>
<dl>
<dt>): Result =</dt><dd><dl class="simple">
<dt>Result(</dt><dd><p>reply,
tweetText,
directedAtMetadata,
conversationId,
selfThreadMetadata,
visibleStart,
community,
exclusiveTweetControl,
trustedFriendsControl,
editControl</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>&#64;param reply              the Reply object to include in the tweet.</p></li>
<li><p>&#64;param tweetText          updated tweet text which may include prepended at-mentions, trimmed</p></li>
<li><p>&#64;param directedAtMetadata see DirectedAtHydrator for usage.</p></li>
<li><p>&#64;param conversationId     conversation id to assign to the tweet.</p></li>
<li><p>&#64;param selfThreadMetadata returns the result of <cite>SelfThreadBuilder</cite></p></li>
<li><p>&#64;param visibleStart       offset into <cite>tweetText</cite> separating hideable at-mentions from the</p></li>
<li><p>visible text.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>case class Result(</dt><dd><p>reply: Reply,
tweetText: String,
directedAtMetadata: DirectedAtUserMetadata,
conversationId: Option[ConversationId] = None,
selfThreadMetadata: Option[SelfThreadMetadata] = None,
visibleStart: Offset.CodePoint = Offset.CodePoint(0),
community: Option[Communities] = None,
exclusiveTweetControl: Option[ExclusiveTweetControl] = None,
trustedFriendsControl: Option[TrustedFriendsControl] = None,
editControl: Option[EditControl] = None) {</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>&#64;param finalText final tweet text after any server-side additions.</p></li>
<li><p>&#64;return true iff the final tweet text consists exclusively of a hidden reply mention prefix.</p></li>
<li><p>When this happens there’s no content to the reply and thus the tweet creation should</p></li>
<li><p>fail.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
</dl>
<p>def replyTextIsEmpty(finalText: String): Boolean = {</p>
<blockquote>
<div><p>// Length of the tweet text originally output via ReplyBuilder.Result before server-side
// additions (e.g. media, quoted-tweet URLs)
val origTextLength = Offset.CodePoint.length(tweetText)</p>
<p>// Length of the tweet text after server-side additions.
val finalTextLength = Offset.CodePoint.length(finalText)</p>
<p>val prefixWasEntireText = origTextLength == visibleStart
val textLenUnchanged = origTextLength == finalTextLength</p>
<p>prefixWasEntireText &amp;&amp; textLenUnchanged</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>type Type = Request =&gt; Future[Option[Result]]</p>
<p>private object InvalidUserException extends NoStackTrace</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A user ID and screen name used for building replies.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
</dl>
<p>private case class User(id: UserId, screenName: String)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Captures the in-reply-to tweet, its author, and if the user is attempting to reply to a</p></li>
<li><p>retweet, then that retweet and its author.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>private case class ReplySource(</dt><dd><p>srcTweet: Tweet,
srcUser: User,
retweet: Option[Tweet] = None,
rtUser: Option[User] = None) {
private val photoTaggedUsers: Seq[User] =</p>
<blockquote>
<div><dl class="simple">
<dt>srcTweet.mediaTags</dt><dd><p>.map(_.tagMap.values.flatten)
.getOrElse(Nil)
.map(toUser)
.toSeq</p>
</dd>
</dl>
</div></blockquote>
<dl>
<dt>private def toUser(mt: MediaTag): User =</dt><dd><dl class="simple">
<dt>mt match {</dt><dd><p>case MediaTag(_, Some(id), Some(screenName), _) =&gt; User(id, screenName)
case _ =&gt; throw InvalidUserException</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>private def toUser(e: MentionEntity): User =</dt><dd><dl class="simple">
<dt>e match {</dt><dd><p>case MentionEntity(_, _, screenName, Some(id), _, _) =&gt; User(id, screenName)
case _ =&gt; throw InvalidUserException</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>private def toUser(d: DirectedAtUser) = User(d.userId, d.screenName)</p>
<dl>
<dt>def allCardUsers(authorUser: User, cardUsersFinder: CardUsersFinder.Type): Future[Set[UserId]] =</dt><dd><dl>
<dt>Stitch.run(</dt><dd><dl>
<dt>cardUsersFinder(</dt><dd><dl class="simple">
<dt>CardUsersFinder.Request(</dt><dd><p>cardReference = getCardReference(srcTweet),
urls = getUrls(srcTweet).map(_.url),
perspectiveUserId = authorUser.id</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>def srcTweetMentionedUsers: Seq[User] = getMentions(srcTweet).map(toUser)</p>
<p>private trait ReplyType {</p>
<blockquote>
<div><p>val allExcludedUserIds: Set[UserId]</p>
<p>def directedAt: Option[User]
def requiredTextMention: Option[User]</p>
<p>def isExcluded(u: User): Boolean = allExcludedUserIds.contains(u.id)</p>
<dl>
<dt>def buildPrefix(otherMentions: Seq[User], maxImplicits: Int): String = {</dt><dd><p>val seen = new mutable.HashSet[UserId]
seen ++= allExcludedUserIds
// Never exclude the required mention
seen –= requiredTextMention.map(_.id)</p>
<dl class="simple">
<dt>(requiredTextMention.toSeq ++ otherMentions)</dt><dd><p>.filter(u =&gt; seen.add(u.id))
.take(maxImplicits.max(requiredTextMention.size))
.map(u =&gt; s”&#64;${u.screenName}”)
.mkString(” “)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private case class SelfReply(</dt><dd><p>allExcludedUserIds: Set[UserId],
enableTweetToNarrowcasting: Boolean)</p>
<blockquote>
<div><p>extends ReplyType {</p>
</div></blockquote>
<p>private def srcTweetDirectedAt: Option[User] = getDirectedAtUser(srcTweet).map(toUser)</p>
<dl class="simple">
<dt>override def directedAt: Option[User] =</dt><dd><p>if (!enableTweetToNarrowcasting) None
else Seq.concat(rtUser, srcTweetDirectedAt).find(!isExcluded(_))</p>
</dd>
<dt>override def requiredTextMention: Option[User] =</dt><dd><p>// Make sure the directedAt user is in the text to avoid confusion
directedAt</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>private case class BatchSubsequentReply(allExcludedUserIds: Set[UserId]) extends ReplyType {</p>
<blockquote>
<div><p>override def directedAt: Option[User] = None</p>
<p>override def requiredTextMention: Option[User] = None</p>
<p>override def buildPrefix(otherMentions: Seq[User], maxImplicits: Int): String = “”</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>private case class RegularReply(</dt><dd><p>allExcludedUserIds: Set[UserId],
enableTweetToNarrowcasting: Boolean)</p>
<blockquote>
<div><p>extends ReplyType {</p>
</div></blockquote>
<dl class="simple">
<dt>override def directedAt: Option[User] =</dt><dd><dl class="simple">
<dt>Some(srcUser)</dt><dd><p>.filterNot(isExcluded)
.filter(_ =&gt; enableTweetToNarrowcasting)</p>
</dd>
</dl>
</dd>
<dt>override def requiredTextMention: Option[User] =</dt><dd><p>// Include the source tweet’s author as a mention in the reply, even if the reply is not
// narrowcasted to that user.  All non-self-reply tweets require this mention.
Some(srcUser)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Computes an implicit mention prefix to add to the tweet text as well as any directed-at user.</p></li>
<li></li>
<li><p>The first implicit mention is the source-tweet’s author unless the reply is a self-reply, in</p></li>
<li><p>which case it inherits the DirectedAtUser from the source tweet, though the current author is</p></li>
<li><p>never added.  This mention, if it exists, is the only mention that may be used to direct-at a</p></li>
<li><p>user and is the user that ends up in DirectedAtUserMetadata.  If the user replied to a</p></li>
<li><p>retweet and the reply doesn’t explicitly mention the retweet author, then the retweet author</p></li>
<li><p>will be next, followed by source tweet mentions and source tweet photo-tagged users.</p></li>
<li></li>
<li><p>Users in excludedScreenNames originate from the PostTweetRequest and are filtered out of any</p></li>
<li><p>non-leading mention.</p></li>
<li></li>
<li><p>Note on maxImplicits:</p></li>
<li><p>This method returns at most ‘maxImplicits’ mentions unless ‘maxImplicits’ is 0 and a</p></li>
<li><p>directed-at mention is required, in which case it returns 1.  If this happens the reply may</p></li>
<li><p>fail downstream validation checks (e.g. TweetBuilder).  With 280 visible character limit it’s</p></li>
<li><p>theoretically possible to explicitly mention 93 users (280 / 3) but this bug shouldn’t really</p></li>
<li><p>be an issue because:</p></li>
<li><p>1.) Most replies don’t have 50 explicit mentions</p></li>
<li><p>2.) TOO-clients have switched to batchMode=Subsequent for self-replies which disable</p></li>
</ul>
<blockquote>
<div><p>source tweet’s directed-at user inheritance</p>
</div></blockquote>
<ul class="simple">
<li><p>3.) Requests rarely are rejected due to mention_limit_exceeded</p></li>
<li><p>If this becomes a problem we could reopen the mention limit discussion, specifically if the</p></li>
<li><p>backend should allow 51 while the explicit limit remains at 50.</p></li>
<li></li>
<li><p>Note on batchMode:</p></li>
<li><p>Implicit mention prefix will be empty string if batchMode is BatchSubsequent. This is to</p></li>
<li><p>support batch composer.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>def implicitMentionPrefixAndDAU(</dt><dd><p>maxImplicits: Int,
excludedUsers: Seq[User],
author: User,
enableTweetToNarrowcasting: Boolean,
batchMode: Option[BatchComposeMode]</p>
</dd>
<dt>): (String, Option[User]) = {</dt><dd><dl>
<dt>def allExcludedUserIds =</dt><dd><p>(excludedUsers ++ Seq(author)).map(_.id).toSet</p>
</dd>
<dt>val replyType =</dt><dd><dl>
<dt>if (author.id == srcUser.id) {</dt><dd><dl class="simple">
<dt>if (batchMode.contains(BatchComposeMode.BatchSubsequent)) {</dt><dd><p>BatchSubsequentReply(allExcludedUserIds)</p>
</dd>
<dt>} else {</dt><dd><p>SelfReply(allExcludedUserIds, enableTweetToNarrowcasting)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>RegularReply(allExcludedUserIds, enableTweetToNarrowcasting)</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>val prefix =</dt><dd><dl class="simple">
<dt>replyType.buildPrefix(</dt><dd><p>otherMentions = List.concat(rtUser, srcTweetMentionedUsers, photoTaggedUsers),
maxImplicits = maxImplicits</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>(prefix, replyType.directedAt)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Finds the longest possible prefix of whitespace separated &#64;-mentions, restricted to</p></li>
<li><p>&#64;-mentions that are derived from the reply chain.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>def hideablePrefix(</dt><dd><p>text: String,
cardUsers: Seq[User],
explicitMentions: Seq[Extractor.Entity]</p>
</dd>
<dt>): Offset.CodePoint = {</dt><dd><dl class="simple">
<dt>val allowedMentions =</dt><dd><dl class="simple">
<dt>(srcTweetMentionedUsers.toSet + srcUser ++ rtUser.toSet ++ photoTaggedUsers ++ cardUsers)</dt><dd><p>.map(_.screenName.toLowerCase)</p>
</dd>
</dl>
</dd>
</dl>
<p>val len = Offset.CodeUnit.length(text)</p>
<p>// To allow NO-BREAK SPACE’ (U+00A0) in the prefix need .isSpaceChar
def isWhitespace(c: Char) = c.isWhitespace || c.isSpaceChar</p>
<p>&#64;tailrec
def skipWs(offset: Offset.CodeUnit): Offset.CodeUnit =</p>
<blockquote>
<div><p>if (offset == len || !isWhitespace(text.charAt(offset.toInt))) offset
else skipWs(offset.incr)</p>
</div></blockquote>
<p>&#64;tailrec
def go(offset: Offset.CodeUnit, mentions: Stream[Extractor.Entity]): Offset.CodeUnit =</p>
<blockquote>
<div><p>if (offset == len) offset
else {</p>
<blockquote>
<div><dl>
<dt>mentions match {</dt><dd><p>// if we are at the next mention, and it is allowed, skip past and recurse
case next #:: tail if next.getStart == offset.toInt =&gt;</p>
<blockquote>
<div><p>if (!allowedMentions.contains(next.getValue.toLowerCase)) offset
else go(skipWs(Offset.CodeUnit(next.getEnd)), tail)</p>
</div></blockquote>
<p>// we found non-mention text
case _ =&gt; offset</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>go(Offset.CodeUnit(0), explicitMentions.toStream).toCodePoint(text)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def replyToUser(user: User, inReplyToStatusId: Option[TweetId] = None): Reply =</dt><dd><dl class="simple">
<dt>Reply(</dt><dd><p>inReplyToUserId = user.id,
inReplyToScreenName = Some(user.screenName),
inReplyToStatusId = inReplyToStatusId</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>A builder that generates reply from <cite>inReplyToTweetId</cite> or tweet text</p></li>
<li></li>
<li><p>There are two kinds of “reply”:</p></li>
<li><ol class="arabic simple">
<li><p>reply to tweet, which is generated from <cite>inReplyToTweetId</cite>.</p></li>
</ol>
</li>
<li></li>
<li><p>A valid reply-to-tweet satisfies the following conditions:</p></li>
<li><p>1). the tweet that is in-reply-to exists (and is visible to the user creating the tweet)</p></li>
<li><p>2). the author of the in-reply-to tweet is mentioned anywhere in the tweet, or</p></li>
<li><p>this is a tweet that is in reply to the author’s own tweet</p></li>
<li></li>
<li><ol class="arabic simple" start="2">
<li><p>reply to user, is generated when the tweet text starts with &#64;user_name.  This is only</p></li>
</ol>
</li>
<li><p>attempted if PostTweetRequest.enableTweetToNarrowcasting is true (default).</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>def apply(</dt><dd><p>userIdentityRepo: UserIdentityRepository.Type,
tweetRepo: TweetRepository.Optional,
replyCardUsersFinder: CardUsersFinder.Type,
selfThreadBuilder: SelfThreadBuilder,
relationshipRepo: RelationshipRepository.Type,
unmentionedEntitiesRepo: UnmentionedEntitiesRepository.Type,
enableRemoveUnmentionedImplicits: Gate[Unit],
stats: StatsReceiver,
maxMentions: Int</p>
</dd>
<dt>): Type = {</dt><dd><p>val exceptionCounters = ExceptionCounter(stats)
val modeScope = stats.scope(“mode”)
val compatModeCounter = modeScope.counter(“compat”)
val simpleModeCounter = modeScope.counter(“simple”)</p>
<dl>
<dt>def getUser(key: UserKey): Future[Option[User]] =</dt><dd><dl class="simple">
<dt>Stitch.run(</dt><dd><dl class="simple">
<dt>userIdentityRepo(key)</dt><dd><p>.map(ident =&gt; User(ident.id, ident.screenName))
.liftNotFoundToOption</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
<dt>def getUsers(userIds: Seq[UserId]): Future[Seq[ReplyBuilder.User]] =</dt><dd><dl class="simple">
<dt>Stitch.run(</dt><dd><dl class="simple">
<dt>Stitch</dt><dd><p>.traverse(userIds)(id =&gt; userIdentityRepo(UserKey(id)).liftNotFoundToOption)
.map(_.flatten)
.map { identities =&gt; identities.map { ident =&gt; User(ident.id, ident.screenName) } }</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val tweetQueryIncludes =</dt><dd><dl>
<dt>TweetQuery.Include(</dt><dd><dl class="simple">
<dt>tweetFields = Set(</dt><dd><p>Tweet.CoreDataField.id,
Tweet.CardReferenceField.id,
Tweet.CommunitiesField.id,
Tweet.MediaTagsField.id,
Tweet.MentionsField.id,
Tweet.UrlsField.id,
Tweet.EditControlField.id</p>
</dd>
</dl>
<p>) ++ selfThreadBuilder.requiredReplySourceFields.map(_.id)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>def tweetQueryOptions(forUserId: UserId) =</dt><dd><dl class="simple">
<dt>TweetQuery.Options(</dt><dd><p>tweetQueryIncludes,
forUserId = Some(forUserId),
enforceVisibilityFiltering = true</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>def getTweet(tweetId: TweetId, forUserId: UserId): Future[Option[Tweet]] =</dt><dd><p>Stitch.run(tweetRepo(tweetId, tweetQueryOptions(forUserId)))</p>
</dd>
<dt>def checkBlockRelationship(authorId: UserId, result: Result): Future[Unit] = {</dt><dd><dl>
<dt>val inReplyToBlocksTweeter =</dt><dd><dl class="simple">
<dt>RelationshipKey.blocks(</dt><dd><p>sourceId = result.reply.inReplyToUserId,
destinationId = authorId</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>Stitch.run(relationshipRepo(inReplyToBlocksTweeter)).flatMap {</dt><dd><p>case true =&gt; Future.exception(InReplyToTweetNotFound)
case false =&gt; Future.Unit</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def checkIPIPolicy(request: Request, reply: Reply): Future[Unit] = {</dt><dd><dl class="simple">
<dt>if (request.spamResult == Spam.DisabledByIpiPolicy) {</dt><dd><p>Future.exception(Spam.DisabledByIpiFailure(reply.inReplyToScreenName))</p>
</dd>
<dt>} else {</dt><dd><p>Future.Unit</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def getUnmentionedUsers(replySource: ReplySource): Future[Seq[UserId]] = {</dt><dd><dl>
<dt>if (enableRemoveUnmentionedImplicits()) {</dt><dd><p>val srcDirectedAt = replySource.srcTweet.directedAtUserMetadata.flatMap(_.userId)
val srcTweetMentions = replySource.srcTweet.mentions.getOrElse(Nil).flatMap(_.userId)
val idsToCheck = srcTweetMentions ++ srcDirectedAt</p>
<p>val conversationId = replySource.srcTweet.coreData.flatMap(_.conversationId)
conversationId match {</p>
<blockquote>
<div><dl>
<dt>case Some(cid) if idsToCheck.nonEmpty =&gt;</dt><dd><p>stats.counter(“unmentioned_implicits_check”).incr()
Stitch</p>
<blockquote>
<div><dl>
<dt>.run(unmentionedEntitiesRepo(cid, idsToCheck)).liftToTry.map {</dt><dd><dl class="simple">
<dt>case Return(Some(unmentionedUserIds)) =&gt;</dt><dd><p>unmentionedUserIds</p>
</dd>
</dl>
<p>case _ =&gt; Seq[UserId]()</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>case _ =&gt; Future.Nil</p>
</div></blockquote>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>Future.Nil</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Constructs a <cite>ReplySource</cite> for the given <cite>tweetId</cite>, which captures the source tweet to be</p></li>
<li><p>replied to, its author, and if <cite>tweetId</cite> is for a retweet of the source tweet, then also</p></li>
<li><p>that retweet and its author.  If the source tweet (or a retweet of it), or a corresponding</p></li>
<li><p>author, can’t be found or isn’t visible to the replier, then <cite>InReplyToTweetNotFound</cite> is</p></li>
<li><p>thrown.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>def getReplySource(tweetId: TweetId, forUserId: UserId): Future[ReplySource] =</dt><dd><dl>
<dt>for {</dt><dd><dl class="simple">
<dt>tweet &lt;- getTweet(tweetId, forUserId).flatMap {</dt><dd><p>case None =&gt; Future.exception(InReplyToTweetNotFound)
case Some(t) =&gt; Future.value(t)</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>user &lt;- getUser(UserKey(getUserId(tweet))).flatMap {</dt><dd><p>case None =&gt; Future.exception(InReplyToTweetNotFound)
case Some(u) =&gt; Future.value(u)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>res &lt;- getShare(tweet) match {</dt><dd><p>case None =&gt; Future.value(ReplySource(tweet, user))
case Some(share) =&gt;</p>
<blockquote>
<div><p>// if the user is replying to a retweet, find the retweet source tweet,
// then update with the retweet and author.
getReplySource(share.sourceStatusId, forUserId)</p>
<blockquote>
<div><p>.map(_.copy(retweet = Some(tweet), rtUser = Some(user)))</p>
</div></blockquote>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>} yield res</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Computes a <cite>Result</cite> for the reply-to-tweet case.  If <cite>inReplyToTweetId</cite> is for a retweet,</p></li>
<li><p>the reply will be computed against the source tweet.  If <cite>prependImplicitMentions</cite> is true</p></li>
<li><p>and source tweet can’t be found or isn’t visible to replier, then this method will return</p></li>
<li><p>a <cite>InReplyToTweetNotFound</cite> failure.  If <cite>prependImplicitMentions</cite> is false, then the reply</p></li>
<li><p>text must either mention the source tweet user, or it must be a reply to self; if both of</p></li>
<li><p>those conditions fail, then <cite>None</cite> is returned.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>def makeReplyToTweet(</dt><dd><p>inReplyToTweetId: TweetId,
text: String,
author: User,
prependImplicitMentions: Boolean,
enableTweetToNarrowcasting: Boolean,
excludeUserIds: Seq[UserId],
batchMode: Option[BatchComposeMode]</p>
</dd>
<dt>): Future[Option[Result]] = {</dt><dd><dl>
<dt>val explicitMentions: Seq[Extractor.Entity] =</dt><dd><p>extractor.extractMentionedScreennamesWithIndices(text).asScala.toSeq</p>
</dd>
<dt>val mentionedScreenNames =</dt><dd><p>explicitMentions.map(_.getValue.toLowerCase).toSet</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>If <cite>prependImplicitMentions</cite> is true, or the reply author is the same as the in-reply-to</p></li>
<li><p>author, then the reply text doesn’t have to mention the in-reply-to author.  Otherwise,</p></li>
<li><p>check that the text contains a mention of the reply author.</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
<dt>def isValidReplyTo(inReplyToUser: User): Boolean =</dt><dd><dl class="simple">
<dt>prependImplicitMentions ||</dt><dd><p>(inReplyToUser.id == author.id) ||
mentionedScreenNames.contains(inReplyToUser.screenName.toLowerCase)</p>
</dd>
</dl>
</dd>
<dt>getReplySource(inReplyToTweetId, author.id)</dt><dd><dl>
<dt>.flatMap { replySrc =&gt;</dt><dd><dl class="simple">
<dt>val baseResult = BaseResult(</dt><dd><p>reply = replyToUser(replySrc.srcUser, Some(replySrc.srcTweet.id)),
conversationId = getConversationId(replySrc.srcTweet),
selfThreadMetadata = selfThreadBuilder.build(author.id, replySrc.srcTweet),
community = replySrc.srcTweet.communities,
// Reply tweets retain the same exclusive
// tweet controls as the tweet being replied to.
exclusiveTweetControl = replySrc.srcTweet.exclusiveTweetControl,
trustedFriendsControl = replySrc.srcTweet.trustedFriendsControl,
editControl = replySrc.srcTweet.editControl</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>if (isValidReplyTo(replySrc.srcUser)) {</dt><dd><p>if (prependImplicitMentions) {</p>
<blockquote>
<div><p>// Simplified Replies mode - append server-side generated prefix to passed in text
simpleModeCounter.incr()
// remove the in-reply-to tweet author from the excluded users, in-reply-to tweet author will always be a directedAtUser
val filteredExcludedIds =</p>
<blockquote>
<div><p>excludeUserIds.filterNot(uid =&gt; uid == TweetLenses.userId(replySrc.srcTweet))</p>
</div></blockquote>
<dl>
<dt>for {</dt><dd><p>unmentionedUserIds &lt;- getUnmentionedUsers(replySrc)
excludedUsers &lt;- getUsers(filteredExcludedIds ++ unmentionedUserIds)
(prefix, directedAtUser) = replySrc.implicitMentionPrefixAndDAU(</p>
<blockquote>
<div><p>maxImplicits = math.max(0, maxMentions - explicitMentions.size),
excludedUsers = excludedUsers,
author = author,
enableTweetToNarrowcasting = enableTweetToNarrowcasting,
batchMode = batchMode</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>} yield {</dt><dd><p>// prefix or text (or both) can be empty strings.  Add “ “ separator and adjust
// prefix length only when both prefix and text are non-empty.
val textChunks = Seq(prefix, text).map(_.trim).filter(_.nonEmpty)
val tweetText = textChunks.mkString(” “)
val visibleStart =</p>
<blockquote>
<div><dl class="simple">
<dt>if (textChunks.size == 2) {</dt><dd><p>Offset.CodePoint.length(prefix + “ “)</p>
</dd>
<dt>} else {</dt><dd><p>Offset.CodePoint.length(prefix)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>Some(</dt><dd><dl class="simple">
<dt>baseResult.toResult(</dt><dd><p>tweetText = tweetText,
directedAtMetadata = DirectedAtUserMetadata(directedAtUser.map(_.id)),
visibleStart = visibleStart</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>} else {</dt><dd><p>// Backwards-compatibility mode - walk from beginning of text until find visibleStart
compatModeCounter.incr()
for {</p>
<blockquote>
<div><p>cardUserIds &lt;- replySrc.allCardUsers(author, replyCardUsersFinder)
cardUsers &lt;- getUsers(cardUserIds.toSeq)
optUserIdentity &lt;- extractReplyToUser(text)
directedAtUserId = optUserIdentity.map(_.id).filter(_ =&gt; enableTweetToNarrowcasting)</p>
</div></blockquote>
<dl>
<dt>} yield {</dt><dd><dl>
<dt>Some(</dt><dd><dl class="simple">
<dt>baseResult.toResult(</dt><dd><p>tweetText = text,
directedAtMetadata = DirectedAtUserMetadata(directedAtUserId),
visibleStart = replySrc.hideablePrefix(text, cardUsers, explicitMentions),</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>} else {</dt><dd><p>Future.None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.handle {</p>
<blockquote>
<div><p>// if <cite>getReplySource</cite> throws this exception, but we aren’t computing implicit
// mentions, then we fall back to the reply-to-user case instead of reply-to-tweet
case InReplyToTweetNotFound if !prependImplicitMentions =&gt; None</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def makeReplyToUser(text: String): Future[Option[Result]] =</dt><dd><dl class="simple">
<dt>extractReplyToUser(text).map(_.map { user =&gt;</dt><dd><p>Result(replyToUser(user), text, DirectedAtUserMetadata(Some(user.id)))</p>
</dd>
</dl>
<p>})</p>
</dd>
<dt>def extractReplyToUser(text: String): Future[Option[User]] =</dt><dd><dl class="simple">
<dt>Option(extractor.extractReplyScreenname(text)) match {</dt><dd><p>case None =&gt; Future.None
case Some(screenName) =&gt; getUser(UserKey(screenName))</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>FutureArrow[Request, Option[Result]] { request =&gt;</dt><dd><dl>
<dt>exceptionCounters {</dt><dd><dl>
<dt>(request.inReplyToTweetId.filter(_ &gt; 0) match {</dt><dd><dl>
<dt>case None =&gt;</dt><dd><p>Future.None</p>
</dd>
<dt>case Some(tweetId) =&gt;</dt><dd><dl class="simple">
<dt>makeReplyToTweet(</dt><dd><p>tweetId,
request.tweetText,
User(request.authorId, request.authorScreenName),
request.prependImplicitMentions,
request.enableTweetToNarrowcasting,
request.excludeUserIds,
request.batchMode</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
<dt>}).flatMap {</dt><dd><dl>
<dt>case Some(r) =&gt;</dt><dd><p>// Ensure that the author of this reply is not blocked by
// the user who they are replying to.
checkBlockRelationship(request.authorId, r)</p>
<blockquote>
<div><p>.before(checkIPIPolicy(request, r.reply))
.before(Future.value(Some(r)))</p>
</div></blockquote>
</dd>
<dt>case None if request.enableTweetToNarrowcasting =&gt;</dt><dd><p>// We don’t check the block relationship when the tweet is
// not part of a conversation (which is to say, we allow
// directed-at tweets from a blocked user.) These tweets
// will not cause notifications for the blocking user,
// despite the presence of the reply struct.
makeReplyToUser(request.tweetText)</p>
</dd>
<dt>case None =&gt;</dt><dd><p>Future.None</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/tweetypie/server/src/main/scala/com/twitter/tweetypie/handler/ReplyBuilder.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>