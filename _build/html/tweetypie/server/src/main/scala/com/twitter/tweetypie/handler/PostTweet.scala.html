<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie
package handler</p>
<p>import com.twitter.context.thriftscala.FeatureContext
import com.twitter.tweetypie.backends.LimiterService
import com.twitter.tweetypie.core._
import com.twitter.tweetypie.serverutil.ExceptionCounter
import com.twitter.tweetypie.store.InsertTweet
import com.twitter.tweetypie.thriftscala._
import com.twitter.tweetypie.util.TweetCreationLock.{Key =&gt; TweetCreationLockKey}</p>
<dl>
<dt>object PostTweet {</dt><dd><p>type Type[R] = FutureArrow[R, PostTweetResult]</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A type-class to abstract over tweet creation requests.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>trait RequestView[R] {</dt><dd><p>def isDark(req: R): Boolean
def sourceTweetId(req: R): Option[TweetId]
def options(req: R): Option[WritePathHydrationOptions]
def userId(req: R): UserId
def uniquenessId(req: R): Option[Long]
def returnSuccessOnDuplicate(req: R): Boolean
def returnDuplicateTweet(req: R): Boolean =</p>
<blockquote>
<div><p>returnSuccessOnDuplicate(req) || uniquenessId(req).nonEmpty</p>
</div></blockquote>
<p>def lockKey(req: R): TweetCreationLockKey
def geo(req: R): Option[TweetCreateGeo]
def featureContext(req: R): Option[FeatureContext]
def additionalContext(req: R): Option[collection.Map[TweetCreateContextKey, String]]
def transientContext(req: R): Option[TransientCreateContext]
def additionalFields(req: R): Option[Tweet]
def duplicateState: TweetCreateState
def scope: String
def isNullcast(req: R): Boolean
def creativesContainerId(req: R): Option[CreativesContainerId]
def noteTweetMentionedUserIds(req: R): Option[Seq[Long]]</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>An implementation of <cite>RequestView</cite> for <cite>PostTweetRequest</cite>.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>implicit object PostTweetRequestView extends RequestView[PostTweetRequest] {</dt><dd><p>def isDark(req: PostTweetRequest): Boolean = req.dark
def sourceTweetId(req: PostTweetRequest): None.type = None
def options(req: PostTweetRequest): Option[WritePathHydrationOptions] = req.hydrationOptions
def userId(req: PostTweetRequest): UserId = req.userId
def uniquenessId(req: PostTweetRequest): Option[Long] = req.uniquenessId
def returnSuccessOnDuplicate(req: PostTweetRequest) = false
def lockKey(req: PostTweetRequest): TweetCreationLockKey = TweetCreationLockKey.byRequest(req)
def geo(req: PostTweetRequest): Option[TweetCreateGeo] = req.geo
def featureContext(req: PostTweetRequest): Option[FeatureContext] = req.featureContext
def additionalContext(</p>
<blockquote>
<div><p>req: PostTweetRequest</p>
</div></blockquote>
<p>): Option[collection.Map[TweetCreateContextKey, String]] = req.additionalContext
def transientContext(req: PostTweetRequest): Option[TransientCreateContext] =</p>
<blockquote>
<div><p>req.transientContext</p>
</div></blockquote>
<p>def additionalFields(req: PostTweetRequest): Option[Tweet] = req.additionalFields
def duplicateState: TweetCreateState.Duplicate.type = TweetCreateState.Duplicate
def scope = “tweet”
def isNullcast(req: PostTweetRequest): Boolean = req.nullcast
def creativesContainerId(req: PostTweetRequest): Option[CreativesContainerId] =</p>
<blockquote>
<div><p>req.underlyingCreativesContainerId</p>
</div></blockquote>
<dl>
<dt>def noteTweetMentionedUserIds(req: PostTweetRequest): Option[Seq[Long]] =</dt><dd><dl class="simple">
<dt>req.noteTweetOptions match {</dt><dd><p>case Some(noteTweetOptions) =&gt; noteTweetOptions.mentionedUserIds
case _ =&gt; None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>An implementation of <cite>RequestView</cite> for <cite>RetweetRequest</cite>.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>implicit object RetweetRequestView extends RequestView[RetweetRequest] {</dt><dd><p>def isDark(req: RetweetRequest): Boolean = req.dark
def sourceTweetId(req: RetweetRequest): None.type = None
def options(req: RetweetRequest): Option[WritePathHydrationOptions] = req.hydrationOptions
def userId(req: RetweetRequest): UserId = req.userId
def uniquenessId(req: RetweetRequest): Option[Long] = req.uniquenessId
def returnSuccessOnDuplicate(req: RetweetRequest): Boolean = req.returnSuccessOnDuplicate
def lockKey(req: RetweetRequest): TweetCreationLockKey =</p>
<blockquote>
<div><dl class="simple">
<dt>req.uniquenessId match {</dt><dd><p>case Some(id) =&gt; TweetCreationLockKey.byUniquenessId(req.userId, id)
case None =&gt; TweetCreationLockKey.bySourceTweetId(req.userId, req.sourceStatusId)</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>def geo(req: RetweetRequest): None.type = None
def featureContext(req: RetweetRequest): Option[FeatureContext] = req.featureContext
def additionalContext(req: RetweetRequest): None.type = None
def transientContext(req: RetweetRequest): None.type = None
def additionalFields(req: RetweetRequest): Option[Tweet] = req.additionalFields
def duplicateState: TweetCreateState.AlreadyRetweeted.type = TweetCreateState.AlreadyRetweeted
def scope = “retweet”
def isNullcast(req: RetweetRequest): Boolean = req.nullcast
def creativesContainerId(req: RetweetRequest): Option[CreativesContainerId] = None
def noteTweetMentionedUserIds(req: RetweetRequest): Option[Seq[Long]] = None</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A <cite>Filter</cite> is used to decorate a <cite>FutureArrow</cite> that has a known return type</p></li>
<li><p>and an input type for which there is a <cite>RequestView</cite> type-class instance.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>trait Filter[Res] { self =&gt;</dt><dd><p>type T[Req] = FutureArrow[Req, Res]</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Wraps a base arrow with additional behavior.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
</dl>
<p>def apply[Req: RequestView](base: T[Req]): T[Req]</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Composes two filter.  The resulting filter itself composes FutureArrows.</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>def andThen(next: Filter[Res]): Filter[Res] =</dt><dd><dl class="simple">
<dt>new Filter[Res] {</dt><dd><dl class="simple">
<dt>def apply[Req: RequestView](base: T[Req]): T[Req] =</dt><dd><p>next(self(base))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>This filter attempts to prevent some race-condition related duplicate tweet creations,</p></li>
<li><p>via use of a <cite>TweetCreateLock</cite>.  When a duplicate is detected, this filter can synthesize</p></li>
<li><p>a successful <cite>PostTweetResult</cite> if applicable, or return the appropriate coded response.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>object DuplicateHandler {</dt><dd><dl>
<dt>def apply(</dt><dd><p>tweetCreationLock: TweetCreationLock,
getTweets: GetTweetsHandler.Type,
stats: StatsReceiver</p>
</dd>
<dt>): Filter[PostTweetResult] =</dt><dd><dl>
<dt>new Filter[PostTweetResult] {</dt><dd><dl>
<dt>def apply[R: RequestView](base: T[R]): T[R] = {</dt><dd><p>val view = implicitly[RequestView[R]]
val notFoundCount = stats.counter(view.scope, “not_found”)
val foundCounter = stats.counter(view.scope, “found”)</p>
<dl>
<dt>FutureArrow.rec[R, PostTweetResult] { self =&gt; req =&gt;</dt><dd><p>val duplicateKey = view.lockKey(req)</p>
<p>// attempts to find the duplicate tweet.
//
// if <cite>returnDupTweet</cite> is true and we find the tweet, then we return a
// successful <cite>PostTweetResult</cite> with that tweet.  if we don’t find the
// tweet, we throw an <cite>InternalServerError</cite>.
//
// if <cite>returnDupTweet</cite> is false and we find the tweet, then we return
// the appropriate duplicate state.  if we don’t find the tweet, then
// we unlock the duplicate key and try again.
def duplicate(tweetId: TweetId, returnDupTweet: Boolean) =</p>
<blockquote>
<div><dl>
<dt>findDuplicate(tweetId, req).flatMap {</dt><dd><dl>
<dt>case Some(postTweetResult) =&gt;</dt><dd><p>foundCounter.incr()
if (returnDupTweet) Future.value(postTweetResult)
else Future.value(PostTweetResult(state = view.duplicateState))</p>
</dd>
<dt>case None =&gt;</dt><dd><p>notFoundCount.incr()
if (returnDupTweet) {</p>
<blockquote>
<div><p>// If we failed to load the tweet, but we know that it
// should exist, then return an InternalServerError, so that
// the client treats it as a failed tweet creation req.
Future.exception(</p>
<blockquote>
<div><p>InternalServerError(“Failed to load duplicate existing tweet: “ + tweetId)</p>
</div></blockquote>
<p>)</p>
</div></blockquote>
<dl class="simple">
<dt>} else {</dt><dd><p>// Assume the lock is stale if we can’t load the tweet. It’s
// possible that the lock is not stale, but the tweet is not
// yet available, which requires that it not be present in
// cache and not yet available from the backend. This means
// that the failure mode is to allow tweeting if we can’t
// determine the state, but it should be rare that we can’t
// determine it.
tweetCreationLock.unlock(duplicateKey).before(self(req))</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>tweetCreationLock(duplicateKey, view.isDark(req), view.isNullcast(req)) {</dt><dd><p>base(req)</p>
</dd>
<dt>}.rescue {</dt><dd><dl class="simple">
<dt>case TweetCreationInProgress =&gt;</dt><dd><p>Future.value(PostTweetResult(state = TweetCreateState.Duplicate))</p>
</dd>
</dl>
<p>// if tweetCreationLock detected a duplicate, look up the duplicate
// and return the appropriate result
case DuplicateTweetCreation(tweetId) =&gt;</p>
<blockquote>
<div><p>duplicate(tweetId, view.returnDuplicateTweet(req))</p>
</div></blockquote>
<p>// it’s possible that tweetCreationLock didn’t find a duplicate for a
// retweet attempt, but <cite>RetweetBuilder</cite> did.
case TweetCreateFailure.AlreadyRetweeted(tweetId) if view.returnDuplicateTweet(req) =&gt;</p>
<blockquote>
<div><p>duplicate(tweetId, true)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private def findDuplicate[R: RequestView](</dt><dd><p>tweetId: TweetId,
req: R</p>
</dd>
<dt>): Future[Option[PostTweetResult]] = {</dt><dd><p>val view = implicitly[RequestView[R]]
val readRequest =</p>
<blockquote>
<div><dl>
<dt>GetTweetsRequest(</dt><dd><p>tweetIds = Seq(tweetId),
// Assume that the defaults are OK for all of the hydration
// options except the ones that are explicitly set in the
// req.
options = Some(</p>
<blockquote>
<div><dl class="simple">
<dt>GetTweetOptions(</dt><dd><p>forUserId = Some(view.userId(req)),
includePerspectivals = true,
includeCards = view.options(req).exists(_.includeCards),
cardsPlatformKey = view.options(req).flatMap(_.cardsPlatformKey)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>getTweets(readRequest).map {</dt><dd><dl>
<dt>case Seq(result) =&gt;</dt><dd><dl>
<dt>if (result.tweetState == StatusState.Found) {</dt><dd><p>// If the tweet was successfully found, then convert the
// read result into a successful write result.
Some(</p>
<blockquote>
<div><dl>
<dt>PostTweetResult(</dt><dd><p>TweetCreateState.Ok,
result.tweet,
// if the retweet is really old, the retweet perspective might no longer
// be available, but we want to maintain the invariant that the <cite>postRetweet</cite>
// endpoint always returns a source tweet with the correct perspective.
result.sourceTweet.map { srcTweet =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>TweetLenses.perspective</dt><dd><p>.update(_.map(_.copy(retweeted = true, retweetId = Some(tweetId))))
.apply(srcTweet)</p>
</dd>
</dl>
</div></blockquote>
<p>},
result.quotedTweet</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>)</p>
</dd>
<dt>} else {</dt><dd><p>None</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A <cite>Filter</cite> that applies rate limiting to failing requests.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>object RateLimitFailures {</dt><dd><dl>
<dt>def apply(</dt><dd><p>validateLimit: RateLimitChecker.Validate,
incrementSuccess: LimiterService.IncrementByOne,
incrementFailure: LimiterService.IncrementByOne</p>
</dd>
<dt>): Filter[TweetBuilderResult] =</dt><dd><dl>
<dt>new Filter[TweetBuilderResult] {</dt><dd><dl>
<dt>def apply[R: RequestView](base: T[R]): T[R] = {</dt><dd><p>val view = implicitly[RequestView[R]]</p>
<dl>
<dt>FutureArrow[R, TweetBuilderResult] { req =&gt;</dt><dd><p>val userId = view.userId(req)
val dark = view.isDark(req)
val contributorUserId: Option[UserId] = getContributor(userId).map(_.userId)</p>
<dl>
<dt>validateLimit((userId, dark))</dt><dd><dl>
<dt>.before {</dt><dd><dl class="simple">
<dt>base(req).onFailure { _ =&gt;</dt><dd><p>// We don’t increment the failure rate limit if the failure
// was from the failure rate limit so that the user can’t
// get in a loop where tweet creation is never attempted. We
// don’t increment it if the creation is dark because there
// is no way to perform a dark tweet creation through the
// API, so it’s most likey some kind of test traffic like
// tap-compare.
if (!dark) incrementFailure(userId, contributorUserId)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}
.onSuccess { resp =&gt;</p>
<blockquote>
<div><p>// If we return a silent failure, then we want to
// increment the rate limit as if the tweet was fully
// created, because we want it to appear that way to the
// user whose creation silently failed.
if (resp.isSilentFail) incrementSuccess(userId, contributorUserId)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A <cite>Filter</cite> for counting non-<cite>TweetCreateFailure</cite> failures.</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>object CountFailures {</dt><dd><dl>
<dt>def apply[Res](stats: StatsReceiver, scopeSuffix: String = “_builder”): Filter[Res] =</dt><dd><dl>
<dt>new Filter[Res] {</dt><dd><dl>
<dt>def apply[R: RequestView](base: T[R]): T[R] = {</dt><dd><p>val view = implicitly[RequestView[R]]
val exceptionCounter = ExceptionCounter(stats.scope(view.scope + scopeSuffix))
base.onFailure {</p>
<blockquote>
<div><p>case (_, _: TweetCreateFailure) =&gt;
case (_, ex) =&gt; exceptionCounter(ex)</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A <cite>Filter</cite> for logging failures.</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>object LogFailures extends Filter[PostTweetResult] {</dt><dd><dl class="simple">
<dt>private[this] val failedTweetCreationsLogger = Logger(</dt><dd><p>“com.twitter.tweetypie.FailedTweetCreations”</p>
</dd>
</dl>
<p>)</p>
<dl>
<dt>def apply[R: RequestView](base: T[R]): T[R] =</dt><dd><dl>
<dt>FutureArrow[R, PostTweetResult] { req =&gt;</dt><dd><dl class="simple">
<dt>base(req).onFailure {</dt><dd><p>case failure =&gt; failedTweetCreationsLogger.info(s”request: $reqnfailure: $failure”)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A <cite>Filter</cite> for converting a thrown <cite>TweetCreateFailure</cite> into a <cite>PostTweetResult</cite>.</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
<dt>object RescueTweetCreateFailure extends Filter[PostTweetResult] {</dt><dd><dl>
<dt>def apply[R: RequestView](base: T[R]): T[R] =</dt><dd><dl>
<dt>FutureArrow[R, PostTweetResult] { req =&gt;</dt><dd><dl class="simple">
<dt>base(req).rescue {</dt><dd><p>case failure: TweetCreateFailure =&gt; Future.value(failure.toPostTweetResult)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Builds a base handler for <cite>PostTweetRequest</cite> and <cite>RetweetRequest</cite>.  The handler</p></li>
<li><p>calls an underlying tweet builder, creates a <cite>InsertTweet.Event</cite>, hydrates</p></li>
<li><p>that, passes it to <cite>tweetStore</cite>, and then converts it to a <cite>PostTweetResult</cite>.</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>object Handler {</dt><dd><dl>
<dt>def apply[R: RequestView](</dt><dd><p>tweetBuilder: FutureArrow[R, TweetBuilderResult],
hydrateInsertEvent: FutureArrow[InsertTweet.Event, InsertTweet.Event],
tweetStore: InsertTweet.Store,</p>
</dd>
<dt>): Type[R] = {</dt><dd><dl>
<dt>FutureArrow { req =&gt;</dt><dd><dl class="simple">
<dt>for {</dt><dd><p>bldrRes &lt;- tweetBuilder(req)
event &lt;- hydrateInsertEvent(toInsertTweetEvent(req, bldrRes))
_ &lt;- Future.when(!event.dark)(tweetStore.insertTweet(event))</p>
</dd>
</dl>
<p>} yield toPostTweetResult(event)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Converts a request/<cite>TweetBuilderResult</cite> pair into an <cite>InsertTweet.Event</cite>.</p></li>
</ul>
<p><a href="#id25"><span class="problematic" id="id26">*</span></a>/</p>
</dd>
<dt>def toInsertTweetEvent[R: RequestView](</dt><dd><p>req: R,
bldrRes: TweetBuilderResult</p>
</dd>
<dt>): InsertTweet.Event = {</dt><dd><p>val view = implicitly[RequestView[R]]
InsertTweet.Event(</p>
<blockquote>
<div><p>tweet = bldrRes.tweet,
user = bldrRes.user,
sourceTweet = bldrRes.sourceTweet,
sourceUser = bldrRes.sourceUser,
parentUserId = bldrRes.parentUserId,
timestamp = bldrRes.createdAt,
dark = view.isDark(req) || bldrRes.isSilentFail,
hydrateOptions = view.options(req).getOrElse(WritePathHydrationOptions()),
featureContext = view.featureContext(req),
initialTweetUpdateRequest = bldrRes.initialTweetUpdateRequest,
geoSearchRequestId = for {</p>
<blockquote>
<div><p>geo &lt;- view.geo(req)
searchRequestID &lt;- geo.geoSearchRequestId</p>
</div></blockquote>
<dl class="simple">
<dt>} yield {</dt><dd><p>GeoSearchRequestId(requestID = searchRequestID.id)</p>
</dd>
</dl>
<p>},
additionalContext = view.additionalContext(req),
transientContext = view.transientContext(req),
noteTweetMentionedUserIds = view.noteTweetMentionedUserIds(req)</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Converts an <cite>InsertTweet.Event</cite> into a successful <cite>PostTweetResult</cite>.</p></li>
</ul>
<p><a href="#id27"><span class="problematic" id="id28">*</span></a>/</p>
</dd>
<dt>def toPostTweetResult(event: InsertTweet.Event): PostTweetResult =</dt><dd><dl class="simple">
<dt>PostTweetResult(</dt><dd><p>TweetCreateState.Ok,
Some(event.tweet),
sourceTweet = event.sourceTweet,
quotedTweet = event.quotedTweet</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/tweetypie/server/src/main/scala/com/twitter/tweetypie/handler/PostTweet.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>