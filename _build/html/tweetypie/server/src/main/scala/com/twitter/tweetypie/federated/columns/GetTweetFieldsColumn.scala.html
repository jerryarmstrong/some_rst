<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../../" id="documentation_options" src="../../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie.federated.columns</p>
<p>import com.twitter.finagle.stats.StatsReceiver
import com.twitter.stitch.MapGroup
import com.twitter.stitch.Stitch
import com.twitter.strato.catalog.Fetch
import com.twitter.strato.catalog.OpMetadata
import com.twitter.strato.config.AllowAll
import com.twitter.strato.config.ContactInfo
import com.twitter.strato.config.Policy
import com.twitter.strato.data.Conv
import com.twitter.strato.data.Description.PlainText
import com.twitter.strato.data.Lifecycle.Production
import com.twitter.strato.fed.StratoFed
import com.twitter.strato.opcontext.OpContext
import com.twitter.strato.response.Err
import com.twitter.strato.thrift.ScroogeConv
import com.twitter.tweetypie.TweetId
import com.twitter.tweetypie.client_id.PreferForwardedServiceIdentifierForStrato
import com.twitter.tweetypie.thriftscala.GetTweetFieldsOptions
import com.twitter.tweetypie.thriftscala.GetTweetFieldsRequest
import com.twitter.tweetypie.thriftscala.GetTweetFieldsResult
import com.twitter.tweetypie.thriftscala.TweetVisibilityPolicy
import com.twitter.util.Future
import com.twitter.util.Try</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Strato federated column implementing GetTweetFields as a Fetch.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>class GetTweetFieldsColumn(</dt><dd><p>handler: GetTweetFieldsRequest =&gt; Future[Seq[GetTweetFieldsResult]],
stats: StatsReceiver)</p>
<blockquote>
<div><p>extends StratoFed.Column(GetTweetFieldsColumn.Path)
with StratoFed.Fetch.StitchWithContext {</p>
</div></blockquote>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>At this point, this fetch op will reject any requests that specify</p></li>
<li><p>visibilityPolicy other than USER_VISIBLE, so no access control is needed.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
</dl>
<p>override val policy: Policy = AllowAll</p>
<p>override type Key = TweetId
override type View = GetTweetFieldsOptions
override type Value = GetTweetFieldsResult</p>
<p>override val keyConv: Conv[Key] = Conv.ofType
override val viewConv: Conv[View] = ScroogeConv.fromStruct[GetTweetFieldsOptions]
override val valueConv: Conv[Value] = ScroogeConv.fromStruct[GetTweetFieldsResult]</p>
<p>override val contactInfo: ContactInfo = TweetypieContactInfo
override val metadata: OpMetadata = OpMetadata(</p>
<blockquote>
<div><p>lifecycle = Some(Production),
description =</p>
<blockquote>
<div><p>Some(PlainText(“Get of tweets that allows fetching only specific subsets of the data.”)),</p>
</div></blockquote>
</div></blockquote>
<p>)</p>
<p>val safetyOpContextOnlyCounter = stats.counter(“safety_op_context_only”)
val safetyOpContextOnlyValueScope = stats.scope(“safety_op_context_only_value”)
val safetyOpContextOnlyCallerScope = stats.scope(“safety_op_context_only_caller”)</p>
<p>val safetyViewOnlyCounter = stats.counter(“safety_view_only”)
val safetyViewOnlyValueScope = stats.scope(“safety_view_only_value”)
val safetyViewOnlyCallerScope = stats.scope(“safety_view_only_caller”)</p>
<p>val safetyLevelInconsistencyCounter = stats.counter(“safety_level_inconsistency”)
val safetyLevelInconsistencyValueScope = stats.scope(“safety_level_inconsistency_value”)
val safetyLevelInconsistencyCallerScope = stats.scope(“safety_level_inconsistency_caller”)</p>
<dl>
<dt>override def fetch(key: Key, view: View, ctx: OpContext): Stitch[Result[Value]] = {</dt><dd><p>compareSafetyLevel(view, ctx)
checkVisibilityPolicyUserVisible(view).flatMap { _ =&gt;</p>
<blockquote>
<div><p>Stitch.call(key, Group(view))</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Only allow [[TweetVisibilityPolicy.UserVisible]] visibilityPolicy.</p></li>
<li></li>
<li><p>This column requires access policy in order to serve requests with visibilityPolicy</p></li>
<li><p>other than [[TweetVisibilityPolicy.UserVisible]]. Before we support access control,</p></li>
<li><p>reject all requests that are not safe.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>private def checkVisibilityPolicyUserVisible(view: View): Stitch[Unit] =</dt><dd><dl>
<dt>view.visibilityPolicy match {</dt><dd><p>case TweetVisibilityPolicy.UserVisible =&gt; Stitch.value(Unit)
case otherValue =&gt;</p>
<blockquote>
<div><dl>
<dt>Stitch.exception(</dt><dd><dl>
<dt>Err(</dt><dd><p>Err.BadRequest,
“GetTweetFields does not support access control on Strato yet. “</p>
<blockquote>
<div><ul class="simple">
<li><p>s”Hence visibilityPolicy can only take the default ${TweetVisibilityPolicy.UserVisible} value, “</p></li>
<li><p>s”got: ${otherValue}.”</p></li>
</ul>
</div></blockquote>
</dd>
</dl>
<p>))</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>/** Compare the SafetyLevels in the View and OpContext <a href="#id7"><span class="problematic" id="id8">*</span></a>/
private def compareSafetyLevel(view: View, ctx: OpContext): Unit =</p>
<blockquote>
<div><dl>
<dt>(view.safetyLevel, ctx.safetyLevel) match {</dt><dd><p>case (None, None) =&gt;
case (Some(viewSafety), None) =&gt; {</p>
<blockquote>
<div><p>safetyViewOnlyCounter.incr()
safetyViewOnlyValueScope.counter(viewSafety.name).incr()
PreferForwardedServiceIdentifierForStrato.serviceIdentifier</p>
<blockquote>
<div><p>.foreach(serviceId =&gt; safetyViewOnlyCallerScope.counter(serviceId.toString).incr())</p>
</div></blockquote>
</div></blockquote>
<p>}
case (None, Some(ctxSafety)) =&gt; {</p>
<blockquote>
<div><p>safetyOpContextOnlyCounter.incr()
safetyOpContextOnlyValueScope.counter(ctxSafety.name).incr()
PreferForwardedServiceIdentifierForStrato.serviceIdentifier</p>
<blockquote>
<div><p>.foreach(serviceId =&gt; safetyOpContextOnlyCallerScope.counter(serviceId.toString).incr())</p>
</div></blockquote>
</div></blockquote>
<p>}
case (Some(viewSafety), Some(ctxSafety)) =&gt;</p>
<blockquote>
<div><dl>
<dt>def safeStringEquals(a: String, b: String) =</dt><dd><p>a.toLowerCase().trim().equals(b.toLowerCase().trim())</p>
</dd>
<dt>if (!safeStringEquals(viewSafety.name, ctxSafety.name)) {</dt><dd><p>safetyLevelInconsistencyCounter.incr()
safetyLevelInconsistencyValueScope.counter(viewSafety.name + ‘-’ + ctxSafety.name).incr()
PreferForwardedServiceIdentifierForStrato.serviceIdentifier</p>
<blockquote>
<div><dl class="simple">
<dt>.foreach(serviceId =&gt;</dt><dd><p>safetyLevelInconsistencyCallerScope.counter(serviceId.toString).incr())</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Means of batching of [[GetTweetFieldsColumn]] calls.</p></li>
<li></li>
<li><p>Only calls issued against the same instance of [[GetTweetFieldsColumn]]</p></li>
<li><p>are batched as Stitch clusters group objects based on equality,</p></li>
<li><p>and nested case class implicitly captures [[GetTweetFieldsColumn]] reference.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>private case class Group(view: GetTweetFieldsOptions)</dt><dd><blockquote>
<div><p>extends MapGroup[TweetId, Fetch.Result[GetTweetFieldsResult]] {</p>
</div></blockquote>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Batches given [[TweetId]] lookups in a single [[GetTweetFieldsRequest]]</p></li>
<li><p>and returns a result mapped by [[TweetId]].</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>override protected def run(</dt><dd><p>keys: Seq[TweetId]</p>
</dd>
<dt>): Future[TweetId =&gt; Try[Fetch.Result[GetTweetFieldsResult]]] =</dt><dd><dl>
<dt>handler(</dt><dd><dl class="simple">
<dt>GetTweetFieldsRequest(</dt><dd><p>// Sorting the keys makes for simpler matchers in the tests
// as matching on a Seq needs to be in order.
tweetIds = keys.sorted,
options = view,</p>
</dd>
</dl>
<p>)).map(groupByTweetId)</p>
</dd>
</dl>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Groups given [[GetTweetFieldsResult]] objects by [[TweetId]] and returns the mapping.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>private def groupByTweetId(</dt><dd><p>allResults: Seq[GetTweetFieldsResult]</p>
</dd>
<dt>): TweetId =&gt; Try[Fetch.Result[GetTweetFieldsResult]] = {</dt><dd><dl>
<dt>allResults</dt><dd><p>.groupBy(_.tweetId)
.mapValues {</p>
<blockquote>
<div><p>case Seq(result) =&gt; Try(Fetch.Result.found(result))
case manyResults =&gt;</p>
<blockquote>
<div><dl class="simple">
<dt>Try {</dt><dd><dl class="simple">
<dt>throw Err(</dt><dd><p>Err.Dependency,
s”Expected one result per tweeet ID, got ${manyResults.length}”)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>object GetTweetFieldsColumn {</dt><dd><p>val Path = “tweetypie/getTweetFields.Tweet”</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../../index.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../../_sources/tweetypie/server/src/main/scala/com/twitter/tweetypie/federated/columns/GetTweetFieldsColumn.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>