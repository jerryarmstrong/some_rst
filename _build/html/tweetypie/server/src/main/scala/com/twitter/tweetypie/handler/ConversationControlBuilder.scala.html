<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../../" id="documentation_options" src="../../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie.handler</p>
<p>import com.twitter.featureswitches.v2.FeatureSwitchResults
import com.twitter.stitch.Stitch
import com.twitter.tweetypie.UserId
import com.twitter.tweetypie._
import com.twitter.tweetypie.core.TweetCreateFailure
import com.twitter.tweetypie.repository.UserIdentityRepository
import com.twitter.tweetypie.repository.UserKey
import com.twitter.tweetypie.thriftscala.ConversationControl
import com.twitter.tweetypie.thriftscala.Tweet
import com.twitter.tweetypie.thriftscala.TweetCreateConversationControl
import com.twitter.tweetypie.thriftscala.TweetCreateState.ConversationControlNotAllowed
import com.twitter.tweetypie.thriftscala.TweetCreateState.InvalidConversationControl
import com.twitter.tweetypie.util.ConversationControls
import com.twitter.util.logging.Logging</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Process request parameters into a ConversationControl value.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>object ConversationControlBuilder extends Logging {</dt><dd><p>type Type = Request =&gt; Stitch[Option[ConversationControl]]</p>
<p>type ScreenName = String</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>The fields necessary to create a [[ConversationControl]].</p></li>
<li></li>
<li><p>This is a trait rather than a case class to avoid running the</p></li>
<li><p>code to extract the mentions in the cases where handling the</p></li>
<li><p>request doesn’t need to use them (the common case where</p></li>
<li><p>tweetCreateConversationControl is None).</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>trait Request {</dt><dd><p>def tweetCreateConversationControl: Option[TweetCreateConversationControl]
def tweetAuthorId: UserId
def mentionedUserScreenNames: Set[String]</p>
<p>def noteTweetMentionedUserIds: Option[Set[Long]]</p>
</dd>
</dl>
<p>}</p>
<p>object Request {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Extract the data necessary to create a [[ConversationControl]]</p></li>
<li><p>for a new [[Tweet]]. This is intended for use when creating</p></li>
<li><p>Tweets. It must be called after the Tweet has had its entities</p></li>
<li><p>extracted.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>def fromTweet(</dt><dd><p>tweet: Tweet,
tweetCreateConversationControl: Option[TweetCreateConversationControl],
noteTweetMentionedUserIdsList: Option[Seq[Long]]</p>
</dd>
<dt>): Request = {</dt><dd><p>val cctl = tweetCreateConversationControl
new Request {</p>
<blockquote>
<div><p>def tweetCreateConversationControl: Option[TweetCreateConversationControl] = cctl
def mentionedUserScreenNames: Set[ScreenName] =</p>
<blockquote>
<div><p>tweet.mentions
// Enforce that the Tweet’s mentions have already been
// extracted from the text. (Mentions will be None if they
// have not yet been extracted.)</p>
<blockquote>
<div><dl class="simple">
<dt>.getOrElse(</dt><dd><dl class="simple">
<dt>throw new RuntimeException(</dt><dd><p>“Mentions must be extracted before applying ConversationControls”))</p>
</dd>
</dl>
</dd>
</dl>
<p>.map(_.screenName)
.toSet</p>
</div></blockquote>
</div></blockquote>
<p>def tweetAuthorId: UserId = tweet.coreData.get.userId
def noteTweetMentionedUserIds: Option[Set[Long]] =</p>
<blockquote>
<div><p>noteTweetMentionedUserIdsList.map(_.toSet)</p>
</div></blockquote>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Create a ConversationControlBuilder that looks up user ids for</p></li>
<li><p>screen names using the specified UserIdentityRepository.</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>def fromUserIdentityRepo(</dt><dd><p>statsReceiver: StatsReceiver,
userIdentityRepo: UserIdentityRepository.Type</p>
</dd>
<dt>): Request =&gt; Stitch[Option[ConversationControl]] =</dt><dd><dl class="simple">
<dt>ConversationControlBuilder(</dt><dd><p>getUserId = screenName =&gt; userIdentityRepo(UserKey.byScreenName(screenName)).map(_.id),
statsReceiver = statsReceiver</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Extract the inviteViaMention value which does not exist on the TweetCreateConversationControl</p></li>
<li><p>itself but does exist on the structures it unions.</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>def inviteViaMention(tccc: TweetCreateConversationControl): Boolean =</dt><dd><dl class="simple">
<dt>tccc match {</dt><dd><p>case TweetCreateConversationControl.ByInvitation(c) =&gt; c.inviteViaMention.contains(true)
case TweetCreateConversationControl.Community(c) =&gt; c.inviteViaMention.contains(true)
case TweetCreateConversationControl.Followers(c) =&gt; c.inviteViaMention.contains(true)
case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Translates the TweetCreateConversationControl into</p></li>
<li><p>ConversationControl using the context from the rest of the tweet</p></li>
<li><p>creation. For the most part, this is just a direct translation,</p></li>
<li><p>plus filling in the contextual user ids (mentioned users and tweet</p></li>
<li><p>author).</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>def apply(</dt><dd><p>statsReceiver: StatsReceiver,
getUserId: ScreenName =&gt; Stitch[UserId]</p>
</dd>
<dt>): Request =&gt; Stitch[Option[ConversationControl]] = {</dt><dd><p>val userIdLookupsCounter = statsReceiver.counter(“user_id_lookups”)
val conversationControlPresentCounter = statsReceiver.counter(“conversation_control_present”)
val conversationControlInviteViaMentionPresentCounter =</p>
<blockquote>
<div><p>statsReceiver.counter(“conversation_control_invite_via_mention_present”)</p>
</div></blockquote>
<p>val failureCounter = statsReceiver.counter(“failures”)</p>
<p>// Get the user ids for these screen names. Any users who do not
// exist will be silently dropped.
def getExistingUserIds(</p>
<blockquote>
<div><p>screenNames: Set[ScreenName],
mentionedUserIds: Option[Set[Long]]</p>
</div></blockquote>
<dl>
<dt>): Stitch[Set[UserId]] = {</dt><dd><dl>
<dt>mentionedUserIds match {</dt><dd><p>case Some(userIds) =&gt; Stitch.value(userIds)
case _ =&gt;</p>
<blockquote>
<div><dl>
<dt>Stitch</dt><dd><dl class="simple">
<dt>.traverse(screenNames.toSeq) { screenName =&gt;</dt><dd><dl class="simple">
<dt>getUserId(screenName).liftNotFoundToOption</dt><dd><p>.ensure(userIdLookupsCounter.incr())</p>
</dd>
</dl>
</dd>
</dl>
<p>}
.map(userIdOptions =&gt; userIdOptions.flatten.toSet)</p>
</dd>
</dl>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<p>// This is broken out just to make it syntactically nicer to add
// the stats handling
def process(request: Request): Stitch[Option[ConversationControl]] =</p>
<blockquote>
<div><dl>
<dt>request.tweetCreateConversationControl match {</dt><dd><p>case None =&gt; Stitch.None
case Some(cctl) =&gt;</p>
<blockquote>
<div><dl>
<dt>cctl match {</dt><dd><dl>
<dt>case TweetCreateConversationControl.ByInvitation(byInvitationControl) =&gt;</dt><dd><dl>
<dt>for {</dt><dd><dl class="simple">
<dt>invitedUserIds &lt;- getExistingUserIds(</dt><dd><p>request.mentionedUserScreenNames,
request.noteTweetMentionedUserIds)</p>
</dd>
</dl>
</dd>
<dt>} yield Some(</dt><dd><dl class="simple">
<dt>ConversationControls.byInvitation(</dt><dd><p>invitedUserIds = invitedUserIds.toSeq.filterNot(_ == request.tweetAuthorId),
conversationTweetAuthorId = request.tweetAuthorId,
byInvitationControl.inviteViaMention</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>case TweetCreateConversationControl.Community(communityControl) =&gt;</dt><dd><dl>
<dt>for {</dt><dd><dl class="simple">
<dt>invitedUserIds &lt;- getExistingUserIds(</dt><dd><p>request.mentionedUserScreenNames,
request.noteTweetMentionedUserIds)</p>
</dd>
</dl>
</dd>
<dt>} yield Some(</dt><dd><dl class="simple">
<dt>ConversationControls.community(</dt><dd><p>invitedUserIds = invitedUserIds.toSeq.filterNot(_ == request.tweetAuthorId),
conversationTweetAuthorId = request.tweetAuthorId,
communityControl.inviteViaMention</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>case TweetCreateConversationControl.Followers(followersControl) =&gt;</dt><dd><dl>
<dt>for {</dt><dd><dl class="simple">
<dt>invitedUserIds &lt;- getExistingUserIds(</dt><dd><p>request.mentionedUserScreenNames,
request.noteTweetMentionedUserIds)</p>
</dd>
</dl>
</dd>
<dt>} yield Some(</dt><dd><dl class="simple">
<dt>ConversationControls.followers(</dt><dd><p>invitedUserIds = invitedUserIds.toSeq.filterNot(_ == request.tweetAuthorId),
conversationTweetAuthorId = request.tweetAuthorId,
followersControl.inviteViaMention</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>// This should only ever happen if a new value is added to the
// union and we don’t update this code.
case TweetCreateConversationControl.UnknownUnionField(fld) =&gt;</p>
<blockquote>
<div><p>throw new RuntimeException(s”Unexpected TweetCreateConversationControl: $fld”)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<dl>
<dt>(request: Request) =&gt; {</dt><dd><p>// Wrap in Stitch to encapsulate any exceptions that happen
// before making a Stitch call inside of process.
Stitch(process(request)).flatten.respond { response =&gt;</p>
<blockquote>
<div><p>// If we count this before doing the work, and the stats are
// collected before the RPC completes, then any failures
// will get counted in a different minute than the request
// that caused it.
request.tweetCreateConversationControl.foreach { cc =&gt;</p>
<blockquote>
<div><p>conversationControlPresentCounter.incr()
if (inviteViaMention(cc)) conversationControlInviteViaMentionPresentCounter.incr()</p>
</div></blockquote>
<p>}</p>
<dl class="simple">
<dt>response.onFailure { e =&gt;</dt><dd><p>error(message = “Failed to create conversation control”, cause = e)
// Don’t bother counting individual exceptions, because
// the cost of keeping those stats is probably not worth
// the convenience of not having to look in the logs.
failureCounter.incr()</p>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Validates if a conversation control request is allowed by feature switches</p></li>
<li><p>and is only requested on a root tweet.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>object Validate {</dt><dd><dl class="simple">
<dt>case class Request(</dt><dd><p>matchedResults: Option[FeatureSwitchResults],
conversationControl: Option[TweetCreateConversationControl],
inReplyToTweetId: Option[TweetId])</p>
</dd>
</dl>
<p>type Type = FutureEffect[Request]</p>
<p>val ExInvalidConversationControl = TweetCreateFailure.State(InvalidConversationControl)
val ExConversationControlNotAllowed = TweetCreateFailure.State(ConversationControlNotAllowed)
val ConversationControlStatusUpdateEnabledKey = “conversation_control_status_update_enabled”
val ConversationControlFollowersEnabledKey = “conversation_control_my_followers_enabled”</p>
<dl>
<dt>def apply(</dt><dd><p>useFeatureSwitchResults: Gate[Unit],
statsReceiver: StatsReceiver</p>
</dd>
<dt>): Type = request =&gt; {</dt><dd><dl>
<dt>def fsDenied(fsKey: String): Boolean = {</dt><dd><dl class="simple">
<dt>val featureEnabledOpt: Option[Boolean] =</dt><dd><p>// Do not log impressions, which would interfere with shared client experiment data.
request.matchedResults.flatMap(_.getBoolean(fsKey, shouldLogImpression = false))</p>
</dd>
</dl>
<p>val fsEnabled = featureEnabledOpt.contains(true)
if (!fsEnabled) {</p>
<blockquote>
<div><p>statsReceiver.counter(s”check_conversation_control/unauthorized/fs/$fsKey”).incr()</p>
</div></blockquote>
<p>}
!fsEnabled</p>
</dd>
</dl>
<p>}</p>
<p>val isCcRequest: Boolean = request.conversationControl.isDefined</p>
<dl>
<dt>val isCcInvalidParams = isCcRequest &amp;&amp; {</dt><dd><p>val isRootTweet = request.inReplyToTweetId.isEmpty
if (!isRootTweet) {</p>
<blockquote>
<div><p>statsReceiver.counter(“check_conversation_control/invalid”).incr()</p>
</div></blockquote>
<p>}
!isRootTweet</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val isCcDeniedByFs = isCcRequest &amp;&amp; {</dt><dd><dl class="simple">
<dt>val isFollower = request.conversationControl.exists {</dt><dd><p>case _: TweetCreateConversationControl.Followers =&gt; true
case _ =&gt; false</p>
</dd>
</dl>
<p>}</p>
<p>fsDenied(ConversationControlStatusUpdateEnabledKey) ||
(isFollower &amp;&amp; fsDenied(ConversationControlFollowersEnabledKey))</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>if (isCcDeniedByFs &amp;&amp; useFeatureSwitchResults()) {</dt><dd><p>Future.exception(ExConversationControlNotAllowed)</p>
</dd>
<dt>} else if (isCcInvalidParams) {</dt><dd><p>Future.exception(ExInvalidConversationControl)</p>
</dd>
<dt>} else {</dt><dd><p>Future.Unit</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../../_sources/tweetypie/server/src/main/scala/com/twitter/tweetypie/handler/ConversationControlBuilder.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>