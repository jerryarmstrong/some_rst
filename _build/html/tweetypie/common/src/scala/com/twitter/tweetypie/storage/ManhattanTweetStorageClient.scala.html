<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../" id="documentation_options" src="../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie.storage</p>
<p>import com.twitter.conversions.DurationOps._
import com.twitter.finagle.mtls.authentication.EmptyServiceIdentifier
import com.twitter.finagle.mtls.authentication.ServiceIdentifier
import com.twitter.finagle.ssl.OpportunisticTls
import com.twitter.finagle.stats.NullStatsReceiver
import com.twitter.finagle.stats.StatsReceiver
import com.twitter.logging.BareFormatter
import com.twitter.logging.Level
import com.twitter.logging.ScribeHandler
import com.twitter.logging._
import com.twitter.stitch.Stitch
import com.twitter.storage.client.manhattan.bijections.Bijections._
import com.twitter.storage.client.manhattan.kv._
import com.twitter.storage.client.manhattan.kv.impl.ValueDescriptor
import com.twitter.tweetypie.client_id.ClientIdHelper
import com.twitter.tweetypie.storage.Scribe.ScribeHandlerFactory
import com.twitter.tweetypie.storage.TweetStorageClient.BounceDelete
import com.twitter.tweetypie.storage.TweetStorageClient.GetTweet
import com.twitter.tweetypie.storage.TweetStorageClient.HardDeleteTweet
import com.twitter.tweetypie.thriftscala.Tweet
import com.twitter.tweetypie.util.StitchUtils
import com.twitter.util.Duration
import com.twitter.util.Return
import com.twitter.util.Throw
import scala.util.Random</p>
<dl>
<dt>object ManhattanTweetStorageClient {</dt><dd><p>object Config {</p>
<blockquote>
<div><dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>The Manhattan dataset where tweets are stored is not externally</p></li>
<li><p>configurable because writing tweets to a non-production dataset</p></li>
<li><p>requires great care. Staging instances using a different dataset will</p></li>
<li><p>write tweets to a non-production store, but will publish events, log to</p></li>
<li><p>HDFS, and cache data referencing tweets in that store which are not</p></li>
<li><p>accessible by the rest of the production cluster.</p></li>
<li></li>
<li><p>In a completely isolated environment it should be safe to write to</p></li>
<li><p>other datasets for testing purposes.</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
</dl>
<p>val Dataset = “tbird_mh”</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Once a tweet has been deleted it can only be undeleted within this time</p></li>
<li><p>window, after which [[UndeleteHandler]] will return an error on</p></li>
<li><p>undelete attempts.</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
</dl>
<p>val UndeleteWindowHours = 240</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Default label used for underlying Manhattan Thrift client metrics</p></li>
<li></li>
<li><p>The finagle client metrics will be exported at clnt/:label.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
</dl>
<p>val ThriftClientLabel = “mh_cylon”</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Return the corresponding Wily path for the Cylon cluster in the “other” DC</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>def remoteDestination(zone: String): String =</dt><dd><p>s”/srv#/prod/${remoteZone(zone)}/manhattan/cylon.native-thrift”</p>
</dd>
<dt>private def remoteZone(zone: String) = zone match {</dt><dd><p>case “pdxa” =&gt; “atla”
case “atla” | “localhost” =&gt; “pdxa”
case _ =&gt;</p>
<blockquote>
<div><p>throw new IllegalArgumentException(s”Cannot configure remote DC for unknown zone ‘$zone’”)</p>
</div></blockquote>
</dd>
</dl>
<p>}</p>
</div></blockquote>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>&#64;param applicationId Manhattan application id used for quota accounting</p></li>
<li><p>&#64;param localDestination Wily path to local Manhattan cluster</p></li>
<li><p>&#64;param localTimeout Overall timeout (including retries) for all reads/writes to local cluster</p></li>
<li><p>&#64;param remoteDestination Wily path to remote Manhattan cluster, used for undelete and force add</p></li>
<li><p>&#64;param remoteTimeout Overall timeout (including retries) for all reads/writes to remote cluster</p></li>
<li><p>&#64;param undeleteWindowHours Amount of time during which a deleted tweet can be undeleted</p></li>
<li><p>&#64;param thriftClientLabel Label used to scope stats for Manhattan Thrift client</p></li>
<li><p>&#64;param maxRequestsPerBatch Configure the Stitch RequestGroup.Generator batch size</p></li>
<li><p>&#64;param serviceIdentifier The ServiceIdentifier to use when making connections to a Manhattan cluster</p></li>
<li><p>&#64;param opportunisticTlsLevel The level to use for opportunistic TLS for connections to the Manhattan cluster</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>case class Config(</dt><dd><p>applicationId: String,
localDestination: String,
localTimeout: Duration,
remoteDestination: String,
remoteTimeout: Duration,
undeleteWindowHours: Int = Config.UndeleteWindowHours,
thriftClientLabel: String = Config.ThriftClientLabel,
maxRequestsPerBatch: Int = Int.MaxValue,
serviceIdentifier: ServiceIdentifier,
opportunisticTlsLevel: OpportunisticTls.Level)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Sanitizes the input for APIs which take in a (Tweet, Seq[Field]) as input.</p></li>
<li></li>
<li><p>NOTE: This function only applies sanity checks which are common to</p></li>
<li><p>all APIs which take in a (Tweet, Seq[Field]) as input. API specific</p></li>
<li><p>checks are not covered here.</p></li>
<li></li>
<li><p>&#64;param apiStitch the backing API call</p></li>
<li><p>&#64;tparam T the output type of the backing API call</p></li>
<li><p>&#64;return a stitch function which does some basic input sanity checking</p></li>
</ul>
<p><a href="#id11"><span class="problematic" id="id12">*</span></a>/</p>
</dd>
<dt>private[storage] def sanitizeTweetFields[T](</dt><dd><p>apiStitch: (Tweet, Seq[Field]) =&gt; Stitch[T]</p>
</dd>
<dt>): (Tweet, Seq[Field]) =&gt; Stitch[T] =</dt><dd><dl class="simple">
<dt>(tweet, fields) =&gt; {</dt><dd><p>require(fields.forall(_.id &gt; 0), s”Field ids ${fields} are not positive numbers”)
apiStitch(tweet, fields)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>// Returns a handler that asynchronously logs messages to Scribe using the BareFormatter which
// logs just the message without any additional metadata
def scribeHandler(categoryName: String): HandlerFactory =</p>
<blockquote>
<div><dl class="simple">
<dt>ScribeHandler(</dt><dd><p>formatter = BareFormatter,
maxMessagesPerTransaction = 100,
category = categoryName,
level = Some(Level.TRACE)</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>A Config appropriate for interactive sessions and scripts.</p></li>
</ul>
<p><a href="#id13"><span class="problematic" id="id14">*</span></a>/</p>
</dd>
<dt>def develConfig(): Config =</dt><dd><dl class="simple">
<dt>Config(</dt><dd><p>applicationId = Option(System.getenv(“USER”)).getOrElse(“&lt;unknown&gt;”) + “.devel”,
localDestination = “/s/manhattan/cylon.native-thrift”,
localTimeout = 10.seconds,
remoteDestination = “/s/manhattan/cylon.native-thrift”,
remoteTimeout = 10.seconds,
undeleteWindowHours = Config.UndeleteWindowHours,
thriftClientLabel = Config.ThriftClientLabel,
maxRequestsPerBatch = Int.MaxValue,
serviceIdentifier = ServiceIdentifier(System.getenv(“USER”), “tweetypie”, “devel”, “local”),
opportunisticTlsLevel = OpportunisticTls.Required</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>/**</dt><dd><ul class="simple">
<li><p>Build a Manhattan tweet storage client for use in interactive</p></li>
<li><p>sessions and scripts.</p></li>
</ul>
<p><a href="#id15"><span class="problematic" id="id16">*</span></a>/</p>
</dd>
<dt>def devel(): TweetStorageClient =</dt><dd><dl class="simple">
<dt>new ManhattanTweetStorageClient(</dt><dd><p>develConfig(),
NullStatsReceiver,
ClientIdHelper.default,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>class ManhattanTweetStorageClient(</dt><dd><p>config: ManhattanTweetStorageClient.Config,
statsReceiver: StatsReceiver,
private val clientIdHelper: ClientIdHelper)</p>
<blockquote>
<div><p>extends TweetStorageClient {</p>
</div></blockquote>
<p>import ManhattanTweetStorageClient._</p>
<p>lazy val scribeHandlerFactory: ScribeHandlerFactory = scribeHandler _
val scribe: Scribe = new Scribe(scribeHandlerFactory, statsReceiver)</p>
<dl>
<dt>def mkClient(</dt><dd><p>dest: String,
label: String</p>
</dd>
<dt>): ManhattanKVClient = {</dt><dd><dl>
<dt>val mhMtlsParams =</dt><dd><p>if (config.serviceIdentifier == EmptyServiceIdentifier) NoMtlsParams
else</p>
<blockquote>
<div><dl class="simple">
<dt>ManhattanKVClientMtlsParams(</dt><dd><p>serviceIdentifier = config.serviceIdentifier,
opportunisticTls = config.opportunisticTlsLevel</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
</dd>
<dt>new ManhattanKVClient(</dt><dd><p>config.applicationId,
dest,
mhMtlsParams,
label,
Seq(Experiments.ApertureLoadBalancer))</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<p>val localClient: ManhattanKVClient = mkClient(config.localDestination, config.thriftClientLabel)</p>
<dl class="simple">
<dt>val localMhEndpoint: ManhattanKVEndpoint = ManhattanKVEndpointBuilder(localClient)</dt><dd><p>.defaultGuarantee(Guarantee.SoftDcReadMyWrites)
.defaultMaxTimeout(config.localTimeout)
.maxRequestsPerBatch(config.maxRequestsPerBatch)
.build()</p>
</dd>
</dl>
<p>val localManhattanOperations = new ManhattanOperations(Config.Dataset, localMhEndpoint)</p>
<dl class="simple">
<dt>val remoteClient: ManhattanKVClient =</dt><dd><p>mkClient(config.remoteDestination, s”${config.thriftClientLabel}_remote”)</p>
</dd>
<dt>val remoteMhEndpoint: ManhattanKVEndpoint = ManhattanKVEndpointBuilder(remoteClient)</dt><dd><p>.defaultGuarantee(Guarantee.SoftDcReadMyWrites)
.defaultMaxTimeout(config.remoteTimeout)
.build()</p>
</dd>
</dl>
<p>val remoteManhattanOperations = new ManhattanOperations(Config.Dataset, remoteMhEndpoint)</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Note: This translation is only useful for non-batch endpoints. Batch endpoints currently</p></li>
<li><p>represent failure without propagating an exception</p></li>
<li><p>(e.g. [[com.twitter.tweetypie.storage.Response.TweetResponseCode.Failure]]).</p></li>
</ul>
<p><a href="#id17"><span class="problematic" id="id18">*</span></a>/</p>
</dd>
<dt>private[this] def translateExceptions(</dt><dd><p>apiName: String,
statsReceiver: StatsReceiver</p>
</dd>
<dt>): PartialFunction[Throwable, Throwable] = {</dt><dd><p>case e: IllegalArgumentException =&gt; ClientError(e.getMessage, e)
case e: DeniedManhattanException =&gt; RateLimited(e.getMessage, e)
case e: VersionMismatchError =&gt;</p>
<blockquote>
<div><p>statsReceiver.scope(apiName).counter(“mh_version_mismatches”).incr()
e</p>
</div></blockquote>
<dl class="simple">
<dt>case e: InternalError =&gt;</dt><dd><p>TweetUtils.log.error(e, s”Error processing $apiName request: ${e.getMessage}”)
e</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Count requests per client id producing metrics of the form</p></li>
<li><p>…/clients/:root_client_id/requests</p></li>
</ul>
<p><a href="#id19"><span class="problematic" id="id20">*</span></a>/</p>
</dd>
<dt>def observeClientId[A, B](</dt><dd><p>apiStitch: A =&gt; Stitch[B],
statsReceiver: StatsReceiver,
clientIdHelper: ClientIdHelper,</p>
</dd>
<dt>): A =&gt; Stitch[B] = {</dt><dd><p>val clients = statsReceiver.scope(“clients”)</p>
<dl class="simple">
<dt>val incrementClientRequests = { args: A =&gt;</dt><dd><p>val clientId = clientIdHelper.effectiveClientIdRoot.getOrElse(ClientIdHelper.UnknownClientId)
clients.counter(clientId, “requests”).incr</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>a =&gt; {</dt><dd><p>incrementClientRequests(a)
apiStitch(a)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Increment counters based on the overall response status of the returned [[GetTweet.Response]].</p></li>
</ul>
<p><a href="#id21"><span class="problematic" id="id22">*</span></a>/</p>
</dd>
<dt>def observeGetTweetResponseCode[A](</dt><dd><p>apiStitch: A =&gt; Stitch[GetTweet.Response],
statsReceiver: StatsReceiver</p>
</dd>
<dt>): A =&gt; Stitch[GetTweet.Response] = {</dt><dd><p>val scope = statsReceiver.scope(“response_code”)</p>
<p>val success = scope.counter(“success”)
val notFound = scope.counter(“not_found”)
val failure = scope.counter(“failure”)
val overCapacity = scope.counter(“over_capacity”)
val deleted = scope.counter(“deleted”)
val bounceDeleted = scope.counter(“bounce_deleted”)</p>
<dl>
<dt>a =&gt;</dt><dd><dl class="simple">
<dt>apiStitch(a).respond {</dt><dd><p>case Return(_: GetTweet.Response.Found) =&gt; success.incr()
case Return(GetTweet.Response.NotFound) =&gt; notFound.incr()
case Return(_: GetTweet.Response.BounceDeleted) =&gt; bounceDeleted.incr()
case Return(GetTweet.Response.Deleted) =&gt; deleted.incr()
case Throw(_: RateLimited) =&gt; overCapacity.incr()
case Throw(_) =&gt; failure.incr()</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>We do 3 things here:</p></li>
<li></li>
<li><ul>
<li><p>Bookkeeping for overall requests</p></li>
</ul>
</li>
<li><ul>
<li><p>Bookkeeping for per api requests</p></li>
</ul>
</li>
<li><ul>
<li><p>Translate exceptions</p></li>
</ul>
</li>
<li></li>
<li><p>&#64;param apiName the API being called</p></li>
<li><p>&#64;param apiStitch the implementation of the API</p></li>
<li><p>&#64;tparam A template for input type of API</p></li>
<li><p>&#64;tparam B template for output type of API</p></li>
<li><p>&#64;return Function which executes the given API call</p></li>
</ul>
<p><a href="#id23"><span class="problematic" id="id24">*</span></a>/</p>
</dd>
<dt>private[storage] def endpoint[A, B](</dt><dd><p>apiName: String,
apiStitch: A =&gt; Stitch[B]</p>
</dd>
<dt>): A =&gt; Stitch[B] = {</dt><dd><p>val translateException = translateExceptions(apiName, statsReceiver)
val observe = StitchUtils.observe[B](statsReceiver, apiName)</p>
<dl>
<dt>a =&gt;</dt><dd><dl class="simple">
<dt>StitchUtils.translateExceptions(</dt><dd><p>observe(apiStitch(a)),
translateException</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>private[storage] def endpoint2[A, B, C](</dt><dd><p>apiName: String,
apiStitch: (A, B) =&gt; Stitch[C],
clientIdHelper: ClientIdHelper,</p>
</dd>
<dt>): (A, B) =&gt; Stitch[C] =</dt><dd><p>Function.untupled(endpoint(apiName, apiStitch.tupled))</p>
</dd>
<dt>val getTweet: TweetStorageClient.GetTweet = {</dt><dd><p>val stats = statsReceiver.scope(“getTweet”)</p>
<dl>
<dt>observeClientId(</dt><dd><dl>
<dt>observeGetTweetResponseCode(</dt><dd><dl>
<dt>endpoint(</dt><dd><p>“getTweet”,
GetTweetHandler(</p>
<blockquote>
<div><p>read = localManhattanOperations.read,
statsReceiver = stats,</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>),
stats,</p>
</dd>
</dl>
<p>),
stats,
clientIdHelper,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val getStoredTweet: TweetStorageClient.GetStoredTweet = {</dt><dd><p>val stats = statsReceiver.scope(“getStoredTweet”)</p>
<dl>
<dt>observeClientId(</dt><dd><dl>
<dt>endpoint(</dt><dd><p>“getStoredTweet”,
GetStoredTweetHandler(</p>
<blockquote>
<div><p>read = localManhattanOperations.read,
statsReceiver = stats,</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>),
stats,
clientIdHelper,</p>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>val addTweet: TweetStorageClient.AddTweet =</dt><dd><dl>
<dt>endpoint(</dt><dd><p>“addTweet”,
AddTweetHandler(</p>
<blockquote>
<div><p>insert = localManhattanOperations.insert,
scribe = scribe,
stats = statsReceiver</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val updateTweet: TweetStorageClient.UpdateTweet =</dt><dd><dl>
<dt>endpoint2(</dt><dd><p>“updateTweet”,
ManhattanTweetStorageClient.sanitizeTweetFields(</p>
<blockquote>
<div><dl class="simple">
<dt>UpdateTweetHandler(</dt><dd><p>insert = localManhattanOperations.insert,
stats = statsReceiver,</p>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>),
clientIdHelper,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val softDelete: TweetStorageClient.SoftDelete =</dt><dd><dl>
<dt>endpoint(</dt><dd><p>“softDelete”,
SoftDeleteHandler(</p>
<blockquote>
<div><p>insert = localManhattanOperations.insert,
scribe = scribe</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val bounceDelete: BounceDelete =</dt><dd><dl>
<dt>endpoint(</dt><dd><p>“bounceDelete”,
BounceDeleteHandler(</p>
<blockquote>
<div><p>insert = localManhattanOperations.insert,
scribe = scribe</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val undelete: TweetStorageClient.Undelete =</dt><dd><dl>
<dt>endpoint(</dt><dd><p>“undelete”,
UndeleteHandler(</p>
<blockquote>
<div><p>read = localManhattanOperations.read,
localInsert = localManhattanOperations.insert,
remoteInsert = remoteManhattanOperations.insert,
delete = localManhattanOperations.delete,
undeleteWindowHours = config.undeleteWindowHours,
stats = statsReceiver</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val getDeletedTweets: TweetStorageClient.GetDeletedTweets =</dt><dd><dl>
<dt>endpoint(</dt><dd><p>“getDeletedTweets”,
GetDeletedTweetsHandler(</p>
<blockquote>
<div><p>read = localManhattanOperations.read,
stats = statsReceiver</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val deleteAdditionalFields: TweetStorageClient.DeleteAdditionalFields =</dt><dd><dl>
<dt>endpoint2(</dt><dd><p>“deleteAdditionalFields”,
DeleteAdditionalFieldsHandler(</p>
<blockquote>
<div><p>delete = localManhattanOperations.delete,
stats = statsReceiver,</p>
</div></blockquote>
<p>),
clientIdHelper,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val scrub: TweetStorageClient.Scrub =</dt><dd><dl>
<dt>endpoint2(</dt><dd><p>“scrub”,
ScrubHandler(</p>
<blockquote>
<div><p>insert = localManhattanOperations.insert,
delete = localManhattanOperations.delete,
scribe = scribe,
stats = statsReceiver,</p>
</div></blockquote>
<p>),
clientIdHelper,</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val hardDeleteTweet: HardDeleteTweet =</dt><dd><dl>
<dt>endpoint(</dt><dd><p>“hardDeleteTweet”,
HardDeleteTweetHandler(</p>
<blockquote>
<div><p>read = localManhattanOperations.read,
insert = localManhattanOperations.insert,
delete = localManhattanOperations.delete,
scribe = scribe,
stats = statsReceiver</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>)</p>
</dd>
<dt>val ping: TweetStorageClient.Ping =</dt><dd><dl>
<dt>() =&gt;</dt><dd><dl>
<dt>Stitch</dt><dd><dl>
<dt>.run(</dt><dd><dl>
<dt>localMhEndpoint</dt><dd><dl>
<dt>.get(</dt><dd><dl class="simple">
<dt>ManhattanOperations.KeyDescriptor</dt><dd><p>.withDataset(Config.Dataset)
.withPkey(Random.nextLong().abs)
.withLkey(TweetKey.LKey.CoreFieldsKey), // could be any lkey</p>
</dd>
</dl>
<p>ValueDescriptor(BufInjection)</p>
</dd>
</dl>
<p>).unit</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../_sources/tweetypie/common/src/scala/com/twitter/tweetypie/storage/ManhattanTweetStorageClient.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>