<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>&lt;no title&gt; &#8212; twit  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../../../../../../../../_static/alabaster.css?v=039e1c02" />
    <script data-url_root="../../../../../../../../" id="documentation_options" src="../../../../../../../../_static/documentation_options.js?v=b3ba4146"></script>
    <script src="../../../../../../../../_static/doctools.js?v=888ff710"></script>
    <script src="../../../../../../../../_static/sphinx_highlight.js?v=4825356b"></script>
    <link rel="index" title="Index" href="../../../../../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../../../../../search.html" />
   
  <link rel="stylesheet" href="../../../../../../../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>package com.twitter.tweetypie.storage</p>
<p>import com.twitter.bijection.Conversion.asMethod
import com.twitter.bijection.Injection
import com.twitter.scrooge.TFieldBlob
import com.twitter.storage.client.manhattan.kv._
import com.twitter.tweetypie.storage.Response.FieldResponse
import com.twitter.tweetypie.storage.Response.FieldResponseCode
import com.twitter.tweetypie.storage_internal.thriftscala.CoreFields
import com.twitter.tweetypie.storage_internal.thriftscala.InternalTweet
import com.twitter.tweetypie.storage_internal.thriftscala.StoredTweet
import java.io.ByteArrayOutputStream
import java.nio.ByteBuffer
import org.apache.thrift.protocol.TBinaryProtocol
import org.apache.thrift.transport.TIOStreamTransport
import org.apache.thrift.transport.TMemoryInputTransport
import scala.collection.immutable
import scala.util.control.NoStackTrace</p>
<p>// NOTE: All field ids and Tweet structure in this file correspond to the StoredTweet struct ONLY</p>
<dl class="simple">
<dt>object ByteArrayCodec {</dt><dd><p>def toByteBuffer(byteArray: Array[Byte]): ByteBuffer = byteArray.as[ByteBuffer]
def fromByteBuffer(buffer: ByteBuffer): Array[Byte] = buffer.as[Array[Byte]]</p>
</dd>
</dl>
<p>}</p>
<dl class="simple">
<dt>object StringCodec {</dt><dd><p>private val string2ByteBuffer = Injection.connect[String, Array[Byte], ByteBuffer]
def toByteBuffer(strValue: String): ByteBuffer = string2ByteBuffer(strValue)
def fromByteBuffer(buffer: ByteBuffer): String = string2ByteBuffer.invert(buffer).get</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Terminology</p></li>
<li></li>
<li><p>Tweet id field             : The field number of ‘tweetId’ in the ‘Tweet’ thrift structure (i.e “1”)</p></li>
<li></li>
<li><p>First AdditionalField id   : The ID if the first additional field in ‘Tweet’ thrift structure. All field Ids less than this are</p></li>
<li><p>considered internal and all the ids greater than or equal to this field id are considered ‘Additional fields’.</p></li>
<li><p>This is set to 100.</p></li>
<li></li>
<li><p>Internal Fields            : Fields with ids [1 to firstAdditionalFieldid) (excluding firstAdditionalFieldId)</p></li>
<li></li>
<li><p>Core fields                : (Subset of Internal fields)- Fields with ids [1 to 8, 19]. These fields are “packed” together and stored</p></li>
<li><p>under a single key. This key is referred to as “CoreFieldsKey” (see &#64;TweetKeyType.CoreFieldsKey).</p></li>
<li><p>Note: Actually field 1 is skipped when packing as this field is the tweet id and it need not be</p></li>
<li><p>explicitly stored since the pkey already contains the tweet Id)</p></li>
<li></li>
<li><p>Root Core field id         : The field id under which the packed core fields are stored in Manhattan. (This is field Id “1”)</p></li>
<li></li>
<li><p>Required fields            : (Subset of Core fields) - Fields with ids [1 to 5] that MUST be present on every tweet.</p></li>
<li></li>
<li><p>Additional Fields          : All fields with field ids &gt;= ‘firstAdditionalFieldId’</p></li>
<li></li>
<li><p>Compiled Additional fields : (Subset of Additional Fields) - All fields that the storage library knows about</p></li>
<li><p>(i.e present on the latest storage_internal.thrift that is compiled-in).</p></li>
<li></li>
<li><p>Passthrough fields         : (Subset of Additional Fields) - The fields on storage_internal.thrift that the storage library is NOT aware of</p></li>
<li><p>These field ids are is obtained looking at the “_passThroughFields” member of the scrooge-generated</p></li>
<li><p>‘Tweet’ object.</p></li>
<li></li>
<li><p>coreFieldsIdInInternalTweet: This is the field id of the core fields (the only field) in the Internal Tweet struct</p></li>
</ul>
<p><a href="#id1"><span class="problematic" id="id2">*</span></a>/</p>
</dd>
<dt>object TweetFields {</dt><dd><p>val firstAdditionalFieldId: Short = 100
val tweetIdField: Short = 1
val geoFieldId: Short = 9</p>
<p>// The field under which all the core field values are stored (in serialized form).
val rootCoreFieldId: Short = 1</p>
<dl class="simple">
<dt>val coreFieldIds: immutable.IndexedSeq[FieldId] = {</dt><dd><p>val quotedTweetFieldId: Short = 19
(1 to 8).map(_.toShort) ++ Seq(quotedTweetFieldId)</p>
</dd>
</dl>
<p>}
val requiredFieldIds: immutable.IndexedSeq[FieldId] = (1 to 5).map(_.toShort)</p>
<p>val coreFieldsIdInInternalTweet: Short = 1</p>
<dl class="simple">
<dt>val compiledAdditionalFieldIds: Seq[FieldId] =</dt><dd><p>StoredTweet.metaData.fields.filter(_.id &gt;= firstAdditionalFieldId).map(_.id)</p>
</dd>
<dt>val internalFieldIds: Seq[FieldId] =</dt><dd><p>StoredTweet.metaData.fields.filter(_.id &lt; firstAdditionalFieldId).map(_.id)</p>
</dd>
<dt>val nonCoreInternalFields: Seq[FieldId] =</dt><dd><p>(internalFieldIds.toSet – coreFieldIds.toSet).toSeq</p>
</dd>
<dt>def getAdditionalFieldIds(tweet: StoredTweet): Seq[FieldId] =</dt><dd><p>compiledAdditionalFieldIds ++ tweet._passthroughFields.keys.toSeq</p>
</dd>
</dl>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Helper object to convert TFieldBlob to ByteBuffer that gets stored in Manhattan.</p></li>
<li></li>
<li><p>The following is the format in which the TFieldBlob gets stored:</p></li>
<li><p>[Version][TField][TFieldBlob]</p></li>
</ul>
<p><a href="#id3"><span class="problematic" id="id4">*</span></a>/</p>
</dd>
<dt>object TFieldBlobCodec {</dt><dd><p>val BinaryProtocolFactory: TBinaryProtocol.Factory = new TBinaryProtocol.Factory()
val FormatVersion = 1.0</p>
<dl>
<dt>def toByteBuffer(tFieldBlob: TFieldBlob): ByteBuffer = {</dt><dd><p>val baos = new ByteArrayOutputStream()
val prot = BinaryProtocolFactory.getProtocol(new TIOStreamTransport(baos))</p>
<p>prot.writeDouble(FormatVersion)
prot.writeFieldBegin(tFieldBlob.field)
prot.writeBinary(ByteArrayCodec.toByteBuffer(tFieldBlob.data))</p>
<p>ByteArrayCodec.toByteBuffer(baos.toByteArray)</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>def fromByteBuffer(buffer: ByteBuffer): TFieldBlob = {</dt><dd><p>val byteArray = ByteArrayCodec.fromByteBuffer(buffer)
val prot = BinaryProtocolFactory.getProtocol(new TMemoryInputTransport(byteArray))</p>
<p>val version = prot.readDouble()
if (version != FormatVersion) {</p>
<blockquote>
<div><dl class="simple">
<dt>throw new VersionMismatchError(</dt><dd><dl class="simple">
<dt>“Version mismatch in decoding ByteBuffer to TFieldBlob. “ +</dt><dd><p>“Actual version: “ + version + “. Expected version: “ + FormatVersion</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
</div></blockquote>
<p>}</p>
<p>val tField = prot.readFieldBegin()
val dataBuffer = prot.readBinary()
val data = ByteArrayCodec.fromByteBuffer(dataBuffer)</p>
<p>TFieldBlob(tField, data)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Helper object to help convert ‘CoreFields’ object to/from TFieldBlob (and also to construct</p></li>
<li><p>‘CoreFields’ object from a ‘StoredTweet’ object)</p></li>
<li></li>
<li><p>More details:</p></li>
<li><ul>
<li><p>A subset of fields on the ‘StoredTweet’ thrift structure (2-8,19) are ‘packaged’ and stored</p></li>
</ul>
</li>
<li><p>together as a serialized TFieldBlob object under a single key in Manhattan (see TweetKeyCodec</p></li>
<li><p>helper object above for more details).</p></li>
<li></li>
<li><ul>
<li><p>To make the packing/unpacking the fields to/from TFieldBlob object, we created the following</p></li>
</ul>
</li>
<li><p>two helper thrift structures ‘CoreFields’ and ‘InternalTweet’</p></li>
<li></li>
<li><p>// The field Ids and types here MUST exactly match field Ids on ‘StoredTweet’ thrift structure.</p></li>
<li><p>struct CoreFields {</p></li>
<li><p>2: optional i64 user_id</p></li>
<li><p>…</p></li>
<li><p>8: optional i64 contributor_id</p></li>
<li><p>…</p></li>
<li><p>19: optional StoredQuotedTweet stored_quoted_tweet</p></li>
<li></li>
<li><p>}</p></li>
<li></li>
<li><p>// The field id of core fields MUST be “1”</p></li>
<li><p>struct InternalTweet {</p></li>
<li><p>1: CoreFields coreFields</p></li>
<li><p>}</p></li>
<li></li>
<li><ul>
<li><p>Given the above two structures, packing/unpacking fields (2-8,19) on StoredTweet object into a TFieldBlob</p></li>
</ul>
</li>
<li><p>becomes very trivial:</p></li>
<li><p>For packing:</p></li>
<li><ol class="lowerroman simple">
<li><p>Copy fields (2-8,19) from StoredTweet object to a new CoreFields object</p></li>
</ol>
</li>
<li><ol class="lowerroman simple" start="2">
<li><p>Create a new InternalTweet object with the ‘CoreFields’ object constructed in step (i) above</p></li>
</ol>
</li>
<li><ol class="lowerroman simple" start="3">
<li><p>Extract field “1” as a TFieldBlob from InternalField (by calling the scrooge generated “getFieldBlob(1)”</p></li>
</ol>
</li>
<li><p>function on the InternalField objecton</p></li>
<li></li>
<li><p>For unpacking:</p></li>
<li><ol class="lowerroman simple">
<li><p>Create an empty ‘InternalField’ object</p></li>
</ol>
</li>
<li><ol class="lowerroman simple" start="2">
<li><p>Call scrooge-generated ‘setField’ by passing the tFieldBlob blob (created by packing steps above)</p></li>
</ol>
</li>
<li><ol class="lowerroman simple" start="3">
<li><p>Doing step (ii) above will create a hydrated ‘CoreField’ object that can be accessed by ‘coreFields’</p></li>
</ol>
</li>
<li><p>member of ‘InternalTweet’ object.</p></li>
</ul>
<p><a href="#id5"><span class="problematic" id="id6">*</span></a>/</p>
</dd>
<dt>object CoreFieldsCodec {</dt><dd><p>val coreFieldIds: Seq[FieldId] = CoreFields.metaData.fields.map(_.id)</p>
<p>// “Pack” the core fields i.e converts ‘CoreFields’ object to “packed” tFieldBlob (See description
// above for more details)
def toTFieldBlob(coreFields: CoreFields): TFieldBlob = {</p>
<blockquote>
<div><p>InternalTweet(Some(coreFields)).getFieldBlob(TweetFields.coreFieldsIdInInternalTweet).get</p>
</div></blockquote>
<p>}</p>
<p>// “Unpack” the core fields from a packed TFieldBlob into a CoreFields object (see description above for
// more details)
def fromTFieldBlob(tFieldBlob: TFieldBlob): CoreFields = {</p>
<blockquote>
<div><p>InternalTweet().setField(tFieldBlob).coreFields.get</p>
</div></blockquote>
<p>}</p>
<p>// “Unpack” the core fields from a packed TFieldBlob into a Map of core-fieldId-&gt; TFieldBlob
def unpackFields(tFieldBlob: TFieldBlob): Map[Short, TFieldBlob] =</p>
<blockquote>
<div><p>fromTFieldBlob(tFieldBlob).getFieldBlobs(coreFieldIds)</p>
</div></blockquote>
<p>// Create a ‘CoreFields’ thrift object from ‘Tweet’ thrift object.
def fromTweet(tweet: StoredTweet): CoreFields = {</p>
<blockquote>
<div><p>// As mentioned above, the field ids and types on the ‘CoreFields’ struct exactly match the
// corresponding fields on StoredTweet structure. So it is safe to call .getField() on Tweet object and
// and pass the returned tFleldBlob a ‘setField’ on ‘CoreFields’ object.
coreFieldIds.foldLeft(CoreFields()) {</p>
<blockquote>
<div><dl>
<dt>case (core, fieldId) =&gt;</dt><dd><dl class="simple">
<dt>tweet.getFieldBlob(fieldId) match {</dt><dd><p>case None =&gt; core
case Some(tFieldBlob) =&gt; core.setField(tFieldBlob)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Helper object to convert ManhattanException to FieldResponseCode thrift object</p></li>
</ul>
<p><a href="#id7"><span class="problematic" id="id8">*</span></a>/</p>
</dd>
<dt>object FieldResponseCodeCodec {</dt><dd><p>import FieldResponseCodec.ValueNotFoundException</p>
<dl>
<dt>def fromManhattanException(mhException: ManhattanException): FieldResponseCode = {</dt><dd><dl class="simple">
<dt>mhException match {</dt><dd><p>case _: ValueNotFoundException =&gt; FieldResponseCode.ValueNotFound
case _: InternalErrorManhattanException =&gt; FieldResponseCode.Error
case _: InvalidRequestManhattanException =&gt; FieldResponseCode.InvalidRequest
case _: DeniedManhattanException =&gt; FieldResponseCode.Error
case _: UnsatisfiableManhattanException =&gt; FieldResponseCode.Error
case _: TimeoutManhattanException =&gt; FieldResponseCode.Timeout</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>
<dl>
<dt>/**</dt><dd><ul class="simple">
<li><p>Helper object to construct FieldResponse thrift object from an Exception.</p></li>
<li><p>This is typically called to convert ‘ManhattanException’ object to ‘FieldResponse’ thrift object</p></li>
</ul>
<p><a href="#id9"><span class="problematic" id="id10">*</span></a>/</p>
</dd>
<dt>object FieldResponseCodec {</dt><dd><p>class ValueNotFoundException extends ManhattanException(“Value not found!”) with NoStackTrace
private[storage] val NotFound = new ValueNotFoundException</p>
<dl>
<dt>def fromThrowable(e: Throwable, additionalMsg: Option[String] = None): FieldResponse = {</dt><dd><dl>
<dt>val (respCode, errMsg) = e match {</dt><dd><dl class="simple">
<dt>case mhException: ManhattanException =&gt;</dt><dd><p>(FieldResponseCodeCodec.fromManhattanException(mhException), mhException.getMessage)</p>
</dd>
</dl>
<p>case _ =&gt; (FieldResponseCode.Error, e.getMessage)</p>
</dd>
</dl>
<p>}</p>
<p>val respMsg = additionalMsg.map(_ + “. “ + errMsg).orElse(Some(errMsg.toString))
FieldResponse(respCode, respMsg)</p>
</dd>
</dl>
<p>}</p>
</dd>
</dl>
<p>}</p>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../../../../../../../../index2.rst.html">twit</a></h1>








<h3>Navigation</h3>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../../../../../../../index2.rst.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../../../../../../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2023, jare.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.1.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.13</a>
      
      |
      <a href="../../../../../../../../_sources/tweetypie/common/src/scala/com/twitter/tweetypie/storage/Codecs.scala.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>